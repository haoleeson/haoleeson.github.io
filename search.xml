<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《人生七年》、《人间世》观后感</title>
    <url>/2019/04/06/AfterWatch7upAndRenJianShi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/AfterWatch7upAndRenJianShi.jpg" class="full-image" />

<p>最近疲于找实习，感觉自己能力不足，有些迷茫，遂重温了《人生七年》、《人间世》，竟有些新的感受。</p>
<h1 id="1-《人生七年》观后感"><a href="#1-《人生七年》观后感" class="headerlink" title="1. 《人生七年》观后感"></a>1. 《人生七年》观后感</h1><ul>
<li>《人生七年》感受到阶级血淋淋地存在，且每个人深受其影响。从一出生，影响就潜移默化地开始了，从家庭背景、思维方式、教育资源、人生规划等方面。7岁的高富帅三人组John、Andrew和Charles的谈吐和未来规划就能初见端倪</li>
</ul>
<a id="more"></a>

<ul>
<li>岁月无情，每隔七年都能看到孩子们又衰老了许多</li>
<li>没有那么多的理所应当，人们只会看到意气风发春风得意，而不会深挖其背后的坚毅与努力，John、Nick是真的唯有努力才能让这一切看起来毫不费力的践行者</li>
<li>阶级壁垒极难打破，但我们却可以选择属于自己的追求与幸福，以及给予孩子的教育</li>
<li>成功从来没有一个权威的定义，有的只是我们从小遵循的普世模式——上个好学校，找个好工作，赚很多很多钱，然后等中年终于获得经济自由时才能放下一切？<ul>
<li>可绝大多数人到老年也不能达到自己限定的条件，壮志难酬，抑郁寡欢，这时才开始反思是否什么错了啊？</li>
<li>这条普世的成功之路真的能导向成功么，且只有获得成功之后才能实现人生价值和自我实现么？</li>
</ul>
</li>
<li>从纪录片中可发现不同阶级的人追逐自我价值的方式多样，但大多都能从帮助他人的博爱与服务社会的奉献中找到自我满足和实现人生价值。<ul>
<li>精英阶层的律师John也说：“在法庭上依据枯燥的条文拿下一场大官司的胜利，远没有他尽自己的能力帮助别人得到的幸福感多”。</li>
<li>伦敦的平民Lynn事业上开始是在图书馆，后来是流动图书馆，再后来回到图书馆给孩子们讲故事，她很喜欢教孩子们看书，生活平淡而满足。</li>
<li>福利院孩子Paul，后来与妻子一起去一家养老社区工作，在那打下手，修补房子呀，送东西之类，服务别人让他们体会到了更大的满足。</li>
<li>单亲家庭的Symon收养了几千个孩子，付出了许多，也收获了无与伦比的快乐。</li>
</ul>
</li>
<li>思考自己究竟以什么模式活着，找到自己内心真正想要什么？当然，这值得我们用一生来寻找答案。</li>
</ul>
<img data-src="../../../../uploads/RenJianShiNewLife.jpg" class="full-image" />

<h1 id="2-《人间世》观后感"><a href="#2-《人间世》观后感" class="headerlink" title="2. 《人间世》观后感"></a>2. 《人间世》观后感</h1><ul>
<li>感受到人间疾苦和生命的规律。从我们呱呱坠地来到人间，经历短暂的一生，然后无可避免地生病、衰老与死去。这是亘古不变的规律，生命或脆弱，却也坚强，总有能在危难之际爆发出难以置信的生命力。</li>
<li>身体健康，家人平安本就是一种即为难得的奢望</li>
<li>亲情、爱情、友情总有缺席的一天，珍惜珍重眼前人</li>
</ul>
<div class="note success"><p>人生不如意之事十之八九，安静平和，身心舒畅，便是清欢。</p>
</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>人生观触动</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Manjaro</title>
    <url>/2018/09/23/AfterInstallManjaro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/AfterInstallManjaro.png" class="full-image" />

<h1 id="1-Manjaro设置国内源"><a href="#1-Manjaro设置国内源" class="headerlink" title="1. Manjaro设置国内源"></a>1. Manjaro设置国内源</h1><h2 id="1-1-添加官方镜像源-包括-core-extra-community-multilib"><a href="#1-1-添加官方镜像源-包括-core-extra-community-multilib" class="headerlink" title="1.1. 添加官方镜像源(包括: core, extra, community, multilib)"></a>1.1. 添加官方镜像源(包括: core, extra, community, multilib)</h2><figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank &#x2F;&#x2F;更新镜像排名</span><br><span class="line">sudo pacman -Syy &#x2F;&#x2F;更新数据源</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-2-添加archlinxCN源-中科大"><a href="#1-2-添加archlinxCN源-中科大" class="headerlink" title="1.2. 添加archlinxCN源(中科大)"></a>1.2. 添加archlinxCN源(中科大)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;pacman.conf</span><br></pre></td></tr></table></figure>
<p>以管理员权限修改&#x2F;etc&#x2F;pacman.conf，在pacman.conf文件末尾添加以下内容</p>
<figure class="highlight plain"><figcaption><span>文件位置：/etc/pacman.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"># USTC</span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel &#x3D; Optional TrustedOnly</span><br><span class="line">Server &#x3D;https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure>
<p>修改配置文件后，执行下面的命令：</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -Syy</span><br><span class="line">sudo pacman -Syyu #(可选) 升级系统到最新</span><br><span class="line">sudo pacman -S archlinuxcn-keyring &#x2F;&#x2F;安装导入GPG key</span><br></pre></td></tr></table></figure>

<h2 id="1-3-添加AUR源"><a href="#1-3-添加AUR源" class="headerlink" title="1.3. 添加AUR源"></a>1.3. 添加AUR源</h2><p>修改&#x2F;etc&#x2F;yaourtrc文件，去掉 # AURURL 的注释，添加清华AUR源</p>
<figure class="highlight plain"><figcaption><span>文件位置：/etc/yaourtrc</span></figcaption><table><tr><td class="code"><pre><span class="line">AURURL&#x3D;&quot;https:&#x2F;&#x2F;aur.tuna.tsinghua.edu.cn&quot;  #添加清华AUR源</span><br></pre></td></tr></table></figure>

<h1 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h1><figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S git</span><br></pre></td></tr></table></figure>
<ul>
<li>Git配置</li>
</ul>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;youremail@example.com&quot;</span><br><span class="line">git config --list #查看配置</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑配置信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure>
<p>查看内容是否如下：</p>
<figure class="highlight plain"><figcaption><span>文件位置：~/.gitconfig</span></figcaption><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">name &#x3D; Your Name</span><br><span class="line">email &#x3D; youremail@domain.com</span><br></pre></td></tr></table></figure>

<ul>
<li>创建公钥(一路回车，全部默认)：</li>
</ul>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">ssh-keygen -C &#39;you email address@gmail.com&#39; -t rsa</span><br></pre></td></tr></table></figure>

<ul>
<li><p>复制公钥<br>打开刚刚新建的公钥，并复制文件所有内容 Ctrl + A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit &#x2F;home&#x2F;haoleeson&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传公钥到GitHub<br>将复制的代码上传到GitHub，打开 <a href="https://www.github.com/">GitHub.com</a>，登录后点击界面右上角用户图标，选择 Account Settings &#x3D;&#x3D;&gt; SSH Public Keys &#x3D;&#x3D;&gt; 粘贴刚刚复制的代码。</p>
</li>
<li><p>测试验证</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">ssh -v git@github.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-安装VIM"><a href="#3-安装VIM" class="headerlink" title="3. 安装VIM"></a>3. 安装VIM</h1><ul>
<li><p>安装vim, ctags<br>打开ADD&#x2F;REMOVE软件管理包，搜索vim、ctags并安装，或输入以下命令安装</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S vim #vim文本编辑器</span><br><span class="line">sudo pacman -S ctags #generates index tool</span><br></pre></td></tr></table></figure>
<p>vim已安装完成，以下为导入GitHub大神分享的vim的IDE配置步骤，可调至下一个标题</p>
</li>
<li><p>打开终端，执行下面的命令自动下载<a href="https://github.com/ma6174/vim-deprecated">GitHub上一个做好的IDE式VIM:</a>组件</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">wget -qO- https:&#x2F;&#x2F;raw.github.com&#x2F;ma6174&#x2F;vim&#x2F;master&#x2F;setup.sh | sh -x</span><br></pre></td></tr></table></figure>
</li>
<li><p>终端输入:”vim”, 打开vim</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">vim</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令模式输入:”:BundleInstall”自动安装<br>“Shift” + “;”进入命令模式，在窗口左下角粘贴(Ctrl+Shift+V)以下代码后回车以自动安装组件</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：vim命令模式下</span></figcaption><table><tr><td class="code"><pre><span class="line">BundleInstall</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后打开配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加如下配置</p>
<figure class="highlight plain"><figcaption><span>文件位置：~/.vimrc</span></figcaption><table><tr><td class="code"><pre><span class="line">&quot;显示空格 回车符</span><br><span class="line">&quot; set listchars&#x3D;eol:$(行尾),tab:&gt;-(制表符),trail:~(空格),extends:&gt;,precedes:&lt;</span><br><span class="line">set listchars&#x3D;tab:&gt;-,trail:-,extends:&gt;,precedes:&lt;</span><br><span class="line">highlight WhitespaceEOL ctermbg&#x3D;red guibg&#x3D;red</span><br><span class="line">match WhitespaceEOL &#x2F;\s\+$&#x2F;</span><br><span class="line">set list</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-安装Node-js"><a href="#4-安装Node-js" class="headerlink" title="4. 安装Node.js"></a>4. 安装Node.js</h1><p>安装 Node.js 的最佳方式是使用 nvm。先卸载系统预装的nvm和nodejs</p>
<ul>
<li>卸载预装nvm<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Q | grep nvm</span><br><span class="line">sudo pacman -Rns nvm</span><br></pre></td></tr></table></figure></li>
<li>卸载预装nodejs<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Q | grep nodejs</span><br><span class="line">sudo pacman -Rns nodejs #</span><br></pre></td></tr></table></figure></li>
<li>先通过cURL方式安装nvm:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.11&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure></li>
<li>待nvm安装完成后，重启终端 并执行下列命令即可安装 Node.js。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install stable #安装 Node.js</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-安装ZSH-可不更改，默认bash也不错"><a href="#5-安装ZSH-可不更改，默认bash也不错" class="headerlink" title="5. 安装ZSH(可不更改，默认bash也不错)"></a>5. <del>安装ZSH</del>(可不更改，默认bash也不错)</h1><p>ZSH可以说是shell中的极品，它的优点太多了，我就不一一写出来，有兴趣的同学可以看这篇文章知乎-为什么说zsh是shell中的极品，参考<a href="https://me.csdn.net/gatieme">JeanCheng</a>的这篇博文：<a href="https://blog.csdn.net/gatieme/article/details/52741221">Linux终极shell-Z Shell–用强大的zsh &amp; oh-my-zsh把Bash换掉</a></p>
<ul>
<li><p>安装zsh</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S zsh</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置oh-my-zsh</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取代bash，设为默认shell</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo usermod -s &#x2F;bin&#x2F;zsh username1</span><br><span class="line">或者</span><br><span class="line">chsh -s &#x2F;bin&#x2F;zsha</span><br><span class="line">chsh -s &#x2F;bin&#x2F;zsh1</span><br><span class="line">chsh -s &#96;which zsh&#96;1</span><br></pre></td></tr></table></figure>
<p>Finish，zsh已经安装完了</p>
</li>
<li><p>如果要切换回去bash：<br>想知道你的系统有几种shell，可以通过以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;shells</span><br></pre></td></tr></table></figure>
<p>切换回去bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>当然你实在不愿意把zsh当成默认的shell, 而又想使用它, 那么你可以每次进入是都使用<strong>zsh</strong>进入, 而输入exit退出</p>
</li>
</ul>
<h1 id="6-安装IBus拼音输入法"><a href="#6-安装IBus拼音输入法" class="headerlink" title="6. 安装IBus拼音输入法"></a>6. 安装IBus拼音输入法</h1><ul>
<li><p>搜索安装ibus-pinyin</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S ibus-pinyin</span><br></pre></td></tr></table></figure>
</li>
<li><p>在”系统设置” &#x3D;&#x3D;&gt; “语言-配置” 中点击“+”添加刚刚安装的chinese-pinyin输入法</p>
</li>
</ul>
<h1 id="7-用Terminator替换默认的Terminal终端"><a href="#7-用Terminator替换默认的Terminal终端" class="headerlink" title="7. 用Terminator替换默认的Terminal终端"></a>7. 用Terminator替换默认的Terminal终端</h1><h2 id="7-1-安装Terminator"><a href="#7-1-安装Terminator" class="headerlink" title="7.1. 安装Terminator"></a>7.1. 安装Terminator</h2><figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S Terminator</span><br></pre></td></tr></table></figure>
<h2 id="7-2-设置Terminator启动快捷键。"><a href="#7-2-设置Terminator启动快捷键。" class="headerlink" title="7.2. 设置Terminator启动快捷键。"></a>7.2. 设置Terminator启动快捷键。</h2><p>打开系统设置，依次”Devices” &#x3D;&#x3D;&gt; “keyboard” &#x3D;&#x3D;&gt; 点击最末’+’ &#x3D;&#x3D;&gt; Name:”Open Terminator” &#x3D;&#x3D;&gt; Command:”&#x2F;usr&#x2F;bin&#x2F;terminator” &#x3D;&#x3D;&gt; 设置启动快捷键(如：Ctrl+Alt+T)。</p>
<h2 id="7-3-配置Terminator配色及透明度。"><a href="#7-3-配置Terminator配色及透明度。" class="headerlink" title="7.3. 配置Terminator配色及透明度。"></a>7.3. 配置Terminator配色及透明度。</h2><p>右键窗体点击”Preferences” &#x3D;&#x3D;&gt; “Colors” &#x3D;&#x3D;&gt; Built-in schemes选择配色(如:”Green on black”) &#x3D;&#x3D;&gt; “Background” &#x3D;&#x3D;&gt; 勾选”Transparent background” &#x3D;&#x3D;&gt; 设置透明度Shade transparent background:(推荐0.8)</p>
<h2 id="7-4-Terminator常用快捷键"><a href="#7-4-Terminator常用快捷键" class="headerlink" title="7.4. Terminator常用快捷键"></a>7.4. Terminator常用快捷键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+Shift+C            #复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V            #粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+O            #上下开新窗口</span><br><span class="line">Ctrl+Shift+Up&#x2F;Down      #分割条向上、下移动（终端上下多开窗口时）</span><br><span class="line">Alt+Up&#x2F;Down             #上、下窗口切换（终端上下多开窗口时）</span><br><span class="line">Ctrl+Shift+W            #关闭当前终端</span><br><span class="line">Ctrl+Shift+F            #搜索</span><br><span class="line">#标签页快捷键</span><br><span class="line">F11                     #全屏开关</span><br><span class="line">Ctrl+Shift+T            #打开一个新的标签</span><br><span class="line">Ctrl+PageDown           #移动到下一个标签</span><br><span class="line">Ctrl+PageUp             #移动到上一个标签</span><br></pre></td></tr></table></figure>

<h1 id="8-编译环境安装-Gcc-Java-Python"><a href="#8-编译环境安装-Gcc-Java-Python" class="headerlink" title="8. 编译环境安装(Gcc, Java, Python)"></a>8. 编译环境安装(Gcc, Java, Python)</h1><h2 id="8-1-安装gcc-make-cmake-gdb环境"><a href="#8-1-安装gcc-make-cmake-gdb环境" class="headerlink" title="8.1. 安装gcc make cmake gdb环境"></a>8.1. 安装gcc make cmake gdb环境</h2><ul>
<li><p>安装gcc, make, cmake, gdb</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S gcc make cmake gdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看GCC环境是否配置成功</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-2-安装JAVA环境"><a href="#8-2-安装JAVA环境" class="headerlink" title="8.2. 安装JAVA环境"></a>8.2. 安装JAVA环境</h2><ul>
<li><p><del>在主目录下，创建JAVA环境包存放目录</del>（用更简便方式代替）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~&#x2F;Environment&#x2F;JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>下载JDK <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JAVA SE下载地址</a>，下载到刚刚创建的目录。选择自己的安装平台，我选择的是”jdk-8u181-linux-x64.tar.gz”，如果下载的不是这个JDK包，后面的涉及JDK包文件时跟换到你的JDK包名就可。</del></p>
</li>
<li><p><del>跳转到压缩包目录解压</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Environment&#x2F;JAVA  #跳转到压缩包目录</span><br><span class="line">tar -xvf jdk-8u181-linux-x64.tar.gz  #解压JDK包</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>解压完成后，打开环境配置文件.bashrc(若配置了刚刚的zsh，则打开～&#x2F;.zshrc)</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.bashrc</span><br><span class="line">#或</span><br><span class="line">vim ~&#x2F;.zshrc #若刚刚已配置zsh</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>添加如下Java环境配置代码到文件末尾</del></p>
<figure class="highlight plain"><figcaption><span>文件位置：~/.bashrc 或 ~/.zshrc</span></figcaption><table><tr><td class="code"><pre><span class="line">#JAVA环境配置</span><br><span class="line">export JAVA_HOME&#x3D;$HOME&#x2F;Environment&#x2F;JAVA&#x2F;jdk1.8.0_181</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;dt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;tools.jar</span><br><span class="line">#IDEA软件需用到</span><br><span class="line">export IDEA_JDK&#x3D;$HOME&#x2F;Environment&#x2F;JAVA&#x2F;jdk1.8.0_181</span><br><span class="line">export IDEA_JDK_64&#x3D;$HOME&#x2F;Environment&#x2F;JAVA&#x2F;jdk1.8.0_181</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>生效刚刚配置的JAVA环境：</del></p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br><span class="line">或</span><br><span class="line">source ~&#x2F;.zshrc #若刚刚已配置zsh</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>查看JAVA环境是否配置成功</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-3-通过’Add-x2F-Remove-Software’软件自动安装JAVA环境"><a href="#8-3-通过’Add-x2F-Remove-Software’软件自动安装JAVA环境" class="headerlink" title="8.3. 通过’Add&#x2F;Remove Software’软件自动安装JAVA环境"></a>8.3. 通过’Add&#x2F;Remove Software’软件<strong>自动安装JAVA环境</strong></h2><ul>
<li>删除系统预装的openjdk<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Q | grep opnjdk #删除openjdk,&#39;sudo pacman -Q&#39;为查询已装软件，&#39;| grep&#39; 只显示与&#39;opnjdk&#39;相关内容</span><br><span class="line">sudo pacman -Rns openjdk # sudo pacman -Rns 最小破换性地卸载（推荐），有效防止删除A软件时误删B软件所需的依赖(大致是这意思吧)..</span><br><span class="line">sudo pacman -Rns openjdkheadless #删除openjdk相关</span><br></pre></td></tr></table></figure></li>
<li>使用’Add&#x2F;Remove Software’软件智能安装JAVA环境，不需手动配置(推荐)<br>在搜索框中搜索’jdk8’关键字，勾选’jdk8’(Oracle Java 8 Development Kit)’，再点击应用即可安装。</li>
</ul>
<h2 id="8-4-安装Python环境-系统已经预装Python2-7和Python3-7-默认"><a href="#8-4-安装Python环境-系统已经预装Python2-7和Python3-7-默认" class="headerlink" title="8.4. 安装Python环境(系统已经预装Python2.7和Python3.7(默认))"></a>8.4. <del>安装Python环境</del>(系统已经预装Python2.7和Python3.7(默认))</h2><h3 id="8-4-1-安装Python3-7"><a href="#8-4-1-安装Python3-7" class="headerlink" title="8.4.1. 安装Python3.7"></a>8.4.1. 安装Python3.7</h3><ul>
<li>直接在软件管理包中搜索”python  3.7.0-3”手动安装即可</li>
<li>或用pacman安装安装Python3.7<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S python3.7</span><br></pre></td></tr></table></figure></li>
<li>查看Python环境是否配置成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-4-2-手动安装数据处理必备Numpy模块-较麻烦且容易失败，后文介绍用pip3方式安装"><a href="#8-4-2-手动安装数据处理必备Numpy模块-较麻烦且容易失败，后文介绍用pip3方式安装" class="headerlink" title="8.4.2. 手动安装数据处理必备Numpy模块(较麻烦且容易失败，后文介绍用pip3方式安装)"></a>8.4.2. <del>手动安装数据处理必备Numpy模块</del>(较麻烦且容易失败，后文介绍用pip3方式安装)</h3><p><del>参考自<a href="https://blog.csdn.net/chenyefei/article/details/77289289?utm_source=blogxgwz0">linux下python3安装numpy与scipy</a>，由于numpy依赖于nose，故在需先安装依赖包nose，再安装numpy。</del></p>
<ul>
<li><p><del>安装Python的nose模块</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Downloads</span><br><span class="line">wget https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;38&#x2F;96&#x2F;7aa1c2583ddec558a230175d6aeddba796cde7191852bf3e6eb3cfb873e1&#x2F;nose-1.1.2.tar.gz &#x2F;&#x2F;下载nose-1.1.2</span><br><span class="line">tar -zxvf nose-1.1.2.tar.gz &#x2F;&#x2F;解压nose安装包(以实际下载的包名为准)</span><br><span class="line">cd nose-1.1.2 &#x2F;&#x2F;进入刚刚解压的目录</span><br><span class="line">sudo python3 setup.py install &#x2F;&#x2F;执行安装命令以安装nose </span><br></pre></td></tr></table></figure>
</li>
<li><p><del>安装Python的atlas模块</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Downloads</span><br><span class="line">wget https:&#x2F;&#x2F;files.pythonhosted.org&#x2F;packages&#x2F;3b&#x2F;30&#x2F;a02c60e3a232cfcfdb9910ea2b5b83a567efeb1d3f1cb4622ce3eba63f9d&#x2F;atlas-0.27.0.tar.gz &#x2F;&#x2F;下载atlas-0.27.0</span><br><span class="line">tar -zxvf atlas-0.27.0.tar.gz &#x2F;&#x2F;解压atlas安装包(以实际下载的包名为准)</span><br><span class="line">cd atlas-0.27.0 &#x2F;&#x2F;进入刚刚解压的目录</span><br><span class="line">sudo python3 setup.py install &#x2F;&#x2F;执行安装命令以安装atlas</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>安装Python的numpy模块</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Downloads</span><br><span class="line">wget https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;numpy&#x2F;files&#x2F;NumPy&#x2F;1.9.0&#x2F;numpy-1.9.0.zip &#x2F;&#x2F;下载numpy包</span><br><span class="line">unzip numpy-1.9.0.zip &#x2F;&#x2F;解压numpy包</span><br><span class="line">cd numpy-1.9.0 &#x2F;&#x2F;进入刚刚解压的目录</span><br><span class="line">sudo python3 setup.py install &#x2F;&#x2F;执行安装命令安装numpy</span><br></pre></td></tr></table></figure>
<p>安装完成后可用以下命令测试是否成功安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import numpy; numpy.test()&#39;</span><br></pre></td></tr></table></figure></li>
<li><p><del>Python数据处理常用包</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">各个安装包：</span><br><span class="line">scipy-0.19.0  下载：https:&#x2F;&#x2F;github.com&#x2F;scipy&#x2F;scipy</span><br><span class="line">numpy-1.9.0  下载：https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;numpy&#x2F;files&#x2F;NumPy&#x2F;1.9.0&#x2F;numpy-1.9.0.zip</span><br><span class="line">nose-1.1.2   下载：https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;38&#x2F;96&#x2F;7aa1c2583ddec558a230175d6aeddba796cde7191852bf3e6eb3cfb873e1&#x2F;nose-1.1.2.tar.gz</span><br><span class="line">lapack-3.7.1   下载： www.netlib.org&#x2F;lapack&#x2F;lapack-3.7.1.tgz</span><br><span class="line">atlas-0.27.0   下载： https:&#x2F;&#x2F;files.pythonhosted.org&#x2F;packages&#x2F;3b&#x2F;30&#x2F;a02c60e3a232cfcfdb9910ea2b5b83a567efeb1d3f1cb4622ce3eba63f9d&#x2F;atlas-0.27.0.tar.gz</span><br><span class="line">Cython-0.26    下载： https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;Cython&#x2F;0.26</span><br><span class="line">依赖关系：scipy 的安装需要依赖于 numpy、lapack、atlas（后两者都是线性代数工具包，而 numpy 和scipy 的测试程序的运行又依赖于 nose，因此，整个安装过程必须要按顺序执行的，否则是无法执行下去的。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-4-3-使用pip3安装Numpy模块"><a href="#8-4-3-使用pip3安装Numpy模块" class="headerlink" title="8.4.3. 使用pip3安装Numpy模块"></a>8.4.3. 使用pip3安装Numpy模块</h3><p>访问<a href="https://pypi.org/">Python packages</a>网站搜索相应模块(如”Numpy”),本地管理员运行其pip3安装代码<code>pip3 install numpy</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple numpy</span><br></pre></td></tr></table></figure>

<p><strong>同理顺序安装其他模块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple numpy        &#x2F;&#x2F;安装Numpy库:提供数组支持，以及相应的高效的处理函数</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple SciPy        &#x2F;&#x2F;安装SciPy库：提供矩阵支持，以及矩阵相关的数值计算模块</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple matplotlib   &#x2F;&#x2F;安装Matplotlib库：强大的数据可视化工具、作图库</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple pandas       &#x2F;&#x2F;安装Pandas库：强大、灵活的数据分析和探索工具</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple statsmodels  &#x2F;&#x2F;安装StatsModels库：统计建模和计量经济学，包括描述统计、统计模型估计和推断</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple scikit-learn &#x2F;&#x2F;安装Scikit-Learn库：支持回归、分类、聚类等强大的机器学习库</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple keras        &#x2F;&#x2F;安装Keras库：深度学习库，用于建立神经网络以及深度学习模型</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple gensim       &#x2F;&#x2F;安装Gensim库：用来做文本主题模型的库，可能用于文本挖掘</span><br></pre></td></tr></table></figure>

<h1 id="9-常用软件安装"><a href="#9-常用软件安装" class="headerlink" title="9. 常用软件安装"></a>9. 常用软件安装</h1><ul>
<li>工具软件<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S git #代码仓库</span><br><span class="line">sudo pacman -S ctags #generates index tool</span><br><span class="line">sudo pacman -S vim #vim文本编辑器</span><br><span class="line">sudo pacman -S zsh #shell中的极品</span><br><span class="line">sudo pacman -S ibus-pinyin #中文输入法支持</span><br><span class="line">sudo pacman -S python-pip #Python Packages安装工具</span><br><span class="line">sudo pacman -S nvm #Nodejs版本管理器，可以轻松切换Nodejs版本</span><br><span class="line">sudo pacman -S nodejs #Nodejs</span><br><span class="line">sudo pacman -S npm</span><br></pre></td></tr></table></figure></li>
<li>应用软件<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S google-chrome #谷歌浏览器</span><br><span class="line">sudo pacman -S netease-cloud-music #网易云音乐</span><br><span class="line">sudo pacman -S electronic-wechat #微信</span><br><span class="line">sudo pacman -S typora #Typora,Markdown文档编辑器</span><br><span class="line">sudo pacman -S Shadowsocks-Qt5 #VPN梯子</span><br></pre></td></tr></table></figure></li>
<li>生产工具<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S gcc make cmake gdb #安装gcc，make, cmake，gdb环境</span><br><span class="line">sudo pacman -S clion #C&#x2F;C++集成IDE开发工具</span><br><span class="line">sudo pacman -S IntelliJ IDEA #Java集成IDE开发工具</span><br><span class="line">sudo pacman -S pycharm-professional #python集成IDE开发工具</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="10-系统常见问题及解决方案："><a href="#10-系统常见问题及解决方案：" class="headerlink" title="10. 系统常见问题及解决方案："></a>10. 系统常见问题及解决方案：</h1><h2 id="10-1-Windows和Linux双系统时间不一致问题"><a href="#10-1-Windows和Linux双系统时间不一致问题" class="headerlink" title="10.1. Windows和Linux双系统时间不一致问题"></a>10.1. Windows和Linux双系统时间不一致问题</h2><p>如何解决 Windows 和 Linux 双系统时间差8小时的问题 ， <a href="https://blog.csdn.net/aaazz47/article/details/78696899">可参考文章</a></p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo timedatectl set-local-rtc 1</span><br></pre></td></tr></table></figure>
<p>在系统设置-&gt;Details-&gt;Date &amp; Time 中点击Automatic Date &amp; Time联网更新时间</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo hwclock --localtime --systohc #将时间写入硬件</span><br></pre></td></tr></table></figure>
<h2 id="10-2-桌面某些组建不正常显示时，重装gnome即可"><a href="#10-2-桌面某些组建不正常显示时，重装gnome即可" class="headerlink" title="10.2. 桌面某些组建不正常显示时，重装gnome即可"></a>10.2. 桌面某些组建不正常显示时，重装gnome即可</h2><p>桌面不正常显示，或某些显示功能不正常可能出现在通过软件管理包卸载软件时卸载部分未知依赖导致出错，如“系统设置未出现“，重新安装gnome所有组建可解决问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gnome</span><br><span class="line">&#x2F;&#x2F;选择&quot;all&quot;,然后一直确定覆盖安装&quot;y</span><br></pre></td></tr></table></figure>
<h2 id="10-3-解决GitHub访问慢，修改host"><a href="#10-3-解决GitHub访问慢，修改host" class="headerlink" title="10.3. 解决GitHub访问慢，修改host"></a>10.3. 解决GitHub访问慢，修改host</h2><ul>
<li><p>修改hosts文件配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure></li>
<li><p>a.手动查询DNS<br>打开 <a href="http://tool.chinaz.com/dns,%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%90%8D%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%9A%84%E5%B7%A5%E5%85%B7">http://tool.chinaz.com/dns,这是一个查询域名映射关系的工具</a><br>查询 github.global.ssl.fastly.net 和 assets-cdn.github.com 两个地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.global.ssl.fastly.net</span><br><span class="line">assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<p>多查几次，选择一个稳定，延迟较低的 ip 按如下方式添加到host文件</p>
</li>
<li><p>b.使用大神分享的, eg:</p>
<figure class="highlight plain"><figcaption><span>文件位置：/etc/hosts</span></figcaption><table><tr><td class="code"><pre><span class="line"># Github  直接输入IP，可以让git变得非常快</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net </span><br><span class="line">192.30.253.113 github.com </span><br><span class="line">103.245.222.133 assets-cdn.github.com </span><br><span class="line">23.235.47.133 assets-cdn.github.com </span><br><span class="line">203.208.39.104 assets-cdn.github.com </span><br><span class="line">204.232.175.78 documentcloud.github.com </span><br><span class="line">204.232.175.94 gist.github.com </span><br><span class="line">107.21.116.220 help.github.com </span><br><span class="line">207.97.227.252 nodeload.github.com </span><br><span class="line">199.27.76.130 raw.github.com </span><br><span class="line">107.22.3.110 status.github.com </span><br><span class="line">204.232.175.78 training.github.com </span><br><span class="line">207.97.227.243 www.github.com </span><br><span class="line">185.31.16.184 github.global.ssl.fastly.net </span><br><span class="line">185.31.18.133 avatars0.githubusercontent.com </span><br><span class="line">185.31.19.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure></li>
<li><p>刷新DNS</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager</span><br></pre></td></tr></table></figure>
<p>Finish, 享受飞速GitHub吧!</p>
</li>
</ul>
<h2 id="10-4-解决pip3命令安装软件速度慢，使用-i参数"><a href="#10-4-解决pip3命令安装软件速度慢，使用-i参数" class="headerlink" title="10.4. 解决pip3命令安装软件速度慢，使用-i参数"></a>10.4. 解决pip3命令安装软件速度慢，使用-i参数</h2><p>参考<a href="https://blog.csdn.net/wukai0909/article/details/62427437">Python-解决pip3下载安装速度慢</a><br>临时使用：<br>可以在使用pip3的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple numpy</span><br><span class="line">#这样就会从清华这边的镜像去安装numpy库。</span><br></pre></td></tr></table></figure>
<h2 id="10-5-解决打开IDEA时弹出JDK路径错误"><a href="#10-5-解决打开IDEA时弹出JDK路径错误" class="headerlink" title="10.5. 解决打开IDEA时弹出JDK路径错误"></a>10.5. 解决打开IDEA时弹出JDK路径错误</h2><p>错误出现原因，删除原系统open-jdk后手动安装JDK时可能出现未知bug，导致终端JDK配置没问题，致使IDEA的idea.sh启动时并不能正确找到JDK路径。因此我们的解决思路是可以修改idea.sh文件的某些位置，强制设置JDK路径为上一步我们配置的地址。</p>
<figure class="highlight plain"><figcaption><span>修改文件:/usr/share/idea/bin/idea.sh</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;usr&#x2F;share&#x2F;idea&#x2F;bin&#x2F;idea.sh #打开idea.sh文件</span><br><span class="line"># Ctrl + F 搜索 “JAVA_BIN”</span><br><span class="line">JDK&#x3D;$HOME&#x2F;Environment&#x2F;JAVA&#x2F;jdk1.8.0_181 #待添加强制定义JDK路径代码，将此行代码添加到idea.sh中的“JAVA_BIN&#x3D;&quot;$JDK&#x2F;bin&#x2F;java”代码的上方一行，强制定义JDK路径，问题解决 Done:)</span><br></pre></td></tr></table></figure>

<h1 id="11-Linux-每日一练"><a href="#11-Linux-每日一练" class="headerlink" title="11. Linux 每日一练"></a>11. Linux 每日一练</h1><p>压缩文件／文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7za a -t7z -r Mytest.7z &#x2F;opt&#x2F;phpMyAdmin-3.3.8.1-all-languages&#x2F;*</span><br><span class="line">7za a -t7z -r haoleeson.github.io_backup20180928.7z &#x2F;home&#x2F;haoleeson&#x2F;haoleeson.github.io&#x2F;*  #压缩本站所有文件</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>a  代表添加文件／文件夹到压缩包</li>
<li>-t 是指定压缩类型，这里定为7z，可不指定，因为7za默认压缩类型就是7z。</li>
<li>-r 表示递归所有的子文件夹</li>
<li>Mytest.7z 是压缩好后的压缩包名</li>
<li>&#x2F;opt&#x2F;phpMyAdmin-3.3.8.1-all-languages&#x2F;*：是压缩目标。</li>
</ul>
<p>注意：7za不仅仅支持.7z压缩格式，还支持.tar.bz2等压缩类型的。如上所述，用-t指定即可。</p>
<h1 id="12-参考文档"><a href="#12-参考文档" class="headerlink" title="12. 参考文档"></a>12. 参考文档</h1><ul>
<li><a href="https://www.jianshu.com/p/79dae972b1e9">简书Manjaro安装后配置</a></li>
<li><a href="https://www.lulinux.com/archives/category/linux_newbie">系统安装|鲁Linux</a></li>
<li><a href="https://blog.csdn.net/dp_dp/article/details/80139283">Manjaro安装后配置</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析与设计练习</title>
    <url>/2019/01/03/AnalysisOfAlgorithmsLesson/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/AnalysisOfAlgorithmsLesson.jpg" class="full-image" />

<h1 id="1-算法分析与设计练习"><a href="#1-算法分析与设计练习" class="headerlink" title="1. 算法分析与设计练习"></a>1. 算法分析与设计练习</h1><p>完整源代码已在本文尾部给出</p>
<h2 id="1-1-No1-优先级队列（大小顶堆）"><a href="#1-1-No1-优先级队列（大小顶堆）" class="headerlink" title="1.1. No1. 优先级队列（大小顶堆）"></a>1.1. No1. 优先级队列（大小顶堆）</h2><p>堆是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于（或不小于）其左子节点和右子节点的值。最小(大)堆能保证堆顶元素最小(大)，相比于用数组存放数据，如果要查找所有数据中最小(大)的数据时，数组的时间复杂度为O(n)，而最小(大)堆的时间复杂度为O(1)。而数据增删数据时，需要保证最小(大)堆的动态可维护性仅需O(logN)。因此对于特定的需求环境，最小(大)堆这种数据结构非常高效。</p>
<a id="more"></a>

<h3 id="1-1-1-最大堆概念"><a href="#1-1-1-最大堆概念" class="headerlink" title="1.1.1. 最大堆概念"></a>1.1.1. 最大堆概念</h3><p>最大堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不小于其左子节点和右子节点的值。</p>
<h4 id="1-1-1-1-最大堆实现思路"><a href="#1-1-1-1-最大堆实现思路" class="headerlink" title="1.1.1.1. 最大堆实现思路"></a>1.1.1.1. 最大堆实现思路</h4><p>将最大堆二叉树存储到数组内，非根节点元素的父节点下标为(i-1)&#x2F;2，若子节点存在则下标为2*i+1。</p>
<p><strong>插入操作</strong>：每当插入一个元素，将元素插入到容器（数组）尾部，然后执行迭代的上升操作，将插入的元素与其父节点比较，若比父节点大则交换，然后再与交换后节点的父节点相互比较交换，直到放置到合适位置。（最坏递归到根节点终止迭代）</p>
<p><strong>弹出操作</strong>：弹出最大值（即数组首地址元素a[0]）。先交换交换堆顶与堆末，再弹出堆末（最大值），然后再将现堆顶元素执行迭代的下降操作，若其子节点存在与其子节点比较，若比子节点小则交换，然后再与交换后的子节点相互比较交换，直到放置在合适位置。（最坏递归到叶子节点）</p>
<p><strong>最大堆运行结果</strong><br><img data-src="/../../../../uploads/AnalysisOfAlgorithmsLesson_Max_Heap.png" alt="1_Max_Heap"></p>
<h3 id="1-1-2-最小堆概念"><a href="#1-1-2-最小堆概念" class="headerlink" title="1.1.2. 最小堆概念"></a>1.1.2. 最小堆概念</h3><p>最小堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节点的值。堆内的所有数据中最小的元素始终在堆顶，而增删一个元素而动态维护最小堆性质的时间复杂度仅为O(logN)</p>
<h4 id="1-1-2-1-最小堆实现思路"><a href="#1-1-2-1-最小堆实现思路" class="headerlink" title="1.1.2.1. 最小堆实现思路"></a>1.1.2.1. 最小堆实现思路</h4><p>将最小堆二叉树存储到数组内，非根节点元素的父节点下标为(i-1)&#x2F;2，若子节点存在则下标为2*i+1。</p>
<p><strong>插入操作</strong>：每当插入一个元素，将元素插入到容器（数组）尾部，然后执行迭代的上升操作，将插入的元素与其父节点比较，若比父节点小则交换，然后再与交换后节点的父节点相互比较交换，直到放置到合适位置。（最坏递归到根节点终止迭代）</p>
<p><strong>弹出操作</strong>：弹出最小值（即数组首地址元素a[0]）。先交换交换堆顶与堆末，再弹出堆末（最小值），然后再将现堆顶元素执行迭代的下降操作，若其子节点存在与其子节点比较，若比子节点小则交换，然后再与交换后的子节点相互比较交换，直到放置在合适位置。（最坏递归到叶子节点）</p>
<p>最小堆运行结果<br><img data-src="/../../../../uploads/AnalysisOfAlgorithmsLesson_Min_Heap.png" alt="1_Min_Heap"></p>
<h2 id="1-2-No2-Quicksort"><a href="#1-2-No2-Quicksort" class="headerlink" title="1.2. No2. Quicksort"></a>1.2. No2. Quicksort</h2><p>快速排序（Quick Sort）由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br>快速排序是不稳定的算法，时间复杂度在最坏情况下是O(N^2)，平均的时间复杂度是O(N*lgN)。</p>
<h3 id="1-2-1-Quick-Sort-实现思想"><a href="#1-2-1-Quick-Sort-实现思想" class="headerlink" title="1.2.1. Quick Sort 实现思想"></a>1.2.1. Quick Sort 实现思想</h3><p>快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：</p>
<ul>
<li>1、从数列中取出一个数作为基准数（枢轴，pivot）。 </li>
<li>2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。</li>
<li>3、再对左右的子区间重复第二步的划分操作，直至每个子区间只有Cutoff（阈值）个元素。</li>
<li>4、对Cutoff（阈值）个元素进行插入排序（实践经验小于一定数量后插入排序快于快速排序），然后返回上一调用堆栈。</li>
</ul>
<h3 id="1-2-2-实现Quicksort核心代码"><a href="#1-2-2-实现Quicksort核心代码" class="headerlink" title="1.2.2. 实现Quicksort核心代码"></a>1.2.2. 实现Quicksort核心代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序算法实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cutoff 5 <span class="comment">//定义快速排序（递归）阈值，数组元素小于Cutoff直接插入排序</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">( vector&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Left, <span class="keyword">long</span> <span class="keyword">int</span> Right )</span> </span>&#123;</span><br><span class="line">    ElementType pivot;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">//是否进行快速排序，阈值判断</span></span><br><span class="line">    <span class="keyword">if</span> ( (Right - Left) &gt;= Cutoff ) &#123;</span><br><span class="line">        <span class="comment">//选主元pivot，藏于A[Right-1]</span></span><br><span class="line">        pivot = <span class="built_in">Median3</span> ( A, Left, Right );<span class="comment">//让这段元素的左、中、右三个有序，并且将中间与这段元素的最右边-1个元素互换，然后返回这段元素的最右边元素-1的下标</span></span><br><span class="line">        i = Left ;</span><br><span class="line">        j = Right - <span class="number">1</span> ;</span><br><span class="line">        <span class="comment">//子集划分(pivot左边全小于pivot；pivot右边全大于pivot)</span></span><br><span class="line">        <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( A[++i] &lt; pivot ) &#123;&#125; <span class="comment">//找到A[i] &gt; pivot, 跳出</span></span><br><span class="line">            <span class="keyword">while</span> ( A[--j] &gt; pivot ) &#123;&#125; <span class="comment">//找到A[j] &lt; pivot, 跳出</span></span><br><span class="line">            <span class="keyword">if</span> ( i &lt; j ) &#123;</span><br><span class="line">                <span class="comment">//说明A[i]与A[j]之间还有其他元素，可交换</span></span><br><span class="line">                <span class="built_in">Swap</span>( &amp;A[i], &amp;A[j] );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Swap</span>( &amp;A[i], &amp;A[Right<span class="number">-1</span>] ); <span class="comment">//将pivot 放到中间，即i下标处</span></span><br><span class="line">        <span class="built_in">Quicksort</span>( A, Left, i<span class="number">-1</span> );<span class="comment">//递归处理左边</span></span><br><span class="line">        <span class="built_in">Quicksort</span>( A, i+<span class="number">1</span>, Right );<span class="comment">//递归处理右边</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//低于阈值，直接调用插入排序</span></span><br><span class="line">        <span class="comment">//递归到最小一层用插入排序(每段的插入排序地址为：&amp;A + Left (即：绝对地址A 加相对地址Left)</span></span><br><span class="line">        <span class="comment">//最小一层插入排序元素个数Number = Right-Left+1</span></span><br><span class="line">        <span class="built_in">Insertion_Sort</span> (  &amp;A[Left], Right-Left+<span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序（统一接口，加壳）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span> <span class="params">( vector&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Number )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Quicksort</span> ( A, <span class="number">0</span>, Number<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-Quick-Sort-运行结果"><a href="#1-2-3-Quick-Sort-运行结果" class="headerlink" title="1.2.3. Quick Sort 运行结果"></a>1.2.3. Quick Sort 运行结果</h3><p><img data-src="/../../../../uploads/AnalysisOfAlgorithmsLesson_QuickSort.png" alt="2_QuickSort"></p>
<h3 id="1-2-4-延伸思考🤔"><a href="#1-2-4-延伸思考🤔" class="headerlink" title="1.2.4. 延伸思考🤔:"></a>1.2.4. 延伸思考🤔:</h3><h4 id="1-2-4-1-1-Quick-sort会在n个具有相同的值的元素列表中进行多少次比较？"><a href="#1-2-4-1-1-Quick-sort会在n个具有相同的值的元素列表中进行多少次比较？" class="headerlink" title="1.2.4.1. (1)Quick sort会在n个具有相同的值的元素列表中进行多少次比较？"></a>1.2.4.1. (1)Quick sort会在n个具有相同的值的元素列表中进行多少次比较？</h4><p>答：N(lgN-1)-lgN次比较。<br>归纳得：子数组长度大于1时，每层的对比次数是上一层元素个数-上一层子数组个数。由于子数组长度大于1时才有比较，所以有比较的层次数是 1(顶层)+lgN-1(底层)&#x3D;lgN。顶层有对比，但未减少元素。底层没有对比。倒数第二层的减少元素数与倒数第三层相关，那么有减少元素个数的层数有lgN-1(底层)-1(倒数第二层)&#x3D;lgN-2。归纳总结后：总的对比次数&#x3D;N<em>对比层数 - 各层的元素减少数之和 &#x3D; N</em>lgN - 各层的元素减少数之和。而第n层的减少元素个数 &#x3D; 2^n-1，各层的减少元素个数和累加为 &#x3D; N-lgN。故总的比较次数为：N(lgN-1)-lgN</p>
<h4 id="1-2-4-2-2-Quick-sort在n个元素列表上进行的最大和最小比较次数是多少，分别给出最大和最小情况的实例。"><a href="#1-2-4-2-2-Quick-sort在n个元素列表上进行的最大和最小比较次数是多少，分别给出最大和最小情况的实例。" class="headerlink" title="1.2.4.2. (2)Quick sort在n个元素列表上进行的最大和最小比较次数是多少，分别给出最大和最小情况的实例。"></a>1.2.4.2. (2)Quick sort在n个元素列表上进行的最大和最小比较次数是多少，分别给出最大和最小情况的实例。</h4><p>答：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？<br>最多需要遍历N次，至少需要遍历lg(N+1)次。</p>
<ul>
<li><p>(1).为什么最少是lg(N+1)次？<br>快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。</p>
</li>
<li><p>(2).为什么最多是N次？<br>将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。</p>
</li>
</ul>
<h2 id="1-3-No3．Matrix-chain-product-The-following-are-some-instances"><a href="#1-3-No3．Matrix-chain-product-The-following-are-some-instances" class="headerlink" title="1.3. No3．Matrix-chain product. The following are some instances"></a>1.3. No3．<strong>Matrix-chain product</strong>. The following are some instances</h2><ul>
<li>a)&lt;3, 5, 2, 1,10&gt;  答：55， 计算次序为：2，1，3</li>
<li>b)&lt;2, 7, 3, 6, 10&gt; 答：198， 计算次序为：1，2，3</li>
<li>c)&lt;10, 3, 15, 12, 7, 2&gt;答：678， 计算次序为：4，2，3，1</li>
<li>d)&lt;7, 2, 4, 15, 20, 5&gt;答：990，计算次序为：2，3，4，1</li>
</ul>
<p>用备忘录解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> length 5 <span class="comment">//矩阵元素个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> numOfMatrix length-1 <span class="comment">//矩阵个数 = length - 1</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="comment">//定义规模为：矩阵链的个数^2 的二维数组,并赋初值无穷大WuQiongDa</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">m</span>(numOfMatrix); <span class="comment">//numOfMatrix 矩阵个数 = length - 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算第i到j段的最小计算次数</span></span><br><span class="line"><span class="comment"> * 返回值&lt;int&gt;：第i到j段的最小运算次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WuQiongDa 69999999</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LookUp_Chain</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//备忘录：若已计算，则返回已计算值</span></span><br><span class="line">    <span class="keyword">if</span> (m[i<span class="number">-1</span>][j<span class="number">-1</span>] != WuQiongDa)&#123;</span><br><span class="line">        <span class="keyword">return</span> m[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若没计算</span></span><br><span class="line">    <span class="comment">//a.过小只有两个矩阵</span></span><br><span class="line">    <span class="keyword">if</span>(j == i+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p[i<span class="number">-1</span>] * p[i] * p[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//b.有可分性</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//计算从 k 处划分(k取值：i到j-1)，后的两边的值 + 两边相乘的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=i; k&lt;=j<span class="number">-1</span>; k++) &#123;</span><br><span class="line">            <span class="comment">//中间值q</span></span><br><span class="line">            <span class="keyword">int</span> q = <span class="built_in">LookUp_Chain</span>(p, i, k) + <span class="built_in">LookUp_Chain</span>(p, k+<span class="number">1</span>, j)</span><br><span class="line">                    + p[i<span class="number">-1</span>] * p[k] * p[j];</span><br><span class="line">            <span class="comment">//记录从k处划分的m[i][j]最小值</span></span><br><span class="line">            <span class="keyword">if</span>(q &lt; m[i<span class="number">-1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;k = &quot;</span> &lt;&lt;  k &lt;&lt; endl;</span><br><span class="line">                m[i<span class="number">-1</span>][j<span class="number">-1</span>] = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 备忘录，矩阵链最小计算次数</span></span><br><span class="line"><span class="comment"> * 传入参数：矩阵链容器，存储顺序的矩阵相乘下标</span></span><br><span class="line"><span class="comment"> * 如：&lt;3, 5, 2, 1, 10&gt; 即为：(3, 5) x (5, 2) x (2, 1) x (1, 10)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Memory_Matrix_Chain</span><span class="params">(<span class="keyword">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numOfMatrix; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;numOfMatrix; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                m[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m[i].<span class="built_in">push_back</span>(WuQiongDa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">LookUp_Chain</span>(p, <span class="number">1</span>, numOfMatrix);<span class="comment">//下标</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>&#125;;<span class="comment">//答：55, 计算次序为：2，1，3</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">5</span>] = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;<span class="comment">//答：198， 计算次序为：1，2，3</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">6</span>] = &#123;<span class="number">10</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>&#125;;<span class="comment">//答：654038</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">6</span>] = &#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">Memory_Matrix_Chain</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Min Calc times = &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-4-No4．最长公共子序列（LCS）"><a href="#1-4-No4．最长公共子序列（LCS）" class="headerlink" title="1.4. No4．最长公共子序列（LCS）"></a>1.4. No4．<strong>最长公共子序列</strong>（LCS）</h2><p>实例输入：</p>
<ul>
<li>a)X: xzyzzyx   Y: zxyyzxz</li>
<li>b)X:MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCALLAAQANKESSSESFISRLLAIVAD<br>Y:MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCTLLAAQANKENSNESFISRLLAIVAG</li>
</ul>
<h3 id="1-4-1-求解思路"><a href="#1-4-1-求解思路" class="headerlink" title="1.4.1. 求解思路"></a>1.4.1. 求解思路</h3><p>因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。最长公共子序列的递归式如下：<br><img data-src="/../../../../uploads/AnalysisOfAlgorithmsLesson_LCS_Formula.png" alt="最长公共子序列的递归式"></p>
<h3 id="1-4-2-C-编程实现LCS"><a href="#1-4-2-C-编程实现LCS" class="headerlink" title="1.4.2. C++编程实现LCS"></a>1.4.2. C++编程实现LCS</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxNum</span><span class="params">(<span class="keyword">int</span> firstNum, <span class="keyword">int</span> secondNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstNum &gt; secondNum ? firstNum : secondNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> direct;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> matrix Matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="keyword">char</span> *strA, <span class="keyword">char</span> *strB, <span class="keyword">int</span> lengthA, <span class="keyword">int</span> lengthB, Matrix *resultMatrix[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//若i = 0 或 j = 0， 返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (lengthA == <span class="number">0</span> || lengthB == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化存储数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lengthA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lengthB; j++) &#123;</span><br><span class="line">            resultMatrix[i][j].num = <span class="number">0</span>; <span class="comment">//设置所有默认的最长为0</span></span><br><span class="line">            resultMatrix[i][j].direct = <span class="number">1</span>; <span class="comment">//所有默认方向变成上 0斜上，1上，-1左</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=lengthB; j++)&#123;</span><br><span class="line">        resultMatrix[<span class="number">0</span>][j].direct = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lengthB; j++) &#123;</span><br><span class="line">            <span class="comment">//若字符串A，字符串B 末尾元素相同</span></span><br><span class="line">            <span class="keyword">if</span> (strA[i] == strB[j]) &#123;</span><br><span class="line">                resultMatrix[i+<span class="number">1</span>][j+<span class="number">1</span>].num = resultMatrix[i][j].num + <span class="number">1</span>;</span><br><span class="line">                resultMatrix[i+<span class="number">1</span>][j+<span class="number">1</span>].direct = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，分别计算子问题求最大</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                resultMatrix[i+<span class="number">1</span>][j+<span class="number">1</span>].num = <span class="built_in">MaxNum</span>(resultMatrix[i+<span class="number">1</span>][j].num, resultMatrix[i][j+<span class="number">1</span>].num);</span><br><span class="line">                resultMatrix[i+<span class="number">1</span>][j+<span class="number">1</span>].direct = resultMatrix[i+<span class="number">1</span>][j].num &gt; resultMatrix[i][j+<span class="number">1</span>].num ? (<span class="number">-1</span>) : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMatrix[lengthA][lengthB].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strA[] = &#123;<span class="string">&quot;xzyzzyx&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> strB[] = &#123;<span class="string">&quot;zxyyzxz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> lengthA = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(strA);</span><br><span class="line">    <span class="keyword">int</span> lengthB = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(strB);</span><br><span class="line">    Matrix *resultMatrix[lengthA+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lengthA; i++) &#123;</span><br><span class="line">        resultMatrix[i] = (Matrix*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct matrix)* (lengthB+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="built_in">LCS</span>(strA, strB, lengthA, lengthB, resultMatrix);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max = &quot;</span> &lt;&lt; max &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt; result_LCS;</span><br><span class="line">    <span class="comment">//便利二维数组，求解最长公共子序列</span></span><br><span class="line">    <span class="comment">//所有默认方向变成上 0斜上，1上，-1左</span></span><br><span class="line">    <span class="keyword">int</span> i=lengthA, j=lengthB;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = resultMatrix[i][j].direct;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (k)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                result_LCS.<span class="built_in">push_back</span>(strA[i<span class="number">-1</span>]);</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;something Error!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=result_LCS.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        cout &lt;&lt;result_LCS[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-3-程序运行结果："><a href="#1-4-3-程序运行结果：" class="headerlink" title="1.4.3. 程序运行结果："></a>1.4.3. 程序运行结果：</h3><ul>
<li>a)X: xzyzzyx   Y: zxyyzxz<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max = <span class="number">4</span></span><br><span class="line">xyzz</span><br></pre></td></tr></table></figure></li>
<li>b)X:MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCALLAAQANKESSSESFISRLLAIVAD<br>Y:MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCTLLAAQANKENSNESFISRLLAIVAG<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max = <span class="number">56</span></span><br><span class="line">MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCLLAAQANKESESFISRLLAIVA</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-5-No5-多级图中的最短路径"><a href="#1-5-No5-多级图中的最短路径" class="headerlink" title="1.5. No5. 多级图中的最短路径"></a>1.5. No5. 多级图中的最短路径</h2><p><strong>多级图是图(1)G&#x3D;(V,E),其中V被划分为K&gt;&#x3D;2个不相交的子集,使得如果(a,b)在E中,则a在Vi中,并且b在Vi+1对于分区中的某些子集中;和(2)|V1|&#x3D;|Vk|&#x3D;1.</strong><br><img data-src="/../../../../uploads/AnalysisOfAlgorithmsLesson_SPIMG.png" alt="Shortest_path_in_multistage_graphs"></p>
<h3 id="1-5-1-求解思路"><a href="#1-5-1-求解思路" class="headerlink" title="1.5.1. 求解思路"></a>1.5.1. 求解思路</h3><p>Dijkstra算法。以起始点为中心向外层层扩展，直到扩展到终点为止。</p>
<h3 id="1-5-2-Dijkstra算法实现："><a href="#1-5-2-Dijkstra算法实现：" class="headerlink" title="1.5.2. Dijkstra算法实现："></a>1.5.2. Dijkstra算法实现：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="comment">/** 构建并初始化一维矩阵dist距离</span></span><br><span class="line"><span class="comment">     * 表示：起始节点v 到其他所有节点的距离</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        dist.<span class="built_in">push_back</span>(WuQiongDa);</span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>;<span class="comment">//节点到自身的距离为0</span></span><br><span class="line">    <span class="comment">//构建存储中间前驱节点变量的一维</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    path[v] = v;<span class="comment">// 起始节点的前驱节点为其自身</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个结点都尝试做中间节点 k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="keyword">this</span>-&gt;n; k++)&#123;</span><br><span class="line">        <span class="comment">//临时的目的节点(j)： 从v到j： v-&gt;k、k-&gt;j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="keyword">this</span>-&gt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[k]!=WuQiongDa &amp;&amp; g[k][j]!=WuQiongDa &amp;&amp; (dist[j] &gt; dist[k]+g[k][j]))&#123;</span><br><span class="line">                dist[j] = dist[k]+g[k][j];<span class="comment">//更新 v到j 距离</span></span><br><span class="line">                path[j] = k;<span class="comment">// 记录前驱节点 k</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The shortest path Length of (&quot;</span>&lt;&lt; v &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; dist[w] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Path: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> from = <span class="keyword">this</span>-&gt;n <span class="number">-1</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; OutPath;</span><br><span class="line">    OutPath.<span class="built_in">push_back</span>(w);</span><br><span class="line">    <span class="keyword">while</span>(path[from]!=v)&#123;</span><br><span class="line">        OutPath.<span class="built_in">push_back</span>(path[from]);</span><br><span class="line">        from = path[from];</span><br><span class="line">    &#125;</span><br><span class="line">    OutPath.<span class="built_in">push_back</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=OutPath.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        cout &lt;&lt; OutPath[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">The shortest path Length <span class="title">of</span> <span class="params">(<span class="number">0</span>-&gt;<span class="number">15</span>)</span> </span>= <span class="number">18</span></span><br><span class="line">Path: <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">4</span> -&gt; <span class="number">7</span> -&gt; <span class="number">11</span> -&gt; <span class="number">14</span> -&gt; <span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-No6-简单的调度问题"><a href="#1-6-No6-简单的调度问题" class="headerlink" title="1.6. No6. 简单的调度问题"></a>1.6. No6. 简单的<strong>调度问题</strong></h2><p>我们给出了作业j1，j2 … jn，它们分别具有已知的运行时间t1，t2 … tn。 我们有一个处理器。安排这些工作以最小化平均完成时间的最佳方法是什么。假设它是非抢先式调度：一旦作业启动，它必须运行完成。 以下是一些实例：</p>
<p>a)(j1, j2, j3, j4) : (15，8，3，10)</p>
<h3 id="1-6-1-解题思路"><a href="#1-6-1-解题思路" class="headerlink" title="1.6.1. 解题思路"></a>1.6.1. 解题思路</h3><p>将工作时长做为贪心算法的参数，贪工作时长最小的工作，时长越短，安排越前。</p>
<h3 id="1-6-2-简单贪心实现"><a href="#1-6-2-简单贪心实现" class="headerlink" title="1.6.2. 简单贪心实现"></a>1.6.2. 简单贪心实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//用贪心求工作时序安排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedulGreedy</span><span class="params">(<span class="keyword">int</span> jobs[], <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">jobSchedule</span><span class="params">(num, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        jobSchedule[i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;num; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jobs[i] &gt; jobs[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = jobs[i];</span><br><span class="line">                jobs[i] = jobs[j];</span><br><span class="line">                jobs[j] = temp;</span><br><span class="line">                temp = jobSchedule[i];</span><br><span class="line">                jobSchedule[i] = jobSchedule[j];</span><br><span class="line">                jobSchedule[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;job schedule is:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;j&quot;</span> &lt;&lt; jobSchedule[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=num<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> jobs[<span class="number">4</span>] = &#123;<span class="number">15</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">schedulGreedy</span>(jobs, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">job schedule is:</span><br><span class="line">j3 -&gt; j2 -&gt; j4 -&gt; j1</span><br></pre></td></tr></table></figure>

<h2 id="1-7-No7-单源最短路径"><a href="#1-7-No7-单源最短路径" class="headerlink" title="1.7. No7. 单源最短路径"></a>1.7. No7. 单源最短路径</h2><p>以下是邻接矩阵，顶点A是源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  A  B  C  D  E</span><br><span class="line">A    <span class="number">-1</span> <span class="number">3</span></span><br><span class="line">B       <span class="number">3</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line">C       </span><br><span class="line">D    <span class="number">1</span>  <span class="number">5</span></span><br><span class="line">E          <span class="number">-3</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-1-分析"><a href="#1-7-1-分析" class="headerlink" title="1.7.1. 分析"></a>1.7.1. 分析</h3><p>手动绘制单向图如下所示：<br><img data-src="/../../../../uploads/AnalysisOfAlgorithmsLesson_single_source_graph.jpg" alt="single source graph"><br>由图可知，图中节点A只有出度，节点C只有入度，其他不得而知，且题目给的较为模糊，不知是(1)求解从节点A-&gt;节点C的最短路径，或是（2）求解从节点A出发到任意节点中路径最短的一条。姑且按（2）求解</p>
<h3 id="1-7-2-解题思路"><a href="#1-7-2-解题思路" class="headerlink" title="1.7.2. 解题思路"></a>1.7.2. 解题思路</h3><p>与求解第5题类似，参数是否为有向图为:true，仍采用Dijkstra算法。以起始点为中心向外层层扩展，直到扩展到终点为止，可以得到从起始节点到所有节点的最短距离。</p>
<h3 id="1-7-3-核心代码"><a href="#1-7-3-核心代码" class="headerlink" title="1.7.3. 核心代码"></a>1.7.3. 核心代码</h3><p>代码与第五题代码部分有所区别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dijkstra算法实现</span></span><br><span class="line"><span class="comment"> * 参数：起始节点 v</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/** 构建并初始化一维矩阵dist距离</span></span><br><span class="line"><span class="comment">     * 表示：起始节点v 到其他所有节点的距离</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        dist.<span class="built_in">push_back</span>(WuQiongDa);</span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>;<span class="comment">//节点到自身的距离为0</span></span><br><span class="line">    <span class="comment">//构建存储中间前驱节点变量的一维</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    path[v] = v;<span class="comment">// 起始节点的前驱节点为其自身</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个结点都尝试做中间节点 k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="keyword">this</span>-&gt;n; k++)&#123;</span><br><span class="line">        <span class="comment">//临时的目的节点(j)： 从v到j： v-&gt;k、k-&gt;j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="keyword">this</span>-&gt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[k]!=WuQiongDa &amp;&amp; g[k][j]!=WuQiongDa &amp;&amp; (dist[j] &gt; dist[k]+g[k][j]))&#123;</span><br><span class="line">                dist[j] = dist[k]+g[k][j];<span class="comment">//更新 v到j 距离</span></span><br><span class="line">                path[j] = k;<span class="comment">// 记录前驱节点 k</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出起始节点到所有节点的距离，顺便找出最短的距离</span></span><br><span class="line">    <span class="keyword">int</span> recordTheShortestPath;</span><br><span class="line">    <span class="keyword">int</span> temp = WuQiongDa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[dist] A-&gt;&quot;</span> &lt;&lt; (<span class="keyword">char</span>)(i+<span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; dist[i] &lt;&lt; <span class="string">&quot;;  &quot;</span>;</span><br><span class="line">        <span class="built_in">showPathFrom0To</span>(i, path);</span><br><span class="line">        <span class="keyword">if</span>(dist[i] &lt; temp)&#123;</span><br><span class="line">            temp = dist[i];</span><br><span class="line">            recordTheShortestPath = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示从起始节点出发到各节点的最短路径</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The shortest Path is [dist] A-&gt;&quot;</span> &lt;&lt; (<span class="keyword">char</span>)(recordTheShortestPath+<span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; dist[recordTheShortestPath] &lt;&lt; <span class="string">&quot;;  &quot;</span>;</span><br><span class="line">    <span class="built_in">showPathFrom0To</span>(recordTheShortestPath, path);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示从起始节点0， 到第w个节点的路径（通过传入的前驱节点path数组显示）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPathFrom0To</span><span class="params">(<span class="keyword">int</span> w, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Path from (A-&gt;&quot;</span> &lt;&lt; (<span class="keyword">char</span>)(w+<span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot;): &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> from = w;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; OutPath;</span><br><span class="line">    OutPath.<span class="built_in">push_back</span>(w);</span><br><span class="line">    <span class="keyword">while</span>(path[from]!=<span class="number">0</span>)&#123;</span><br><span class="line">        OutPath.<span class="built_in">push_back</span>(path[from]);</span><br><span class="line">        from = path[from];</span><br><span class="line">    &#125;</span><br><span class="line">    OutPath.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=OutPath.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">char</span>)(OutPath[i]+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[dist] A-&gt;B = <span class="number">-1</span>;  <span class="function">Path <span class="title">from</span> <span class="params">(A-&gt;B)</span>: A -&gt; B</span></span><br><span class="line"><span class="function">[dist] A-&gt;C =</span>  <span class="number">2</span>;  <span class="function">Path <span class="title">from</span> <span class="params">(A-&gt;C)</span>: A -&gt; B -&gt; C</span></span><br><span class="line"><span class="function">[dist] A-&gt;D =</span> <span class="number">-2</span>;  <span class="function">Path <span class="title">from</span> <span class="params">(A-&gt;D)</span>: A -&gt; B -&gt; E -&gt; D</span></span><br><span class="line"><span class="function">[dist] A-&gt;E =</span>  <span class="number">1</span>;  <span class="function">Path <span class="title">from</span> <span class="params">(A-&gt;E)</span>: A -&gt; B -&gt; E</span></span><br><span class="line"><span class="function">The shortest Path is [dist] A-&gt;D =</span> <span class="number">-2</span>;  <span class="function">Path <span class="title">from</span> <span class="params">(A-&gt;D)</span>: A -&gt; B -&gt; E -&gt; D</span></span><br></pre></td></tr></table></figure>
<p>可知</p>
<ul>
<li><p>(1)求解从节点A-&gt;节点C的最短路径<br>[dist] A-&gt;C &#x3D;  2;  Path from (A-&gt;C): A -&gt; B -&gt; C</p>
</li>
<li><p>(2)求解从节点A出发到任意节点中路径最短的一条。<br>The shortest Path is [dist] A-&gt;D &#x3D; -2;  Path from (A-&gt;D): A -&gt; B -&gt; E -&gt; D</p>
</li>
</ul>
<h2 id="1-8-No8．回溯算法（8皇后问题）"><a href="#1-8-No8．回溯算法（8皇后问题）" class="headerlink" title="1.8. No8．回溯算法（8皇后问题）"></a>1.8. No8．回溯算法（8皇后问题）</h2><h3 id="1-8-1-回溯算法"><a href="#1-8-1-回溯算法" class="headerlink" title="1.8.1. 回溯算法"></a>1.8.1. 回溯算法</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h3 id="1-8-2-回溯算法在N皇后问题求解算发中实现（核心代码）"><a href="#1-8-2-回溯算法在N皇后问题求解算发中实现（核心代码）" class="headerlink" title="1.8.2. 回溯算法在N皇后问题求解算发中实现（核心代码）"></a>1.8.2. 回溯算法在N皇后问题求解算发中实现（核心代码）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用回溯算法求解8皇后问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueensByBackTracking</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//k:表示行数，从第0行开始</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(n, <span class="number">-1</span>)</span></span>;<span class="comment">//创建int x[n]容器，x[k]用于存储第k行皇后放置的列数</span></span><br><span class="line">    <span class="keyword">while</span> (k&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        x[k]++;<span class="comment">//第k行皇后放置位置右移，初次正好到0； 回溯时在上一次失败尝试下右移</span></span><br><span class="line">        <span class="comment">//试探右移找到不冲突的列</span></span><br><span class="line">        <span class="keyword">while</span>(x[k]&lt;n &amp;&amp; !<span class="built_in">PLACE</span>(k, x))&#123;</span><br><span class="line">            x[k]++;<span class="comment">//列右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【判断】上一步退出while的原因（是否找到不冲突的列）</span></span><br><span class="line">        <span class="comment">//一、若已找到不冲突的列</span></span><br><span class="line">        <span class="keyword">if</span> (x[k] &lt; n)&#123;</span><br><span class="line">            <span class="comment">//【判断】：是否所有行均找到结果</span></span><br><span class="line">            <span class="comment">//1.所有行结果均已找到：输出结果</span></span><br><span class="line">            <span class="keyword">if</span>(k == n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">showResult</span>(x);<span class="comment">//显示n皇后结果</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.k行后面行还没找到结果</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k++;<span class="comment">//行数后移</span></span><br><span class="line">                x[k] = <span class="number">-1</span>;<span class="comment">//初始值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二、（未找到不冲突的列）当前行k的所有结果均冲突时，回溯，行数k-1</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; queens problem has no answer&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">The answer of <span class="number">8</span> queens problem is:   <span class="number">0</span>  <span class="number">4</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">3</span></span><br><span class="line">============= Draw =============</span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"><span class="number">0</span>  Q  -  -  -  -  -  -  -</span><br><span class="line"><span class="number">1</span>  -  -  -  -  Q  -  -  -</span><br><span class="line"><span class="number">2</span>  -  -  -  -  -  -  -  Q</span><br><span class="line"><span class="number">3</span>  -  -  -  -  -  Q  -  -</span><br><span class="line"><span class="number">4</span>  -  -  Q  -  -  -  -  -</span><br><span class="line"><span class="number">5</span>  -  -  -  -  -  -  Q  -</span><br><span class="line"><span class="number">6</span>  -  Q  -  -  -  -  -  -</span><br><span class="line"><span class="number">7</span>  -  -  -  Q  -  -  -  -</span><br></pre></td></tr></table></figure>

<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ul>
<li>在求解No3时：边界条件的判断、容器vector的使用、中间选择过程的记录；</li>
<li>在求解最长公共子序列时，对Dp中间求解的过程变量存储，选取的(i,j+1)还是（i+1,j）的细节判断，及后续逆便利中间过程记录二维矩阵时的走向与方向的细节执行；</li>
<li>Dijkstra算法实现过程中的问题，图节点的遍历，及根据中间记录的选择过程逆向遍历得到最短路径；</li>
<li>回溯算法中什么时候k++,什么时候k–，以及x[k]的初值问题；</li>
<li>及各类算法编程实现的通用问题，算法实现、边界条件、状态转换、初值等等。</li>
</ul>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：C++<br><strong>所有实验题目完整源代码</strong>：<a href="../../../../uploads/AnalysisOfAlgorithmsLesson_code.zip">AnalysisOfAlgorithmsLesson_code.zip</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树与B*树</title>
    <url>/2020/12/24/BPlusTreeAndBStartTree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/BPlusTree1.jpg" class="full-image" />

<h1 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1. B+树"></a>1. B+树</h1><h2 id="1-1-B-树简介"><a href="#1-1-B-树简介" class="headerlink" title="1.1. B+树简介"></a>1.1. B+树简介</h2><p>B+树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</p>
<a id="more"></a>

<h2 id="1-2-B-树应用场景"><a href="#1-2-B-树应用场景" class="headerlink" title="1.2. B+树应用场景"></a>1.2. B+树应用场景</h2><p>B+树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入。</p>
<h2 id="1-3-B-树定义"><a href="#1-3-B-树定义" class="headerlink" title="1.3. B+树定义"></a>1.3. B+树定义</h2><ul>
<li>B+树是应文件系统所需而出的一种B树的变型树。一棵m阶的B+树和m阶的B树的差异在于：<ul>
<li>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。</li>
</ul>
</li>
</ul>
<p>备注：通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>
<ul>
<li>B+树是B树的变体，也是一种多路搜索树，其定义除以下存有差异的定义外基本与B树同：<ul>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ul>
</li>
</ul>
<p><img data-src="/../../../../uploads/BPlusTree2.PNG" alt="B+树"></p>
<p>备注：B+的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<h2 id="1-4-B-的特性"><a href="#1-4-B-的特性" class="headerlink" title="1.4. B+的特性"></a>1.4. B+的特性</h2><ul>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ul>
<h1 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B*树"></a>2. B*树</h1><p><img data-src="/../../../../uploads/BStartTree.PNG" alt="B*树"></p>
<h2 id="2-1-B-树的定义"><a href="#2-1-B-树的定义" class="headerlink" title="2.1. B*树的定义"></a>2.1. B*树的定义</h2><ul>
<li>是B+树的变体，在B+树的非根和非叶子结点再增加<strong>指向兄弟的指针</strong>；</li>
<li>B*树定义了非叶子结点关键字个数至少为(2&#x2F;3)*M，即块的最低使用率为2&#x2F;3（代替B+树的1&#x2F;2）；</li>
</ul>
<h1 id="3-B树，B-树，B-树小结"><a href="#3-B树，B-树，B-树小结" class="headerlink" title="3. B树，B+树，B*树小结"></a>3. B树，B+树，B*树小结</h1><table>
<thead>
<tr>
<th align="left">数据结构</th>
<th align="left">小结</th>
</tr>
</thead>
<tbody><tr>
<td align="left">B树</td>
<td align="left">多路搜索树，每个结点存储M&#x2F;2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</td>
</tr>
<tr>
<td align="left">B+树</td>
<td align="left">在B树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</td>
</tr>
<tr>
<td align="left">B*树</td>
<td align="left">在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1&#x2F;2提高到2&#x2F;3；</td>
</tr>
</tbody></table>
<h1 id="4-B树，B-树与B-树的优缺点比较"><a href="#4-B树，B-树与B-树的优缺点比较" class="headerlink" title="4. B树，B+树与B*树的优缺点比较"></a>4. B树，B+树与B*树的优缺点比较</h1><p>备注：B-树就是B树，”-“是个连字符号，不是减号。</p>
<h2 id="4-1-B树-vs-B-树"><a href="#4-1-B树-vs-B-树" class="headerlink" title="4.1. B树 vs B+树"></a>4.1. B树 vs B+树</h2><ul>
<li>B树是一种平衡的多路查找(又称排序)树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance)</li>
<li>B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。</li>
<li>B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。</li>
<li>B树的优势是当你要查找的值恰好处在一个非叶子节点时，查找到该节点就会成功并结束查询，而B+树由于非叶节点只是索引部分，这些节点中只含有其子树中的最大(或最小)关键字，当非终端节点上的关键字等于给点值时，查找并不终止，而是继续向下直到叶子节点。因此在B+树中，无论查找成功与否，都是走了一条从根到叶子节点的路径。有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。</li>
<li>另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。 mysql底层存储是用B+树实现的，因为内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了。</li>
</ul>
<h2 id="4-2-B-树-vs-B-树"><a href="#4-2-B-树-vs-B-树" class="headerlink" title="4.2. B+树 vs B*树"></a>4.2. B+树 vs B*树</h2><ul>
<li>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B树定义了非叶子结点关键字个数至少为(2&#x2F;3)M，即块的最低使用率为2&#x2F;3（代替B+树的1&#x2F;2）；</li>
<li>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1&#x2F;2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</li>
<li>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1&#x2F;3的数据到新结点，最后在父结点增加新结点的指针； 所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</li>
</ul>
<h1 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h1><ul>
<li><a href="https://www.jianshu.com/p/7323130d351b">讲点”B树”，一文详解B树，B+树，B*树及其优缺点比较</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>测试内存中变量的存储方式</title>
    <url>/2019/07/24/BitPrint/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/bitPrint.jpg" class="full-image" />

<p>众所周知，程序中的变量存放于计算机内存中，程序对这些变量执行特定的赋值和计算等操作以实现某种功能。你是否好奇变量是如何被存储和表示于内存之中呢？</p>
<a id="more"></a>

<p>不同类型的变量所占字节大小不同、相同类型的变量在不同操作系统内所占字节大小也可能不同。而对于超过1字节的变量，根据不同的操作系统，还涉及字节序、字节对齐、大端or小端等其他问题。接下来让我们探究一下变量在内存中的表示与存放吧！</p>
<p><strong>关键词:</strong> 比特打印、字节序、字节对齐</p>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>一般初学一门编程语言时，最开始了解的就是这门语言支持的基本变量类型、其大小（占多少字节），可表示的数值范围。如在C&#x2F;C++语言中，char类型的变量占一个字节(一个字节含8bit，为减少内存管理负担，一字节通常也是操作系统内存的最小单位，但应用时各bit可被赋予不同的语义）。char变量有8bit，除去最高位为符号位用于表示数的正负外，剩余的低7位可以表示到(0 ~ 2^7 - 1，即0～127)，加上符号位即 + - (0～127)，又由于”-0”(0x80)与我们常用的数学方式不符，而被译为-128，故在C&#x2F;C++程序语言中，一个char类型的变量，仅占用一个字节，却被可以表示 -128 ~ 127 的数值范围。</p>
<h1 id="2-存储方式探究"><a href="#2-存储方式探究" class="headerlink" title="2. 存储方式探究"></a>2. 存储方式探究</h1><h2 id="2-1-打印各比特原理概述"><a href="#2-1-打印各比特原理概述" class="headerlink" title="2.1. 打印各比特原理概述"></a>2.1. 打印各比特原理概述</h2><p>运用C&#x2F;C++中提供的位操作符和与操作原理“a &amp; 1 &#x3D; a” 和 “a &amp; 0 &#x3D; 0”获得各位的0&#x2F;1值。依次从最高位开始提取，若为1则打印“1”，若为0则打印“0”，然后提取次高位的0&#x2F;1值并打印，直至提取打印到最低位。至此一个字节的各比特的值都以打印出来。</p>
<h2 id="2-2-编码测试"><a href="#2-2-编码测试" class="headerlink" title="2.2. 编码测试"></a>2.2. 编码测试</h2><h3 id="2-2-1-byte-变量各比特位打印实现"><a href="#2-2-1-byte-变量各比特位打印实现" class="headerlink" title="2.2.1. byte 变量各比特位打印实现"></a>2.2.1. byte 变量各比特位打印实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印一个 byte 变量的各位</span></span><br><span class="line"><span class="comment"> * 默认各字节从左至右 对应 高位至地位</span></span><br><span class="line"><span class="comment"> * eg. 0x80  --&gt; [1000 0000]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitPrint::bitPrint_Byte</span><span class="params">(<span class="keyword">const</span> byte val)</span> </span>&#123;</span><br><span class="line">    byte comp = <span class="number">0x80</span>;<span class="comment">//相当于标尺，当前取最高位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; [&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (comp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comp == <span class="number">0x08</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((val &amp; comp) == comp)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        comp &gt;&gt;= <span class="number">1</span>;<span class="comment">//逻辑右移，依次取各位</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在调用该函数并传入参数0x55时，其执行结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="number">0101</span> <span class="number">0101</span>]</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：<br>由于传入参数0x55其高低字节都为5，二进制中表示为0101，而我们可以看到其在内存中存储结果其高低字节分别为[0101 0101]，与分析相符。</p>
<h3 id="2-2-2-char-变量各比特的打印实现"><a href="#2-2-2-char-变量各比特的打印实现" class="headerlink" title="2.2.2. char 变量各比特的打印实现"></a>2.2.2. char 变量各比特的打印实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印一个 char 变量的各位</span></span><br><span class="line"><span class="comment"> * 默认各字节从左至右 对应 高位至地位</span></span><br><span class="line"><span class="comment"> * eg. 0x80  --&gt; [1000 0000]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitPrint::bitPrint_Char</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;char = &quot;</span> &lt;&lt; val &lt;&lt; endl &lt;&lt; <span class="string">&quot;Bits:&quot;</span>;</span><br><span class="line">    <span class="built_in">bitPrint_Byte</span>((byte)val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在调用该函数并传入参数’M’时，其执行结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> = M</span><br><span class="line">Bits: [<span class="number">0100</span> <span class="number">1101</span>]</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：<br>char类型与byte类型十分相似，都占用一个字节，但其最高位拥有特殊语义，最高位为0表示正数，最高位为1表示负数。当传入参数为’M’，查询ASCII（美国信息交换标准代码）表可知’M’的为表中第77个字符，用0x4D表示。其中高字节4二进制表示为0100，低字节D二进制表示为1101，且最高位（最左位）为0表示正数，结果与分析一致。</p>
<h3 id="2-2-3-int-变量各比特的打印实现"><a href="#2-2-3-int-变量各比特的打印实现" class="headerlink" title="2.2.3. int 变量各比特的打印实现"></a>2.2.3. int 变量各比特的打印实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印一个 int 变量的各位</span></span><br><span class="line"><span class="comment"> * 默认各字节从左至右 对应 高位至地位,</span></span><br><span class="line"><span class="comment"> * 默认从左至右为内存地址的增长方向</span></span><br><span class="line"><span class="comment"> * 小端字节序（正序）：高字节对应内存的高地址</span></span><br><span class="line"><span class="comment"> * 大端字节序（逆序）：高字节对应内存的低地址（网络传输统一用大端字节序）</span></span><br><span class="line"><span class="comment"> * eg. 0x00001234</span></span><br><span class="line"><span class="comment"> * 小端（正序） [0011 0100] [0001 0010] [0000 0000] [0000 0000]</span></span><br><span class="line"><span class="comment"> * 大端（逆序） [0000 0000] [0000 0000] [0001 0010] [0011 0100]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitPrint::bitPrint_Int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    byte* byteBuf = (byte *) &amp;val;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;int = &quot;</span> &lt;&lt; val &lt;&lt; endl &lt;&lt; <span class="string">&quot;Bits:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;IntLen; i++) &#123;</span><br><span class="line">        <span class="built_in">bitPrint_Byte</span>(byteBuf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在调用该函数并传入参数19088743时，其执行结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> = <span class="number">19088743</span></span><br><span class="line">Bits: [<span class="number">0110</span> <span class="number">0111</span>] [<span class="number">0100</span> <span class="number">0101</span>] [<span class="number">0010</span> <span class="number">0011</span>] [<span class="number">0000</span> <span class="number">0001</span>]</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>int变量类型占用四个字节，其最高位拥有特殊语义，最高位为0表示正数，最高位为1表示负数。int变量占四个字节，所以就会引发这样一个问题——“字节在电脑中存放时的序列与输入（输出）时的序列是先到的在前还是后到的在前？”针对此问题，产生两种不同的字节序，即规定多字节变量在内存中连续存放时的顺序是低地址对应高字节or低地址对应低字节。产生了两种字节序：</p>
<ul>
<li>小端字节序（正序）：高字节对应内存的高地址</li>
<li>大端字节序（逆序）：高字节对应内存的低地址（网络传输统一用大端字节序）<br>由于不同的系统采用的字节序不同，正好也可验证下自己的操作系统采用哪种字节序。<br>当传入参数为19088743，其十六进制表示为0x01234567。而分析其执行结果，低地址存放为[0110 0111]，十六进制为0x67，对应int值的低字节；而高地址存放为[0000 0001]，十六进制为0x01，对应int值的高字节。故可得知博主操作系统字节序为小端字节序（正序）。</li>
</ul>
<h2 id="2-3-扩展延伸"><a href="#2-3-扩展延伸" class="headerlink" title="2.3. 扩展延伸"></a>2.3. 扩展延伸</h2><h3 id="2-3-1-打印-任意-变量的各比特"><a href="#2-3-1-打印-任意-变量的各比特" class="headerlink" title="2.3.1. 打印 任意 变量的各比特"></a>2.3.1. 打印 任意 变量的各比特</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印一个 任意 变量的各位</span></span><br><span class="line"><span class="comment"> * 默认各字节从左至右 对应 高位至地位,</span></span><br><span class="line"><span class="comment"> * 默认从左至右为内存地址的增长方向</span></span><br><span class="line"><span class="comment"> * 小端字节序（正序）：高字节对应内存的高地址</span></span><br><span class="line"><span class="comment"> * 大端字节序（逆序）：高字节对应内存的低地址（网络传输统一用大端字节序）</span></span><br><span class="line"><span class="comment"> * eg. 0x00001234</span></span><br><span class="line"><span class="comment"> * 小端（正序） [0011 0100] [0001 0010] [0000 0000] [0000 0000]</span></span><br><span class="line"><span class="comment"> * 大端（逆序） [0000 0000] [0000 0000] [0001 0010] [0011 0100]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitPrint::bitPrint_Element</span><span class="params">(<span class="keyword">void</span> *val, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    byte* byteBuf = <span class="keyword">new</span> byte[len];<span class="comment">//申请len长度的内存用于存放变量的所有字节</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(byteBuf, val, len);<span class="comment">//深拷贝</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bits:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="built_in">bitPrint_Byte</span>(byteBuf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> byteBuf;<span class="comment">//释放byteBuf内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在调用该函数并传入参数为一个自定义类（或结构体）时，其执行结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数：学生成绩类的首地址</span></span><br><span class="line"><span class="comment">//学生成绩类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> id;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">char</span> id, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主函数内运行</span></span><br><span class="line">Student* xiaoming = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">88</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;class = &#123;&quot;</span> &lt;&lt; xiaoming-&gt;id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; xiaoming-&gt;score &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">bitPrint-&gt;<span class="built_in">bitPrint_Element</span>(xiaoming, <span class="built_in"><span class="keyword">sizeof</span></span>(Student));</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> =</span> &#123;A, <span class="number">88</span>&#125;</span><br><span class="line">Bits: [<span class="number">0100</span> <span class="number">0001</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0101</span> <span class="number">1000</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0000</span> <span class="number">0000</span>]</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：<br>从学生成绩类的定义可以看出，此类含有两个属性：char类型的学生编号id 和 int类型的学生成绩score，按理说这个类实例化后分配的内存应该是（1+4）为5个字节，但结果确是8个字节，这是为了方便快速地寻址，编译器会采用字节对齐，将下一个变量地址放置在系统能快速读取的位置（如：32位系统，放在偶地址的变量能够1个读周期取到值，而放在奇地址的变量却需要2个读周期才能取到值，故会存在字节对齐）。所以在第一个char变量后跳过了3个字节，将第二个int变量首地址设置为第5个字节。故此Student类在内存中的存放为：0x41、连续3个0x00对齐字节，4个字节的int变量[0101 1000] [0000 0000] [0000 0000] [0000 0000]，合计8个字节。</p>
<h3 id="2-3-2-判断系统是否为大端字节序"><a href="#2-3-2-判断系统是否为大端字节序" class="headerlink" title="2.3.2. 判断系统是否为大端字节序"></a>2.3.2. 判断系统是否为大端字节序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 判断系统是否为大端字节序</span></span><br><span class="line"><span class="comment"> * 小端字节序（正序）：高字节对应内存的高地址</span></span><br><span class="line"><span class="comment"> * 大端字节序（逆序）：高字节对应内存的低地址（网络传输统一用大端字节序）</span></span><br><span class="line"><span class="comment"> * @Return 是大端字节序（true）；是小端字节序（false）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BitPrint::isBigEndian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">0x01</span>;</span><br><span class="line">    byte* byteBuf = (byte *) &amp;test;</span><br><span class="line">    <span class="comment">//取低地址的一个字节为Byte变量，若其值等于低字节0x01则为正序（小端）</span></span><br><span class="line">    <span class="keyword">return</span> (byteBuf[<span class="number">0</span>] == <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数内运行 main.cpp</span></span><br><span class="line"><span class="comment">//判断系统是否为大端字节序</span></span><br><span class="line"><span class="keyword">if</span> (bitPrint-&gt;<span class="built_in">isBigEndian</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Yes, this system is Big Endian System&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;No, this system is Small Endian System&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line">No, <span class="keyword">this</span> system is Small Endian System</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>通过判断特定的int变量在内存中存放的次序即可判断当前系统采用的字节序。实际操作为取特定值为0x01的int变量的低地址的一个字节为Byte变量，若其值等于低字节0x01则为正序（小端），反之则为大端字节序。</p>
<h1 id="3-字节对齐"><a href="#3-字节对齐" class="headerlink" title="3. 字节对齐"></a>3. 字节对齐</h1><p>前面分析到为了方便快速地寻址，编译器会采用字节对齐，将下一个变量地址放置在系统能快速读取的位置（如：32位系统，放在偶地址的变量能够1个读周期取到值，而放在奇地址的变量却需要2个读周期才能取到值，故会存在字节对齐）。<br>即对待结构体内的各位元素就像对待sizeof为n的数组一样，从结构体首地址开始依次向后为每个成员寻找第一个满足“addr % N &#x3D;&#x3D; 0”的地址，如果不够则在前一个成员变量后补空字节使之满足条件。上面的N为对齐参数(N &#x3D; min(sizeof(第i个成员类型),n))，n，可以设置，在c++中缺省值为8。<br>下面一起来验证一下吧！</p>
<h2 id="3-1-先自定义一个包含多类型变量的结构体"><a href="#3-1-先自定义一个包含多类型变量的结构体" class="headerlink" title="3.1. 先自定义一个包含多类型变量的结构体"></a>3.1. 先自定义一个包含多类型变量的结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MSG1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">16</span>];<span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> type;<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">char</span> flag;<span class="comment">// 1  --&gt;   字节对齐（其后闲置1字节，共占2字节）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uiHashValue;<span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uiDataLen;<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> contentData[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MSG0</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">16</span>];<span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> type;<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">char</span> flag; <span class="comment">// 1  --&gt;   字节对齐（其后闲置1字节）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uiHashValue;<span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uiDataLen;<span class="comment">// 4  --&gt;   字节对齐（其后闲置4字节，共占8字节）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ulStartTime;<span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ulEndTime;<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> contentData[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个该结构体变量并打印出各成员变量的地址如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MSG1 msg1;</span><br><span class="line">    cout &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1:\t\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.ID:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.ID &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.ID - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.type:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.type &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.type - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.flag:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.flag &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.flag - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.uiHashValue:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.uiHashValue &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.uiHashValue - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.uiDataLen:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.uiDataLen &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.uiDataLen - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.contentData:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)msg1.contentData &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.contentData - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MSG0 msg0;</span><br><span class="line">    cout &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0:\t\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.ID:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.ID &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.ID - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.type:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.type &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.type - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.flag:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.flag &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.flag - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.uiHashValue:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.uiHashValue &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.uiHashValue - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.uiDataLen:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.uiDataLen &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.uiDataLen - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.ulStartTime:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.ulStartTime &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.ulStartTime - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.ulEndTime:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.ulEndTime &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.ulEndTime - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.contentData:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)msg0.contentData &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.contentData - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line">&amp;msg1:				<span class="number">0x7ffeed56a8d8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg1.ID:			<span class="number">0x7ffeed56a8d8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg1.type:			<span class="number">0x7ffeed56a8e8</span> , <span class="number">16</span></span><br><span class="line">&amp;msg1.flag:			<span class="number">0x7ffeed56a8ea</span> , <span class="number">18</span></span><br><span class="line">&amp;msg1.uiHashValue:	<span class="number">0x7ffeed56a8ec</span> , <span class="number">20</span></span><br><span class="line">&amp;msg1.uiDataLen:	<span class="number">0x7ffeed56a8f0</span> , <span class="number">24</span></span><br><span class="line">&amp;msg1.contentData:	<span class="number">0x7ffeed56a8f4</span> , <span class="number">28</span></span><br><span class="line"></span><br><span class="line">&amp;msg0:				<span class="number">0x7ffeecdd38c0</span> , <span class="number">0</span></span><br><span class="line">&amp;msg0.ID:			<span class="number">0x7ffeecdd38c0</span> , <span class="number">0</span></span><br><span class="line">&amp;msg0.type:			<span class="number">0x7ffeecdd38d0</span> , <span class="number">16</span></span><br><span class="line">&amp;msg0.flag:			<span class="number">0x7ffeecdd38d2</span> , <span class="number">18</span></span><br><span class="line">&amp;msg0.uiHashValue:	<span class="number">0x7ffeecdd38d4</span> , <span class="number">20</span></span><br><span class="line">&amp;msg0.uiDataLen:	<span class="number">0x7ffeecdd38d8</span> , <span class="number">24</span></span><br><span class="line">&amp;msg0.ulStartTime:	<span class="number">0x7ffeecdd38e0</span> , <span class="number">32</span></span><br><span class="line">&amp;msg0.ulEndTime:	<span class="number">0x7ffeecdd38e8</span> , <span class="number">40</span></span><br><span class="line">&amp;msg0.contentData:	<span class="number">0x7ffeecdd38f0</span> , <span class="number">48</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>通过结构体MSG1定义的变量，其成员变量的地址于首地址的偏差可以看出，第三个成员变量flag虽为char类型，只占1字节，但编译器为了访问后续自变量更方便（放在偶地址，若为奇地址需要2个读周期才能取到值），所以编译器将下一个变量uiHashValue的首地址向后挪动一位到偏移地址为20处（偶地址的变量能够1个读周期取到值），相当于第三个成员变量占用2各字节（后一字节闲置）</p>
<ul>
<li>第一个成员地址为0，已对齐。</li>
<li>第二个成员，由于上一个成员大小为16所以当前准地址为：16，N &#x3D; min(sizeof(unsigned short),8)等于2，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
<li>第三个成员，由于上一个成员大小为2所以当前准地址为：18，N &#x3D; min(sizeof(char),8)等于1，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
<li>第四个成员，由于上一个成员大小为1所以当前准地址为：19，N &#x3D; min(sizeof(unsigned int),8)等于4，不满足“addr % N &#x3D;&#x3D; 0”，19%4余1，故在前一个变量后补1个字节，使当前地址20满足“addr % N &#x3D;&#x3D; 0”</li>
<li>第五个成员，由于上一个成员大小为4所以当前准地址为：24，N &#x3D; min(sizeof(unsigned int),8)等于4，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
<li>第六个成员，由于上一个成员大小为4所以当前准地址为：28，N &#x3D; min(sizeof(char),8)等于1，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
</ul>
<p>同理对结构体MSG0的实际变量定义的变量，齐成员变量的地址于首地址的偏差可看出除了同样在第三个成员变量flag后跳过了1个字节，将下一个变量uiHashValue的首地址向后挪动一位到偏移地址为20处外，还在第5个变量uiDataLen后插入4字节闲置字节{8+8},{2+(1+1)+4},{(4+4)},{8},{8}。</p>
<ul>
<li>第一个成员地址为0，已对齐。</li>
<li>第二个成员，由于上一个成员大小为16所以当前准地址为：16，N &#x3D; min(sizeof(unsigned short),8)等于2，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
<li>第三个成员，由于上一个成员大小为2所以当前准地址为：18，N &#x3D; min(sizeof(char),8)等于1，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
<li>第四个成员，由于上一个成员大小为1所以当前准地址为：19，N &#x3D; min(sizeof(unsigned int),8)等于4，不满足“addr % N &#x3D;&#x3D; 0”，19%4余1，故在前一个成员后补1个字节，使当前地址20满足“addr % N &#x3D;&#x3D; 0”</li>
<li>第五个成员，由于上一个成员大小为4所以当前准地址为：24，N &#x3D; min(sizeof(unsigned int),8)等于4，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
<li>第六个成员，由于上一个成员大小为4所以当前准地址为：28，N &#x3D; min(sizeof(unsigned long long int),8)等于8，不满足“addr % N &#x3D;&#x3D; 0”，28%8余4，故在前一字成员后补4个字节，使当前地址为32满足“addr % N &#x3D;&#x3D; 0”</li>
<li>第七个成员，由于上一个成员大小为8所以当前准地址为：40，N &#x3D; min(sizeof(unsigned int),8)等于8，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
<li>第八个成员，由于上一个成员大小为8所以当前准地址为：48，N &#x3D; min(sizeof(char),8)等于1，满足“addr % N &#x3D;&#x3D; 0”，已对齐</li>
</ul>
<h2 id="3-2-禁止编译器自动字节对齐"><a href="#3-2-禁止编译器自动字节对齐" class="headerlink" title="3.2. 禁止编译器自动字节对齐"></a>3.2. 禁止编译器自动字节对齐</h2><p>我们可以在定义结构体上方加一句配置，设置对齐参数为1字节从而实现关闭编译器自动对齐的目的（可能带来性能损失或其他错误）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">// 编译使用1字节对齐，未设置则自动字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MSG1</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MSG0</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出各成员变量的地址如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp;msg1:				<span class="number">0x7ffee5ce28d8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg1.ID:			<span class="number">0x7ffee5ce28d8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg1.type:			<span class="number">0x7ffee5ce28e8</span> , <span class="number">16</span></span><br><span class="line">&amp;msg1.flag:			<span class="number">0x7ffee5ce28ea</span> , <span class="number">18</span></span><br><span class="line">&amp;msg1.uiHashValue:	<span class="number">0x7ffee5ce28eb</span> , <span class="number">19</span></span><br><span class="line">&amp;msg1.uiDataLen:	<span class="number">0x7ffee5ce28ef</span> , <span class="number">23</span></span><br><span class="line">&amp;msg1.contentData:	<span class="number">0x7ffee5ce28f3</span> , <span class="number">27</span></span><br><span class="line"></span><br><span class="line">&amp;msg0:				<span class="number">0x7ffee5ce28a8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg0.ID:			<span class="number">0x7ffee5ce28a8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg0.type:			<span class="number">0x7ffee5ce28b8</span> , <span class="number">16</span></span><br><span class="line">&amp;msg0.flag:			<span class="number">0x7ffee5ce28ba</span> , <span class="number">18</span></span><br><span class="line">&amp;msg0.uiHashValue:	<span class="number">0x7ffee5ce28bb</span> , <span class="number">19</span></span><br><span class="line">&amp;msg0.uiDataLen:	<span class="number">0x7ffee5ce28bf</span> , <span class="number">23</span></span><br><span class="line">&amp;msg0.ulStartTime:	<span class="number">0x7ffee5ce28c3</span> , <span class="number">27</span></span><br><span class="line">&amp;msg0.ulEndTime:	<span class="number">0x7ffee5ce28cb</span> , <span class="number">35</span></span><br><span class="line">&amp;msg0.contentData:	<span class="number">0x7ffee5ce28d3</span> , <span class="number">43</span></span><br></pre></td></tr></table></figure>
<p>可以看出设置字节对齐参数为1字节后，相当于关闭了字节对齐</p>
<h1 id="4-按字节访问"><a href="#4-按字节访问" class="headerlink" title="4. 按字节访问"></a>4. 按字节访问</h1><p>所有对结构体成员的指针访问，都可以理解为用特定的类型去解读一个地址。下方为示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG1_HEAD_LEN  (offsetof(MSG1,contentData))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG0_HEAD_LEN  (offsetof(MSG0,contentData))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; MSG0_HEAD_LEN &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; MSG1_HEAD_LEN &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    MSG0 msg0;</span><br><span class="line">    msg0.ulStartTime = <span class="number">20181112ULL</span>;</span><br><span class="line">    msg0.ulEndTime = <span class="number">561341235ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* p = &amp;msg0;</span><br><span class="line"></span><br><span class="line">    MSG1* msg1Ptr = (MSG1*)p;</span><br><span class="line"></span><br><span class="line">    cout  &lt;&lt; <span class="string">&quot;(msg1Ptr-&gt;contentData): &quot;</span> &lt;&lt; (<span class="keyword">void</span> *)(msg1Ptr-&gt;contentData) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt;  *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>*)(msg1Ptr-&gt;contentData)  &lt;&lt; <span class="string">&quot; ULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout  &lt;&lt; <span class="string">&quot;(msg1Ptr-&gt;contentData + 8): &quot;</span> &lt;&lt; (<span class="keyword">void</span> *)(msg1Ptr-&gt;contentData + <span class="number">8</span>)&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt;  *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>*)(msg1Ptr-&gt;contentData + <span class="number">8</span>) &lt;&lt; <span class="string">&quot; ULL&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line">(msg1Ptr-&gt;contentData): <span class="number">0x7ffeeb5118e3</span>, <span class="number">20181112</span> ULL</span><br><span class="line">(msg1Ptr-&gt;contentData + <span class="number">8</span>): <span class="number">0x7ffeeb5118eb</span>, <span class="number">561341235</span> ULL</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>代码主要是有结构体MSG0定义了一个变量并未其相对于MSG1多出的两个变量赋值，然后实现用MSG1类型的指针访问MSG0中多出的变量（默认没有指针），来例证c++的访问变量的机制为“以特定的类型去解读一个地址”，无论其是否真的被定义成那样（前提条件：该地址是被定义过的且可访问的地址，否则会被认为内存越界）。</p>
<p>附录：完整代码详见个人git仓库：<a href="https://github.com/haoleeson/Cpp_Learning/blob/master/BitPrint.cpp">BitPrint.cpp</a>,<a href="https://github.com/haoleeson/Cpp_Learning/blob/master/BitPrint.h">BitPrint.h</a></p>
<h1 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h1><ul>
<li><a href="https://wenku.baidu.com/view/ec9cba000740be1e650e9aa5.html">结构体内存分配分析</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算学习笔记</title>
    <url>/2019/07/05/CloudComputingNote/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/cloudComputing.jpg" class="full-image" />

<h1 id="1-Bigtable————分布式结构化数据表"><a href="#1-Bigtable————分布式结构化数据表" class="headerlink" title="1. Bigtable————分布式结构化数据表"></a>1. Bigtable————分布式结构化数据表</h1><h2 id="1-1-Bigtable特点"><a href="#1-1-Bigtable特点" class="headerlink" title="1.1. Bigtable特点"></a>1.1. Bigtable特点</h2><ul>
<li>数据种类繁多，满足一系列Google产品的存储要求</li>
<li>吞吐量大，响应海量的服务请求</li>
<li>高可用性，几乎所有情况下的系统均可用</li>
<li>高扩展性，可根据需要随时加入或撤销服务器</li>
<li>简单，简单的底层系统，既减小了系统出错概念，又使上层应用开发更简单</li>
</ul>
<a id="more"></a>
<h2 id="1-2-Bigtable存储结构"><a href="#1-2-Bigtable存储结构" class="headerlink" title="1.2. Bigtable存储结构"></a>1.2. Bigtable存储结构</h2><p>Bigtable是一个分布式多维映射表，表中的数据通过一个行关键字（Row Key）、一个列关键字（Column Key）以及一个时间戳（Time Stamp）进行索引</p>
<p><img data-src="/../../../../uploads/CloudComputing-20190617095713134.png" alt="CloudComputing-20190617095713134"></p>
<h3 id="1-2-1-行关键字（Row-Key）"><a href="#1-2-1-行关键字（Row-Key）" class="headerlink" title="1.2.1. 行关键字（Row Key）"></a>1.2.1. 行关键字（Row Key）</h3><ul>
<li>可为任意字符串，最大64KB</li>
<li>表中数据根据行关键字排序（词典序）</li>
<li>同一地址域的网页关键字会存储在表中连续位置</li>
<li>压缩倒排以提高压缩率</li>
</ul>
<h3 id="1-2-2-列关键字（Column-Key）"><a href="#1-2-2-列关键字（Column-Key）" class="headerlink" title="1.2.2. 列关键字（Column Key）"></a>1.2.2. 列关键字（Column Key）</h3><ul>
<li>列的关键字应有其意义</li>
<li>列的簇名同时也是Bigtable中ACL访问控制的基本单元</li>
</ul>
<h3 id="1-2-3-时间戳（Time-Stamp）"><a href="#1-2-3-时间戳（Time-Stamp）" class="headerlink" title="1.2.3. 时间戳（Time Stamp）"></a>1.2.3. 时间戳（Time Stamp）</h3><ul>
<li>相同的内容需要保存不同时刻的数据版本（eg.网页检索数据、用户个性化设置数据）</li>
<li>64位整形存储，用户自定义赋值方式和意义</li>
</ul>
<h3 id="1-2-4-Bigtable数据存储及读写操作"><a href="#1-2-4-Bigtable数据存储及读写操作" class="headerlink" title="1.2.4. Bigtable数据存储及读写操作"></a>1.2.4. Bigtable数据存储及读写操作</h3><ul>
<li>较新的数据存储在内存中称为内存表（Memtable）的有序缓冲里</li>
<li>较旧的数据以SSTable格式保存在GFS中</li>
</ul>
<h4 id="1-2-4-1-读写操作有很大差异"><a href="#1-2-4-1-读写操作有很大差异" class="headerlink" title="1.2.4.1. 读写操作有很大差异"></a>1.2.4.1. 读写操作有很大差异</h4><p><img data-src="/../../../../uploads/CloudComputing-20190618161018598.png" alt="CloudComputing-20190618161018598"></p>
<h2 id="1-3-Bigtable基本架构"><a href="#1-3-Bigtable基本架构" class="headerlink" title="1.3. Bigtable基本架构"></a>1.3. Bigtable基本架构</h2><p><img data-src="/../../../../uploads/CloudComputing-20190617100822880.png" alt="CloudComputing-20190617100822880"></p>
<h3 id="1-3-1-其中Chubby的作用"><a href="#1-3-1-其中Chubby的作用" class="headerlink" title="1.3.1. 其中Chubby的作用"></a>1.3.1. 其中Chubby的作用</h3><ul>
<li>保证一致性（使所有子表服务器选取唯一一个主服务器）</li>
<li>获取子表服务器列表。扫描并发现目前活跃的子表服务器列表</li>
<li>保存Bigtable的模式信息和ACL访问控制列表。与所有活跃的子表服务器联系，并获取所有子表的分配情况；通过扫描元数据表发现未分配的子表，并将其分配到合适的子表服务器</li>
</ul>
<h3 id="1-3-2-其中主服务器的作用"><a href="#1-3-2-其中主服务器的作用" class="headerlink" title="1.3.2. 其中主服务器的作用"></a>1.3.2. 其中主服务器的作用</h3><ul>
<li>新子表分配。当新子表产生时，主服务器通过一个加载命令将新子表分配给一个拥有足够空间的子表服务器，子表服务器分割完成后会向主服务器返回一个通知（创建新表、合并表、大表分裂都会产生一个或多个子表）</li>
<li>子表服务器集群的状态监控。主服务器对子表服务器状态进行监控，以便于及时监测到服务器的加入和撤销</li>
<li>子表服务器之间的负载均衡</li>
</ul>
<h3 id="1-3-3-其中子表服务器"><a href="#1-3-3-其中子表服务器" class="headerlink" title="1.3.3. 其中子表服务器"></a>1.3.3. 其中子表服务器</h3><h4 id="1-3-3-1-子表SSTable-Sorted-String-Table"><a href="#1-3-3-1-子表SSTable-Sorted-String-Table" class="headerlink" title="1.3.3.1. 子表SSTable(Sorted String Table)"></a>1.3.3.1. 子表SSTable(Sorted String Table)</h4><p>每个子表服务器上保存几十～几千哥子表。SSTable是Google为Bigtable设计的内部数据存储格式。所有的SSTable文件都存储在GFS上，用户可以通过键来查询相应的值。</p>
<p><img data-src="/../../../../uploads/CloudComputing-20190617104500323.png" alt="CloudComputing-20190617104500323"></p>
<h4 id="1-3-3-2-子表的组成"><a href="#1-3-3-2-子表的组成" class="headerlink" title="1.3.3.2. 子表的组成"></a>1.3.3.2. 子表的组成</h4><ul>
<li>不同子表的SSTable可以共享</li>
<li>每个子表服务器上仅保存一个日志文件</li>
<li>日志内容按照键值排序</li>
<li>每个子表服务器上保存几十～几千个子表（平均100个子表）</li>
</ul>
<p><img data-src="/../../../../uploads/CloudComputing-20190617104904894.png" alt="CloudComputing-20190617104904894"></p>
<h4 id="1-3-3-3-子表地址"><a href="#1-3-3-3-子表地址" class="headerlink" title="1.3.3.3. 子表地址"></a>1.3.3.3. 子表地址</h4><p>Bigtable系统内部采用的是一种类似B+树的三层查询体系</p>
<p><img data-src="/../../../../uploads/CloudComputing-20190617110037290.png" alt="CloudComputing-20190617110037290"></p>
<h4 id="1-3-3-4-三种形式压缩之间的关系"><a href="#1-3-3-4-三种形式压缩之间的关系" class="headerlink" title="1.3.3.4. 三种形式压缩之间的关系"></a>1.3.3.4. 三种形式压缩之间的关系</h4><p><img data-src="/../../../../uploads/CloudComputing-20190618161124154.png" alt="CloudComputing-20190618161124154"></p>
<h2 id="1-4-Bigtable中的性能优化"><a href="#1-4-Bigtable中的性能优化" class="headerlink" title="1.4. Bigtable中的性能优化"></a>1.4. Bigtable中的性能优化</h2><h3 id="1-4-1-局部性群组"><a href="#1-4-1-局部性群组" class="headerlink" title="1.4.1. 局部性群组"></a>1.4.1. 局部性群组</h3><p>Bigtable允许用户将存储在不同区域的数据组织在一个单独的SSTable中（以列簇为单位），以构成一个局部性群组。（类似数据库中两个表的自然连接）</p>
<ul>
<li>可筛选在意的数据内容（类似数据库中投影）</li>
<li>改善经常被读取的局部数据的访问速率</li>
</ul>
<p><img data-src="/../../../../uploads/CloudComputing-20190618161816332.png" alt="CloudComputing-20190618161816332"></p>
<h3 id="1-4-2-压缩"><a href="#1-4-2-压缩" class="headerlink" title="1.4.2. 压缩"></a>1.4.2. 压缩</h3><p>Bigtable中广泛应用压缩（eg.用于构成局部性群组的SSTable中）</p>
<ul>
<li>利用Bentley &amp; McIlroy方式（BMDiff）在大的扫描窗口将常见的长串进行压缩</li>
<li>采取Zippy技术进行快速压缩，它在一个16KB大小的扫描窗口内寻找重复数据，这个过程非常快</li>
</ul>
<h3 id="1-4-3-布隆过滤器"><a href="#1-4-3-布隆过滤器" class="headerlink" title="1.4.3. 布隆过滤器"></a>1.4.3. 布隆过滤器</h3><p>巴顿·布隆于1970年提出，它实际上是一个很长的二进制向量和一系列随机映射函数。在Bigtable中用于读写操作中确定子表位置</p>
<p>优点：</p>
<ul>
<li>速度快，省空间</li>
<li>不会将一个子表误判成不存在</li>
</ul>
<p>缺点：</p>
<ul>
<li>某些情况下，会将不存在的子表误判成存在</li>
</ul>
<h1 id="2-Megastore————分布式存储系统"><a href="#2-Megastore————分布式存储系统" class="headerlink" title="2. Megastore————分布式存储系统"></a>2. Megastore————分布式存储系统</h1><h2 id="2-1-产生原因（业务驱动）："><a href="#2-1-产生原因（业务驱动）：" class="headerlink" title="2.1. 产生原因（业务驱动）："></a>2.1. 产生原因（业务驱动）：</h2><ul>
<li>高负载的交互式应用，传统关系型数据库通过连接（join）提升性能代价过于高昂</li>
<li>业务需求中读操作远远大于写操作</li>
<li>基于Bigtable这样的key&#x2F;value存储系统之上，设计存储和查询级联数据的分布式存储系统非常方便</li>
</ul>
<h2 id="2-2-说明"><a href="#2-2-说明" class="headerlink" title="2.2. 说明"></a>2.2. 说明</h2><ul>
<li>介于传统关系型数据库和NoSQL之间的存储技术，并尽可能地实现高可用性和高可扩展性的统一。</li>
<li>对于高可用性，Megastore实现了一个同步的、容错的、适合远距离传输的<strong>复制机制</strong></li>
<li>对高扩展性，Megastore将数据分割成很多小数据分区（存放于NoSQL数据库中）</li>
</ul>
<p><img data-src="/../../../../uploads/CloudComputing-20190618163837063.png" alt="CloudComputing-20190618163837063"></p>
<ul>
<li>在Megastore中，这些小的数据分区被称为实体组集（Entity Groups）</li>
<li>每个实体组集包含若干的实体组（Entity Group，相当于分区中表的概念）</li>
<li>一个实体组中包含很多的实体（Entity，相当于表中记录的概念）</li>
</ul>
<p>性能</p>
<ul>
<li>平均读取延迟在<strong>万分之一毫秒</strong>之内，平均写入延迟在<strong>100至400毫秒</strong>之间</li>
</ul>
<h2 id="2-3-Megastore数据模型"><a href="#2-3-Megastore数据模型" class="headerlink" title="2.3. Megastore数据模型"></a>2.3. Megastore数据模型</h2><ul>
<li>同关系型数据库一样，Megastore的数据模型是在模式（schema）中定义的且是强类型的（strongly typed）</li>
<li>每个模式都由一系列的表（tables）构成，表又包含有一系列的实体（entities），每实体中包含一系列属性（properties）</li>
<li>属性是命名的且具有类型，这些类型包括字符型（strings）、数字类型（numbers）或者Google的Protocol Buffers。</li>
</ul>
<h2 id="2-4-Megastore索引"><a href="#2-4-Megastore索引" class="headerlink" title="2.4. Megastore索引"></a>2.4. Megastore索引</h2><ul>
<li>局部索引。定义在单个实体组中，作用域仅限于单个实体组（ 如PhotosByTime ）</li>
<li>全局索引。可以横跨多个实体组集进行数据读取操作（ 如PhotosByTag ）</li>
<li>额外索引。STORING子句、可重复的索引、内联索引</li>
</ul>
<h2 id="2-5-在Bigtable中的存储情况"><a href="#2-5-在Bigtable中的存储情况" class="headerlink" title="2.5. 在Bigtable中的存储情况"></a>2.5. 在Bigtable中的存储情况</h2><table>
<thead>
<tr>
<th>行键（Row Key）</th>
<th><strong>User.name</strong></th>
<th><strong>Photo.time</strong></th>
<th><strong>Photo.tag</strong></th>
<th>**Photo._**<strong>url</strong></th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>John</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>101,500</td>
<td></td>
<td>12:30:01</td>
<td>Dinner,   Paris</td>
<td>…</td>
</tr>
<tr>
<td>101,502</td>
<td></td>
<td>12:15:22</td>
<td>Betty, Paris</td>
<td>…</td>
</tr>
<tr>
<td>102</td>
<td>Mary</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Bigtable的列名实际上是表名和属性名结合在一起得到，不同表中实体可存储在同一个Bigtable行中</p>
<h2 id="2-6-Megastore中的事务及并发控制"><a href="#2-6-Megastore中的事务及并发控制" class="headerlink" title="2.6. Megastore中的事务及并发控制"></a>2.6. Megastore中的事务及并发控制</h2><h3 id="2-6-1-读操作"><a href="#2-6-1-读操作" class="headerlink" title="2.6.1. 读操作"></a>2.6.1. 读操作</h3><ul>
<li>current。总是在单个实体组中完成</li>
<li>snapshot。总是在单个实体组中完成、系统取出已知的最后一个完整提交的事务的时间戳，接着从这个位置读数据</li>
<li>inconsistent。忽略日志的状态直接读取最新的值</li>
</ul>
<h3 id="2-6-2-完整的事物周期"><a href="#2-6-2-完整的事物周期" class="headerlink" title="2.6.2. 完整的事物周期"></a>2.6.2. 完整的事物周期</h3><ul>
<li><p>读。获取最后一次提交的事务的时间戳和日志位置</p>
</li>
<li><p>应用逻辑。从Bigtable读取且聚集数据到日志入口</p>
</li>
<li><p>提交。使用Paxos协议达成一致性，将一个入口追加到日志</p>
</li>
<li><p>生效。将数据更新到Bigtable中的实体和索引中</p>
</li>
<li><p>清除。清除不需要的数据</p>
</li>
</ul>
<h3 id="2-6-3-Megastore中的事务机制"><a href="#2-6-3-Megastore中的事务机制" class="headerlink" title="2.6.3. Megastore中的事务机制"></a>2.6.3. Megastore中的事务机制</h3><p><img data-src="/../../../../uploads/CloudComputing-20190618171208831.png" alt="CloudComputing-20190618171208831"></p>
<h2 id="2-7-Megastore基本架构"><a href="#2-7-Megastore基本架构" class="headerlink" title="2.7. Megastore基本架构"></a>2.7. Megastore基本架构</h2><p>在Megastore中共有三种副本：</p>
<ul>
<li>完整副本（Full Replica）</li>
<li>见证者副本（Witness Replica）</li>
<li>只读副本（Read-only Replica）</li>
</ul>
<p><img data-src="/../../../../uploads/CloudComputing-20190618171436506.png" alt="CloudComputing-20190618171436506"></p>
<h2 id="2-8-快速读与快速写"><a href="#2-8-快速读与快速写" class="headerlink" title="2.8. 快速读与快速写"></a>2.8. 快速读与快速写</h2><h3 id="2-8-1-快速读"><a href="#2-8-1-快速读" class="headerlink" title="2.8.1. 快速读"></a>2.8.1. 快速读</h3><ul>
<li>利用本地读取实现快速读，带来更好的用户体验及更低的延迟</li>
<li>关键是保证选择的副本上数据是最新的</li>
<li>协调者是一个服务，该服务分布在每个副本的数据中心里面。它的主要作用就是跟踪一个实体组集合</li>
<li>协调者的状态是由写算法来保证</li>
</ul>
<h3 id="2-8-2-快速写"><a href="#2-8-2-快速写" class="headerlink" title="2.8.2. 快速写"></a>2.8.2. 快速写</h3><ul>
<li>如果一次写成功，那么下一次写的时候就跳过准备过程，直接进入接受阶段</li>
<li>Megastore没有使用专门的主服务器，而是使用leaders </li>
<li>leader主要是来裁决哪个写入的值可以获取0号提议</li>
<li>客户端、网络及Bigtable的故障都会导致一个写操作处于不确定的状态</li>
</ul>
<h2 id="2-9-Megastore核心技术–复制"><a href="#2-9-Megastore核心技术–复制" class="headerlink" title="2.9. Megastore核心技术–复制"></a>2.9. Megastore核心技术–复制</h2><h3 id="2-9-1-复制的日志"><a href="#2-9-1-复制的日志" class="headerlink" title="2.9.1. 复制的日志"></a>2.9.1. 复制的日志</h3><ul>
<li><p>每个副本都存有记录所有更新的数据</p>
</li>
<li><p>Megastore允许副本不按顺序接受日志，这些日志将独立的存储在Bigtable中</p>
</li>
</ul>
<p><img data-src="/../../../../uploads/CloudComputing-20190618171942921.png" alt="CloudComputing-20190618171942921"></p>
<h3 id="2-9-2-读取数据"><a href="#2-9-2-读取数据" class="headerlink" title="2.9.2. 读取数据"></a>2.9.2. 读取数据</h3><p>本地查询 -&gt; 发现位置 -&gt; 追赶 -&gt; 验证 -&gt; 查询数据</p>
<p><img data-src="/../../../../uploads/CloudComputing-20190618172138062.png" alt="CloudComputing-20190618172138062"></p>
<h3 id="2-9-3-写入数据"><a href="#2-9-3-写入数据" class="headerlink" title="2.9.3. 写入数据"></a>2.9.3. 写入数据</h3><p>接收leader -&gt; 准备 -&gt; 接收 -&gt; 失效 -&gt; 生效</p>
<p><img data-src="/../../../../uploads/CloudComputing-20190618172312027.png" alt="CloudComputing-20190618172312027"></p>
<h3 id="2-9-4-协调者的可用性"><a href="#2-9-4-协调者的可用性" class="headerlink" title="2.9.4. 协调者的可用性"></a>2.9.4. 协调者的可用性</h3><ul>
<li>协调者在系统中是比较重要的——协调者的进程运行在每个数据中心。每次的写操作中都要涉及协调者，因此协调者的故障将会导致系统的不可用</li>
<li>Megastore使用了Chubby锁服务，为了处理请求，一个协调者必须持有多数锁。一旦因为出现问题导致它丢失了大部分锁，协调者就会恢复到一个默认保守状态</li>
<li>除了可用性问题，对于协调者的读写协议必须满足一系列的竞争条件</li>
</ul>
<h1 id="3-Dapper————大规模分布式系统的监控基础架构"><a href="#3-Dapper————大规模分布式系统的监控基础架构" class="headerlink" title="3. Dapper————大规模分布式系统的监控基础架构"></a>3. Dapper————大规模分布式系统的监控基础架构</h1><h2 id="3-1-三个基本概念"><a href="#3-1-三个基本概念" class="headerlink" title="3.1. 三个基本概念"></a>3.1. 三个基本概念</h2><ul>
<li>监控树（Trace Tree）。一个同特定事件相关的所有消息</li>
<li>区间（Span）。实际上就是一条记录</li>
<li>注释（Annotation）。主要用来辅助推断区间关系，也可以包含一些自定义的内容</li>
</ul>
<h2 id="3-2-监控信息的汇总"><a href="#3-2-监控信息的汇总" class="headerlink" title="3.2. 监控信息的汇总"></a>3.2. 监控信息的汇总</h2><p><img data-src="/../../../../uploads/CloudComputing-20190710111630677.png" alt="CloudComputing-20190710111630677"></p>
<h2 id="3-3-关键性技术"><a href="#3-3-关键性技术" class="headerlink" title="3.3. 关键性技术"></a>3.3. 关键性技术</h2><h3 id="3-3-1-轻量级核心功能库"><a href="#3-3-1-轻量级核心功能库" class="headerlink" title="3.3.1. 轻量级核心功能库"></a>3.3.1. 轻量级核心功能库</h3><p><img data-src="/../../../../uploads/CloudComputing-20190710111819223.png" alt="CloudComputing-20190710111819223"></p>
<ul>
<li>最关键的代码基础是——基本RPC、线程和控制流函数库的实现</li>
<li>主要功能是——实现区间创建、抽样和在本地磁盘上记录日志。</li>
<li>将复杂的功能实现限制在一个轻量级的核心功能库中——保证了Dapper的监控过程基本对应用层透明。</li>
</ul>
<h3 id="3-3-2-二次抽样技术"><a href="#3-3-2-二次抽样技术" class="headerlink" title="3.3.2. 二次抽样技术"></a>3.3.2. 二次抽样技术</h3><p>利用二次抽样技术成功地解决了<strong>低开销及广泛可部署性</strong>的问题。</p>
<ol>
<li>第一次抽样。实践中，设计人员发现当抽样率低至1&#x2F;1024时也能够产生足够多的有效监控数据，即在1024个请求中抽取1个进行监控也是可行的，从而可以捕获有效数据</li>
<li>第二次抽样。发生在数据写入Bigtable前，具体方法是将监控id散列成一个标量z（0≤z≤1），如果某个区间的z小于事先定义好的汇总抽样系数，则保留这个区间并将它写入Bigtable，否则丢弃</li>
</ol>
<h2 id="3-4-Dapper使用心得"><a href="#3-4-Dapper使用心得" class="headerlink" title="3.4. Dapper使用心得"></a>3.4. Dapper使用心得</h2><ol>
<li>新服务部署中Dapper的使用。利用Dapper对系统延迟情况进行一系列的跟踪，进而发现存在的问题</li>
<li>定位长尾延迟（Addressing Long Tail Latency）。端到端性能和关键路径上的网络延迟有着极大的关系</li>
<li>推断服务间的依存关系（Inferring Service Dependencies）。Google的“服务依存关系”项目使用监控注释和DPAI的MapReduce接口实现了服务依存关系确定的自动化</li>
<li>确定不同服务的网络使用情况。利用Dapper平台构建了一个连续不断更新的控制台，用来显示内部集群网络通信中最活跃的应用层终端</li>
<li>分层的共享式存储系统。没有Dapper之类的工具的情况下对于这种共享式服务资源的争用也同样难以调试</li>
<li>利用Dapper进行“火拼”（Firefighting with Dapper）。Dapper用户可以通过和Dapper守护进程的直接通信，将所需的最新数据汇总在一起</li>
</ol>
<h1 id="4-Dremel————海量数据的交互式分析工具"><a href="#4-Dremel————海量数据的交互式分析工具" class="headerlink" title="4. Dremel————海量数据的交互式分析工具"></a>4. Dremel————海量数据的交互式分析工具</h1><h2 id="4-1-Dremel支持的典型应用"><a href="#4-1-Dremel支持的典型应用" class="headerlink" title="4.1. Dremel支持的典型应用"></a>4.1. Dremel支持的典型应用</h2><ul>
<li>Web文档的分析</li>
<li>Android市场的应用安装数据的跟踪</li>
<li>Google产品的错误报告</li>
<li>Google图书的光学字符识别</li>
<li>欺诈信息的分析</li>
<li>Google地图的调试</li>
<li>Bigtable实例上的tablet迁移</li>
<li>Google分布式构建系统的测试结果分析</li>
<li>磁盘I&#x2F;O信息的统计</li>
<li>Google数据中心上运行任务的资源监控</li>
<li>Google代码库的符号和依赖关系分析</li>
</ul>
<h1 id="5-Dremel的数据模型"><a href="#5-Dremel的数据模型" class="headerlink" title="5. Dremel的数据模型"></a>5. Dremel的数据模型</h1><h3 id="5-0-1-两方面的技术支撑"><a href="#5-0-1-两方面的技术支撑" class="headerlink" title="5.0.1. 两方面的技术支撑"></a>5.0.1. 两方面的技术支撑</h3><ul>
<li>一方面：统一的存储平台<br>实现高效的数据存储，Dremel使用的底层数据存储平台是GFS</li>
<li>另一方面：统一的数据存储格式<br>存储的数据才可以被不同的平台所使用</li>
</ul>
<h3 id="5-0-2-面向记录和面向列的存储"><a href="#5-0-2-面向记录和面向列的存储" class="headerlink" title="5.0.2. 面向记录和面向列的存储"></a>5.0.2. 面向记录和面向列的存储</h3><p>Google的Dremel是第一个在嵌套数据模型基础上实现列存储的系统。</p>
<p><img data-src="/../../../../uploads/CloudComputing-Dremel.png" alt="Dremel面向记录和面向列的存储"></p>
<p>优势：</p>
<ul>
<li>处理时只需要使用涉及的列数据</li>
<li>列存储更利于数据的压缩</li>
</ul>
<h3 id="5-0-3-Dremel小结"><a href="#5-0-3-Dremel小结" class="headerlink" title="5.0.3. Dremel小结"></a>5.0.3. Dremel小结</h3><ul>
<li>Dremel和MapReduce并不是互相替代，而是相互补充的技术。在不同的应用场景下各有其用武之地。</li>
<li>Drill的设计目标就是复制一个开源的Dremel，但是从目前来看，该项目无论是进展还是影响力都达不到Hadoop的高度。</li>
<li>希望未来能出现一个真正有影响力的开源系统实现Dremel的主要功能并被广泛采用。</li>
</ul>
<h1 id="6-PowerDrill————内存大数据分析系统"><a href="#6-PowerDrill————内存大数据分析系统" class="headerlink" title="6. PowerDrill————内存大数据分析系统"></a>6. PowerDrill————内存大数据分析系统</h1><h2 id="6-1-PowerDrill产生背景与设计目标"><a href="#6-1-PowerDrill产生背景与设计目标" class="headerlink" title="6.1. PowerDrill产生背景与设计目标"></a>6.1. PowerDrill产生背景与设计目标</h2><p>现象：</p>
<ul>
<li>在查询过程中，平均**92.41%<strong>的数据被略去</strong>5.02%<strong>的数据会直接被缓存命中，一般仅须扫描</strong>2.66%**的数据即可得到查询结果</li>
<li>超过<strong>70%<strong>的查询是不需要从磁盘访问任何数据的这些查询的平均访问延迟大约是</strong>25秒</strong>，<strong>96.5%<strong>的查询需要访问的磁盘量不超过</strong>1GB</strong></li>
</ul>
<p>背景：</p>
<ul>
<li>绝大多数的查询是类似和一致的；</li>
<li>存储系统中的表只有一小部分是经常被使用的，绝大部分的表使用频率不高。</li>
</ul>
<p>目的：</p>
<ul>
<li>尽可能在查询中略去不需要的数据分块；</li>
<li>尽可能地减少数据在内存中的占用。（越少的内存占用意味着内存中可加载和处理的数据越多）</li>
</ul>
<h2 id="6-2-ProwerDrill系统组成"><a href="#6-2-ProwerDrill系统组成" class="headerlink" title="6.2. ProwerDrill系统组成"></a>6.2. ProwerDrill系统组成</h2><ul>
<li>Web UI</li>
<li>一个抽象层</li>
<li>列式存储</li>
</ul>
<h2 id="6-3-PowerDrill数据结构"><a href="#6-3-PowerDrill数据结构" class="headerlink" title="6.3. PowerDrill数据结构"></a>6.3. PowerDrill数据结构</h2><p>PowerDrill采用的是一个双层数据字典结构</p>
<p><img data-src="/Users/haoleeson/Documents/CloudComputing/CloudComputing-20190710154540235.png" alt="CloudComputing-20190710154540235"></p>
<h2 id="6-4-PowerDrill采用的性能优化"><a href="#6-4-PowerDrill采用的性能优化" class="headerlink" title="6.4. PowerDrill采用的性能优化"></a>6.4. PowerDrill采用的性能优化</h2><h3 id="6-4-1-数据分块"><a href="#6-4-1-数据分块" class="headerlink" title="6.4.1. 数据分块"></a>6.4.1. 数据分块</h3><ul>
<li>背景：传统的索引对于PowerDrill的查询场景作用不是很大，因此一个很自然的考虑就是对数据进行分块，过滤查询中不需要的数据块来减少数据量</li>
<li>分块方法：常见的分区方法有范围分区、散列分区等。PowerDrill实际采用的是一种组合范围分区方法。</li>
<li>分块步骤：a. 领域专家确定若干个划分的域；b. 利用这几个域对数据进行划分；c. 每个块的行数达到阈值时就停止划分。</li>
<li>局限性：域的确定需要领域专家（需要经验划分域）</li>
</ul>
<h3 id="6-4-2-数据编码的优化"><a href="#6-4-2-数据编码的优化" class="headerlink" title="6.4.2. 数据编码的优化"></a>6.4.2. 数据编码的优化</h3><ul>
<li>对于不同的块，如果我们可以确定块中不同值的数量，那么就可以根据这个数量值来选择可变的比特位来记录块id</li>
<li>有一个专有名词用于统计一组数中不同值的个数，称为“基数估计”</li>
<li>对于小规模的数据集，可以比较容易地统计出精确的基数。但是在大数据的环境下，精确的基数统计非常耗时，因此能保证一定精度的基数估计就可以满足实际的需求</li>
<li>基数估计的方法很多，大多利用了散列函数的一些特性，Google内部使用的是一种称为Hyperloglog的基数估计方法的变种</li>
</ul>
<h3 id="6-4-3-全局字典优化"><a href="#6-4-3-全局字典优化" class="headerlink" title="6.4.3. 全局字典优化"></a>6.4.3. 全局字典优化</h3><p>特性：</p>
<ul>
<li>全局字典是有序的</li>
<li>排序后的数据常常有共同的前缀</li>
</ul>
<p>备注：</p>
<ul>
<li>实际使用中为了进一步减少查询中需要加载到内存的全局字典，对全局字典又进行了分块</li>
<li>对每个全局字典块还会维护一个布隆过滤器（bloom filter）来快速确定某个值是否在字典中</li>
</ul>
<h3 id="6-4-4-压缩算法"><a href="#6-4-4-压缩算法" class="headerlink" title="6.4.4. 压缩算法"></a>6.4.4. 压缩算法</h3><p>不管压缩算法的解压速度多快，总会消耗一定的物理资源与时间。对此PowerDrill采用了一种<strong>冷热数据</strong>分别对待的策略。</p>
<p>在冷热数据切换策略中，比较常用的是LRU算法。PowerDrill开发团队采用了<strong>启发式的缓存策略</strong>来代替原始的LRU算法。</p>
<h3 id="6-4-5-行的重排"><a href="#6-4-5-行的重排" class="headerlink" title="6.4.5. 行的重排"></a>6.4.5. 行的重排</h3><p>PowerDrill在实际生产环境中对数据分块时选定的那几个域按照字典序进行排序来得到重排的结果。数据压缩的算法有很多，比较常用的一种称为游程编码（Run-Length Encoding，RLE），又称行程长度编码，其好处是压缩和解压缩都非常快。</p>
<h2 id="6-5-PowerDrill与Dremel的对比"><a href="#6-5-PowerDrill与Dremel的对比" class="headerlink" title="6.5. PowerDrill与Dremel的对比"></a>6.5. PowerDrill与Dremel的对比</h2><table>
<thead>
<tr>
<th><strong>设计目标</strong></th>
<th><strong>处理非常大量的数据集</strong></th>
<th><strong>分析少量的核心数据集</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>设计理念</strong></td>
<td>处理的数据来自外存</td>
<td>处理的数据尽可能地存于内存</td>
</tr>
<tr>
<td></td>
<td>未进行数据分区，分析时要扫描所有需要的列</td>
<td>使用了组合范围分区，分析时可以跳过很多不需要的分区</td>
</tr>
<tr>
<td></td>
<td>数据通常不需要加载，增加数据很方便</td>
<td>数据需要加载，增加数据相对不便</td>
</tr>
</tbody></table>
<h1 id="7-Google应用程序引擎"><a href="#7-Google应用程序引擎" class="headerlink" title="7. Google应用程序引擎"></a>7. Google应用程序引擎</h1><p>Google App Engine是一个由Python应用服务器群、Bigtable数据库及GFS数据存储服务组成的平台，它能为开发者提供一体化的可自动升级的在线应用服务。</p>
<p>特点：</p>
<ul>
<li>Google App Engine可以让开发人员在Google的基础架构上运行网络应用程序。</li>
<li>在Google App Engine中，用户可以使用appspot.com域上的免费域名为应用程序提供服务，也可以使用Google企业应用套件从自己的域为它提供服务。</li>
<li>可以免费使用Google App Engine。注册一个免费账户即可开发和发布应用程序，而且不需要承担任何费用和责任。</li>
</ul>
<h2 id="7-1-Google-App-Engine的整体架构"><a href="#7-1-Google-App-Engine的整体架构" class="headerlink" title="7.1. Google App Engine的整体架构"></a>7.1. Google App Engine的整体架构</h2><p><img data-src="/../../../../uploads/CloudComputing-20190710161656740.png" alt="CloudComputing-20190710161656740"></p>
<h2 id="7-2-应用程序环境的特性"><a href="#7-2-应用程序环境的特性" class="headerlink" title="7.2. 应用程序环境的特性"></a>7.2. 应用程序环境的特性</h2><ul>
<li><strong>动态网络服务</strong>功能。能够完全支持常用的网络技术。</li>
<li>具有<strong>持久存储的空间</strong>。在这个空间里平台可以支持一些基本操作，如查询、分类和事务的操作。</li>
<li>具有自主平衡网络和系统的负载、自动进行<strong>扩展</strong>的功能。</li>
<li>可以对用户的<strong>身份进行验证</strong>，并且支持使用Google账户发送邮件。</li>
<li>有一个功能完整的<strong>本地开发环境</strong>，可以在自身的计算机上模拟Google          App Engine环境。</li>
<li>支持在指定时间或定期触发事件的<strong>计划任务</strong>。</li>
</ul>
<h2 id="7-3-沙盒的限制"><a href="#7-3-沙盒的限制" class="headerlink" title="7.3. 沙盒的限制"></a>7.3. 沙盒的限制</h2><ul>
<li>用户的应用程序只能通过Google App Engine提供的网址抓取API和电子邮件服务API来访问互联网中其他的计算机，其他计算机如请求与该应用程序相连接，只能在标准接口上通过HTTP或HTTPS进行</li>
<li>应用程序无法对Google App Engine的文件系统进行写入操作，只能读取应用程序代码上的文件，并且该应用程序必须使用Google App Engine的Data Store数据库来存储应用程序运行期间持续存在的数据</li>
<li>应用程序只有在响应网络请求时才运行，并且这个响应时间必须极短，在几秒之内必须完成。与此同时，请求处理的程序不能在自己的响应发送后产生子进程或执行代码</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>编码规范笔记</title>
    <url>/2021/07/14/CodeSpecificationNote/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-排版与格式"><a href="#1-排版与格式" class="headerlink" title="1. 排版与格式"></a>1. 排版与格式</h1><h2 id="1-1-include"><a href="#1-1-include" class="headerlink" title="1.1. include"></a>1.1. include</h2><p>include guards 或#pragma once<br>include guards 必须使用<CODEPATH>_<FILE>_H（或 HPP）的全大写形式。CODEPATH 中需要去掉标示主干&#x2F;分支的关键词如：trunk, branch-xxx </p>
<a id="more"></a>

<h2 id="1-2-头文件顺序"><a href="#1-2-头文件顺序" class="headerlink" title="1.2. 头文件顺序"></a>1.2. 头文件顺序</h2><p>强制头 (.h) 文件按以下顺序组织：</p>
<ul>
<li>文件声明</li>
<li>include guards</li>
<li>引用的头文件</li>
<li>自定义类型声明，函数声明（一般函数，模板函数）, 内联函数&#x2F;模板函数</li>
</ul>
<h2 id="1-3-源文件顺序"><a href="#1-3-源文件顺序" class="headerlink" title="1.3. 源文件顺序"></a>1.3. 源文件顺序</h2><p>强制 CPP 文件按以下顺序组织：</p>
<ul>
<li>文件声明</li>
<li>引用的头文件</li>
<li>代码部分（注意：涉及的函数和类方法按照头文件的顺序组织）</li>
</ul>
<h2 id="1-4-代码格式要求"><a href="#1-4-代码格式要求" class="headerlink" title="1.4. 代码格式要求"></a>1.4. 代码格式要求</h2><p>代码行组织要求：</p>
<ul>
<li><p>强制使用适当的空行来分组代码的逻辑</p>
</li>
<li><p>强制左大括号不独立，右大括号独立成行。并且左大括号所在行进行垂直对齐</p>
</li>
<li><p>以 4 个空格为单位缩进，不使用制表符</p>
</li>
<li><p>命名空间不缩进</p>
</li>
<li><p>public&#x2F;protected&#x2F;private 关键字与类声明对齐</p>
</li>
<li><p>比较短的函数声明，整个声明占一行；过长的函数声明，令每一参数占一行，并且垂直对齐，换行后的参数至少保持 8 个空格缩进</p>
</li>
<li><p>比较短的函数调用语句，整个语句占一行；过长的函数调用，控制折行确保每行不要超过 100 列，换行后至少额外缩进 8 个空格</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">grey_wolf.<span class="built_in">eat</span>(white_sheep);</span><br><span class="line">hungry_lion.<span class="built_in">eat</span>(</span><br><span class="line">        big_grey_wolf,</span><br><span class="line">        little_white_sheep,</span><br><span class="line">        quick_brown_fox,</span><br><span class="line">        lazy_dog);</span><br></pre></td></tr></table></figure>
</li>
<li><p>if 语句的分支部分必须使用大括号包围</p>
</li>
<li><p>如果条件表达式很长很复杂，在低优先级运算符前换行，换行后运算符 (|| or &amp;&amp;) 放在新行最前面，并额外缩进 8 个空格</p>
</li>
<li><p>强制连续的 if…elseif… 判断，原则上应该以 else 语句结束。若该条件合法但没有相应动作，通过注释标明&#x2F;&#x2F;pass 或&#x2F;&#x2F;do nothing; 若是不合法情况，应报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (you.<span class="built_in">com_from</span>(EARTH)</span><br><span class="line">        || you.<span class="built_in">com_from</span>(MARS)</span><br><span class="line">        ||you.<span class="built_in">com_from</span>(VENUS)) &#123;</span><br><span class="line">    <span class="keyword">return</span><span class="string">&quot;youcomefromsolar system&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// else do nothing</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制每一个 case 语句都必须以 break 语句或 return 语句结束</p>
</li>
<li><p>强制语句原则上应该有一个 default 语句，如果没有动作，通过注释标明&#x2F;&#x2F;pass 或&#x2F;&#x2F;do nothing</p>
</li>
<li><p>强制 case 语句需要与 switch 对齐，不要增加额外缩进</p>
</li>
</ul>
<h1 id="2-命名及注释"><a href="#2-命名及注释" class="headerlink" title="2. 命名及注释"></a>2. 命名及注释</h1><h2 id="2-1-命名"><a href="#2-1-命名" class="headerlink" title="2.1. 命名"></a>2.1. 命名</h2><ul>
<li>文件名全部用小写字母，中间用_间隔；比如：this_is_my_awesome_file.cpp</li>
<li>单元测试文件名使用&lt;被测文件名&gt;_test.h(.cpp) 命名</li>
<li>函数命名使用下划线分隔的全小写命名法</li>
<li>类类型使用首字母大写的驼峰命名法命名</li>
<li>使用下划线分隔的全小写命名法命名命名空间</li>
<li>一行内只应声明一个变量</li>
<li>局部变量应在声明处赋初值，指针类型局部变量必须在声明处赋初值</li>
</ul>
<h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2. 注释"></a>2.2. 注释</h2><ul>
<li>强制 每个文件都必须有文件声明放在文件头部，按如下内容组织：1) 版权声明；2) 许可证（可选）3) 作者 4) 代码功能&#x2F;用法说明</li>
<li>强制 文档化注释必须标明作者和简要介绍，公有函数必须解释其输入参数、输入参数合法取值、输出参数、返回值、抛出的异常</li>
</ul>
<h1 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3. 代码规范"></a>3. 代码规范</h1><ul>
<li><p>强制 class 表示被封装的用户自定义类型，不公开定义非静态数据成员，一般通过成员方法进行交互</p>
</li>
<li><p>建议 struct 表示数据的简单集合，公开定义数据成员，只定义用于初始化数据成员的方法</p>
</li>
<li><p>强制 必须使用构造函数初始化列表显式初始化直接基类与所有的基本类型数据成员</p>
</li>
<li><p><strong>强制 没有复制意义的类必须用 DISALLOW_COPY_AND_ASSIGN 宏禁止拷贝构造函数和赋值构造函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(TypeName) \</span></span><br><span class="line">        <span class="built_in">TypeName</span>(constTypeName&amp;); \</span><br><span class="line">        TypeName&amp; <span class="keyword">operator</span>=(constTypeName&amp;)</span><br><span class="line">class Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Foo</span>(<span class="keyword">int</span> f) : _f(f) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">DISALLOW_COPY_AND_ASSIGN</span>(Foo);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制 有默认值语意的类，必须显式定义默认构造函数</p>
</li>
<li><p>强制 没有默认值语意的类，必须显式定义其它构造函数或 private 声明默认构造函数，并不给出实现</p>
</li>
<li><p>强制 若类定义了虚函数，必须定义虚析构函数</p>
</li>
</ul>
<h2 id="3-1-命名空间"><a href="#3-1-命名空间" class="headerlink" title="3.1. 命名空间"></a>3.1. 命名空间</h2><ul>
<li><strong>所有代码都应该定义在 namespace 中，main() 函数除外。</strong></li>
<li><strong>头文件中禁止在函数、方法和类作用域外的地方使用 using namespace 或者 using class</strong>，但是类别名（type alias）和别名模板（alias template）的使用不受限制</li>
</ul>
<h2 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3.2. 类型转换"></a>3.2. 类型转换</h2><ul>
<li>强制 必须使用 C++ 风格类型转换。如 static_cast、dynamic_cast、const_cast、reinterpret_cast<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i);</span><br><span class="line"><span class="keyword">const</span> MyBuf * buf = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> MyBuf*&gt;(network_buf);</span><br><span class="line"><span class="keyword">const</span> Derived * d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived*&gt;(b);</span><br><span class="line"><span class="built_in">old_copy</span>(dest, <span class="keyword">const_cast</span>&lt;<span class="keyword">void</span> *&gt;(src), n);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3-smart-ptr"><a href="#3-3-smart-ptr" class="headerlink" title="3.3. smart_ptr"></a>3.3. smart_ptr</h2><ul>
<li><p><strong>强制 禁止使用 auto_ptr</strong></p>
</li>
<li><p>应使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">ptr</span><span class="params">(newFoo())</span></span>;</span><br><span class="line">std::scoped_ptr&lt;Shape&gt; p;</span><br><span class="line">std::shared_ptr&lt;Shape&gt; p = <span class="built_in">createShape</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>建议不要使用 strcpy()&#x2F;strcat()&#x2F;strdup()&#x2F;sprintf() 等没有越界检查的函数</p>
</li>
<li><p>建议不要使用 strncpy&#x2F;strncat 实现有问题的函数</p>
</li>
<li><p>强制 禁止定义 struct 的同时 typedef 一个类型名，除非该头文件必须兼容 gcc，应使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-4-返回值"><a href="#3-4-返回值" class="headerlink" title="3.4. 返回值"></a>3.4. 返回值</h2><ul>
<li>强制 如果使用 int 作为返回值，必须遵循“负值表示失败，非负值表示成功”</li>
</ul>
<h2 id="3-5-除下述类型的函数都需要单测"><a href="#3-5-除下述类型的函数都需要单测" class="headerlink" title="3.5. 除下述类型的函数都需要单测"></a>3.5. 除下述类型的函数都需要单测</h2><ul>
<li>接口型函数</li>
<li>流程型函数</li>
<li>框架型函数</li>
</ul>
<h1 id="道"><a href="#道" class="headerlink" title="道"></a>道</h1><h2 id="一流代码特性"><a href="#一流代码特性" class="headerlink" title="一流代码特性"></a>一流代码特性</h2><ul>
<li>高效、鲁棒、简洁、简短、共享、可测试、可移植</li>
<li>可监控、可运维、可扩展</li>
</ul>
<h2 id="写好代码注重什么？"><a href="#写好代码注重什么？" class="headerlink" title="写好代码注重什么？"></a>写好代码注重什么？</h2><ul>
<li>正确和性能、可读和可维护、共享和重用、运维和运营</li>
</ul>
<h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><ul>
<li>《编写可读代码的艺术》</li>
<li>《code complete》</li>
<li>《设计模式》</li>
<li>《重构-改善既有代码的设计》</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title>数据中心网络DCN常见缩写词</title>
    <url>/2022/01/23/Common_acronyms_for_data_center_network_DCN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table>
<thead>
<tr>
<th align="left">缩写词</th>
<th align="left">全称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DCN</td>
<td align="left">Data Communicate Network</td>
<td align="left">数据通信网络</td>
</tr>
<tr>
<td align="left">ADC</td>
<td align="left">Advance Data center Core</td>
<td align="left">高级数据中心，承载普通IDC数据中心到B1流量和不同机房间的直通流量</td>
</tr>
<tr>
<td align="left">CADC</td>
<td align="left">Cloud Advance Data center Core</td>
<td align="left">高级云数据中心，承载公有云数据中心到B1流量和不同AZ间的直通流量</td>
</tr>
<tr>
<td align="left">DC</td>
<td align="left">Data Center</td>
<td align="left">数据中心，承担普通IDC机房内集群间流量。当机房内多于一个集群时，增加DC设备，避免集群数量多、ADC设备端口紧张的问题，例如阳泉机房</td>
</tr>
<tr>
<td align="left">CDC</td>
<td align="left">Cloud Data center Core</td>
<td align="left">公有云数据中心，承担公有云机房内集群间流量，当机房内多于一个集群时，增加CDC设备</td>
</tr>
<tr>
<td align="left">IC</td>
<td align="left">Internal Core</td>
<td align="left">普通IDC数据中心中的内网核心</td>
</tr>
<tr>
<td align="left">CIC</td>
<td align="left">Cloud Internal Core</td>
<td align="left">公有云机房中的内网核心</td>
</tr>
<tr>
<td align="left">IB</td>
<td align="left">Internal Border</td>
<td align="left">普通IDC数据中心的ToR设备</td>
</tr>
<tr>
<td align="left">CIB</td>
<td align="left">Cloud Internal Border</td>
<td align="left">公有云数据中心的ToR设备</td>
</tr>
<tr>
<td align="left">EC</td>
<td align="left">External Core</td>
<td align="left">外网核心层交换机</td>
</tr>
<tr>
<td align="left">EB</td>
<td align="left">External Border</td>
<td align="left">外网汇聚层交换机</td>
</tr>
<tr>
<td align="left">BC</td>
<td align="left">Backbone Core</td>
<td align="left">外网核心层交换机</td>
</tr>
<tr>
<td align="left">TOR</td>
<td align="left">Top of Rack</td>
<td align="left">接入层交换机</td>
</tr>
<tr>
<td align="left">IB</td>
<td align="left">Inner Border</td>
<td align="left">内网接入层交换机</td>
</tr>
<tr>
<td align="left">IC</td>
<td align="left">Inner Core</td>
<td align="left">内网核心层交换机</td>
</tr>
<tr>
<td align="left">SC</td>
<td align="left">Super Core</td>
<td align="left">内网超级核心层交换机</td>
</tr>
<tr>
<td align="left">4 Post</td>
<td align="left"></td>
<td align="left">一个集群由四个数据中心普通核心组成的网络架构，集群内为两层结构（ToR-IC），扩展性较弱</td>
</tr>
<tr>
<td align="left">CLOS</td>
<td align="left"></td>
<td align="left">利用三层无阻塞网络构成组成集群的网络架构，集群内为三层结构（ToR-Leaf-Spine），扩展、备份、容灾性强</td>
</tr>
<tr>
<td align="left">Spine</td>
<td align="left"></td>
<td align="left">核心层Spine交换机，在不同Pod间负责无阻塞连通的网络元素</td>
</tr>
<tr>
<td align="left">Leaf</td>
<td align="left"></td>
<td align="left">汇聚层Leaf交换机，连接ToR的网络元素</td>
</tr>
<tr>
<td align="left">SV</td>
<td align="left"></td>
<td align="left">Server服务器</td>
</tr>
<tr>
<td align="left">PoD</td>
<td align="left"></td>
<td align="left">CLOS架构下，四个Leaf及下联设备构成的单元</td>
</tr>
<tr>
<td align="left">服务器PoD</td>
<td align="left"></td>
<td align="left">仅包含业务服务器的PoD</td>
</tr>
<tr>
<td align="left">基础服务PoD</td>
<td align="left"></td>
<td align="left">包含基础服务IBGW、BIGNAT服务器的PoD</td>
</tr>
<tr>
<td align="left">出口PoD</td>
<td align="left"></td>
<td align="left">负责集群间连接的PoD</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 实用指令记录</title>
    <url>/2020/05/29/ConfusedShellLang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/ConfusedShellLang.jpg" class="full-image" />

<p>博文记录了一些实用 Shell 指令，以备不时之需。</p>
<a id="more"></a>

<h1 id="1-几种特殊的替换用法"><a href="#1-几种特殊的替换用法" class="headerlink" title="1. 几种特殊的替换用法"></a>1. 几种特殊的替换用法</h1><ul>
<li>若变量为空，则用默认值执行${var:-string}<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var=</span><br><span class="line">echo $&#123;var:-NULL&#125;</span><br><span class="line">echo $var</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">NULL</span><br></pre></td></tr></table></figure></li>
<li>若变量为空，则用默认值赋值给空变量${var:&#x3D;abc}<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var=</span><br><span class="line">echo $&#123;var:=abc&#125;</span><br><span class="line">echo $var</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure></li>
<li>若变量非空，则用默认值执行，若变量为空，则不作为${var:+string}<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var1=abc</span><br><span class="line">var2=</span><br><span class="line">echo $&#123;var1:+FULL&#125;</span><br><span class="line">echo $&#123;var2:+FULL&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">FULL</span><br></pre></td></tr></table></figure></li>
<li>若变量非空，则用其值，若变量为空，则输出 string 到标准错误中后退出脚本${var:?string}<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var1=abc</span><br><span class="line">var2=</span><br><span class="line">echo $&#123;var1:+FULL&#125;</span><br><span class="line">echo $&#123;var2:+FULL&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">FULL</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-支持-POSIX-标准的扩展计算"><a href="#2-支持-POSIX-标准的扩展计算" class="headerlink" title="2. 支持 POSIX 标准的扩展计算"></a>2. 支持 POSIX 标准的扩展计算</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">((exp))</span></span><br></pre></td></tr></table></figure>

<p>其中 exp 为符合 C 语言的运算符，示例如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo $((1+2))</span><br><span class="line">echo $((1&lt;2))</span><br><span class="line">echo $((5&lt;4?0:1))</span><br><span class="line">echo $((var=2+3))</span><br><span class="line">echo $((var++))</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h1 id="3-四种模式匹配替换"><a href="#3-四种模式匹配替换" class="headerlink" title="3. 四种模式匹配替换"></a>3. 四种模式匹配替换</h1><ul>
<li># 是去掉左边（在键盘上、#在、$之左边）；</li>
<li>% 是去掉右边（在键盘上、%在、$之右边）；</li>
<li>#和、%中的单一符号是最小匹配，两个相同符号是最大匹配。</li>
<li>这四种模式中都不会改变 variable 的值，其中，只有在 pattern 中使用了、*匹配符号时，%和%%，#和##才有区别。</li>
<li>结构中的 pattern 支持通配符：<ul>
<li>*表示零个或多个任意字符</li>
<li>? 表示仅与一个任意字符匹配</li>
<li>[…] 表示匹配中括号里面的字符</li>
<li>[!…] 表示不匹配中括号里面的字符</li>
</ul>
</li>
</ul>
<p><strong>模式 1：${variable%pattern}</strong></p>
<p>说明：shell 在 variable 中查找，判断 variable 是否以 pattern 结尾，如果是，就从命令行把 variable 中的内容去掉右边<strong>最短的</strong>匹配模式</p>
<p><strong>模式 2：${variable%%pattern}</strong></p>
<p>说明：shell 在 variable 中查找，判断 variable 是否以 pattern 结尾，如果是，就从命令行把 variable 中的内容去掉右边<strong>最长的</strong>匹配模式</p>
<p><strong>模式 3：${variable#pattern}</strong></p>
<p>说明：shell 在 variable 中查找，判断 variable 是否以 pattern 开始，如果是，就从命令行把 variable 中的内容去掉左边最短的匹配模式</p>
<p><strong>模式 4：${variable##pattern}</strong></p>
<p>shell 在 variable 中查找，判断 variable 是否以 pattern 开始，如果是，就从命令行把 variable 中的内容去掉右边最长的匹配模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">VAR=ABCABCDEFDEF</span><br><span class="line">PATTERN1=DEF</span><br><span class="line">PATTERN2=ABC</span><br><span class="line"></span><br><span class="line">echo &quot;VAR=$VAR&quot;</span><br><span class="line">echo &quot;PATTERN1=$PATTERN1&quot;</span><br><span class="line">echo &quot;PATTERN2=$PATTERN2&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;M1.$&#123;VAR%*$PATTERN1&#125;&#x27;</span><br><span class="line">echo $&#123;VAR%*$PATTERN1&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M2.$&#123;VAR%%*$PATTERN1&#125;&#x27;</span><br><span class="line">echo $&#123;VAR%%*$PATTERN1&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M2.$&#123;VAR%%?$PATTERN1&#125;&#x27;</span><br><span class="line">echo $&#123;VAR%%?$PATTERN1&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M3.$&#123;VAR#*$PATTERN2&#125;&#x27;</span><br><span class="line">echo $&#123;VAR#*$PATTERN2&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M4.$&#123;VAR##*$PATTERN2&#125;&#x27;</span><br><span class="line">echo $&#123;VAR##*$PATTERN2&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M4.$&#123;VAR##$PATTERN2*&#125;&#x27;</span><br><span class="line">echo $&#123;VAR##$PATTERN2*&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果</span></span><br><span class="line">VAR=ABCABCDEFDEF</span><br><span class="line">PATTERN1=DEF</span><br><span class="line">PATTERN2=ABC</span><br><span class="line">M1.$&#123;VAR%*$PATTERN1&#125;</span><br><span class="line">ABCABCDEF</span><br><span class="line">M2.$&#123;VAR%%*$PATTERN1&#125;</span><br><span class="line">（空）</span><br><span class="line">M2.$&#123;VAR%%?$PATTERN1&#125;</span><br><span class="line">ABCABCDE</span><br><span class="line">M3.$&#123;VAR#*$PATTERN2&#125;</span><br><span class="line">ABCDEFDEF</span><br><span class="line">M4.$&#123;VAR##*$PATTERN2&#125;</span><br><span class="line">DEFDEF</span><br><span class="line">M4.$&#123;VAR##$PATTERN2*&#125;</span><br><span class="line">（空）</span><br></pre></td></tr></table></figure>

<h1 id="4-变量判空"><a href="#4-变量判空" class="headerlink" title="4. 变量判空"></a>4. 变量判空</h1><ul>
<li>判空必要性：某些环境下执行空变量可能造成严重后果，如执行 rm 删除操作时，rm -rf 空路径变量会删除根目录，造成无法挽回的严重后果。</li>
<li>正确操作：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断 DIR 变量非空，才会执行 rm 命令</span></span><br><span class="line">[ -n $DIR ] &amp;&amp; rm -rf $DIR</span><br></pre></td></tr></table></figure></li>
<li>变量判空常用方法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">para=</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判空方式 1. 直接判断变量</span></span><br><span class="line">if [ ! $para ];then</span><br><span class="line">    echo &quot;NULL&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判空方式 2. 作字符串判空</span></span><br><span class="line">if [ ! -n &quot;$para&quot; ];then</span><br><span class="line">    echo &quot;NULL&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判空方式 3. 与“空字符串”比较判空</span></span><br><span class="line">if [ &quot;$para&quot; = &quot;&quot; ];then</span><br><span class="line">    echo &quot;NULL&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判空方式 4. 利用 <span class="built_in">test</span> 判空</span></span><br><span class="line">if test -z &quot;$para&quot;</span><br><span class="line">then</span><br><span class="line">    echo &quot;NULL&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-Shell-字符分割"><a href="#5-Shell-字符分割" class="headerlink" title="5. Shell 字符分割"></a>5. Shell 字符分割</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux a -t $(tmux ls | grep build2021 | awk &#x27;&#123; print $1 &#125;&#x27; | cut  -d \: -f 1)</span><br></pre></td></tr></table></figure>

<h1 id="6-shell-字符变量切分"><a href="#6-shell-字符变量切分" class="headerlink" title="6. shell 字符变量切分"></a>6. shell 字符变量切分</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str1=&quot;I am chinese&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据空格分割为数组</span></span><br><span class="line">array1=($&#123;str1// / &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="7-获取字符串变量长度"><a href="#7-获取字符串变量长度" class="headerlink" title="7. 获取字符串变量长度"></a>7. 获取字符串变量长度</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">STR=&#x27;hello&#x27;; echo $&#123;#STR&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-字符串截取"><a href="#8-字符串截取" class="headerlink" title="8. 字符串截取"></a>8. 字符串截取</h1><h2 id="8-1-头部截取（最大-匹配）"><a href="#8-1-头部截取（最大-匹配）" class="headerlink" title="8.1. 头部截取（最大 -* 匹配）"></a>8.1. 头部截取（最大 -* 匹配）</h2><p>从右往左匹配最后遇到的’-‘字符及之后的部分（减掉表达式”-*”最大匹配的部分”-serial-14210”），结果：”&#x2F;dev&#x2F;tty.usb”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">STR=&quot;/dev/tty.usb-serial-14210&quot;; echo $&#123;STR%%-*&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-头部截取（最小-匹配）"><a href="#8-2-头部截取（最小-匹配）" class="headerlink" title="8.2. 头部截取（最小 -* 匹配）"></a>8.2. 头部截取（最小 -* 匹配）</h2><p>从右往左匹配最先遇到的’-‘字符及之后的部分（减掉表达式”-*”最大匹配的部分”-14210”），结果：”&#x2F;dev&#x2F;tty.usb-serial”<br>最后一个’-‘之前的部分，结果：”&#x2F;dev&#x2F;tty.usb-serial”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">STR=&quot;/dev/tty.usb-serial-14210&quot;; echo $&#123;STR%-*&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-尾部截取（-最大匹配）"><a href="#8-3-尾部截取（-最大匹配）" class="headerlink" title="8.3. 尾部截取（ *- 最大匹配）"></a>8.3. 尾部截取（ *- 最大匹配）</h2><p>从左往右匹配最后遇到的’-‘字符及之前的部分（减掉表达式”*-“最大匹配的部分”&#x2F;dev&#x2F;tty.usb-serial-“），结果：”14210”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">STR=&quot;/dev/tty.usb-serial-14210&quot;; echo $&#123;STR##*-&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-4-尾部截取（-最小匹配）"><a href="#8-4-尾部截取（-最小匹配）" class="headerlink" title="8.4. 尾部截取（ *- 最小匹配）"></a>8.4. 尾部截取（ *- 最小匹配）</h2><p>从左往右匹配最先遇到的’-‘字符及之前的部分（减掉表达式”*-“最小匹配的部分”&#x2F;dev&#x2F;tty.usb-“），结果：”serial-14210”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">STR=&quot;/dev/tty.usb-serial-14210&quot;; echo $&#123;STR#*-&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-5-cut-截取命令-（以截取-ip-“192-168-3-35-x2F-24”中’-x2F-‘字符前部为例）"><a href="#8-5-cut-截取命令-（以截取-ip-“192-168-3-35-x2F-24”中’-x2F-‘字符前部为例）" class="headerlink" title="8.5. cut 截取命令 （以截取 ip “192.168.3.35&#x2F;24”中’&#x2F;‘字符前部为例）"></a>8.5. cut 截取命令 （以截取 ip “192.168.3.35&#x2F;24”中’&#x2F;‘字符前部为例）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr | grep &#x27;eth0&#x27; | awk &#x27;&#123; print $2 &#125;&#x27; | cut -d / -f 1</span><br></pre></td></tr></table></figure>

<h1 id="9-变量转大小写"><a href="#9-变量转大小写" class="headerlink" title="9. 变量转大小写"></a>9. 变量转大小写</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str=&#x27;HelLo World&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 变量转换为大写</span></span><br><span class="line">upper_str=$&#123;str^^&#125;</span><br><span class="line">upper_str=$(echo &quot;$str&quot; | tr [a-z] [A-Z])</span><br><span class="line">upper_str=$(echo &quot;$str&quot; | tr [:lower:] [:upper:])</span><br><span class="line"><span class="meta">#</span><span class="bash"> 变量转换为小写</span></span><br><span class="line">lower_str=$&#123;str,,&#125;</span><br><span class="line">lower_str=$(echo &quot;$str&quot; | tr [A-Z] [a-z])</span><br><span class="line">lower_str=$(echo &quot;$str&quot; | tr [:upper:] [:lower:])</span><br></pre></td></tr></table></figure>

<h1 id="10-输出内容的-字符替换-amp-字符删除"><a href="#10-输出内容的-字符替换-amp-字符删除" class="headerlink" title="10. 输出内容的 字符替换 &amp; 字符删除"></a>10. 输出内容的 字符替换 &amp; 字符删除</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 替换</span></span><br><span class="line">echo &#x27;ABCDABCD&#x27; | sed &#x27;s/ABC/DEF/g&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> tr 替换，注意是字符集合替换</span></span><br><span class="line">echo &#x27;ABCDABCD&#x27; | tr &#x27;AD&#x27; &#x27;C&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除</span></span><br><span class="line">echo &#x27;ABCDABCD&#x27; | sed &#x27;s/ABC//g&#x27;</span><br><span class="line">echo &#x27;ABCDABCD&#x27; | tr -d &#x27;AC&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="11-显示文件列表"><a href="#11-显示文件列表" class="headerlink" title="11. 显示文件列表"></a>11. 显示文件列表</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l -A --color=auto --group-directories-first /var/log/</span><br></pre></td></tr></table></figure>

<h1 id="12-查看个人进程"><a href="#12-查看个人进程" class="headerlink" title="12. 查看个人进程"></a>12. 查看个人进程</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef |grep lih |fgrep -v vscode | fgrep -v baas</span><br></pre></td></tr></table></figure>

<h1 id="13-查找文件（过滤无效信息）"><a href="#13-查找文件（过滤无效信息）" class="headerlink" title="13. 查找文件（过滤无效信息）"></a>13. 查找文件（过滤无效信息）</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo find / -name &quot;makefile&quot; -print 2&gt;&amp;1 | fgrep -v &quot;Operation not permitted&quot; | fgrep -v &quot;No such file&quot;</span><br></pre></td></tr></table></figure>

<h1 id="14-统计第-2-列总类型"><a href="#14-统计第-2-列总类型" class="headerlink" title="14. 统计第 2 列总类型"></a>14. 统计第 2 列总类型</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command | awk &#x27;&#123; print $2 &#125;&#x27; | uniq | sort | uniq</span><br><span class="line"></span><br><span class="line">cat ~/1.txt  | awk &#x27;&#123; for(i=2;i&lt;=NF;i++) printf $i&quot;&quot;FS;print &quot;&quot; &#125;&#x27; | uniq | sort | uniq</span><br></pre></td></tr></table></figure>
<h1 id="15-只打印-第-n-最末-列"><a href="#15-只打印-第-n-最末-列" class="headerlink" title="15. 只打印 第 n~最末 列"></a>15. 只打印 第 n~最末 列</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat xxx.log | awk &#x27;&#123; for(i=1; i&lt;=3; i++)&#123; $i=&quot;&quot; &#125;; print $0 &#125;&#x27;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 16. grep 查找命令说明</span></span><br><span class="line">```shell</span><br><span class="line">-r 是递归查找</span><br><span class="line">-n 是显示行号</span><br><span class="line">-R 查找所有文件包含子目录</span><br><span class="line">-i 忽略大小写</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加显示匹配行的 前后各 [number] 行</span></span><br><span class="line">grep -C number pattern files</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加显示匹配行的 前的 [number] 行</span></span><br><span class="line">grep -B number pattern files</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加显示匹配行的 后的 [number] 行</span></span><br><span class="line">grep -A number pattern files</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 反向查找 “不匹配” 的行</span></span><br><span class="line">grep -v dis_pattern files</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正则表达式查找 1</span></span><br><span class="line">grep -E &quot;[1-9]+&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正则表达式查找 2</span></span><br><span class="line">egrep &quot;[1-9]+&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不显示错误信息</span></span><br><span class="line">grep -s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按匹配文件中内容查询</span></span><br><span class="line">grep -f pattern_file file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不区分大小写地搜索。默认情况区分大小写，</span> </span><br><span class="line">grep -i pattern files</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只列出匹配的文件名，</span> </span><br><span class="line">grep -l pattern files</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出不匹配的文件名，</span> </span><br><span class="line">grep -L pattern files</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），</span> </span><br><span class="line">grep -w pattern files</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示匹配 pattern1 或 pattern2 的行，</span> </span><br><span class="line">grep pattern1 | pattern2 files</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示既匹配 pattern1 又匹配 pattern2 的行。</span></span><br><span class="line">grep pattern1 files | grep pattern2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>grep -a “systemd” &#x2F;var&#x2F;log&#x2F;daemon.log | grep “snmp”<br>grep -a “systemd” | “snmp” &#x2F;var&#x2F;log&#x2F;daemon.log</p>
<p>–group-directories-first</p>
<h2 id="16-1-倒序查看-n-行-符合条件行"><a href="#16-1-倒序查看-n-行-符合条件行" class="headerlink" title="16.1. 倒序查看 n 行 符合条件行"></a>16.1. 倒序查看 n 行 符合条件行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -E &#x27;Psu|Fan|Sff|Linecard&#x27; /var/log/syslog | sort -r | head -n 40</span><br></pre></td></tr></table></figure>

<h1 id="17-查看某容器中-打印到-某文件的进程列表"><a href="#17-查看某容器中-打印到-某文件的进程列表" class="headerlink" title="17. 查看某容器中 打印到 某文件的进程列表"></a>17. 查看某容器中 打印到 某文件的进程列表</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -a &quot;bgp&quot; /var/log/syslog | awk &#x27;&#123; print $7 &#125;&#x27; | uniq | sort | uniq</span><br><span class="line">grep -a &quot;bgp&quot; /var/log/user.log | awk &#x27;&#123; print $7 &#125;&#x27; | uniq | sort | uniq</span><br></pre></td></tr></table></figure>

<h1 id="18-查看某进程打印日志的类别-列表"><a href="#18-查看某进程打印日志的类别-列表" class="headerlink" title="18. 查看某进程打印日志的类别 列表"></a>18. 查看某进程打印日志的类别 列表</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -a &quot;database&quot; /var/log/user.log | awk &#x27;&#123; print $4 &#125;&#x27; | uniq | sort | uniq</span><br></pre></td></tr></table></figure>

<h1 id="19-shell-脚本中临时调用-pexpect"><a href="#19-shell-脚本中临时调用-pexpect" class="headerlink" title="19. shell 脚本中临时调用 pexpect"></a>19. shell 脚本中临时调用 pexpect</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expect -c &quot;</span><br><span class="line">spawn scp lih@10.32.19.100:/home/lih/pexpect-2.3.tar.gz $RUN_PATH</span><br><span class="line"></span><br><span class="line">expect \&quot;assword:\&quot;</span><br><span class="line">send \&quot;$PASSWD\r\&quot;</span><br><span class="line">expect eof</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<h1 id="20-tmux-常用命令"><a href="#20-tmux-常用命令" class="headerlink" title="20. tmux 常用命令"></a>20. tmux 常用命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建会话</span></span><br><span class="line">tmux new -s user_session_name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已创建的会话</span></span><br><span class="line">tmux ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入一个已创建的会话</span></span><br><span class="line">tmux a -t user_session_name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时跳出当前会话（快捷键）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 先按 control + B 后松开（触发 tmux 功能键监听）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 再按 D （跳出会话窗口）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Kill 远程会话</span></span><br><span class="line">tmux kill-session -t user_session_name</span><br></pre></td></tr></table></figure>

<h1 id="21-tmux-快捷键"><a href="#21-tmux-快捷键" class="headerlink" title="21. tmux 快捷键"></a>21. tmux 快捷键</h1><p>均为先按 ctrl + b，放开后再按：</p>
<ul>
<li>分屏<ul>
<li>水平向： %</li>
<li>垂直向： “</li>
</ul>
</li>
<li>光标切换： o</li>
<li>会话终端切换： s</li>
<li>退出终端窗口： d</li>
<li>终止终端窗口： &amp;</li>
<li>在当前窗口基础上再开一个新窗口： c</li>
<li>关闭所有分屏后的窗口： !</li>
<li>终端内显示时间： t</li>
<li>显示终端编号：q</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编译过程总结</title>
    <url>/2019/12/19/CppCompile/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/CppCompile.jpg" class="full-image" />


<h1 id="1-step1-预编译"><a href="#1-step1-预编译" class="headerlink" title="1. step1.预编译"></a>1. step1.预编译</h1><p>“宏展开”，也就是对那些#***的命令的一种展开。例如define MAX 1000就是建立起MAX和1000之间的对等关系，好在编译阶段进行替换。例如ifdef&#x2F;ifndef就是从一个文件中有选择性的挑出一些符合条件的代码来交给下一步的编译阶段来处理。这里面最复杂的莫过于include了，相当于把那个对应的文件里面的内容一下子替换到这条include***语句的地方来。</p>
<a id="more"></a>

<h1 id="2-step2-编译"><a href="#2-step2-编译" class="headerlink" title="2. step2.编译"></a>2. step2.编译</h1><p>编译是以一个个独立的文件作为单元的，一个文件就会编译出一个目标文件。（这里插入一点关于编译的文件的说明，编译器通过后缀名来辨识是否编译该文件，因此“.h”的头文件一概不理会，而“.cpp”的源文件一律都要被编译，我实验过把.h文件的后缀名改为.cpp，然后在include的地方相应的改为***.cpp，这样一来，编译器就会编译许多不必要的头文件，只不过头文件里我们通常只放置声明而不是定义，因此最后链接生成的可执行文件的大小是不会改变的）。<br>清楚编译是以一个个单独的文件为单元的，这一点很重要，因此编译只负责本单元的那些事，而对外部的事情一概不理会，在这一步里，我们可以调用一个函数而不必给出这个函数的定义，但是要在调用前得到这个函数的声明（其实这就是include的本质，不就是为了给你提前提供个声明而好让你使用吗？至于那个函数到底是如何实现的，需要在链接这一步里去找函数的入口地址。因此提供声明的方式可以是用include把放在别的文件中的声明拿过来，也可以是在调用之前自己写一句void max(int,int);都行。），编译阶段剩下的事情就是分析语法的正确性之类的工作了。</p>
<ul>
<li>第一步，检验函数或者变量是否存在它们的声明；</li>
<li>第二步，检查语句是否符合C++语法。</li>
</ul>
<h1 id="3-step3-链接"><a href="#3-step3-链接" class="headerlink" title="3. step3.链接"></a>3. step3.链接</h1><p>它会把所有编译好的单元全部链接为一个整体文件，其实这一步可以比作一个“连线”的过程，比如A文件用了B文件中的函数，那么链接的这一步会建立起这个关联。链接时最重要的我认为是检查全局空间里面是不是有重复定义或者缺失定义。这也就解释了为什么我们一般不在头文件中出现定义，因为头文件有可能被释放到多个源文件中，每个源文件都会单独编译，链接时就会发现全局空间中有多个定义了。</p>
<h1 id="4-标准C和C-将编译过程定义为9个阶段"><a href="#4-标准C和C-将编译过程定义为9个阶段" class="headerlink" title="4. 标准C和C++将编译过程定义为9个阶段"></a>4. 标准C和C++将编译过程定义为9个阶段</h1><h2 id="4-1-字符映射-Character-Mapping"><a href="#4-1-字符映射-Character-Mapping" class="headerlink" title="4.1. 字符映射(Character Mapping)"></a>4.1. 字符映射(Character Mapping)</h2><p>文件中的物理源字符被映射到源字符集中，其中包括三字符运算符的替换、控制字符(行尾的回车换行)的替换。许多非美式键盘不支持基本源字符集中的一些字符，文件中可用三字符来代替这些基本源字符，以??为前导。但如果所用键盘是美式键盘，有些编译器可能不对三字符进行查找和替换，需要增加-trigraphs编译参数。在C++程序中，任何不在基本源字符集中的字符都被它的通用字符名替换。</p>
<h2 id="4-2-行合并-Line-Splicing"><a href="#4-2-行合并-Line-Splicing" class="headerlink" title="4.2. 行合并(Line Splicing)"></a>4.2. 行合并(Line Splicing)</h2><p>以反斜杠&#x2F;结束的行和它接下来的行合并。</p>
<h2 id="4-3-标记化-Tokenization"><a href="#4-3-标记化-Tokenization" class="headerlink" title="4.3. 标记化(Tokenization)"></a>4.3. 标记化(Tokenization)</h2><p>每一条注释被一个单独的空字符所替换。C++双字符运算符被识别为标记(为了开发可读性更强的程序，C++为非ASCII码开发者定义了一套双字符运算符集和新的保留字集)。源代码被分析成预处理标记。</p>
<h2 id="4-4-预处理-Preprocessing"><a href="#4-4-预处理-Preprocessing" class="headerlink" title="4.4. 预处理(Preprocessing)"></a>4.4. 预处理(Preprocessing)</h2><p>调用预处理指令并扩展宏。使用#include指令包含的文件，重复步骤1到4。上述四个阶段统称为预处理阶段。</p>
<h2 id="4-5-字符集映射-Character-set-Mapping"><a href="#4-5-字符集映射-Character-set-Mapping" class="headerlink" title="4.5. 字符集映射(Character-set Mapping)"></a>4.5. 字符集映射(Character-set Mapping)</h2><p>源字符集成员、转义序列被转换成等价的执行字符集成员。例如：’&#x2F;a’在ASCII环境下会被转换成值为一个字节，值为7。</p>
<h2 id="4-6-字符串连接-String-Concatenation"><a href="#4-6-字符串连接-String-Concatenation" class="headerlink" title="4.6. 字符串连接(String Concatenation)"></a>4.6. 字符串连接(String Concatenation)</h2><p>相邻的字符串被连接。例如：”””hahaha””huohuohuo”将成为”hahahahuohuohuo”。</p>
<h2 id="4-7-翻译-Translation"><a href="#4-7-翻译-Translation" class="headerlink" title="4.7. 翻译(Translation)"></a>4.7. 翻译(Translation)</h2><p>进行语法和语义分析编译，并翻译成目标代码。</p>
<h2 id="4-8-处理模板"><a href="#4-8-处理模板" class="headerlink" title="4.8. 处理模板"></a>4.8. 处理模板</h2><p>处理模板实例。</p>
<h2 id="4-9-连接-Linkage"><a href="#4-9-连接-Linkage" class="headerlink" title="4.9. 连接(Linkage)"></a>4.9. 连接(Linkage)</h2><p>解决外部引用的问题，准备好程序映像以便执行。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++易混淆知识点总结</title>
    <url>/2020/08/11/CppConfusedNotes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/CppConfusedNotes.png" class="full-image" />

<h1 id="1-struct-和-union-的区别"><a href="#1-struct-和-union-的区别" class="headerlink" title="1. struct 和 union 的区别"></a>1. struct 和 union 的区别</h1><ul>
<li>结构体struct：把不同类型的数据组合成一个整体，自定义类型。</li>
<li>共同体union：使几个不同类型的变量共同占用一段内存<a id="more"></a></li>
</ul>
<h1 id="2-字节对齐"><a href="#2-字节对齐" class="headerlink" title="2. 字节对齐"></a>2. 字节对齐</h1><p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2，4或8)的倍数。为了方便快速地寻址，编译器会采用字节对齐，将下一个变量地址放置在系统能快速读取的位置（如：32 位系统，放在偶地址的变量能够 1 个读周期取到值，而放在奇地址的变量却需要 2 个读周期才能取到值，故会存在字节对齐）。</p>
<p>关于内存对齐，有四个重要的基本概念：</p>
<ul>
<li>数据类型自身的对齐值：<br>对于char型数据，其自身对齐值为1，对于short型为2，对于int，float，double类型，其自身对齐值为4，单位字节。</li>
<li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</li>
<li>指定对齐值：#pragma pack(n)，n&#x3D;1，2，4，8，16改变系统的对齐系数</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</li>
</ul>
<h1 id="3-字节序（小正逆大）"><a href="#3-字节序（小正逆大）" class="headerlink" title="3. 字节序（小正逆大）"></a>3. 字节序（小正逆大）</h1><ul>
<li>小端模式：Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</li>
<li>大端模式：Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>网络字节顺序(大端)是TCP&#x2F;IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。</li>
</ul>
<h1 id="4-static的作用"><a href="#4-static的作用" class="headerlink" title="4. static的作用"></a>4. static的作用</h1><h2 id="4-1-对普通变量的作用"><a href="#4-1-对普通变量的作用" class="headerlink" title="4.1. 对普通变量的作用"></a>4.1. 对普通变量的作用</h2><ul>
<li>static修饰局部变量</li>
</ul>
<p>它改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。</p>
<ul>
<li>static修饰全局变量。</li>
</ul>
<p>并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，好处如下：（1）不会被其他文件所访问修改（2）其他文件中可以使用相同名字的变量，不会发生冲突。</p>
<h2 id="4-2-对成员变量的作用"><a href="#4-2-对成员变量的作用" class="headerlink" title="4.2. 对成员变量的作用"></a>4.2. 对成员变量的作用</h2><p>用static修饰类的数据成员成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化(初始化格式： int base::var&#x3D;10; )，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。</p>
<h2 id="4-3-对成员函数的作用"><a href="#4-3-对成员函数的作用" class="headerlink" title="4.3. 对成员函数的作用"></a>4.3. 对成员函数的作用</h2><p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。<br>静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。base::func(5，3)；当static成员函数在类外定义时不需要加static修饰符。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。</p>
<h1 id="5-const的作用"><a href="#5-const的作用" class="headerlink" title="5. const的作用"></a>5. const的作用</h1><ul>
<li>限定变量为不可修改。</li>
<li>限定成员函数不可以修改任何数据成员。</li>
<li>const与指针：<ul>
<li>const char *p，不能改变指向的内容；</li>
<li>char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。</li>
</ul>
</li>
</ul>
<h1 id="6-不能同时使用const和static修饰类的成员函数"><a href="#6-不能同时使用const和static修饰类的成员函数" class="headerlink" title="6. 不能同时使用const和static修饰类的成员函数"></a>6. 不能同时使用const和static修饰类的成员函数</h1><p>static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。</p>
<h1 id="7-指针常量和常量指针"><a href="#7-指针常量和常量指针" class="headerlink" title="7. 指针常量和常量指针"></a>7. 指针常量和常量指针</h1><ul>
<li>指针常量（char * const p）：指针变量的值一经初始化（初始化是必要的），不可以改变指向另一个变量（但可以改变已经指向的变量的内容）。</li>
<li>常量指针（const char *p）：指向常量的指针。不可以改变指向某变量的值，可以改变指向另一个变量。</li>
</ul>
<h1 id="8-指针和引用的区别"><a href="#8-指针和引用的区别" class="headerlink" title="8. 指针和引用的区别"></a>8. 指针和引用的区别</h1><ul>
<li>指针是一个新的变量，只是这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量。</li>
<li>引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。</li>
<li>引用在定义的时候必须初始化；指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。</li>
<li>指针和引用的自增(++)运算意义不一样。</li>
</ul>
<h1 id="9-多态及其用途"><a href="#9-多态及其用途" class="headerlink" title="9. 多态及其用途"></a>9. 多态及其用途</h1><ul>
<li>定义：“一个接口，多种方法”，程序在运行时才决定调用的函数。</li>
<li>实现：C++多态性主要是通过虚函数实现的，虚函数允许子类重写override(注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表&#x2F;类型不同）。</li>
<li>目的：接口重用。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。</li>
<li>用法：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。</li>
<li>详见：<a href="https://eisenhao.cn/2018/10/14/PolymorphismTest/">C++ 中的四种多态</a></li>
</ul>
<h1 id="10-重载、覆盖与重写的区别"><a href="#10-重载、覆盖与重写的区别" class="headerlink" title="10. 重载、覆盖与重写的区别"></a>10. 重载、覆盖与重写的区别</h1><h2 id="10-1-Overload-重载"><a href="#10-1-Overload-重载" class="headerlink" title="10.1. Overload(重载)"></a>10.1. Overload(重载)</h2><p>在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。</p>
<ul>
<li>相同的范围（在同一个类中）；</li>
<li>函数名字相同；</li>
<li>参数不同；</li>
<li>virtual 关键字可有可无。</li>
</ul>
<h2 id="10-2-Override-覆盖"><a href="#10-2-Override-覆盖" class="headerlink" title="10.2. Override(覆盖)"></a>10.2. Override(覆盖)</h2><p>是指派生类函数覆盖基类函数，特征是：</p>
<ul>
<li>不同的范围（分别位于派生类与基类）；</li>
<li>函数名字相同；</li>
<li>参数相同；</li>
<li>基类函数必须有virtual 关键字。</li>
</ul>
<p>注：重写基类虚函数的时候，会自动转换这个函数为virtual函数，不管有没有加virtual，因此重写的时候不加virtual也是可以的，不过为了易读性，还是加上比较好。</p>
<h2 id="10-3-Overwrite-重写"><a href="#10-3-Overwrite-重写" class="headerlink" title="10.3. Overwrite(重写)"></a>10.3. Overwrite(重写)</h2><p>是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</p>
<ul>
<li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</li>
</ul>
<h1 id="11-面向对象的三要素"><a href="#11-面向对象的三要素" class="headerlink" title="11. 面向对象的三要素"></a>11. 面向对象的三要素</h1><p>封装、继承、多态</p>
<h1 id="12-纯虚函数与抽象类"><a href="#12-纯虚函数与抽象类" class="headerlink" title="12. 纯虚函数与抽象类"></a>12. 纯虚函数与抽象类</h1><p>将函数定义为纯虚函数<code>virtual ReturnType Function() = 0;</code>，纯虚函数不能再在基类中实现，编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。<br>特点：</p>
<ul>
<li>在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；（避免类被实例化且在编译时候被发现，可以采用此方法）</li>
<li>这个方法必须在派生类(derived class)中被实现;目的：使派生类仅仅只是继承函数的接口。</li>
<li>抽象类只能作为基类来使用，而继承了抽象类的派生类如果没有实现纯虚函数，而只是继承纯虚函数，那么该类仍旧是一个抽象类，如果实现了纯虚函数，就不再是抽象类。</li>
</ul>
<h1 id="13-虚函数的作用"><a href="#13-虚函数的作用" class="headerlink" title="13. 虚函数的作用"></a>13. 虚函数的作用</h1><p>实现动态绑定，即运行期绑定</p>
<h1 id="14-析构函数定义为虚函数的原因"><a href="#14-析构函数定义为虚函数的原因" class="headerlink" title="14. 析构函数定义为虚函数的原因"></a>14. 析构函数定义为虚函数的原因</h1><p>基类指针可以指向派生类的对象（多态性），如果删除该指针delete p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。</p>
<p>构造函数为什么不能为虚函数（延伸）<br>虚函数对应一个指向虚函数表的指针，而这个指向vtable的指针是存储在对象的内存空间的。假设构造函数是虚的，就需要要通过查询vtable来调用，但是对象还没有实例化，因此也就不存在vtable，所以构造函数不能是虚函数。</p>
<h1 id="15-深拷贝与浅拷贝："><a href="#15-深拷贝与浅拷贝：" class="headerlink" title="15. 深拷贝与浅拷贝："></a>15. 深拷贝与浅拷贝：</h1><ul>
<li>浅拷贝，默认的拷贝构造函数只是完成了对象之间的位拷贝，也就是把对象里的值完全复制给另一个对象，如A&#x3D;B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存（并未另申请内存）。这就会导致野指针问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</li>
<li>深拷贝，自定义复制构造函数需要注意，对象之间发生复制，资源重新分配，即A有5个空间，B也应该有5个空间，而不是指向A的5个空间。</li>
</ul>
<h1 id="16-vector中size-和capacity-的区别。"><a href="#16-vector中size-和capacity-的区别。" class="headerlink" title="16. vector中size()和capacity()的区别。"></a>16. vector中size()和capacity()的区别。</h1><ul>
<li>size()指容器当前拥有的元素个数；</li>
<li>capacity()指容器在必须分配存储空间之前可以存储的元素总数。</li>
</ul>
<h1 id="17-map和set默认是排序的"><a href="#17-map和set默认是排序的" class="headerlink" title="17. map和set默认是排序的"></a>17. map和set默认是排序的</h1><p>map和set的底层实现主要是由红黑树实现的</p>
<h1 id="18-在TCP连接建立过程中，若client发送了SYN消息后，client、server可能状态"><a href="#18-在TCP连接建立过程中，若client发送了SYN消息后，client、server可能状态" class="headerlink" title="18. 在TCP连接建立过程中，若client发送了SYN消息后，client、server可能状态"></a>18. 在TCP连接建立过程中，若client发送了SYN消息后，client、server可能状态</h1><ul>
<li>client处于SYN_SENT状态；</li>
<li>server可能仍处于listen状态（未收到SYN消息），或处于SYN_RCVD状态</li>
</ul>
<h1 id="19-析构函数不推荐抛出异常"><a href="#19-析构函数不推荐抛出异常" class="headerlink" title="19. 析构函数不推荐抛出异常"></a>19. 析构函数不推荐抛出异常</h1><p>从语法上面讲，析构函数抛出异常是可以的，C++并没有禁止析构函数引发异常，但是C++不推荐这一做法，从析构函数中抛出异常是及其危险的。</p>
<p>析构函数可能在对象正常结束生命周期时调用，也可能在有异常发生时从函数堆栈清理时调用。前一种情况抛出异常不会有无法预料的结果，可以正常捕获；但后一种情况下，因为函数发生了异常而导致函数的局部变量的析构函数被调用，析构函数又抛出异常，本来局部对象抛出的异常应该是由它所在的函数负责捕获的，现在函数既然已经发生了异常，必定不能捕获，因此，异常处理机制只能调用terminate()。</p>
<h1 id="20-进程和线程"><a href="#20-进程和线程" class="headerlink" title="20. 进程和线程"></a>20. 进程和线程</h1><h2 id="20-1-进程"><a href="#20-1-进程" class="headerlink" title="20.1. 进程"></a>20.1. 进程</h2><p>是并发执行的程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。</p>
<h2 id="20-2-线程"><a href="#20-2-线程" class="headerlink" title="20.2. 线程"></a>20.2. 线程</h2><p>是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。</p>
<h2 id="20-3-进程和线程的区别"><a href="#20-3-进程和线程的区别" class="headerlink" title="20.3. 进程和线程的区别"></a>20.3. 进程和线程的区别</h2><p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于：</p>
<ul>
<li>地址空间：线程是进程内的一个执行单元；一个程序至少有一个进程，一个进程至少有一个线程；它们共享进程的地址空间；而各个进程有自己独立的地址空间；</li>
<li>资源拥有：进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源</li>
<li>划分尺度：线程的划分尺度小于进程，使得多线程程序的并发性高（进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。）</li>
<li>执行过程：每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>线程是处理器调度的基本单位，而进程不是</li>
<li>管理与分配：多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
</ul>
<h1 id="21-进程间通信方式"><a href="#21-进程间通信方式" class="headerlink" title="21. 进程间通信方式"></a>21. 进程间通信方式</h1><ul>
<li>管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>命名管道（FIFO）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>消息队列（MessageQueue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存（SharedMemory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>信号量（Semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>套接字（Socket）：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
<li>信号（sinal）： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>AdaBoost算法——数据挖掘</title>
    <url>/2018/12/03/DataMining_AdaBoost/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DataMining_AdaBoost.png" class="full-image" />

<h1 id="1-集成学习AdaBoost算法简介"><a href="#1-集成学习AdaBoost算法简介" class="headerlink" title="1. 集成学习AdaBoost算法简介"></a>1. 集成学习AdaBoost算法简介</h1><p>AdaBoost全称是adaptive boosting，该算法基本思想:多个结构较为简单，分类或预测精度较低的弱学习算法可以通过某种方式结合成具有较强学习能力的强学习算法。根据统计学习方法的三要素，AdaBoost 方法&#x3D;加法模型+指数损失函数(策略)+前向分步 算法。</p>
<a id="more"></a>
<h1 id="2-AdaBoost运行原理如下"><a href="#2-AdaBoost运行原理如下" class="headerlink" title="2. AdaBoost运行原理如下:"></a>2. AdaBoost运行原理如下:</h1><ul>
<li><p>S1.初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值:1&#x2F;N。</p>
</li>
<li><p>S2.训练弱分类器。</p>
<ul>
<li>具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低;</li>
<li>相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。</li>
<li>然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</li>
</ul>
</li>
<li><p>S3.将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。</p>
</li>
</ul>
<h1 id="3-Python编程实现基于单层决策树的AdaBoost算法"><a href="#3-Python编程实现基于单层决策树的AdaBoost算法" class="headerlink" title="3. Python编程实现基于单层决策树的AdaBoost算法"></a>3. Python编程实现基于单层决策树的AdaBoost算法</h1><h2 id="3-1-基于单层决策树的AdaBoost算法步骤"><a href="#3-1-基于单层决策树的AdaBoost算法步骤" class="headerlink" title="3.1. 基于单层决策树的AdaBoost算法步骤"></a>3.1. 基于单层决策树的AdaBoost算法步骤</h2><ul>
<li>S1.找出最佳单层决策树: a.将最小分类误差率minerror&#x3D;inf b.对数据集中的每一个特征: c.对该特征的每个步长(找出决策阈值): d.对每个不等号(&gt;&#x3D;，&lt;): e.建立一颗单层决策树(只包含树桩)并利用加权数据集并计算该决策树的分类误差率 f.如果分类误差率小于minerror，则将当前单层决策树设置成最佳单层决策树。</li>
<li>S2.利用单层决策树的分类误差率计算该决策树的比例系数alpha</li>
<li>S3.计算更新权重向量D</li>
<li>S4.更新累计类别估计值，计算AdaBoost模型的错误率</li>
<li>S5.如果错误率为0或者分类器数目i&gt;M，则退出循环</li>
</ul>
<h2 id="3-2-寻找最优决策树"><a href="#3-2-寻找最优决策树" class="headerlink" title="3.2. 寻找最优决策树"></a>3.2. 寻找最优决策树</h2><p>找到加权错误率(分类错误率)最小的单层决策树(会被不断迭代)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildStump</span>(<span class="params">dataArray， classLabels， D</span>):</span></span><br><span class="line">    dataMatrix = np.mat(dataArray); labelMat = np.mat(classLabels).T</span><br><span class="line">    m， n = np.shape(dataMatrix)</span><br><span class="line">    stepNum = <span class="number">10.0</span>; bestStump = &#123;&#125;; bestClassEst = np.mat(np.zeros((m， <span class="number">1</span>)))</span><br><span class="line">    minError = np.inf</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        rangeMin = dataMatrix[:， i].<span class="built_in">min</span>(); rangeMax = dataMatrix[:， i].<span class="built_in">max</span>()</span><br><span class="line">        stepSize = (rangeMax - rangeMin)/stepNum</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1</span>， <span class="built_in">int</span>(stepNum)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> thresholdIneq <span class="keyword">in</span> [<span class="string">&#x27;lt&#x27;</span>， <span class="string">&#x27;gt&#x27;</span>]:</span><br><span class="line">                thresholdValue =  rangeMin + <span class="built_in">float</span>(j) * stepSize</span><br><span class="line">                predictClass = stumpClassify(dataMatrix， i， thresholdValue， thresholdIneq)</span><br><span class="line">                errArray =  np.mat(np.ones((m， <span class="number">1</span>)))</span><br><span class="line">                errArray[predictClass == labelMat] = <span class="number">0</span></span><br><span class="line">                weightError = D.T * errArray</span><br><span class="line">                <span class="comment">#print &quot;split: dim %d， thresh: %.2f， threIneq:%s， weghtError %.3F&quot; %(i， thresholdValue， thresholdIneq， weightError)</span></span><br><span class="line">                <span class="keyword">if</span> weightError &lt; minError:</span><br><span class="line">                    minError = weightError</span><br><span class="line">                    bestClassEst = predictClass.copy()</span><br><span class="line">                    bestStump[<span class="string">&#x27;dimen&#x27;</span>] = i</span><br><span class="line">                    bestStump[<span class="string">&#x27;thresholdValue&#x27;</span>] = thresholdValue</span><br><span class="line">                    bestStump[<span class="string">&#x27;thresholdIneq&#x27;</span>] = thresholdIneq</span><br><span class="line">    <span class="keyword">return</span> bestClassEst， minError， bestStump</span><br></pre></td></tr></table></figure>

<h2 id="3-3-输出多个弱分类器的数组"><a href="#3-3-输出多个弱分类器的数组" class="headerlink" title="3.3. 输出多个弱分类器的数组"></a>3.3. 输出多个弱分类器的数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adaBoostTrainDS</span>(<span class="params">dataArray， classLabels， numIt=<span class="number">40</span></span>):</span></span><br><span class="line">    weakClass = []<span class="comment">#定义弱分类数组，保存每个基本分类器bestStump</span></span><br><span class="line">    m， n = np.shape(dataArray)</span><br><span class="line">    D = np.mat(np.ones((m， <span class="number">1</span>))/m)</span><br><span class="line">    aggClassEst = np.mat(np.zeros((m， <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numIt):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:&quot;</span>， i)</span><br><span class="line">        bestClassEst， minError， bestStump = buildStump(dataArray， classLabels， D)<span class="comment">#step1:找到最佳的单层决策树</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;D.T:&quot;</span>， D.T)</span><br><span class="line">        alpha = <span class="built_in">float</span>(<span class="number">0.5</span>*np.log((<span class="number">1</span>-minError)/<span class="built_in">max</span>(minError， <span class="number">1e-16</span>)))<span class="comment">#step2: 更新alpha</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;alpha:&quot;</span>， alpha)</span><br><span class="line">        bestStump[<span class="string">&#x27;alpha&#x27;</span>] = alpha</span><br><span class="line">        weakClass.append(bestStump)<span class="comment">#step3:将基本分类器添加到弱分类的数组中</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;classEst:&quot;</span>， bestClassEst)</span><br><span class="line">        expon = np.multiply(-<span class="number">1</span>*alpha*np.mat(classLabels).T， bestClassEst)</span><br><span class="line">        D = np.multiply(D， np.exp(expon))</span><br><span class="line">        D = D/D.<span class="built_in">sum</span>()<span class="comment">#step4:更新权重，该式是让D服从概率分布</span></span><br><span class="line">        aggClassEst += alpha*bestClassEst<span class="comment">#steo5:更新累计类别估计值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;aggClassEst:&quot;</span>， aggClassEst.T)</span><br><span class="line">        <span class="built_in">print</span>(np.sign(aggClassEst) != np.mat(classLabels).T)</span><br><span class="line">        aggError = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T， np.ones((m， <span class="number">1</span>)))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;aggError&quot;</span>， aggError)</span><br><span class="line">        aggErrorRate = aggError.<span class="built_in">sum</span>()/m</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;total error:&quot;</span>， aggErrorRate)</span><br><span class="line">        <span class="keyword">if</span> aggErrorRate == <span class="number">0.0</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> weakClass</span><br></pre></td></tr></table></figure>

<h2 id="3-4-输出分类结果"><a href="#3-4-输出分类结果" class="headerlink" title="3.4. 输出分类结果"></a>3.4. 输出分类结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adaTestClassify</span>(<span class="params">dataToClassify， weakClass</span>):</span></span><br><span class="line">    dataMatrix = np.mat(dataToClassify)        </span><br><span class="line">    m =np.shape(dataMatrix)[<span class="number">0</span>]</span><br><span class="line">    aggClassEst = np.mat(np.zeros((m， <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weakClass)):</span><br><span class="line">        <span class="comment"># 输出决策树桩标签</span></span><br><span class="line">        classEst = stumpClassify(dataToClassify， weakClass[i][<span class="string">&#x27;dimen&#x27;</span>]， weakClass[i][<span class="string">&#x27;thresholdValue&#x27;</span>]， weakClass[i][<span class="string">&#x27;thresholdIneq&#x27;</span>])</span><br><span class="line">        aggClassEst += weakClass[i][<span class="string">&#x27;alpha&#x27;</span>] * classEst</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>， i， <span class="string">&#x27;个弱分类器权值：&#x27;</span>， aggClassEst)</span><br><span class="line">    <span class="keyword">return</span> np.sign(aggClassEst)</span><br></pre></td></tr></table></figure>

<h2 id="3-5-主函数"><a href="#3-5-主函数" class="headerlink" title="3.5. 主函数"></a>3.5. 主函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__  ==  <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    D =np.mat(np.ones((<span class="number">5</span>， <span class="number">1</span>))/<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 加载一个两个特征的数据集</span></span><br><span class="line">    dataMatrix， classLabels = loadSimData()</span><br><span class="line">    <span class="comment"># 找到加权错误率（分类错误率）最小的单层决策树</span></span><br><span class="line">    bestClassEst， minError， bestStump = buildStump(dataMatrix， classLabels， D)</span><br><span class="line">    <span class="comment"># 输出：多个弱分类器的数组</span></span><br><span class="line">    weakClass = adaBoostTrainDS(dataMatrix， classLabels， <span class="number">9</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    testClass = adaTestClassify(np.mat([<span class="number">0</span>， <span class="number">0</span>])， weakClass)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最终分类标签：&#x27;</span>， testClass)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D.T: [[<span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span>]]</span><br><span class="line">alpha: <span class="number">0.6931471805599453</span></span><br><span class="line">classEst: [[-<span class="number">1.</span>]</span><br><span class="line">[ <span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]</span><br><span class="line">[ <span class="number">1.</span>]]</span><br><span class="line">aggClassEst: [[-<span class="number">0.69314718</span> <span class="number">0.69314718</span> -<span class="number">0.69314718</span> -<span class="number">0.69314718</span> <span class="number">0.69314718</span>]]</span><br><span class="line">[[ <span class="literal">True</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]]</span><br><span class="line">aggError [[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]]</span><br><span class="line">total error: <span class="number">0.2</span></span><br><span class="line">i: <span class="number">1</span></span><br><span class="line">D.T: [[<span class="number">0.5</span></span><br><span class="line"><span class="number">0.125</span> <span class="number">0.125</span> <span class="number">0.125</span> <span class="number">0.125</span>]]</span><br><span class="line">alpha: <span class="number">0.9729550745276565</span></span><br><span class="line">classEst: [[ <span class="number">1.</span>]</span><br><span class="line">[ <span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]]</span><br><span class="line">aggClassEst: [[ <span class="number">0.27980789</span> <span class="number">1.66610226</span> -<span class="number">1.66610226</span> -<span class="number">1.66610226</span> -<span class="number">0.27980789</span>]]</span><br><span class="line">[[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[ <span class="literal">True</span>]]</span><br><span class="line">aggError [[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">1.</span>]]</span><br><span class="line">total error: <span class="number">0.2</span></span><br><span class="line">i: <span class="number">2</span></span><br><span class="line">D.T: [[<span class="number">0.28571429</span> <span class="number">0.07142857</span> <span class="number">0.07142857</span> <span class="number">0.07142857</span> <span class="number">0.5</span>  ]]</span><br><span class="line">alpha: <span class="number">0.8958797346140273</span></span><br><span class="line">classEst: [[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">1.</span>]]</span><br><span class="line">aggClassEst: [[ <span class="number">1.17568763</span> <span class="number">2.56198199</span> -<span class="number">0.77022252</span> -<span class="number">0.77022252</span> <span class="number">0.61607184</span>]]</span><br><span class="line">[[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]]</span><br><span class="line">aggError [[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]]</span><br><span class="line">total error: <span class="number">0.0</span></span><br><span class="line">第 <span class="number">0</span> 个弱分类器权值: [[-<span class="number">0.69314718</span>]]</span><br><span class="line">第 <span class="number">1</span> 个弱分类器权值: [[-<span class="number">1.66610226</span>]]</span><br><span class="line">第 <span class="number">2</span> 个弱分类器权值: [[-<span class="number">2.56198199</span>]]</span><br><span class="line">最终分类标签: [[-<span class="number">1.</span>]]</span><br></pre></td></tr></table></figure>


<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>源代码</strong>：<a href="../../../../uploads/AdaBoost.py">AdaBoost.py</a></p>
</div>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Apriori算法——数据挖掘</title>
    <url>/2018/12/10/DataMining_Apriori/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DataMining_Apriori.png" class="full-image" />

<h1 id="1-Apriori算法简介"><a href="#1-Apriori算法简介" class="headerlink" title="1. Apriori算法简介"></a>1. Apriori算法简介</h1><ul>
<li>Apriori是一种在事务数据库上进行频繁项集挖掘和关联规则学习的算法。</li>
<li>它通过识别数据库中的频繁单项，并将经常出现的项扩展到越来越大的项目集。</li>
<li>Apriori确定的频繁项目集可用于确定关联规则，能够显示出数据库中项的一般趋势，故常应用于诸如市场购物栏分析的领域中（决策分析）。</li>
</ul>
<a id="more"></a>

<ul>
<li>Apriori算法由Agrawal和Srikant于1994年提出。Apriori旨在对包含交易的数据库(例如：客户购买的项目集合，或网站频繁或IP地址的详细信息)进行操作。</li>
<li>其他算法设计用于在没有事务(Winepi和Minepi)或没有时间戳(DNA序列)的数据中查找关联规则。</li>
<li>每个事务都被视为一组项(项集)。给出一个门槛 C，Apriori算法识别至少是子集的项集 C 数据库中的事务。Apriori使用“自下而上”方法，其中频繁的子集一次扩展一个项目(称为候选生成的步骤)，并且针对数据测试候选组。当没有找到进一步成功的扩展时，算法终止。</li>
</ul>
<h1 id="2-Python编程实现Apriori算法"><a href="#2-Python编程实现Apriori算法" class="headerlink" title="2. Python编程实现Apriori算法"></a>2. Python编程实现Apriori算法</h1><h2 id="2-1-Apriori算法步骤"><a href="#2-1-Apriori算法步骤" class="headerlink" title="2.1. Apriori算法步骤"></a>2.1. Apriori算法步骤</h2><ul>
<li>S1.令 k&#x3D;1</li>
<li>S2.扫描数据库，生成长度为k的候选项集的集合Ck</li>
<li>S3.重复S4~S8直到找不到新的候选项集的集合Ck</li>
<li>S4.从长度为k的频繁项集Lk生成长度为(k + 1)的候选项集</li>
<li>S5.修剪长度为(k + 1)的候选项集中的出现频率低于(min_support阈值)的候选项目</li>
<li>S6.通过扫描数据库，统计每个候选项的数目</li>
<li>S7.删除出现频率低于(min_support阈值)的候选项，只留下频繁出现的候选项目集Lk</li>
<li>S8. k &#x3D; k + 1</li>
</ul>
<h2 id="2-2-生成长度为1的候选项集C1"><a href="#2-2-生成长度为1的候选项集C1" class="headerlink" title="2.2. 生成长度为1的候选项集C1"></a>2.2. 生成长度为1的候选项集C1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># C1 是大小为1的所有候选项集的集合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createC1</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    C1 = []</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> transaction:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> [item] <span class="keyword">in</span> C1:</span><br><span class="line">                C1.append([item]) <span class="comment">#store all the item unrepeatly</span></span><br><span class="line">    <span class="comment"># C1.sort()</span></span><br><span class="line">    <span class="comment">#return map(frozenset， C1)#frozen set， user can&#x27;t change it.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">frozenset</span>， C1))</span><br></pre></td></tr></table></figure>

<h2 id="2-3-扫描数据库，返回频繁出现的候选项目集Lk-出现频率大于给定阈值minSupport"><a href="#2-3-扫描数据库，返回频繁出现的候选项目集Lk-出现频率大于给定阈值minSupport" class="headerlink" title="2.3. 扫描数据库，返回频繁出现的候选项目集Lk(出现频率大于给定阈值minSupport)"></a>2.3. 扫描数据库，返回频繁出现的候选项目集Lk(出现频率大于给定阈值minSupport)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanD</span>(<span class="params">D， Ck， minSupport</span>):</span></span><br><span class="line">    ssCnt=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tid <span class="keyword">in</span> D:</span><br><span class="line">        <span class="keyword">for</span> can <span class="keyword">in</span> Ck:</span><br><span class="line">            <span class="keyword">if</span> can.issubset(tid):</span><br><span class="line">                <span class="comment">#if not ssCnt.has_key(can):</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> can <span class="keyword">in</span> ssCnt:</span><br><span class="line">                    ssCnt[can]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: ssCnt[can]+=<span class="number">1</span></span><br><span class="line">    numItems=<span class="built_in">float</span>(<span class="built_in">len</span>(D))</span><br><span class="line">    retList = []</span><br><span class="line">    supportData = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> ssCnt:</span><br><span class="line">        support = ssCnt[key]/numItems <span class="comment">#compute support</span></span><br><span class="line">        <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">            retList.insert(<span class="number">0</span>， key)</span><br><span class="line">        supportData[key] = support</span><br><span class="line">    <span class="keyword">return</span> retList， supportData</span><br></pre></td></tr></table></figure>

<h2 id="2-4-apriori组合，向上合并L"><a href="#2-4-apriori组合，向上合并L" class="headerlink" title="2.4. apriori组合，向上合并L"></a>2.4. apriori组合，向上合并L</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aprioriGen</span>(<span class="params">Lk， k</span>):</span></span><br><span class="line">    <span class="comment">#creates Ck 参数：频繁项集列表 Lk 与项集元素个数 k</span></span><br><span class="line">    retList = []</span><br><span class="line">    lenLk = <span class="built_in">len</span>(Lk)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenLk):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>， lenLk): <span class="comment">#两两组合遍历</span></span><br><span class="line">            L1 = <span class="built_in">list</span>(Lk[i])[:k-<span class="number">2</span>]; L2 = <span class="built_in">list</span>(Lk[j])[:k-<span class="number">2</span>]</span><br><span class="line">            L1.sort(); L2.sort()</span><br><span class="line">            <span class="keyword">if</span> L1 == L2: <span class="comment">#若两个集合的前k-2个项相同时， 则将两个集合合并</span></span><br><span class="line">                retList.append(Lk[i] | Lk[j]) <span class="comment">#set union</span></span><br><span class="line">    <span class="keyword">return</span> retList</span><br></pre></td></tr></table></figure>

<h2 id="2-5-apriori算法核心函数"><a href="#2-5-apriori算法核心函数" class="headerlink" title="2.5. apriori算法核心函数"></a>2.5. apriori算法核心函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apriori</span>(<span class="params">dataSet， minSupport = <span class="number">0.5</span></span>):</span></span><br><span class="line">    C1 = createC1(dataSet)</span><br><span class="line">    D = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">set</span>， dataSet)) <span class="comment">#python3</span></span><br><span class="line">    L1， supportData = scanD(D， C1， minSupport)<span class="comment">#单项最小支持度判断 0.5，生成L1</span></span><br><span class="line">    L = [L1]</span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(L[k-<span class="number">2</span>]) &gt; <span class="number">0</span>):<span class="comment">#创建包含更大项集的更大列表， 直到下一个大的项集为空</span></span><br><span class="line">        Ck = aprioriGen(L[k-<span class="number">2</span>]， k)<span class="comment">#Ck</span></span><br><span class="line">        Lk， supK = scanD(D， Ck， minSupport)<span class="comment">#get Lk</span></span><br><span class="line">        supportData.update(supK)</span><br><span class="line">        L.append(Lk)</span><br><span class="line">        k += <span class="number">1</span> <span class="comment">#继续向上合并 生成项集个数更多的</span></span><br><span class="line">    <span class="keyword">return</span> L， supportData</span><br></pre></td></tr></table></figure>

<h2 id="2-6-主函数"><a href="#2-6-主函数" class="headerlink" title="2.6. 主函数"></a>2.6. 主函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#加载数据集</span></span><br><span class="line">    dataSet = loadDataSet()</span><br><span class="line">    <span class="comment">#挖掘频繁项集</span></span><br><span class="line">    L， supportData = apriori(dataSet， <span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;L = &#x27;</span>， L)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;supportData = &#x27;</span>， supportData)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [[<span class="built_in">frozenset</span>(&#123;<span class="number">5</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">3</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>&#125;)]， [<span class="built_in">frozenset</span>(&#123;<span class="number">2</span>，</span><br><span class="line"><span class="number">5</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>， <span class="number">3</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>， <span class="number">3</span>&#125;)]， []]</span><br><span class="line">supportData = &#123;<span class="built_in">frozenset</span>(&#123;<span class="number">1</span>&#125;): <span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">3</span>&#125;): <span class="number">0.75</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">4</span>&#125;): <span class="number">0.25</span>，</span><br><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">2</span>&#125;): <span class="number">0.75</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">5</span>&#125;): <span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>， <span class="number">3</span>&#125;): <span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>， <span class="number">3</span>&#125;):</span><br><span class="line"><span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>， <span class="number">5</span>&#125;): <span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">3</span>， <span class="number">5</span>&#125;): <span class="number">0.25</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>， <span class="number">5</span>&#125;): <span class="number">0.25</span>，</span><br><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">1</span>， <span class="number">2</span>&#125;): <span class="number">0.25</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>， <span class="number">3</span>， <span class="number">5</span>&#125;): <span class="number">0.25</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>对于数据集[[1， 3， 4]， [2， 3]， [1， 2， 3， 5]， [2， 5]]，运行apriori挖掘(出现频率大于阈值0.5)的频繁项集合为:[5]， [2]，<br>[3]， [1]， [2，5]， [2，3]， [1，3]，其中[2，5]， [2，3]， [1，3]在数据库中出现的频率均为0.5</p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>源代码</strong>：<a href="../../../../uploads/Apriori.py">Apriori.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>DBSCAN算法——数据挖掘</title>
    <url>/2018/11/10/DataMining_DBSCAN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DataMining_DBSCAN.png" class="full-image" />

<h1 id="1-DBSCAN算法简介"><a href="#1-DBSCAN算法简介" class="headerlink" title="1. DBSCAN算法简介"></a>1. DBSCAN算法简介</h1><ul>
<li>基于密度的噪声应用空间聚类（DBSCAN）是Martin Ester，Hans-Peter Kriegel，JörgSander和Xiaowei Xu于1996年提出的数据聚类算法。</li>
<li>它是一种基于密度的聚类算法：给定一些空间中的一组点，它将紧密堆积在一起的点（具有许多邻近邻居的点）组合在一起，标记为单独位于低密度区域的离群点（最近的点）邻居们太远了）。</li>
<li>DBSCAN是最常见的聚类算法之一，也是科学文献中引用最多的算法。</li>
<li>2014年，该算法在领先的数据挖掘会议KDD上获得了时间奖的测试（在理论和实践中获得了大量关注的算法奖）。<a id="more"></a></li>
</ul>
<h1 id="2-Python编程实现DBSCAN算法"><a href="#2-Python编程实现DBSCAN算法" class="headerlink" title="2. Python编程实现DBSCAN算法"></a>2. Python编程实现DBSCAN算法</h1><p><strong>DBSCAN算法主要分为以下步骤实现</strong>：</p>
<ul>
<li>S1. 任意选择一个未访问过的点 P</li>
<li>S2. 标记点 P为已访问</li>
<li>S3. 计算得到所有从p 关于 Eps 和 MinPts 密度可达的点的集合 NeighborPts</li>
<li>S4. 若 P 不是核心对象，标记点 P 为噪声，跳转步骤S1重新选取 P；若 P 为核心对象，则扩展当前核心对象 P 的所属簇（expandCluster函数）</li>
<li>S5. 判断是否所有点均已被访问，若是则跳转S6; 若否则继续 S1 ~ S5步骤</li>
<li>S6. DBSCAN算法运行结束，返回二维分类数组Cluster</li>
</ul>
<h1 id="3-DBSCAN算法Python代码实现如下"><a href="#3-DBSCAN算法Python代码实现如下" class="headerlink" title="3. DBSCAN算法Python代码实现如下"></a>3. DBSCAN算法Python代码实现如下</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于密度的DBSCAN算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DBSCAN</span>(<span class="params">data, Eps, MinPts</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始DBSCAN...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建一个同规模数组，记录每个点的 分类、是否访问</span></span><br><span class="line">    classification = np.ones(<span class="built_in">len</span>(data)) * NoVisitedValue  <span class="comment"># 存储是否访问及分类信息: -3，未访问； -2，噪声点；</span></span><br><span class="line">    Cluster = [] <span class="comment">#记录分簇信息，第i行存储所有归类于第i簇的元素下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="comment"># 选择一个 未访问的 点 P</span></span><br><span class="line">        P = chooseOneNoVisitedP(data, classification)</span><br><span class="line">        <span class="keyword">if</span> (P == isAllVisitedValue): <span class="comment">#已经全部遍历，退出While循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment"># # 若点 P 已被访问，跳过（注释，包含点P）</span></span><br><span class="line">        <span class="comment"># if (isVisited(classification, P) == True):</span></span><br><span class="line">        <span class="comment">#     continue</span></span><br><span class="line">        <span class="comment">#  若点 P 未被访问， 标记 P 为已访问</span></span><br><span class="line">        classification[P] = VisitedValue</span><br><span class="line">        NeighborPts = regionQuery(data, P, Eps)</span><br><span class="line">        <span class="comment"># print(P,&#x27;\&#x27;s NeighborPts is: &#x27;, NeighborPts)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(NeighborPts) &lt; MinPts):  <span class="comment"># 若 P非核心对象</span></span><br><span class="line">            <span class="comment">#标记 P 为 NOISE</span></span><br><span class="line">            classification[P] = NoiseValue</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print(&#x27;扩展当前核心对象 P = &#x27;, P, &#x27;的所属簇&#x27;)</span></span><br><span class="line">            classification, Cluster = expandCluster(data, classification, P, NeighborPts, Cluster, Eps, MinPts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Cluster</span><br></pre></td></tr></table></figure>

<h2 id="3-1-DBSCAN算法中的关键函数–expandCluster函数实现步骤"><a href="#3-1-DBSCAN算法中的关键函数–expandCluster函数实现步骤" class="headerlink" title="3.1. DBSCAN算法中的关键函数–expandCluster函数实现步骤"></a>3.1. DBSCAN算法中的关键函数–expandCluster函数实现步骤</h2><ul>
<li>S1. 将当前核心对象 P 添加到新的 P 的所属类Cluster_P中</li>
<li>S2. 从点 P 的邻域列表 NeighborPts 中取一个点 P’</li>
<li>S3. 判断点 P’ 是否已被访问。若已被访问，跳转步骤S7；若未被访问，继续执行下一步骤</li>
<li>S4. 标记点 P’ 为已被访问，并计算得到所有从P’ 关于 Eps 和 MinPts 密度可达的点的集合 NeighborPts_i</li>
<li>S5. 判断点 P’ 是否为核心对象，若是，将 P’ 的邻域内点 NeighborPts_i 非重复地添加到点 P 的扩展邻域列表NeighborPts中；若否，继续执行下一步骤</li>
<li>S6. 判断点 P’ 是否已经被分类，若否，添加点 P’ 到列表 Cluster_P 中；若是，继续执行下一步骤</li>
<li>S7. 判断是否 P 扩展邻域列表 NeighborPts 中的所有元素均已被访问，若否，则循环步骤 S2 ～ S7; 若是，继续执行下一步骤</li>
<li>S8. 将列表 Cluster_P 添加到总分类列表 Cluster 中</li>
</ul>
<h2 id="3-2-expandCluster函数Python代码实现如下："><a href="#3-2-expandCluster函数Python代码实现如下：" class="headerlink" title="3.2. expandCluster函数Python代码实现如下："></a>3.2. expandCluster函数Python代码实现如下：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 扩展当前核心对象 P 的所属簇</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expandCluster</span>(<span class="params">data, classification, P, NeighborPts, Cluster, Eps, MinPts</span>):</span></span><br><span class="line">    Cluster_P = []</span><br><span class="line">    Cluster_P += [P] <span class="comment">#将核心对象添加到 P 的临时所属簇</span></span><br><span class="line">    <span class="comment"># 遍历点 P 的所有 NeighborPts， 这个NeighborPts可能会增加</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="comment"># 若邻域内的 P&#x27; 正好是 P，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (NeighborPts[i] == P):</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 若所有 NeighborPts 均已遍历，退出while</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="built_in">len</span>(NeighborPts)):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 跳过</span></span><br><span class="line">        <span class="comment"># 若 P&#x27; 未访问</span></span><br><span class="line">        <span class="keyword">if</span> (isVisited(classification, NeighborPts[i]) == <span class="literal">False</span>):</span><br><span class="line">            classification[NeighborPts[i]] = VisitedValue <span class="comment"># 标记 P&#x27; 已访问</span></span><br><span class="line">            NeighborPts_i = regionQuery(data, NeighborPts[i], Eps) <span class="comment"># 求 P&#x27; Eps邻域内的点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">len</span>(NeighborPts_i) &gt;= MinPts): <span class="comment"># 若 P&#x27; 也为 核心对象</span></span><br><span class="line">                NeighborPts = addNeighborPts(NeighborPts, NeighborPts_i) <span class="comment">#增加P&#x27; Eps邻域内的点到 点 P 的邻域元素 NeighborPts中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若 P&#x27; 不属于任何一个已有类(将当前邻域内元素添加到核心对象 P 的所属簇)</span></span><br><span class="line">            <span class="keyword">if</span> (isNoBelongsToAnyCluster(Cluster, Cluster_P, NeighborPts[i]) == <span class="literal">True</span>):</span><br><span class="line">                Cluster_P += [NeighborPts[i]]</span><br><span class="line"></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若所有 NeighborPts 均已遍历，退出while</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="built_in">len</span>(NeighborPts)):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    Cluster += [Cluster_P]</span><br><span class="line">    <span class="keyword">return</span> classification, Cluster</span><br></pre></td></tr></table></figure>

<h1 id="4-DBSCAN算法执行、参数调整并分析"><a href="#4-DBSCAN算法执行、参数调整并分析" class="headerlink" title="4. DBSCAN算法执行、参数调整并分析"></a>4. DBSCAN算法执行、参数调整并分析</h1><h2 id="4-1-显示聚类前后对比图函数"><a href="#4-1-显示聚类前后对比图函数" class="headerlink" title="4.1. 显示聚类前后对比图函数"></a>4.1. 显示聚类前后对比图函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示聚类前后对比图（最多表示8种颜色的集群）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showClusterImage</span>(<span class="params">data, Cluster, Eps, MinPts</span>):</span></span><br><span class="line">    num_Cluster = <span class="built_in">len</span>(Cluster) <span class="comment"># 分类个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制第 i 个类的 颜色列表</span></span><br><span class="line">    <span class="comment"># b--blue, c--cyan, g--green, k--black</span></span><br><span class="line">    <span class="comment"># m--magenta, r--red, w--white, y--yellow</span></span><br><span class="line">    color = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">    <span class="comment"># 绘制第 i 个类的 形状列表</span></span><br><span class="line">    mark = [<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> num_Cluster &gt; <span class="built_in">len</span>(color):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sorry! Your len(Cluster)=&#x27;</span>, <span class="built_in">len</span>(Cluster), <span class="string">&#x27; is too large!( &gt; len(color)=&#x27;</span>, <span class="built_in">len</span>(color), <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制图片</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&#x27;Eps=&#x27;</span>+<span class="built_in">str</span>(Eps)+<span class="string">&#x27;, MinPts=&#x27;</span>+<span class="built_in">str</span>(MinPts)+<span class="string">&#x27;  Result Cluster=&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(Cluster)), fontsize=<span class="number">12</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    fig.gca().xaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">    fig.gca().yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图1: 绘制原图</span></span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    len_data = <span class="built_in">len</span>(data)</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_data):</span><br><span class="line">        x += [data[i][<span class="number">0</span>]]</span><br><span class="line">        y += [data[i][<span class="number">1</span>]]</span><br><span class="line">    ax1.scatter(x, y, s=<span class="number">4</span>, c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置标题并加上轴标签</span></span><br><span class="line">    ax1.set_title(<span class="string">&#x27;Original Graph&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置坐标的取值范围</span></span><br><span class="line">    ax1.axis(getMinMaxXandY(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图2: 绘制DBSCAN</span></span><br><span class="line">    ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 分别绘制不同 类别点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Cluster)):</span><br><span class="line">        <span class="comment"># 提取第 i 个类别的(x, y)坐标</span></span><br><span class="line">        x = []</span><br><span class="line">        y = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Cluster[i])):</span><br><span class="line">            x += [data[Cluster[i][j]][<span class="number">0</span>]]</span><br><span class="line">            y += [data[Cluster[i][j]][<span class="number">1</span>]]</span><br><span class="line">        <span class="comment"># 对第 i 个类别内所有点 以不同颜色绘制</span></span><br><span class="line">        ax2.scatter(x, y, s=<span class="number">4</span>, c=color[i], marker=mark[i])</span><br><span class="line">    ax2.set_title(<span class="string">&#x27;DBSCAN Graph&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置坐标的取值范围</span></span><br><span class="line">    ax2.axis(getMinMaxXandY(data))</span><br><span class="line"></span><br><span class="line">    plt.show() <span class="comment"># 显示绘制图像</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2-主函数"><a href="#4-2-主函数" class="headerlink" title="4.2. 主函数"></a>4.2. 主函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 加载long.mat数据</span></span><br><span class="line">    data = loadDataFile(<span class="string">&#x27;long.mat&#x27;</span>)</span><br><span class="line">    data = data[<span class="string">&#x27;long1&#x27;</span>] <span class="comment">#Eps=0.15， MinPts=8，最终分类数：2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># DBSCAN两个重要参数</span></span><br><span class="line">    Eps = <span class="number">0.15</span> <span class="comment">#邻域半径</span></span><br><span class="line">    MinPts = <span class="number">8</span> <span class="comment">#邻域内元素个数（包括点P）</span></span><br><span class="line">    Cluster = DBSCAN(data, Eps, MinPts) <span class="comment"># 执行 DBSCAN 算法，返回聚类后的下标二维数组</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All Done&#x27;</span>)</span><br><span class="line">    PrintCluster(Cluster) <span class="comment"># 打印簇信息</span></span><br><span class="line">    showClusterImage(data, Cluster, Eps, MinPts) <span class="comment"># 绘制基于密度的DBSCAN算法后的效果图</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-long-mat文件的DBSCAN算法聚类效果"><a href="#4-3-long-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.3. long.mat文件的DBSCAN算法聚类效果"></a>4.3. long.mat文件的DBSCAN算法聚类效果</h2><p>尝试设置Eps#邻域半径、MinPts#邻域内元素个数（包括点P）两个参数，由于Eps及MinPts两个参数没设置好导致被分成许多类，不方便绘图显示每个类。调试参数时也确认了两个参数设置的重要性，参数对分类结果的影响如下：</p>
<h3 id="Eps-x3D-0-08-MinPts-x3D-7"><a href="#Eps-x3D-0-08-MinPts-x3D-7" class="headerlink" title="Eps&#x3D;0.08, MinPts&#x3D;7"></a>Eps&#x3D;0.08, MinPts&#x3D;7</h3><p>当设置Eps&#x3D;0.08, MinPts&#x3D;7时已经能够成功绘制图形，但数据被分成6个类，效果不是很理想，如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_longEps=0.08MinPts=7ResultCluster=6.png" alt="Eps=0.08,MinPts=7的效果图"><br><strong>分析：</strong>虽然能从图中明确看出被分成6个类，但视觉分析应该分成2个类更合适，间接说明分类数过多，表明在扩展其中两个大类时与另外两个类“断开了”，下面分别尝试增加领域半径Eps值、减小MinPts#邻域内元素个数，尝试让小类与大类“连接”起来。</p>
<h3 id="Eps-x3D-0-1-MinPts-x3D-7"><a href="#Eps-x3D-0-1-MinPts-x3D-7" class="headerlink" title="Eps&#x3D;0.1, MinPts&#x3D;7"></a>Eps&#x3D;0.1, MinPts&#x3D;7</h3><p>当只增加领域半径Eps值，MinPts不变，设置Eps&#x3D;0.1, MinPts&#x3D;7，分类结果如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_longEps=0.1MinPts=7ResultCluster=3.png" alt="Eps=0.1,MinPts=7的效果图"><br><strong>分析：</strong>增加领域半径Eps值已有明显效果，此时分类数为3，继续尝试增大领域半径Eps值</p>
<h3 id="Eps-x3D-0-18-MinPts-x3D-7"><a href="#Eps-x3D-0-18-MinPts-x3D-7" class="headerlink" title="Eps&#x3D;0.18, MinPts&#x3D;7"></a>Eps&#x3D;0.18, MinPts&#x3D;7</h3><p>继续增大Eps值直到Eps&#x3D;0.18, MinPts&#x3D;7时才能被分为两类，分类结果如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_longEps=0.18MinPts=7ResultCluster=2.png" alt="Eps=0.18,MinPts=7的效果图"><br><strong>分析：</strong>虽然此时按密度被成功聚类为2类，但相比之下每个类变得更“松散”，包括了许多不需要的边界非核心对象</p>
<h3 id="Eps-x3D-0-08，MinPts-x3D-5"><a href="#Eps-x3D-0-08，MinPts-x3D-5" class="headerlink" title="Eps&#x3D;0.08，MinPts&#x3D;5"></a>Eps&#x3D;0.08，MinPts&#x3D;5</h3><p>当只减小MinPts，领域半径Eps值不变，设置Eps&#x3D;0.08, MinPts&#x3D;5时，数据分类数为5，如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_longEps=0.08MinPts=5ResultCluster=5.png" alt="Eps=0.08,MinPts=5的效果图"><br><strong>分析：</strong>一味只减少MinPts并没有得到很好的聚类结果，尝试减少MinPts并不能实现只分为两类的效果</p>
<h3 id="Eps-x3D-0-15，MinPts-x3D-8"><a href="#Eps-x3D-0-15，MinPts-x3D-8" class="headerlink" title="Eps&#x3D;0.15，MinPts&#x3D;8"></a>Eps&#x3D;0.15，MinPts&#x3D;8</h3><p>综合调节Eps邻域半径大小与MinPts邻域内元素个数，设置Eps&#x3D;0.15, MinPts&#x3D;8时分类数为2，分类结果如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_longEps=0.15MinPts=8ResultCluster=2.png" alt="Eps=0.15,MinPts=8的效果图"><br><strong>分析：</strong>联合调整参数Eps和MinPts比只更改单一变量更难调节，在能够分类成2个类的结果下，Eps邻域半径越小、MinPts邻域内元素个数越小，得到的聚类内部对象间隔越“紧密”</p>
<h2 id="4-4-其他文件数据的DBSCAN聚类结果"><a href="#4-4-其他文件数据的DBSCAN聚类结果" class="headerlink" title="4.4. 其他文件数据的DBSCAN聚类结果"></a>4.4. 其他文件数据的DBSCAN聚类结果</h2><p>由于调整Eps#邻域半径、MinPts#邻域内元素个数参数方法与上面一致，为直观显示效果，只给出聚类较理想的结果图及其对应Eps、MinPts参数</p>
<h3 id="4-4-1-moon-mat文件的DBSCAN算法聚类效果"><a href="#4-4-1-moon-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.4.1. moon.mat文件的DBSCAN算法聚类效果"></a>4.4.1. moon.mat文件的DBSCAN算法聚类效果</h3><p>当设置Eps&#x3D;0.11, MinPts&#x3D;5时，数据被分成2个类，效果较理想，如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_moonEps=0.11MinPts=5ResultCluster=2.png" alt="Eps=0.11,MinPts=5的效果图"></p>
<h3 id="4-4-2-sizes5-mat文件的DBSCAN算法聚类效果"><a href="#4-4-2-sizes5-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.4.2. sizes5.mat文件的DBSCAN算法聚类效果"></a>4.4.2. sizes5.mat文件的DBSCAN算法聚类效果</h3><p>当设置Eps&#x3D;1.32, MinPts&#x3D;10时，数据分类数Cluster&#x3D;4，效果较理想，如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_sizes5Eps=1.32MinPts=10ResultCluster=4.png" alt="Eps=1.32,MinPts=10的效果图"></p>
<h3 id="4-4-3-smile-mat文件的DBSCAN算法聚类效果"><a href="#4-4-3-smile-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.4.3. smile.mat文件的DBSCAN算法聚类效果"></a>4.4.3. smile.mat文件的DBSCAN算法聚类效果</h3><p>当设置Eps&#x3D;0.08, MinPts&#x3D;10时，数据分类数Cluster&#x3D;3，效果较理想，如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_smileEps=0.08MinPts=10ResultCluster=3.png" alt="Eps=0.08,MinPts=10的效果图"></p>
<h3 id="4-4-4-spiral-mat文件的DBSCAN算法聚类效果"><a href="#4-4-4-spiral-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.4.4. spiral.mat文件的DBSCAN算法聚类效果"></a>4.4.4. spiral.mat文件的DBSCAN算法聚类效果</h3><p>当设置Eps&#x3D;1, MinPts&#x3D;8时，数据分类数Cluster&#x3D;2，效果较理想，如下图所示<br><img data-src="/../../../../uploads/DataMining_DBSCAN_spiralEps=1MinPts=8ResultCluster=2.png" alt="Eps=1,MinPts=8的效果图"></p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待聚类数据集文件</strong>：<a href="../../../../uploads/long.mat">long.mat</a>、<a href="../../../../uploads/moon.mat">moon.mat</a>、<a href="../../../../uploads/sizes5.mat">sizes5.mat</a>、<a href="../../../../uploads/smile.mat">smile.mat</a>、<a href="../../../../uploads/spiral.mat">spiral.mat</a><br><strong>源代码</strong>：<a href="../../../../uploads/DensityBasedClustering.py">DensityBasedClustering.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理——数据挖掘</title>
    <url>/2018/10/21/DataMining_DataPreprocess/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DataMining_DataPreprocess.jpg" class="full-image" />

<h1 id="1-在Linux系统安装Python及数据处理所需的numpy、pandas库"><a href="#1-在Linux系统安装Python及数据处理所需的numpy、pandas库" class="headerlink" title="1. 在Linux系统安装Python及数据处理所需的numpy、pandas库"></a>1. 在Linux系统安装Python及数据处理所需的numpy、pandas库</h1><p>之前尝试手动下载numpy库，解压，然后按提示安装，却发现numpy库依赖上级库nose,又下载nose库，但在手动安装pandas库时出错…后发现可通过pip的简单方式安装，自动解决依赖，相比于需要手动下载安装上级依赖的手动安装方式更方便，安装代码如下</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy        //安装Numpy库:提供数组支持，以及相应的高效的处理函数</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple SciPy        //安装SciPy库：提供矩阵支持，以及矩阵相关的数值计算模块</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple matplotlib   //安装Matplotlib库：强大的数据可视化工具、作图库</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas       //安装Pandas库：强大、灵活的数据分析和探索工具</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple statsmodels  //安装StatsModels库：统计建模和计量经济学，包括描述统计、统计模型估计和推断</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple scikit-learn //安装Scikit-Learn库：支持回归、分类、聚类等强大的机器学习库</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple keras        //安装Keras库：深度学习库，用于建立神经网络以及深度学习模型</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple gensim       //安装Gensim库：用来做文本主题模型的库，可能用于文本挖掘</span><br></pre></td></tr></table></figure>

<h1 id="2-数据加载"><a href="#2-数据加载" class="headerlink" title="2. 数据加载"></a>2. 数据加载</h1><p>使用python的pandas库提供的数据处理支持，读取特定文件中庞大数据到到程序的运行内存中以便进行处理。如读取存放于“Train_UWu5bXk.csv”文件中的Bigmart销售数据到变量data中，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># Pandas库：强大、灵活的数据分析和探索工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据加载:\n&quot;</span>)</span><br><span class="line"><span class="comment"># 定义销售数据12个列名</span></span><br><span class="line">variables=[<span class="string">&#x27;Item_Identifier&#x27;</span>, <span class="string">&#x27;Item_Weight&#x27;</span>, <span class="string">&#x27;Item_Fat_Content&#x27;</span>, <span class="string">&#x27;Item_Visibility&#x27;</span>, <span class="string">&#x27;Item_Type&#x27;</span>, <span class="string">&#x27;Item_MRP&#x27;</span>, <span class="string">&#x27;Outlet_Identifier&#x27;</span>, <span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>, <span class="string">&#x27;Outlet_Size&#x27;</span>, <span class="string">&#x27;Outlet_Location_Type&#x27;</span>, <span class="string">&#x27;Outlet_Type&#x27;</span>, <span class="string">&#x27;Item_Outlet_Sales&#x27;</span>] <span class="comment"># Train_UWu5bXk.csv</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;Train_UWu5bXk.csv&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, header=<span class="literal">None</span>, skiprows=<span class="number">1</span>, names=variables) <span class="comment"># Train_UWu5bXk.csv</span></span><br></pre></td></tr></table></figure>

<h1 id="3-粗略查看数据规模分布等信息"><a href="#3-粗略查看数据规模分布等信息" class="headerlink" title="3. 粗略查看数据规模分布等信息"></a>3. 粗略查看数据规模分布等信息</h1><p>通过上一步数据加载已经成功加载了Bigmart销售数据，接下来先粗略了解Bigmart销售数据的矩阵规模信息，然后再根据信息对销售数据有粗略认识，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据粗略查看</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n查看各字段的信息&quot;</span>)</span><br><span class="line">data.info()     <span class="comment">#查看各字段的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最小值、最大值、四分位数和数值型变量的均值，以及因子向量和逻辑型向量的频数统计</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n数据粗略查看:&#x27;</span>)</span><br><span class="line">list_view = data.describe()    <span class="comment">#使用describe函数输出计算结果</span></span><br><span class="line">list_view.loc[<span class="string">&#x27;jicha&#x27;</span>] = list_view.loc[<span class="string">&#x27;max&#x27;</span>] - list_view.loc[<span class="string">&#x27;min&#x27;</span>]    <span class="comment">#求极差</span></span><br><span class="line">list_view.loc[<span class="string">&#x27;bianyixishu&#x27;</span>] = list_view.loc[<span class="string">&#x27;std&#x27;</span>]/list_view.loc[<span class="string">&#x27;mean&#x27;</span>]    <span class="comment">#变异系数</span></span><br><span class="line">list_view.loc[<span class="string">&#x27;sifenweijianju&#x27;</span>] = list_view.loc[<span class="string">&#x27;75%&#x27;</span>] - list_view.loc[<span class="string">&#x27;25%&#x27;</span>]    <span class="comment">#四分位间距</span></span><br><span class="line"><span class="built_in">print</span>(list_view)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询丢失信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n输出每个列丢失值也即值为NaN的数据和，并从多到少排序：&#x27;</span>)</span><br><span class="line">total = data.isnull().<span class="built_in">sum</span>().sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">percent =(data.isnull().<span class="built_in">sum</span>()/data.isnull().count()).sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">missing_data = pd.concat([total, percent], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;Total&#x27;</span>, <span class="string">&#x27;Percent&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(missing_data)</span><br></pre></td></tr></table></figure>
<p>显示“Train_UWu5bXk.csv”文件中的Bigmart销售数据粗略信息如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查看各字段的信息</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">8523</span> entries, <span class="number">0</span> to <span class="number">8522</span></span><br><span class="line">Data columns (total <span class="number">12</span> columns):</span><br><span class="line">Item_Identifier              <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Item_Weight                  <span class="number">7060</span> non-null float64</span><br><span class="line">Item_Fat_Content             <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Item_Visibility              <span class="number">8523</span> non-null float64</span><br><span class="line">Item_Type                    <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Item_MRP                     <span class="number">8523</span> non-null float64</span><br><span class="line">Outlet_Identifier            <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Outlet_Establishment_Year    <span class="number">8523</span> non-null int64</span><br><span class="line">Outlet_Size                  <span class="number">6113</span> non-null <span class="built_in">object</span></span><br><span class="line">Outlet_Location_Type         <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Outlet_Type                  <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Item_Outlet_Sales            <span class="number">8523</span> non-null float64</span><br><span class="line">dtypes: float64(<span class="number">4</span>), int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">7</span>)</span><br><span class="line">memory usage: <span class="number">799.1</span>+ KB</span><br><span class="line"></span><br><span class="line">数据粗略查看:</span><br><span class="line">                Item_Weight  Item_Visibility     Item_MRP  Outlet_Establishment_Year  Item_Outlet_Sales</span><br><span class="line">count           <span class="number">7060.000000</span>      <span class="number">8523.000000</span>  <span class="number">8523.000000</span>                <span class="number">8523.000000</span>        <span class="number">8523.000000</span></span><br><span class="line">mean              <span class="number">12.857645</span>         <span class="number">0.066132</span>   <span class="number">140.992782</span>                <span class="number">1997.831867</span>        <span class="number">2181.288914</span></span><br><span class="line">std                <span class="number">4.643456</span>         <span class="number">0.051598</span>    <span class="number">62.275067</span>                   <span class="number">8.371760</span>        <span class="number">1706.499616</span></span><br><span class="line"><span class="built_in">min</span>                <span class="number">4.555000</span>         <span class="number">0.000000</span>    <span class="number">31.290000</span>                <span class="number">1985.000000</span>          <span class="number">33.290000</span></span><br><span class="line"><span class="number">25</span>%                <span class="number">8.773750</span>         <span class="number">0.026989</span>    <span class="number">93.826500</span>                <span class="number">1987.000000</span>         <span class="number">834.247400</span></span><br><span class="line"><span class="number">50</span>%               <span class="number">12.600000</span>         <span class="number">0.053931</span>   <span class="number">143.012800</span>                <span class="number">1999.000000</span>        <span class="number">1794.331000</span></span><br><span class="line"><span class="number">75</span>%               <span class="number">16.850000</span>         <span class="number">0.094585</span>   <span class="number">185.643700</span>                <span class="number">2004.000000</span>        <span class="number">3101.296400</span></span><br><span class="line"><span class="built_in">max</span>               <span class="number">21.350000</span>         <span class="number">0.328391</span>   <span class="number">266.888400</span>                <span class="number">2009.000000</span>       <span class="number">13086.964800</span></span><br><span class="line">jicha             <span class="number">16.795000</span>         <span class="number">0.328391</span>   <span class="number">235.598400</span>                  <span class="number">24.000000</span>       <span class="number">13053.674800</span></span><br><span class="line">bianyixishu        <span class="number">0.361144</span>         <span class="number">0.780224</span>     <span class="number">0.441690</span>                   <span class="number">0.004190</span>           <span class="number">0.782335</span></span><br><span class="line">sifenweijianju     <span class="number">8.076250</span>         <span class="number">0.067596</span>    <span class="number">91.817200</span>                  <span class="number">17.000000</span>        <span class="number">2267.049000</span></span><br><span class="line"></span><br><span class="line">输出每个列丢失值也即值为NaN的数据和，并从多到少排序：</span><br><span class="line">                           Total   Percent</span><br><span class="line">Outlet_Size                 <span class="number">2410</span>  <span class="number">0.282764</span></span><br><span class="line">Item_Weight                 <span class="number">1463</span>  <span class="number">0.171653</span></span><br><span class="line">Item_Outlet_Sales              <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Outlet_Type                    <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Outlet_Location_Type           <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Outlet_Establishment_Year      <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Outlet_Identifier              <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_MRP                       <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_Type                      <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_Visibility                <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_Fat_Content               <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_Identifier                <span class="number">0</span>  <span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
<p>从以上信息我们可初步了解到”Train_UWu5bXk.csv”文件中的数据的规模为：8523x12。且可看出在12列属性中有些列的数据有缺失如：’产品重量Item_Weight’列（7060，缺失1463, 占17.2%）和’商店覆盖面积Outlet_Size’列（6113，缺失2410, 占28.3%）。对于数据的分布情况，从中可看出：</p>
<ul>
<li>产品重量’Item_Weight’变量：值集为4.555～21.35，均值为：12.857645，方差为4.643456，变异系数为0.361144，四分位间距为8.076250，说明分布较为均匀但数据较分散，存在缺失项（占17.2%）。</li>
<li>分配给特定产品的商店中所有产品的总显示区域的百分比’Item_Visibility’变量：值集为0～0.328391,均值为0.066132，方差为0.051598，变异系数为0.780224，四分位间距为0.067596，说明数据较为集中在平均值附近，数据较为紧凑，无缺项。</li>
<li>产品的最大零售价’Item_MRP’变量：值集为31.29～266.8884，均值为140.992782，方差为62.275067，变异系数为0.441690，四分位间距为91.817200，数据较分散，无缺项。</li>
<li>商店开店年份’Outlet_Establishment_Year’变量：值集为1985～2009，均值为1997.831867，方差为8.371760，变异系数为0.004190，四分位间距为17，数据较紧凑，且无缺项。</li>
<li>在特定商店销售产品’Item_Outlet_Sales’(这是要预测的结果变量)</li>
</ul>
<h1 id="4-数据清洗"><a href="#4-数据清洗" class="headerlink" title="4. 数据清洗"></a>4. 数据清洗</h1><h2 id="4-1-缺失值处理"><a href="#4-1-缺失值处理" class="headerlink" title="4.1. 缺失值处理"></a>4.1. 缺失值处理</h2><p><strong>判断缺失值的分布情况：</strong><br>从上一步粗略查看已知’产品重量Item_Weight’、’商店覆盖面积utlet_Size’两列的数据有缺失。而缺失值处理常用的方法有以下几种：1.直接删除、2.使用一个全局常量填充、3.使用均值或中位数代替、4.插补法（包括：随机插补法、多重插补法、热平台插补、拉格朗日差值法和牛顿插值法）、5.建模法。</p>
<ul>
<li>由数据粗略查看知,’Item_Weight’分布较为均匀但数据较分散,存在缺失项,故决定缺失内容采用均值填补</li>
<li>对于商店覆盖面积’Outlet_Size’变量：为有限个字符串变量，故对缺失内容采用出现次数最多的值填补<br>代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用平均数填补 Item_Weight</span></span><br><span class="line">Item_Weight_mean = data[<span class="string">&#x27;Item_Weight&#x27;</span>].mean() <span class="comment">#计算&#x27;Item_Weight&#x27;平均值</span></span><br><span class="line">data[<span class="string">&#x27;Item_Weight&#x27;</span>] = data[<span class="string">&#x27;Item_Weight&#x27;</span>].fillna(Item_Weight_mean) <span class="comment">#用&#x27;Item_Weight&#x27;平均值填充缺失值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用出现次数最多的值填补 utlet_Size</span></span><br><span class="line">utlet_Size_mode = data[<span class="string">&#x27;utlet_Size&#x27;</span>].mode() <span class="comment">#获取&#x27;utlet_Size&#x27;众数</span></span><br><span class="line">data[<span class="string">&#x27;utlet_Size&#x27;</span>] = data[<span class="string">&#x27;utlet_Size&#x27;</span>].fillna(utlet_Size_mode[<span class="number">0</span>]) <span class="comment">#用&#x27;utlet_Size&#x27;出现最多的值填充缺失值</span></span><br></pre></td></tr></table></figure>
对于此Train_UWu5bXk.csv数据，执行上放代码后会用’Item_Weight’平均值12.857645184135976填充’Item_Weight’缺失值，用’utlet_Size’出现最多的值’Medium’填充缺失值。</li>
</ul>
<h1 id="5-异常值处理"><a href="#5-异常值处理" class="headerlink" title="5. 异常值处理"></a>5. 异常值处理</h1><p>调用matplotlib库将各个数据可视化（python中的pyplot），观察异常值</p>
<h2 id="5-1-产品重量’Item-Weight’"><a href="#5-1-产品重量’Item-Weight’" class="headerlink" title="5.1. 产品重量’Item_Weight’"></a>5.1. 产品重量’Item_Weight’</h2><p>打印’Item_Weight’数据分布散点图代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Plot Item_Weight</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_Weight&#x27;</span>])))</span><br><span class="line">y_Item_Weight = data[<span class="string">&#x27;Item_Weight&#x27;</span>]</span><br><span class="line">plt.scatter(x, y_Item_Weight, s=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#设置标题并加上轴标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Item_Weight&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置每个坐标的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_Weight&#x27;</span>]), <span class="built_in">min</span>(data[<span class="string">&#x27;Item_Weight&#x27;</span>]), <span class="built_in">max</span>(data[<span class="string">&#x27;Item_Weight&#x27;</span>])])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="/../../../../uploads/DataMining_DataPreprocess_Item_Weight.png" alt="&#39;Item_Weight&#39;数据分布散点图"></p>
<p>从图中可看出’Item_Weight’分布较为均匀（5.5～21之间），未发现异常值</p>
<h2 id="5-2-分配给特定产品的商店中所有产品的总显示区域的百分比’Item-Visibility’"><a href="#5-2-分配给特定产品的商店中所有产品的总显示区域的百分比’Item-Visibility’" class="headerlink" title="5.2. 分配给特定产品的商店中所有产品的总显示区域的百分比’Item_Visibility’"></a>5.2. 分配给特定产品的商店中所有产品的总显示区域的百分比’Item_Visibility’</h2><p>打印’Item_Visibility’数据分布散点图代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Plot Item_Visibility</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_Visibility&#x27;</span>])))</span><br><span class="line">y_Item_Visibility = data[<span class="string">&#x27;Item_Visibility&#x27;</span>]</span><br><span class="line">plt.scatter(x, y_Item_Visibility, s=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#设置标题并加上轴标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Item_Visibility&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置每个坐标的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_Visibility&#x27;</span>]), <span class="built_in">min</span>(data[<span class="string">&#x27;Item_Visibility&#x27;</span>]), <span class="built_in">max</span>(data[<span class="string">&#x27;Item_Visibility&#x27;</span>])])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="/../../../../uploads/DataMining_DataPreprocess_Item_Visibility.png" alt="&#39;Item_Visibility&#39;数据分布散点图"></p>
<p>从图中可看出’Item_Visibility’分布主要集中于0～0.2区间内，分布随着值增加逐渐稀疏，未发现异常值</p>
<h2 id="5-3-产品的最大零售价’Item-MRP’"><a href="#5-3-产品的最大零售价’Item-MRP’" class="headerlink" title="5.3. 产品的最大零售价’Item_MRP’"></a>5.3. 产品的最大零售价’Item_MRP’</h2><p>打印’Item_MRP’数据分布散点图代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Plot Item_MRP</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_MRP&#x27;</span>])))</span><br><span class="line">y_Item_MRP = data[<span class="string">&#x27;Item_MRP&#x27;</span>]</span><br><span class="line">plt.scatter(x, y_Item_MRP, s=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#设置标题并加上轴标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Item_MRP&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">    <span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置每个坐标的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_MRP&#x27;</span>]), <span class="built_in">min</span>(data[<span class="string">&#x27;Item_MRP&#x27;</span>]), <span class="built_in">max</span>(data[<span class="string">&#x27;Item_MRP&#x27;</span>])])</span><br><span class="line">plt.psd(y_Item_MRP, <span class="number">10</span>, <span class="number">10</span>) <span class="comment">#Draw Grid</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="/../../../../uploads/DataMining_DataPreprocess_Item_MRP.png" alt="&#39;Item_MRP&#39;数据分布散点图"></p>
<p>从图中可看出’Item_MRP’分布较为阶梯型分布，大致可分为4段(31<del>70, 70</del>135, 135~200, &gt;200)，未发现异常值</p>
<h3 id="5-3-1-商店成立年份’Outlet-Establishment-Year’"><a href="#5-3-1-商店成立年份’Outlet-Establishment-Year’" class="headerlink" title="5.3.1. 商店成立年份’Outlet_Establishment_Year’"></a>5.3.1. 商店成立年份’Outlet_Establishment_Year’</h3><p>打印’Outlet_Establishment_Year’数据分布散点图代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Plot Outlet_Establishment_Year</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>])))</span><br><span class="line">y_Outlet_Establishment_Year = data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>]</span><br><span class="line">plt.scatter(x, y_Outlet_Establishment_Year, s=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#设置标题并加上轴标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Outlet_Establishment_Year&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">    <span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置每个坐标的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>]), <span class="built_in">min</span>(data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>]), <span class="built_in">max</span>(data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>])])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="/../../../../uploads/DataMining_DataPreprocess_Outlet_Establishment_Year.png" alt="&#39;Outlet_Establishment_Year&#39;数据分布散点图"></p>
<p>从图中可看出’Outlet_Establishment_Year’值集仅有有限几个，值集为1985～2009，未发现异常值</p>
<h1 id="6-数据转换"><a href="#6-数据转换" class="headerlink" title="6. 数据转换"></a>6. 数据转换</h1><p>将数据中字符串数据映射为数字</p>
<h2 id="6-1-产品是否低脂肪’Item-Fat-Content’"><a href="#6-1-产品是否低脂肪’Item-Fat-Content’" class="headerlink" title="6.1. 产品是否低脂肪’Item_Fat_Content’"></a>6.1. 产品是否低脂肪’Item_Fat_Content’</h2><p>打印’Item_Fat_Content’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Item_Fat_Content’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Low Fat    5089</span><br><span class="line">Regular    2889</span><br><span class="line">LF          316</span><br><span class="line">reg         117</span><br><span class="line">low fat     112</span><br></pre></td></tr></table></figure>
<p>以下代码将’Item_Fat_Content’的字符串值:’Low Fat’,’LF’,’low fat’映射成数字2; 将字符串值:’Regular’, ‘reg’映射成数字1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Item_Fat_Content</span></span><br><span class="line">Item_Fat_Content_mapping = &#123;<span class="string">&#x27;Regular&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;reg&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;Low Fat&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;LF&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;low fat&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>] = data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].<span class="built_in">map</span>(Item_Fat_Content_mapping)</span><br><span class="line">data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>] = data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-2-产品所属的类别-‘Item-Type’"><a href="#6-2-产品所属的类别-‘Item-Type’" class="headerlink" title="6.2. 产品所属的类别 ‘Item_Type’"></a>6.2. 产品所属的类别 ‘Item_Type’</h2><p>打印’Item_Type’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;Item_Type&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Item_Type’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fruits and Vegetables    1232</span><br><span class="line">Snack Foods              1200</span><br><span class="line">Household                 910</span><br><span class="line">Frozen Foods              856</span><br><span class="line">Dairy                     682</span><br><span class="line">Canned                    649</span><br><span class="line">Baking Goods              648</span><br><span class="line">Health and Hygiene        520</span><br><span class="line">Soft Drinks               445</span><br><span class="line">Meat                      425</span><br><span class="line">Breads                    251</span><br><span class="line">Hard Drinks               214</span><br><span class="line">Others                    169</span><br><span class="line">Starchy Foods             148</span><br><span class="line">Breakfast                 110</span><br><span class="line">Seafood                    64</span><br></pre></td></tr></table></figure>
<p>以下代码将’Item_Type’按照出现字符串次数，正序将字符串映射成数字1～16。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Item_Type</span></span><br><span class="line">Item_Type_mapping = &#123;<span class="string">&#x27;Seafood&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>),</span><br><span class="line">                     <span class="string">&#x27;Breakfast&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>),</span><br><span class="line">                     <span class="string">&#x27;Starchy Foods&#x27;</span>:<span class="built_in">int</span>(<span class="number">3</span>),</span><br><span class="line">                     <span class="string">&#x27;Others&#x27;</span>:<span class="built_in">int</span>(<span class="number">4</span>),</span><br><span class="line">                     <span class="string">&#x27;Hard Drinks&#x27;</span>:<span class="built_in">int</span>(<span class="number">5</span>),</span><br><span class="line">                     <span class="string">&#x27;Breads&#x27;</span>:<span class="built_in">int</span>(<span class="number">6</span>),</span><br><span class="line">                     <span class="string">&#x27;Meat&#x27;</span>:<span class="built_in">int</span>(<span class="number">7</span>),</span><br><span class="line">                     <span class="string">&#x27;Soft Drinks&#x27;</span>:<span class="built_in">int</span>(<span class="number">8</span>),</span><br><span class="line">                     <span class="string">&#x27;Health and Hygiene&#x27;</span>:<span class="built_in">int</span>(<span class="number">9</span>),</span><br><span class="line">                     <span class="string">&#x27;Baking Goods&#x27;</span>:<span class="built_in">int</span>(<span class="number">10</span>),</span><br><span class="line">                     <span class="string">&#x27;Canned&#x27;</span>:<span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">                     <span class="string">&#x27;Dairy&#x27;</span>:<span class="built_in">int</span>(<span class="number">12</span>),</span><br><span class="line">                     <span class="string">&#x27;Frozen Foods&#x27;</span>:<span class="built_in">int</span>(<span class="number">13</span>),</span><br><span class="line">                     <span class="string">&#x27;Household&#x27;</span>:<span class="built_in">int</span>(<span class="number">14</span>),</span><br><span class="line">                     <span class="string">&#x27;Snack Foods&#x27;</span>:<span class="built_in">int</span>(<span class="number">15</span>),</span><br><span class="line">                     <span class="string">&#x27;Fruits and Vegetables&#x27;</span>:<span class="built_in">int</span>(<span class="number">16</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Item_Type&#x27;</span>] = data[<span class="string">&#x27;Item_Type&#x27;</span>].<span class="built_in">map</span>(Item_Type_mapping)</span><br><span class="line">data[<span class="string">&#x27;Item_Type&#x27;</span>] = data[<span class="string">&#x27;Item_Type&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-3-唯一商店ID-‘Outlet-Identifier’"><a href="#6-3-唯一商店ID-‘Outlet-Identifier’" class="headerlink" title="6.3. 唯一商店ID ‘Outlet_Identifier’"></a>6.3. 唯一商店ID ‘Outlet_Identifier’</h2><p>打印’Outlet_Identifier’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;Outlet_Identifier&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Outlet_Identifier’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OUT027    935</span><br><span class="line">OUT013    932</span><br><span class="line">OUT035    930</span><br><span class="line">OUT046    930</span><br><span class="line">OUT049    930</span><br><span class="line">OUT045    929</span><br><span class="line">OUT018    928</span><br><span class="line">OUT017    926</span><br><span class="line">OUT010    555</span><br><span class="line">OUT019    528</span><br></pre></td></tr></table></figure>
<p>以下代码将’Outlet_Identifier’值的字符串中提取数字，并覆盖原先str变量为int。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义函数清理数据:去除&#x27;OUT&#x27;并将剩余str转换为数字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_currency</span>(<span class="params">var</span>):</span></span><br><span class="line">    new_value = var.replace(<span class="string">&#x27;OUT&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">#new_value = var[3:6]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(new_value)</span><br><span class="line"></span><br><span class="line">data[<span class="string">&#x27;Outlet_Identifier&#x27;</span>] = data[<span class="string">&#x27;Outlet_Identifier&#x27;</span>].apply(convert_currency)</span><br></pre></td></tr></table></figure>
<p>转换后数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27    935</span><br><span class="line">13    932</span><br><span class="line">46    930</span><br><span class="line">35    930</span><br><span class="line">49    930</span><br><span class="line">45    929</span><br><span class="line">18    928</span><br><span class="line">17    926</span><br><span class="line">10    555</span><br><span class="line">19    528</span><br><span class="line">Name: Outlet_Identifier, dtype: int64</span><br></pre></td></tr></table></figure>

<h2 id="6-4-商店的面积覆盖面积-‘Outlet-Size’"><a href="#6-4-商店的面积覆盖面积-‘Outlet-Size’" class="headerlink" title="6.4. 商店的面积覆盖面积 ‘Outlet_Size’"></a>6.4. 商店的面积覆盖面积 ‘Outlet_Size’</h2><p>打印’Outlet_Size’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;Outlet_Size&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Outlet_Size’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Medium    5203</span><br><span class="line">Small     2388</span><br><span class="line">High       932</span><br></pre></td></tr></table></figure>
<p>以下代码将’Outlet_Size’的字符串值:’Small’映射成数字1; ‘Medium’映射成数字2; 将字符串值:’High’映射成数字3。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Outlet_Size</span></span><br><span class="line">Outlet_Size_mapping = &#123;<span class="string">&#x27;Small&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;Medium&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;High&#x27;</span>:<span class="built_in">int</span>(<span class="number">3</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Outlet_Size&#x27;</span>] = data[<span class="string">&#x27;Outlet_Size&#x27;</span>].<span class="built_in">map</span>(Outlet_Size_mapping)</span><br><span class="line">data[<span class="string">&#x27;Outlet_Size&#x27;</span>] = data[<span class="string">&#x27;Outlet_Size&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-5-商店所在的城市类型-‘Outlet-Location-Type’"><a href="#6-5-商店所在的城市类型-‘Outlet-Location-Type’" class="headerlink" title="6.5. 商店所在的城市类型 ‘Outlet_Location_Type’"></a>6.5. 商店所在的城市类型 ‘Outlet_Location_Type’</h2><p>打印’Outlet_Location_Type’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Outlet_Location_Type’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tier 3    3350</span><br><span class="line">Tier 2    2785</span><br><span class="line">Tier 1    2388</span><br></pre></td></tr></table></figure>
<p>以下代码将’Outlet_Location_Type’的字符串值:’Tier 1’映射成数字1; ‘Tier 2’映射成数字2; 将字符串值:’Tier 3’映射成数字3。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Outlet_Location_Type</span></span><br><span class="line">Outlet_Location_Type_mapping = &#123;<span class="string">&#x27;Tier 1&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;Tier 2&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;Tier 3&#x27;</span>:<span class="built_in">int</span>(<span class="number">3</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>] = data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>].<span class="built_in">map</span>(Outlet_Location_Type_mapping)</span><br><span class="line">data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>] = data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-6-出口是一家杂货店还是某种超市-‘Outlet-Type’"><a href="#6-6-出口是一家杂货店还是某种超市-‘Outlet-Type’" class="headerlink" title="6.6. 出口是一家杂货店还是某种超市 ‘Outlet_Type’"></a>6.6. 出口是一家杂货店还是某种超市 ‘Outlet_Type’</h2><p>打印’Outlet_Type’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;Outlet_Type&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Outlet_Type’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Supermarket Type1    5577</span><br><span class="line">Grocery Store        1083</span><br><span class="line">Supermarket Type3     935</span><br><span class="line">Supermarket Type2     928</span><br></pre></td></tr></table></figure>
<p>以下代码将’Outlet_Type’的字符串值:’Supermarket Type1’映射成数字1; ‘Supermarket Type2’映射成数字2; ‘Supermarket Type3’映射成数字3; ‘Grocery Store’映射成数字4。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Outlet_Type</span></span><br><span class="line">Outlet_Type_mapping = &#123;<span class="string">&#x27;Supermarket Type1&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;Supermarket Type2&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;Supermarket Type3&#x27;</span>:<span class="built_in">int</span>(<span class="number">3</span>), <span class="string">&#x27;Grocery Store&#x27;</span>:<span class="built_in">int</span>(<span class="number">4</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Outlet_Type&#x27;</span>] = data[<span class="string">&#x27;Outlet_Type&#x27;</span>].<span class="built_in">map</span>(Outlet_Type_mapping)</span><br><span class="line">data[<span class="string">&#x27;Outlet_Type&#x27;</span>] = data[<span class="string">&#x27;Outlet_Type&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h1 id="7-数据归一化"><a href="#7-数据归一化" class="headerlink" title="7. 数据归一化"></a>7. 数据归一化</h1><h2 id="7-1-产品重量’Item-Weight’"><a href="#7-1-产品重量’Item-Weight’" class="headerlink" title="7.1. 产品重量’Item_Weight’"></a>7.1. 产品重量’Item_Weight’</h2><p>由前几步可看出’Item_Weight’分布较为均匀（5.5～21之间），故规范化时采用最小-最大规范化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Item_Weight_min = data[<span class="string">&#x27;Item_Weight&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Item_Weight_max = data[<span class="string">&#x27;Item_Weight&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Item_Weight&#x27;</span>] = (data[<span class="string">&#x27;Item_Weight&#x27;</span>] - Item_Weight_min) / (Item_Weight_max - Item_Weight_min)</span><br></pre></td></tr></table></figure>
<p>类似的适合数据归一化的还有:’Item_Visibility’, ‘Item_MRP’, ‘Outlet_Establishment_Year’, ‘Outlet_Size’,将这些变量也进行归一化处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 分配给特定产品的商店中所有产品的总显示区域的百分比&#x27;Item_Visibility&#x27;</span></span><br><span class="line">Item_Visibility_min = data[<span class="string">&#x27;Item_Visibility&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Item_Visibility_max = data[<span class="string">&#x27;Item_Visibility&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Item_Visibility&#x27;</span>] = (data[<span class="string">&#x27;Item_Visibility&#x27;</span>] - Item_Visibility_min) / (Item_Visibility_max - Item_Visibility_min)</span><br><span class="line"><span class="comment">## 产品的最大零售价 &#x27;Item_MRP&#x27;</span></span><br><span class="line">Item_MRP_min = data[<span class="string">&#x27;Item_MRP&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Item_MRP_max = data[<span class="string">&#x27;Item_MRP&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Item_MRP&#x27;</span>] = (data[<span class="string">&#x27;Item_MRP&#x27;</span>] - Item_MRP_min) / (Item_MRP_max - Item_MRP_min)</span><br><span class="line"><span class="comment">## 商店成立的年份 &#x27;Outlet_Establishment_Year&#x27;</span></span><br><span class="line">Outlet_Establishment_Year_min = data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Outlet_Establishment_Year_max = data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>] = (data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>] - Outlet_Establishment_Year_min) / (Outlet_Establishment_Year_max - Outlet_Establishment_Year_min)</span><br><span class="line"><span class="comment">## 商店的面积覆盖面积 &#x27;Outlet_Size&#x27;</span></span><br><span class="line">Outlet_Size_min = data[<span class="string">&#x27;Outlet_Size&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Outlet_Size_max = data[<span class="string">&#x27;Outlet_Size&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Outlet_Size&#x27;</span>] = (data[<span class="string">&#x27;Outlet_Size&#x27;</span>] - Outlet_Size_min) / (Outlet_Size_max - Outlet_Size_min)</span><br></pre></td></tr></table></figure>
<p>数据预处理后如下：</p>
<p><img data-src="/../../../../uploads/DataMining_DataPreprocess_Output_Train_afterProprecess.png" alt="“Train_UWu5bXk.csv”文件中的Bigmart销售数据预处理后"></p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待处理文件</strong>：<a href="../../../../uploads/Test_u94Q5KV.csv">Test_u94Q5KV.csv</a>、<a href="../../../../uploads/Train_UWu5bXk.csv">Train_UWu5bXk.csv</a><br><strong>源代码</strong>：<a href="../../../../uploads/datapreprocess.py">datapreprocess.py</a></p>
</div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>ID3算法——数据挖掘</title>
    <url>/2018/11/16/DataMining_ID3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DataMining_ID3.png" class="full-image" />

<h1 id="1-ID3算法简介"><a href="#1-ID3算法简介" class="headerlink" title="1. ID3算法简介"></a>1. ID3算法简介</h1><ul>
<li>ID3算法最早是由罗斯昆（J.Ross Quinlan）于1975年在悉尼大学提出的一种分类预测算法，算法的核心是“信息熵（Information entropy）”。</li>
<li>ID3算法通过计算每个属性的信息增益，认为信息增益高的是好属性，每次划分选取信息增益最高的属性为划分标准，重复这个过程，直至生成一个能完美分类训练样例的决策树。</li>
</ul>
<a id="more"></a>

<h1 id="2-Python编程实现ID3决策树建立算法"><a href="#2-Python编程实现ID3决策树建立算法" class="headerlink" title="2. Python编程实现ID3决策树建立算法"></a>2. Python编程实现ID3决策树建立算法</h1><p><strong>ID3决策树建立算法步骤</strong>：</p>
<ul>
<li>S1.决定分类属性；</li>
<li>S2.对目前的数据表，建立一个节点N</li>
<li>S3.如果数据库中的数据都属于同一个类，N就是树叶，在树叶上标出所属的类</li>
<li>S4.如果数据表中没有其他属性可以考虑，则N也是树叶，按照少数服从多数的原则在树叶上标出所属类别</li>
<li>S5.否则，根据平均信息期望值E或GAIN值选出一个最佳属性作为节点N的测试属性</li>
<li>S6.节点属性选定后，对于该属性中的每个值：从N生成一个分支，并将数据表中与该分支有关的数据收集形成分支节点的数据表，在表中删除节点属性那一栏如果分支数据表非空，则运用以上算法从该节点建立子树。</li>
</ul>
<h2 id="2-1-计算样本的信息期望"><a href="#2-1-计算样本的信息期望" class="headerlink" title="2.1. 计算样本的信息期望"></a>2.1. 计算样本的信息期望</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算样本的信息期望</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcH</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    numOfRow = <span class="built_in">len</span>(dataSet) <span class="comment">#得到行数，数据量个数</span></span><br><span class="line">    <span class="comment">#为所有的分类类目创建字典</span></span><br><span class="line">    <span class="comment"># labelCounts： 表示最后一列的字典统计信息(属性值种类及个数)</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> iRow <span class="keyword">in</span> dataSet:</span><br><span class="line">        currentLable = iRow[-<span class="number">1</span>] <span class="comment">#取得当前行最后一列数据（决策属性值）</span></span><br><span class="line">        <span class="keyword">if</span> currentLable <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): <span class="comment">#如果不在字典中，则添加到字典中</span></span><br><span class="line">            labelCounts[currentLable] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLable] += <span class="number">1</span> <span class="comment">#如果在字典中，则对应的key计数+1</span></span><br><span class="line">    <span class="comment">#计算给定样本所需的数学期望信息（香农熵）</span></span><br><span class="line">    H = <span class="number">0.0</span> <span class="comment">#测试样本的信息期望</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = <span class="built_in">float</span>(labelCounts[key]) / numOfRow <span class="comment">#即p(t)</span></span><br><span class="line">        H -= prob * math.log(prob, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> H <span class="comment">#返回样本的信息期望</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-根据第-i-列属性值A划分子集"><a href="#2-2-根据第-i-列属性值A划分子集" class="headerlink" title="2.2. 根据第 i 列属性值A划分子集"></a>2.2. 根据第 i 列属性值A划分子集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#得到根据第 i 列属性值A划分成的子集</span></span><br><span class="line"><span class="comment">#输入三个变量（待划分的数据集，特征，分类值）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span></span><br><span class="line">    retDataSet = [] <span class="comment">#表示由当第 i 列属性值A划分成的子集</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reduceFeatVec = featVec[:axis]</span><br><span class="line">            reduceFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reduceFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet <span class="comment">#表示由当第 i 列属性值A划分成的子集（不含划分特征A）</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-得到最大信息增益条件属性列下标"><a href="#2-3-得到最大信息增益条件属性列下标" class="headerlink" title="2.3. 得到最大信息增益条件属性列下标"></a>2.3. 得到最大信息增益条件属性列下标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    numOfFeature = <span class="built_in">len</span>(dataSet[<span class="number">0</span>])-<span class="number">1</span>  <span class="comment">#条件属性值个数</span></span><br><span class="line">    H = calcH(dataSet)<span class="comment">#返回样本的信息期望</span></span><br><span class="line">    bestInforGain = <span class="number">0</span> <span class="comment">#最大信息增益值，初始化为0</span></span><br><span class="line">    bestFeature = -<span class="number">1</span> <span class="comment">##最大信息增益值对应的条件属性列，，初始化为 -1</span></span><br><span class="line">    <span class="comment">#分别计算每一个条件属性的熵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numOfFeature):</span><br><span class="line">        <span class="comment"># featList 表示第 i 列的所有值</span></span><br><span class="line">        featList = [number[i] <span class="keyword">for</span> number <span class="keyword">in</span> dataSet] <span class="comment">#得到某个特征下所有值（某列）</span></span><br><span class="line">        <span class="comment"># uniqualVals 表示当前第 i 列的条件属性内的属性值的列表</span></span><br><span class="line">        uniqualVals = <span class="built_in">set</span>(featList) <span class="comment">#set无重复的属性特征值</span></span><br><span class="line">        <span class="comment"># E_A：表示由属性 A 划分子集的熵或平均期望</span></span><br><span class="line">        E_A = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqualVals:</span><br><span class="line">            <span class="comment"># subDataSet： 表示由当第 i 列属性值A划分成的子集</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            prob = <span class="built_in">float</span>(<span class="built_in">len</span>(subDataSet)) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet)) <span class="comment">#即p(t)</span></span><br><span class="line">            E_A += prob * calcH(subDataSet)<span class="comment">#对各子集香农熵求和</span></span><br><span class="line">        Gain_A = H - E_A <span class="comment">#计算条件属性 第 i 列 的信息增益</span></span><br><span class="line">        <span class="comment"># 从所有条件属性对应的信息增益中挑选最大信息增益（的列下标）</span></span><br><span class="line">        <span class="keyword">if</span> (Gain_A &gt; bestInforGain):</span><br><span class="line">            bestInforGain = Gain_A</span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature <span class="comment">#返回特征值（最佳分类列下标）</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-建立ID3决策树核心函数"><a href="#2-4-建立ID3决策树核心函数" class="headerlink" title="2.4. 建立ID3决策树核心函数"></a>2.4. 建立ID3决策树核心函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 决策树构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span>(<span class="params">dataSet, labels</span>):</span></span><br><span class="line">    classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment">#如果类别相同，停止划分</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[-<span class="number">1</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#长度为1，返回出现次数最多的类别</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(classList[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    <span class="comment">#按照信息增益最高选取分类特征属性</span></span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)<span class="comment">#返回分类的特征序号</span></span><br><span class="line">    bestFeatLable = labels[bestFeat] <span class="comment">#该特征的label</span></span><br><span class="line">    myTree = &#123;bestFeatLable:&#123;&#125;&#125; <span class="comment">#构建树的字典</span></span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat]) <span class="comment">#从labels的list中删除该label</span></span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = <span class="built_in">set</span>(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subLables = labels[:] <span class="comment">#子集合</span></span><br><span class="line">        <span class="comment">#构建数据的子集合，并进行递归</span></span><br><span class="line">        myTree[bestFeatLable][value] = createTree(splitDataSet(dataSet,bestFeat,value),subLables)</span><br><span class="line">    <span class="keyword">return</span> myTree <span class="comment"># 最后生成的决策树myTree是一个多层嵌套的字典</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-使用Matplotlib绘制决策树"><a href="#2-5-使用Matplotlib绘制决策树" class="headerlink" title="2.5. 使用Matplotlib绘制决策树"></a>2.5. 使用Matplotlib绘制决策树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==================使用Matplotlib绘制决策树============================</span></span><br><span class="line">decisionNode = <span class="built_in">dict</span>(boxstyle=<span class="string">&quot;square&quot;</span>, ec=<span class="string">&#x27;k&#x27;</span>, fc=<span class="string">&#x27;yellow&#x27;</span>,)<span class="comment">#决策点样式</span></span><br><span class="line">leafNode = <span class="built_in">dict</span>(boxstyle=<span class="string">&quot;round&quot;</span>, ec=(<span class="number">1.</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), fc=(<span class="number">1.</span>, <span class="number">0.8</span>, <span class="number">0.8</span>),)<span class="comment">#叶节点样式</span></span><br><span class="line">arrow_args = <span class="built_in">dict</span>(arrowstyle=<span class="string">&#x27;&lt;-&#x27;</span>) <span class="comment">#箭头样式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotNode</span>(<span class="params">nodeTxt, centerPt, parentPt, nodeType</span>):</span></span><br><span class="line">    createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=<span class="string">&#x27;axes fraction&#x27;</span>,</span><br><span class="line">                            xytext=centerPt, textcoords=<span class="string">&#x27;axes fraction&#x27;</span>,</span><br><span class="line">                            va=<span class="string">&#x27;center&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, bbox=nodeType, arrowprops=arrow_args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span>():</span></span><br><span class="line">    fig=plt.figure(<span class="number">1</span>,facecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.clf()</span><br><span class="line">    createPlot.ax1=plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">    plotNode(<span class="string">&#x27;决策节点&#x27;</span>, (<span class="number">0.5</span>,<span class="number">0.1</span>), (<span class="number">0.1</span>,<span class="number">0.5</span>), decisionNode)</span><br><span class="line">    plotNode(<span class="string">&#x27;叶节点&#x27;</span>, (<span class="number">0.8</span>,<span class="number">0.1</span>), (<span class="number">0.3</span>,<span class="number">0.8</span>), leafNode)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取叶节点数量（广度）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumLeafs</span>(<span class="params">myTree</span>):</span></span><br><span class="line">    numLeafs=<span class="number">0</span></span><br><span class="line">    firstStr=<span class="built_in">list</span>(myTree.keys())[<span class="number">0</span>]<span class="comment">#&#x27;dict_keys&#x27; object does not support indexing</span></span><br><span class="line">    secondDict=myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__==<span class="string">&#x27;dict&#x27;</span>:</span><br><span class="line">            numLeafs+=getNumLeafs(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>:numLeafs+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取树的深度的函数（深度）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTreeDepth</span>(<span class="params">myTree</span>):</span></span><br><span class="line">    maxDepth=<span class="number">0</span></span><br><span class="line">    firstStr=<span class="built_in">list</span>(myTree.keys())[<span class="number">0</span>]</span><br><span class="line">    secondDict=myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__==<span class="string">&#x27;dict&#x27;</span>:</span><br><span class="line">            thisDepth=<span class="number">1</span>+getTreeDepth(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>: thisDepth=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> thisDepth &gt; maxDepth:</span><br><span class="line">            maxDepth=thisDepth</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义在父子节点之间填充文本信息的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMidText</span>(<span class="params">cntrPt,parentPt,txtString</span>):</span></span><br><span class="line">    xMid=(parentPt[<span class="number">0</span>]-cntrPt[<span class="number">0</span>])/<span class="number">2</span>+cntrPt[<span class="number">0</span>]</span><br><span class="line">    yMid=(parentPt[<span class="number">1</span>]-cntrPt[<span class="number">1</span>])/<span class="number">2</span>+cntrPt[<span class="number">1</span>]</span><br><span class="line">    createPlot.ax1.text(xMid,yMid,txtString)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义树绘制的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTree</span>(<span class="params">myTree, parentPt, nodeTxt</span>):</span></span><br><span class="line">    numLeafs=getNumLeafs(myTree)</span><br><span class="line">    depth=getTreeDepth(myTree)</span><br><span class="line">    firstStr=<span class="built_in">list</span>(myTree.keys())[<span class="number">0</span>]</span><br><span class="line">    cntrPt=(plotTree.xOff+(<span class="number">1.0</span>+<span class="built_in">float</span>(numLeafs))/<span class="number">2</span>/plotTree.totalW,plotTree.yOff)</span><br><span class="line">    plotMidText(cntrPt, parentPt, nodeTxt)</span><br><span class="line">    plotNode(firstStr, cntrPt, parentPt, decisionNode)</span><br><span class="line">    secondDict=myTree[firstStr]</span><br><span class="line">    plotTree.yOff=plotTree.yOff -<span class="number">1</span>/plotTree.totalD</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__==<span class="string">&#x27;dict&#x27;</span>:</span><br><span class="line">            plotTree(secondDict[key], cntrPt, <span class="built_in">str</span>(key))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plotTree.xOff=plotTree.xOff+<span class="number">1.0</span>/plotTree.totalW</span><br><span class="line">            plotNode(secondDict[key],(plotTree.xOff,plotTree.yOff),cntrPt,leafNode)</span><br><span class="line">            plotMidText((plotTree.xOff,plotTree.yOff),cntrPt,<span class="built_in">str</span>(key))</span><br><span class="line">    plotTree.yOff=plotTree.yOff+<span class="number">1</span>/plotTree.totalD</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示决策树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span>(<span class="params">inTree</span>):</span></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.clf()</span><br><span class="line">    axprops = <span class="built_in">dict</span>(xticks=[], yticks=[])</span><br><span class="line">    createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>, **axprops)</span><br><span class="line">    plotTree.totalW = <span class="built_in">float</span>(getNumLeafs(inTree))</span><br><span class="line">    plotTree.totalD = <span class="built_in">float</span>(getTreeDepth(inTree))</span><br><span class="line">    plotTree.xOff = -<span class="number">0.5</span>/plotTree.totalW; plotTree.yOff = <span class="number">1.0</span>;</span><br><span class="line">    plotTree(inTree, (<span class="number">0.5</span>, <span class="number">1.0</span>), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="2-6-处理得到运动和不运动与天气之间的规则树"><a href="#2-6-处理得到运动和不运动与天气之间的规则树" class="headerlink" title="2.6. 处理得到运动和不运动与天气之间的规则树"></a>2.6. 处理得到运动和不运动与天气之间的规则树</h2><p>数据存放于<a href="../../../../uploads/ID3dataEn.csv">ID3dataEn.csv</a>文件</p>
<figure class="highlight plain"><figcaption><span>文件：ID3dataEn.csv</span></figcaption><table><tr><td class="code"><pre><span class="line">sunny,85,85,unwindy,unsuitable</span><br><span class="line">sunny,80,90,windy,unsuitable</span><br><span class="line">cloudy,83,78,unwindy,suitable</span><br><span class="line">rain,70,96,unwindy,suitable</span><br><span class="line">rain,68,80,unwindy,suitable</span><br><span class="line">rain,65,70,windy,unsuitable</span><br><span class="line">cloudy,64,65,windy,suitable</span><br><span class="line">sunny,72,95,unwindy,unsuitable</span><br><span class="line">sunny,69,70,unwindy,suitable</span><br><span class="line">rain,75,80,unwindy,suitable</span><br><span class="line">sunny,75,70,windy,suitable</span><br><span class="line">cloudy,72,90,windy,suitable</span><br><span class="line">cloudy,81,75,unwindy,suitable</span><br><span class="line">rain,71,80,windy,unsuitable</span><br></pre></td></tr></table></figure>

<h2 id="2-7-加载数据"><a href="#2-7-加载数据" class="headerlink" title="2.7. 加载数据"></a>2.7. 加载数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据文件函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataFile</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加载&#x27;</span>, filename, <span class="string">&#x27;文件数据...&#x27;</span>)</span><br><span class="line">    fr = <span class="built_in">open</span>(filename)</span><br><span class="line">    data = [inst.strip().split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">dataLabels = [<span class="string">&#x27;weather&#x27;</span>, <span class="string">&#x27;temperature&#x27;</span>, <span class="string">&#x27;humidity&#x27;</span>, <span class="string">&#x27;wind conditions&#x27;</span>, <span class="string">&#x27;exercise&#x27;</span>] <span class="comment">#数据的属性名称</span></span><br><span class="line">data = loadDataFile(<span class="string">&#x27;ID3dataEn.csv&#x27;</span>) <span class="comment">#加载数据文件</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-预处理-温度和湿度-数据"><a href="#2-8-预处理-温度和湿度-数据" class="headerlink" title="2.8. 预处理 温度和湿度 数据"></a>2.8. 预处理 温度和湿度 数据</h2><p>由于温度和湿度数据量过多，故将温度和湿度数据进行整合，将数据取十位整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#预处理 温度和湿度 数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataWrangling</span>(<span class="params">data, iColumn</span>):</span></span><br><span class="line">    <span class="keyword">for</span> iRow <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        num = <span class="built_in">int</span>(data[iRow][iColumn])</span><br><span class="line">        num = num - (num%<span class="number">10</span>)</span><br><span class="line">        data[iRow][iColumn] = <span class="built_in">str</span>(num)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="comment">#预处理 温度和湿度 数据</span></span><br><span class="line">data = dataWrangling(data, <span class="number">1</span>) <span class="comment">#整理 温度数据 取“十位”整数</span></span><br><span class="line">data = dataWrangling(data, <span class="number">2</span>) <span class="comment">#整理 湿度数据 取“十位”整数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-9-主函数"><a href="#2-9-主函数" class="headerlink" title="2.9. 主函数"></a>2.9. 主函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dataLabels = [<span class="string">&#x27;weather&#x27;</span>, <span class="string">&#x27;temperature&#x27;</span>, <span class="string">&#x27;humidity&#x27;</span>, <span class="string">&#x27;wind conditions&#x27;</span>, <span class="string">&#x27;exercise&#x27;</span>] <span class="comment">#数据的属性名称</span></span><br><span class="line">    data = loadDataFile(<span class="string">&#x27;ID3dataEn.csv&#x27;</span>) <span class="comment">#加载数据文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预处理前数据：&#x27;</span>, data)</span><br><span class="line">    <span class="comment">#预处理 温度和湿度 数据</span></span><br><span class="line">    data = dataWrangling(data, <span class="number">1</span>) <span class="comment">#整理 温度数据 取十位数</span></span><br><span class="line">    data = dataWrangling(data, <span class="number">2</span>) <span class="comment">#整理 湿度数据 取十位数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;处理后数据：&#x27;</span>, data)</span><br><span class="line">    myTree = createTree(data, dataLabels) <span class="comment">#构造决策树</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;决策树构造函数测试&#x27;</span>, myTree)</span><br><span class="line">    createPlot(myTree) <span class="comment">#显示决策树</span></span><br></pre></td></tr></table></figure>

<h2 id="2-10-得到的决策树图如下所示"><a href="#2-10-得到的决策树图如下所示" class="headerlink" title="2.10. 得到的决策树图如下所示"></a>2.10. 得到的决策树图如下所示</h2><p><img data-src="/../../../../uploads/DataMining_ID3_Result_myTree.png" alt="myTree决策树图"></p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待分类数据集文件</strong>：<a href="../../../../uploads/ID3dataEn.csv">ID3dataEn.csv</a><br><strong>源代码</strong>：<a href="../../../../uploads/ID3.py">ID3.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘简介与发展动向</title>
    <url>/2018/09/27/DataMining_Introduction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DataMining_Introduction.jpg" class="full-image" />

<blockquote class="blockquote-center">
<p>Data mining, the science of extracting useful knowledge from such huge data repositories, has emerged as a young and interdisciplinary field in computer science.  – by <strong>KDD</strong></p>

</blockquote>

<h1 id="1-数据挖掘简介"><a href="#1-数据挖掘简介" class="headerlink" title="1. 数据挖掘简介"></a>1. 数据挖掘简介</h1><a id="more"></a>

<ul>
<li>数据挖掘是一个动态的、强势快速扩展的领域。可简要将数据挖掘研究的主要问题分为五组：挖掘方法、用户交互、有效性与可伸缩性、数据类型的多样性、数据挖掘与社会。</li>
<li>数据挖掘吸纳了诸如<strong>统计学</strong>、<strong>机器学习</strong>、<strong>模式识别</strong>、<strong>数据库和数据仓库</strong>、<strong>信息检索</strong>、<strong>可视化</strong>、<strong>算法</strong>、<strong>高性能计算</strong>和许多应用领域的大量技术。</li>
</ul>
<h2 id="1-1-数据挖掘的意义"><a href="#1-1-数据挖掘的意义" class="headerlink" title="1.1. 数据挖掘的意义"></a>1.1. 数据挖掘的意义</h2><ul>
<li>利用大数据帮助做出<strong>预测</strong>或<strong>决策</strong></li>
<li>发现数据中潜在的<strong>有趣模式</strong>或<strong>知识</strong></li>
</ul>
<h1 id="2-最新技术与发展动向"><a href="#2-最新技术与发展动向" class="headerlink" title="2. 最新技术与发展动向"></a>2. 最新技术与发展动向</h1><h2 id="2-1-数据挖掘最新技术"><a href="#2-1-数据挖掘最新技术" class="headerlink" title="2.1. 数据挖掘最新技术"></a>2.1. 数据挖掘最新技术</h2><ul>
<li>超越传统技术和数据分析工具的能力的数据集催生了许多新的技术和工具–by<a href="https://link.springer.com/content/pdf/10.1007/978-3-319-08254-7.pdf">Information granularity, big data, and computational intelligence</a></li>
</ul>
<p>面对数据挖掘中3V的挑战（即：超大数据量、多样化的数据种类、处理数据的速度要求），如大型零售商的客户交易，天气监测，情报收集等数据集快速超越传统技术和数据分析工具的能力等问题，驱使数据可视化，采集和序列化中诞生了许多新的技术和工具。</p>
<h3 id="2-1-1-数据预处理技术"><a href="#2-1-1-数据预处理技术" class="headerlink" title="2.1.1. 数据预处理技术"></a>2.1.1. 数据预处理技术</h3><p>数据清理、数据集成、数据归约、数据变换和数据离散化。</p>
<ul>
<li>Deren Li methods 2015，为了揭示空间数据挖掘的各向异性，挖掘视图方法利用尺度、层次和粒度来区分不同的需求。Deren Li方法对数据进行预处理，为进一步的知识发现做准备，方法是选择一个权重进行迭代，以便尽可能多地清理观察到的空间数据。–by<a href="https://link.springer.com/content/pdf/10.1007/978-3-662-48538-5.pdf">Spatial data mining</a></li>
</ul>
<h3 id="2-1-2-数据仓库、OLAP、数据立方体技术"><a href="#2-1-2-数据仓库、OLAP、数据立方体技术" class="headerlink" title="2.1.2. 数据仓库、OLAP、数据立方体技术"></a>2.1.2. 数据仓库、OLAP、数据立方体技术</h3><p><strong>数据仓库</strong>：是一种数据库，它与单位的操作数据库分别维护。数据仓库的建立为工商企业主管提供了体系结构和工具，以便他们系统地组织、理解和使用数据进行决策。</p>
<p><strong>OLAP</strong>：OLAP是在线分析处理的缩写。OLAP实现业务数据的多维分析，并提供复杂计算、趋势分析和复杂数据建模的能力。</p>
<p><strong>数据立方体</strong>：一种多维数据模型。数据立方体创建了灵活而强有力的手段，对数据的子集分组和聚集。它们使得用户可以在多维组合和变化的聚集粒度上探索数据。这种能力极大地开阔了分析的范围，有助于从数据中有效地发现有趣的模式和知识。</p>
<h3 id="2-1-3-Apriori算法及其变形"><a href="#2-1-3-Apriori算法及其变形" class="headerlink" title="2.1.3. Apriori算法及其变形"></a>2.1.3. Apriori算法及其变形</h3><p>Apriori是一种用于在事务数据库上进行频繁项集挖掘和关联规则学习的算法。 它通过识别数据库中的频繁单个项目并将它们扩展到越来越大的项目集来进行，只要这些项目集在数据库中经常出现。</p>
<h3 id="2-1-4-基于约束模式挖掘和挖掘近似模式"><a href="#2-1-4-基于约束模式挖掘和挖掘近似模式" class="headerlink" title="2.1.4. 基于约束模式挖掘和挖掘近似模式"></a>2.1.4. 基于约束模式挖掘和挖掘近似模式</h3><p>一种好的启发式方法是让用户说明他们对挖掘导致的有趣模式的直观或期望，作为限制搜索空间的约束条件。这种策略称为基于约束的挖掘。</p>
<h3 id="2-1-5-分类"><a href="#2-1-5-分类" class="headerlink" title="2.1.5. 分类"></a>2.1.5. 分类</h3><p><strong>基本分类方法</strong>：包括决策树归纳、贝叶斯分类和基于规则的分类。</p>
<p><strong>高级分类方法</strong>：贝叶斯信念网络、后向传播的神经网络技术、支持向量机、使用频繁模式的分类、k-最邻近分类、基于案例的推理、遗传算法、模糊集方法、多类分类、半监督分类、主动学习和迁移学习。</p>
<h4 id="2-1-5-1-数据挖掘中的分类算法对比"><a href="#2-1-5-1-数据挖掘中的分类算法对比" class="headerlink" title="2.1.5.1. 数据挖掘中的分类算法对比"></a>2.1.5.1. 数据挖掘中的分类算法对比</h4><p>分类是一种重要的数据挖掘技术，具有广泛的应用前景。分类用于找出在给定数据集中每个数据实例在哪个组中相关。分类算法主要有：<strong>C4.5</strong>、<strong>ID3</strong>、<strong>k近邻分类器</strong>、<strong>朴素贝叶斯</strong>、<strong>SVM</strong>、<strong>ANN</strong>等。分类技术一般采用统计方法、机器学习方法和神经网络方法进行分类。Nikam对不同的分类算法及其特点和局限性进行了全面的综述。</p>
<p>– <a href="https://pdfs.semanticscholar.org/7c97/57ee09afa570db37f04e3b6cc4da0e2f3571.pdf">A comparative study of classification techniques in data mining algorithms</a></p>
<p><img data-src="/../../../../uploads/AdvantagesAndDisadvantagesOfClassificationAlgorithm.png" alt="AdvantagesAndDisadvantagesOfClassificationAlgorithm"></p>
<ul>
<li>基于<strong>神经网络</strong>和<strong>遗传算法</strong>的数据挖掘技术</li>
</ul>
<p><strong>Ali, Sayyed Muzammil</strong>概述了常见的知识发现任务以及解决这些任务的方法。总结了数据挖掘的概念，阐述了数据挖掘对其方法论的意义。详细研究了基于神经网络和遗传算法的数据挖掘技术，综述了实现神经网络和遗传算法数据挖掘的关键技术和方法。</p>
<p>– <a href="http://www.academia.edu/download/33555810/V3I4201499a89.pdf">data mining Techniques</a></p>
<h3 id="2-1-6-聚类分析"><a href="#2-1-6-聚类分析" class="headerlink" title="2.1.6. 聚类分析"></a>2.1.6. 聚类分析</h3><p><strong>基本聚类分析</strong>：</p>
<ul>
<li>k-均值和k-中心点划分算法、凝聚的与分裂的层次聚类算法、</li>
<li>基于密度的DBSCAN、OPTICS、DENCLUE聚类分析</li>
<li>基于网络的STING、CLIQUE聚类分析</li>
</ul>
<p><strong>高级聚类分析</strong>：</p>
<ul>
<li><p>基于概率模型的模糊簇、期望最大化算法的聚类分析</p>
</li>
<li><p>子空间聚类方法、双聚类（聚类高维数据）</p>
</li>
<li><p>SCAN算法（用于聚类图数据）</p>
</li>
<li><p>具有约束的COP-k-均值算法</p>
</li>
<li><p>数据挖掘问题的<strong>多目标进化算法</strong>的最新进展</p>
</li>
</ul>
<p><strong>Mukhopadhyay, Anirban</strong>对数据挖掘问题的多目标进化算法的最新进展进行了全面的综述。本文第一部分给出了多目标优化和数据挖掘的一些基本概念。随后，对两大数据挖掘任务特征选择和分类的多目标演化方法进行了研究。在本文的第二部分中，我们调查了用于聚类、关联规则挖掘等多个数据挖掘任务的不同多目标进化算法，并对该领域未来的研究范围进行了一般性讨论。</p>
<p>– <a href="https://ieeexplore.ieee.org/iel7/4235/4358751/06658835.pdf">A Survey of Multiobjective Evolutionary Algorithms for data mining: Part I.</a></p>
<h3 id="2-1-7-基于随机选择选项的算法"><a href="#2-1-7-基于随机选择选项的算法" class="headerlink" title="2.1.7. 基于随机选择选项的算法"></a>2.1.7. 基于随机选择选项的算法</h3><p>有时基于<strong>随机选择选项</strong>的算法收效良好。在数据挖掘和控制领域，当一个问题需要“蛮力”选择选项时，基于<strong>随机选择选项</strong>的算法在有限的时间内提供了一定概率的良好结果，并显著减少了操作量。</p>
<p>– <a href="https://pdfs.semanticscholar.org/7c97/57ee09afa570db37f04e3b6cc4da0e2f3571.pdf">A comparative study of classification techniques in data mining algorithms</a></p>
<h3 id="2-1-8-流算法"><a href="#2-1-8-流算法" class="headerlink" title="2.1.8. 流算法"></a>2.1.8. 流算法</h3><ul>
<li><strong>APSO加速粒子群优化算法</strong></li>
</ul>
<p><strong>Fong, Simon</strong>为解决当涉及到在高维数据上的挖掘时，获得最优特征子集的搜索空间以指数级增长，这导致了计算上的一个棘手需求这一问题，<strong>提出了一种新的轻量级特征选择方法</strong>。该特征选择是为了实时挖掘流数据，采用加速粒子群优化算法(APSO)，在合理的处理时间内提高了分析精度。</p>
<p>– <a href="https://ieeexplore.ieee.org/iel7/4629386/4629387/07115942.pdf">Accelerated PSO swarm search feature selection for data stream mining big data</a></p>
<h3 id="2-1-9-分布式数据挖掘"><a href="#2-1-9-分布式数据挖掘" class="headerlink" title="2.1.9. 分布式数据挖掘"></a>2.1.9. 分布式数据挖掘</h3><p><strong>Le-Khac, Nhien-An</strong>提出了一个新的框架，开发新的和创新的数据挖掘技术，以处理非常大的分布式异构数据集在商业和学术应用。详细介绍了其中的主要组件及其接口，允许用户在Globus ToolKit、DGET等网格平台上高效地开发和实现其数据挖掘应用程序技术。</p>
<p> – <a href="https://arxiv.org/abs/1703.09756">ADMIRE framework: Distributed data mining on data grid platforms</a></p>
<p><strong>Janez Kranjc</strong>介绍了一种分布式计算平台，利用最新的软件技术和计算范式开发出了支持大数据挖掘的平台。这个平台称为ClowdFlows，它是一个基于云的web应用程序，具有图形用户界面，支持数据挖掘工作流的构建和执行，其中包括作为工作流组件使用的web服务。</p>
<p> – <a href="https://www.sciencedirect.com/science/article/pii/S0167739X16302709">ClowdFlows: Online workflows for distributed big data mining</a></p>
<h2 id="2-2-数据挖掘发展动向"><a href="#2-2-数据挖掘发展动向" class="headerlink" title="2.2. 数据挖掘发展动向"></a>2.2. 数据挖掘发展动向</h2><h3 id="2-2-1-与物联网相结合"><a href="#2-2-1-与物联网相结合" class="headerlink" title="2.2.1. 与物联网相结合"></a>2.2.1. 与物联网相结合</h3><p>对许多人来说，物联网生成或捕获的海量数据被认为具有非常有用和有价值的信息。数据挖掘无疑将在使这种系统足够智能以提供更方便的服务和环境方面发挥关键作用。<br><strong>Chun-Wei Tsai</strong>从物联网开始讨论，简要回顾了“物联网数据”和“物联网数据挖掘”的特点，最后，讨论了该领域的变化、潜力、开放问题和未来趋势。</p>
<p>– <a href="https://ieeexplore.ieee.org/iel7/9739/6734839/06674155.pdf">data mining for Internet of Things: A survey.</a></p>
<h3 id="2-2-2-基于云计算的数据挖掘更低成本"><a href="#2-2-2-基于云计算的数据挖掘更低成本" class="headerlink" title="2.2.2. 基于云计算的数据挖掘更低成本"></a>2.2.2. 基于云计算的数据挖掘更低成本</h3><p>数据挖掘技术和应用程序可以有效地用于云计算范式。云计算是一种能够支持广泛应用的通用技术。基于云计算的数据挖掘技术的实现将允许用户从几乎集成的数据仓库中检索有意义的信息，从而**降低基础设施和存储的成本，并且可以从云检索有用的和潜在的信息。</p>
<p>– <a href="http://ijrise.org/asset/archive/15SANKALP1.pdf">A review on data mining based cloud computing</a></p>
<h3 id="2-2-3-与统计与机器学习结合"><a href="#2-2-3-与统计与机器学习结合" class="headerlink" title="2.2.3. 与统计与机器学习结合"></a>2.2.3. 与统计与机器学习结合</h3><p>– <a href="https://books.google.com/books?hl=en&lr=&id=ETwuDwAAQBAJ&oi=fnd&pg=PR19&dq=data+mining+Development+trend&ots=2NWgjl2RLK&sig=sQBatbtbXqXyebsmDBRzPVYNL_8">Data mining for business analytics: concepts, techniques, and applications in R</a></p>
<h3 id="2-2-4-数据挖掘实现的集成库及平台化"><a href="#2-2-4-数据挖掘实现的集成库及平台化" class="headerlink" title="2.2.4. 数据挖掘实现的集成库及平台化"></a>2.2.4. 数据挖掘实现的集成库及平台化</h3><ul>
<li><strong>SPMF——一个开源数据挖掘库</strong> 2014</li>
</ul>
<p><strong>Fournier-Viger</strong>提供了一个用Java实现的跨平台库——<strong>SPMF</strong>，一个开源数据挖掘库**，提供了超过55种数据挖掘算法的实现。<br>SPMF专门用于发现事务和序列数据库中的模式，如频繁项目集、关联规则和顺序模式。<br>源代码可以集成到其他Java程序中。<br>此外，SPMF还提供了命令行界面和简单的图形界面来进行快速测试。</p>
<p>– <a href="http://www.jmlr.org/papers/volume15/fournierviger14a/fournierviger14a.pdf">SPMF: a Java open-source pattern mining library</a></p>
<ul>
<li><strong>SAMOA——一个挖掘大数据流的平台</strong> 2015</li>
</ul>
<p><strong>Morales GD</strong>提供了一个挖掘大数据流的平台——<strong>SAMOA</strong>。它提供了一组分布式流算法，用于最常见的数据挖掘和机器学习任务，如分类、聚类和回归，以及开发新算法的编程抽象。它具有一个可插入的体系结构，允许它在多个分布式流处理引擎(如Storm、S4和Samza)上运行。萨摩亚是用Java编写的，是开源的，可以在<a href="http://samoa-project.net的apache/">http://samoa-project.net的Apache</a> Software License version 2.0下访问。</p>
<p>– <a href="http://www.jmlr.org/papers/volume16/morales15a/morales15a.pdf">SAMOA: scalable advanced massive online analysis.</a></p>
<ul>
<li>与应用相结合 </li>
<li>研制和开发数据挖掘标准 </li>
<li>支持移动环境</li>
</ul>
<h1 id="3-应用领域及行业应用"><a href="#3-应用领域及行业应用" class="headerlink" title="3. 应用领域及行业应用"></a>3. 应用领域及行业应用</h1><h2 id="3-1-应用领域"><a href="#3-1-应用领域" class="headerlink" title="3.1. 应用领域"></a>3.1. 应用领域</h2><p><strong>数据挖掘有许多成功的应用，如电子商务、Web搜索、生物信息学、卫生保健信息学、商务智能、金融、数字图书馆和政府等。</strong></p>
<h2 id="3-2-行业应用"><a href="#3-2-行业应用" class="headerlink" title="3.2. 行业应用"></a>3.2. 行业应用</h2><h3 id="3-2-1-动态资源的新闻识别"><a href="#3-2-1-动态资源的新闻识别" class="headerlink" title="3.2.1. 动态资源的新闻识别"></a>3.2.1. 动态资源的新闻识别</h3><p><strong>Kalmegh, Sushilkumar</strong>讨论了动态资源的新闻识别可以通过所提出的模型来完成，使用REPTree、Simple Cart和RandomTree三种分类器来分析数据集。结果表明，随机树算法在对新闻进行分类时表现最佳。REPTree和Simple Cart算法的整体性能是不可接受的，因为可以看出，这两种算法都只能正确地对政治新闻进行分类。</p>
<p>– <a href="https://pdfs.semanticscholar.org/26d6/73f140807942313545489b38241c1f0401d0.pdf">Analysis of WEKA data mining algorithm REPTree, Simple CART and RandomTree for classification of Indian news</a></p>
<h3 id="3-2-2-教育数据挖掘-EDM-领域"><a href="#3-2-2-教育数据挖掘-EDM-领域" class="headerlink" title="3.2.2. 教育数据挖掘(EDM)领域"></a>3.2.2. 教育数据挖掘(EDM)领域</h3><ul>
<li>教育数据挖掘和学习分析</li>
</ul>
<p><strong>Sin, Katrina</strong>近年来，学习管理系统在教育中的应用越来越多。学生们已经开始使用移动电话，主要是智能手机，它们已经成为他们日常生活的一部分，以获取在线内容。学生的在线活动产生了大量未使用的数据，由于传统的学习分析无法处理这些数据，这些数据被浪费了。这使得大数据技术和工具渗透到教育中，处理大量的数据。本研究探讨了大数据技术在教育领域的最新应用，并对教育数据挖掘和学习分析方面的文献进行了综述。</p>
<p>– <a href="http://www.academia.edu/download/51542496/APPLICATION_OF_BIG_DATA_IN_EDUCATION_DAT.pdf">APPLICATION OF BIG data IN EDUCATION data mining AND LEARNING ANALYTICS–A LITERATURE REVIEW.</a></p>
<ul>
<li>挖掘学生入学率、考勤记录以及他们的考试数据，使之有利于教育质量的改进与提高。</li>
</ul>
<p>–  <a href="https://ieeexplore.ieee.org/iel7/6287639/6514899/07820050.pdf">A systematic review on educational data mining</a></p>
<h3 id="3-2-3-地理信息科学和遥感方面"><a href="#3-2-3-地理信息科学和遥感方面" class="headerlink" title="3.2.3. 地理信息科学和遥感方面"></a>3.2.3. 地理信息科学和遥感方面</h3><ul>
<li>空间数据挖掘应用于<strong>地理信息科学和遥感方面</strong></li>
</ul>
<p><strong>Li, Deren</strong>提供了空间数据挖掘在地理信息科学和遥感方面的应用实例。实践项目包括用于维护公共安全的时空视频数据挖掘、用于评估叙利亚危机严重程度的夜间灯光序列图像挖掘、以及在政府“一带一路”项目中的应用。</p>
<p>– <a href="https://link.springer.com/content/pdf/10.1007/978-3-662-48538-5.pdf">Spatial data mining</a></p>
<h3 id="3-2-4-医疗大数据"><a href="#3-2-4-医疗大数据" class="headerlink" title="3.2.4. 医疗大数据"></a>3.2.4. 医疗大数据</h3><ul>
<li>医疗大数据创新路径包括三个阶段：疾病早期发现、诊断、治疗和预后阶段、生命健康促进阶段和护理阶段。</li>
<li>研究热点主要集中在三个维度：疾病维度(如流行病学、乳腺癌、肥胖、糖尿病)、技术维度(如数据挖掘、机器学习)、健康服务维度(如定制服务、养老护理)</li>
</ul>
<p> – <a href="https://www.sciencedirect.com/science/article/pii/S1386505616302556">Visualizing the knowledge structure and evolution of big data research in healthcare informatics</a></p>
<ul>
<li>与云技术结合提供医疗服务</li>
</ul>
<p><strong>Zhang, Yin</strong>提出了一个基于云和大数据分析技术的以患者为中心的医疗应用和服务的网络物理系统，称为Health-CPS。该系统由具有统一标准的数据采集层、用于分布式存储和并行计算的数据管理层和面向数据的服务层组成。研究结果表明，云技术和大数据技术可以提高医疗系统的性能，使人们可以享受各种智能医疗应用和服务。</p>
<p> – <a href="https://ieeexplore.ieee.org/abstract/document/7219371/">Health-CPS: Healthcare cyber-physical system assisted by cloud and big data</a></p>
<ul>
<li>医学大数据研究的文献计量分析与可视化 –<a href="https://www.mdpi.com/2071-1050/10/1/166"><strong>A bibliometric analysis</strong> and <strong>visualization</strong> of <strong>medical big data research</strong></a></li>
<li>预测和解决乳腺癌生存率 –<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2994925">Data mining techniques: To predict and resolve breast cancer survivability</a></li>
</ul>
<h3 id="3-2-5-能源评估"><a href="#3-2-5-能源评估" class="headerlink" title="3.2.5. 能源评估"></a>3.2.5. 能源评估</h3><ul>
<li>全球水资源趋势和可持续发展的未来前景 –<a href="https://www.sciencedirect.com/science/article/pii/S0959652617321182">Global water <strong>trends</strong> and future scenarios for sustainable development: The case of Russia</a></li>
<li>对智能电网环境下用电量数据的数据质量分析 –<a href="https://www.sciencedirect.com/science/article/pii/S1364032116307109">data quality of electricity consumption data in a smart grid environment</a></li>
</ul>
<h3 id="3-2-6-业务运营和风险管理"><a href="#3-2-6-业务运营和风险管理" class="headerlink" title="3.2.6. 业务运营和风险管理"></a>3.2.6. 业务运营和风险管理</h3><ul>
<li>工业系统的可靠性和安全性以及它们的操作风险管理 –<a href="https://ieeexplore.ieee.org/abstract/document/7378465/">Recent development in big data analytics for business operations and risk management</a></li>
<li>业务分析的数据挖掘 –<a href="https://books.google.com/books?hl=en&lr=&id=ETwuDwAAQBAJ&oi=fnd&pg=PR19&dq=data+mining+Development+trend&ots=2NWgjl2RLK&sig=sQBatbtbXqXyebsmDBRzPVYNL_8">Data mining for business analytics: concepts, techniques, and applications in R</a></li>
</ul>
<h3 id="3-2-7-用于保险行业"><a href="#3-2-7-用于保险行业" class="headerlink" title="3.2.7. 用于保险行业"></a>3.2.7. 用于保险行业</h3><p>数据挖掘技术在人寿保险中的应用 –<a href="https://www.researchgate.net/institution/Chh_Shahu_Institute_of_Business_Education_Research/publications">Applications of Data mining techniques in life insurance</a></p>
<h3 id="3-2-8-用于政府机构"><a href="#3-2-8-用于政府机构" class="headerlink" title="3.2.8. 用于政府机构"></a>3.2.8. 用于政府机构</h3><ul>
<li>可持续自然资源管理评价污染防治 –<a href="https://www.sciencedirect.com/science/article/pii/S0959652616317115">How would big data support societal development and environmental sustainability? Insights and practices</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Kmeans算法——数据挖掘</title>
    <url>/2018/10/24/DataMining_Kmeans/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DataMining_Kmeans.png" class="full-image" />

<h1 id="1-实现K-means算法对无噪声的waveform数据集进行分割"><a href="#1-实现K-means算法对无噪声的waveform数据集进行分割" class="headerlink" title="1. 实现K-means算法对无噪声的waveform数据集进行分割"></a>1. 实现K-means算法对无噪声的waveform数据集进行分割</h1><h2 id="1-1-K-means算法简介"><a href="#1-1-K-means算法简介" class="headerlink" title="1.1. K-means算法简介"></a>1.1. K-means算法简介</h2><ul>
<li>k均值聚类是一种矢量量化方法，最初来自信号处理，是数据挖掘中聚类分析的常用方法。</li>
<li>k均值聚类的目的是将n个观测值划分为k个聚类，其中每个观测值属于具有最近均值的聚类，作为聚类的原型。这导致数据空间划分为Voronoi单元。</li>
</ul>
<a id="more"></a>

<ul>
<li>这个问题在计算上很困难（NP难）；然而，有效的启发式算法快速收敛到局部最优。这些通常类似于通过k均值和高斯混合建模所采用的迭代细化方法的高斯分布混合的期望最大化算法。他们都使用集群中心来建模数据;然而，k均值聚类倾向于找到具有可比空间范围的聚类，而期望最大化机制允许聚类具有不同的形状。</li>
<li>该算法与k-最近邻分类器具有松散的关系，这是一种流行的分类机器学习技术，由于名称的原因常常与k-means混淆。应用1最近邻分类器，通过k均值获得的聚类中心将新数据分类到现有聚类中。这被称为最近的质心分类器或Rocchio算法。</li>
</ul>
<h2 id="1-2-Python编程实现K-means算法"><a href="#1-2-Python编程实现K-means算法" class="headerlink" title="1.2. Python编程实现K-means算法"></a>1.2. Python编程实现K-means算法</h2><p><strong>K-means算法主要分为以下步骤实现</strong>：</p>
<ul>
<li>S1. 随机生成 k 个 “种子”</li>
<li>S2. 依次求解当前(第i个)元素对k个’种子’的最小欧式距离，得到距当前(第i个)元素欧式距离最小的(‘种子’)集群</li>
<li>S3. 如果当前(第i个)元素的与k个‘种子’(集群)的最小欧式距离所对应的【种子编号】遇上一次记录不一致 &#x3D;&#x3D;&gt; (第i个)元素所属集群发生改变，更新所属集群</li>
<li>S4. 重新计算k个(‘种子’)集群的各属性值的平均值，得到新的k个(‘种子’)集群</li>
<li>S5. 若S2～S4的运行过程中，至少1个元素的所属‘种子’(集群)发生改变，则不断重复运行S2~S5过程,直至没有元素所属‘种子’(集群)发生改变视为聚类成功(也可限定最大迭代次数)跳转S6</li>
<li>S6. 结束迭代，返回k个集群的中心值centroids, 及每个集群所包含的元素数组clusterAssment</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># Pandas库：强大、灵活的数据分析和探索工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算欧式距离:</span></span><br><span class="line"><span class="comment"># 将&#x27;vector1&#x27;与&#x27;vector2&#x27;中所有对应属性值之差的平方求和，再求平方根</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caclEucDistance</span>(<span class="params">vector1, vector2</span>):</span></span><br><span class="line">    distance = np.sqrt(np.<span class="built_in">sum</span>(np.square(vector2 - vector1)))</span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成 k 个 “种子”</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span>(<span class="params">dataSet, k</span>):</span></span><br><span class="line">    numSamples, dim = dataSet.shape</span><br><span class="line">    centroids = np.zeros((k, dim)) <span class="comment">#创建大小为：&#x27;k x 元素属性列值&#x27; 的全0矩阵，用于存放k个‘种子’（集群）</span></span><br><span class="line">    <span class="comment"># 随机生成 k 个 “种子”</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        index = <span class="built_in">int</span>(random.uniform(<span class="number">0</span>, numSamples))</span><br><span class="line">        centroids[i, :] = dataSet[index, :] <span class="comment">#在数据集中取 k 个值</span></span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line"><span class="comment"># k-means 算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span>(<span class="params">dataSet, k</span>):</span></span><br><span class="line">    numSamples = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    clusterAssment = np.mat(np.zeros((numSamples, <span class="number">2</span>)))</span><br><span class="line">    <span class="comment"># clusterAssment &#x27;元素属性值行 x 2列矩阵&#x27;</span></span><br><span class="line">    <span class="comment"># 第一列：存储此示例所属的(&#x27;种子&#x27;)集群</span></span><br><span class="line">    <span class="comment"># 第二列：存储当前(第i个)元素与其所属的(&#x27;种子&#x27;)集群的欧式距离</span></span><br><span class="line">    clusterChanged = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># clusterChanged：在迭代时&#x27;种子&#x27;是否改变标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 随机生成 k 个 “种子”</span></span><br><span class="line">    centroids = initCentroids(dataSet, k)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 一直迭代直到没有1个&#x27;种子&#x27;的所属(&#x27;种子&#x27;)集群发生改变</span></span><br><span class="line">    <span class="keyword">while</span> clusterChanged:</span><br><span class="line">   </span><br><span class="line">        <span class="comment"># 迭代前为&#x27;种子&#x27;是否改变标志赋初值(False:未改变，如果执行完循环体后仍未False,视作迭代完成，退出迭代)</span></span><br><span class="line">        clusterChanged = <span class="literal">False</span> </span><br><span class="line">                </span><br><span class="line">        <span class="comment">## 依次求解每个元素对k个&#x27;种子&#x27;的最小距离</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numSamples):</span><br><span class="line">            minDist = <span class="number">100000.0</span></span><br><span class="line">            minIndex = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#比较当前(第i个)元素 对应 k个&#x27;种子&#x27; 的欧式距离，求出最小（存于minDist），并记录对应种子编号（存于minIndex）</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                distance = caclEucDistance(centroids[j, :], dataSet[i, :])</span><br><span class="line">                <span class="keyword">if</span> distance &lt; minDist:</span><br><span class="line">                    minDist = distance</span><br><span class="line">                    minIndex = j</span><br><span class="line"></span><br><span class="line">            <span class="comment">## 如果当前(第i个)元素的与k个‘种子’(集群)的最小欧式距离所对应的【种子编号】遇上一次记录不一致 ==&gt; (第i个)元素所属集群发生改变</span></span><br><span class="line">            <span class="keyword">if</span> clusterAssment[i, <span class="number">0</span>] != minIndex:</span><br><span class="line">            	<span class="comment"># 该变标志置&#x27;True&#x27; , 更新当前(第i个)元素的所属集群编号</span></span><br><span class="line">                clusterChanged = <span class="literal">True</span></span><br><span class="line">                clusterAssment[i, :] = minIndex, minDist ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## 重新计算各个集群的中心点，并更新</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            pointsInCluster = dataSet[np.nonzero(clusterAssment[:, <span class="number">0</span>].A == j)[<span class="number">0</span>]]</span><br><span class="line">            centroids[j, :] = np.mean(pointsInCluster, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处表示退出迭代 ==&gt; 聚类成功</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Congratulations, cluster complete!&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> centroids, clusterAssment</span><br></pre></td></tr></table></figure>

<h2 id="1-3-编写Python程序实现K-means算法对UCI的waveform数据集的3个类中每类数据取100个的分割"><a href="#1-3-编写Python程序实现K-means算法对UCI的waveform数据集的3个类中每类数据取100个的分割" class="headerlink" title="1.3. 编写Python程序实现K-means算法对UCI的waveform数据集的3个类中每类数据取100个的分割"></a>1.3. 编写Python程序实现K-means算法对UCI的waveform数据集的3个类中每类数据取100个的分割</h2><p>从UCI获取<a href="http://archive.ics.uci.edu/ml/datasets/waveform+database+generator+(version+2)">Waveform Database Generator (Version 2) Data Set</a>数据集。由网页介绍可知该数据集中，数据量为：5000，属性数为：40(实际21列), waves数据的类为：3。</p>
<h3 id="1-3-1-程序加载waveform-data数据"><a href="#1-3-1-程序加载waveform-data数据" class="headerlink" title="1.3.1. 程序加载waveform.data数据"></a>1.3.1. 程序加载waveform.data数据</h3><p>通过以下代码读取Waveform Database Generator (Version 2) Data Set中’waveform.data’文件内的所有数据，可看到数据的最后一列为类属性的标识号，由网页介绍可知，waves数据共有3类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数据加载...\n&#x27;</span>)</span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;waveform.data&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, header=<span class="literal">None</span>, skiprows=<span class="number">0</span>, names=<span class="literal">None</span>) <span class="comment"># waveform.data</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-在第0-2类中，每类提取100个数据"><a href="#1-3-2-在第0-2类中，每类提取100个数据" class="headerlink" title="1.3.2. 在第0~2类中，每类提取100个数据"></a>1.3.2. 在第0~2类中，每类提取100个数据</h3><p>在3类中每类取100个数据使用上一步实现的K-means算法的进行聚类,其中每类取100个样本，并将这300个样本拼接到一个列表，将这个操作封装成函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在data中，第0~2类，每获取100个数据并简单拼接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geteveryClass3Data100Samples</span>(<span class="params">data</span>):</span></span><br><span class="line">    data_class0 = data[data[<span class="number">21</span>]==<span class="number">0</span>].head(<span class="number">100</span>) <span class="comment">#取第0类数据前100个</span></span><br><span class="line">    data_class1 = data[data[<span class="number">21</span>]==<span class="number">1</span>].head(<span class="number">100</span>) <span class="comment">#取第1类数据前100个</span></span><br><span class="line">    data_class2 = data[data[<span class="number">21</span>]==<span class="number">2</span>].head(<span class="number">100</span>) <span class="comment">#取第2类数据前100个</span></span><br><span class="line">    data_3x100 = pd.concat([data_class0, data_class1, data_class2]) <span class="comment">#简单拼接到一起</span></span><br><span class="line">    data_3x100 = data_3x100.sort_index() <span class="comment">#将这300个样本，按原文件的索引从小到大排序(打乱第0~2类的数据)</span></span><br><span class="line">    data_3x100 = data_3x100.reset_index(drop=<span class="literal">True</span>) <span class="comment">#重新建立索引</span></span><br><span class="line">    <span class="keyword">return</span> data_3x100</span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-用K-means算法对UCI的waveform数据集中筛选出的300个样本进行分割"><a href="#1-3-3-用K-means算法对UCI的waveform数据集中筛选出的300个样本进行分割" class="headerlink" title="1.3.3. 用K-means算法对UCI的waveform数据集中筛选出的300个样本进行分割"></a>1.3.3. 用K-means算法对UCI的waveform数据集中筛选出的300个样本进行分割</h3><p>设置’种子’(集群)个数为:5, 运行k-means算法进行迭代分割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_3x100 = np.mat(data_3x100)</span><br><span class="line">k = <span class="number">5</span></span><br><span class="line">centroids, clusterAssment = kmeans(data_3x100, k)</span><br></pre></td></tr></table></figure>
<p>设置分割’种子’(集群)个数为:5时，k-means分割（集群中心点）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">centroids:</span><br><span class="line">[[-<span class="number">0.07813559</span>  <span class="number">0.40762712</span> -<span class="number">0.00067797</span>  <span class="number">0.27966102</span>  <span class="number">0.30101695</span>  <span class="number">0.99237288</span></span><br><span class="line">   <span class="number">2.17169492</span>  <span class="number">2.86677966</span>  <span class="number">3.79711864</span>  <span class="number">4.43864407</span>  <span class="number">5.55898305</span>  <span class="number">4.80983051</span></span><br><span class="line">   <span class="number">3.42457627</span>  <span class="number">3.19677966</span>  <span class="number">2.29627119</span>  <span class="number">1.22847458</span>  <span class="number">0.41711864</span>  <span class="number">0.37355932</span></span><br><span class="line">   <span class="number">0.1579661</span>   <span class="number">0.04322034</span>  <span class="number">0.28288136</span>  <span class="number">1.54237288</span>]</span><br><span class="line"> [-<span class="number">0.09621622</span>  <span class="number">0.93040541</span>  <span class="number">1.7172973</span>   <span class="number">2.41486486</span>  <span class="number">3.45162162</span>  <span class="number">4.06337838</span></span><br><span class="line">   <span class="number">5.0372973</span>   <span class="number">4.08067568</span>  <span class="number">3.61054054</span>  <span class="number">2.96756757</span>  <span class="number">2.16027027</span>  <span class="number">1.42175676</span></span><br><span class="line">   <span class="number">0.93310811</span>  <span class="number">0.84135135</span>  <span class="number">0.76283784</span>  <span class="number">0.67040541</span>  <span class="number">0.5422973</span>   <span class="number">0.45581081</span></span><br><span class="line">   <span class="number">0.01040541</span>  <span class="number">0.13513514</span>  <span class="number">0.15216216</span>  <span class="number">0.43243243</span>]</span><br><span class="line"> [-<span class="number">0.0027027</span>   <span class="number">0.50324324</span>  <span class="number">0.90378378</span>  <span class="number">1.23</span>        <span class="number">1.77783784</span>  <span class="number">1.97189189</span></span><br><span class="line">   <span class="number">2.92</span>        <span class="number">2.16405405</span>  <span class="number">1.71540541</span>  <span class="number">1.70378378</span>  <span class="number">1.92513514</span>  <span class="number">2.20432432</span></span><br><span class="line">   <span class="number">2.42216216</span>  <span class="number">2.71108108</span>  <span class="number">3.4572973</span>   <span class="number">2.60216216</span>  <span class="number">2.22405405</span>  <span class="number">1.64891892</span></span><br><span class="line">   <span class="number">1.4772973</span>   <span class="number">0.91378378</span> -<span class="number">0.10621622</span>  <span class="number">0.</span>        ]</span><br><span class="line"> [ <span class="number">0.11701149</span> -<span class="number">0.04942529</span>  <span class="number">0.15103448</span>  <span class="number">0.2254023</span>   <span class="number">0.02505747</span>  <span class="number">0.53701149</span></span><br><span class="line">   <span class="number">0.52448276</span>  <span class="number">0.95298851</span>  <span class="number">1.39574713</span>  <span class="number">2.04942529</span>  <span class="number">2.98126437</span>  <span class="number">3.51758621</span></span><br><span class="line">   <span class="number">3.88402299</span>  <span class="number">4.27816092</span>  <span class="number">4.94563218</span>  <span class="number">3.90206897</span>  <span class="number">2.75586207</span>  <span class="number">2.2708046</span></span><br><span class="line">   <span class="number">1.31091954</span>  <span class="number">0.7808046</span>  -<span class="number">0.05574713</span>  <span class="number">1.56321839</span>]</span><br><span class="line"> [ <span class="number">0.16418605</span>  <span class="number">0.40674419</span>  <span class="number">0.60651163</span>  <span class="number">1.61302326</span>  <span class="number">1.84697674</span>  <span class="number">2.77744186</span></span><br><span class="line">   <span class="number">4.06790698</span>  <span class="number">3.94511628</span>  <span class="number">4.00023256</span>  <span class="number">4.18767442</span>  <span class="number">4.25465116</span>  <span class="number">3.05651163</span></span><br><span class="line">   <span class="number">2.0372093</span>   <span class="number">1.23186047</span>  <span class="number">0.92744186</span>  <span class="number">0.74837209</span> -<span class="number">0.07837209</span> -<span class="number">0.14767442</span></span><br><span class="line">   <span class="number">0.1255814</span>  -<span class="number">0.0727907</span>  -<span class="number">0.06697674</span>  <span class="number">0.95348837</span>]]</span><br></pre></td></tr></table></figure>
<p>设置分割’种子’(集群)个数为:10时，k-means分割（集群中心点）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">centroids:</span><br><span class="line"> [[ <span class="number">0.05916667</span>  <span class="number">0.48</span>        <span class="number">0.4125</span>      <span class="number">1.08</span>        <span class="number">1.20388889</span>  <span class="number">2.09888889</span></span><br><span class="line">   <span class="number">3.15527778</span>  <span class="number">3.62388889</span>  <span class="number">4.28333333</span>  <span class="number">4.35555556</span>  <span class="number">5.08</span>        <span class="number">3.77861111</span></span><br><span class="line">   <span class="number">2.64166667</span>  <span class="number">1.89805556</span>  <span class="number">1.35138889</span>  <span class="number">0.85166667</span> -<span class="number">0.05416667</span>  <span class="number">0.03388889</span></span><br><span class="line">   <span class="number">0.08083333</span>  <span class="number">0.07666667</span>  <span class="number">0.16888889</span>  <span class="number">1.</span>        ]</span><br><span class="line"> [-<span class="number">0.48290323</span>  <span class="number">0.64677419</span>  <span class="number">1.51258065</span>  <span class="number">2.13935484</span>  <span class="number">3.30935484</span>  <span class="number">3.56096774</span></span><br><span class="line">   <span class="number">4.61419355</span>  <span class="number">3.29774194</span>  <span class="number">3.21</span>        <span class="number">2.65354839</span>  <span class="number">1.97225806</span>  <span class="number">1.4</span></span><br><span class="line">   <span class="number">1.31290323</span>  <span class="number">1.58870968</span>  <span class="number">1.15967742</span>  <span class="number">1.19612903</span>  <span class="number">1.1016129</span>   <span class="number">0.96290323</span></span><br><span class="line">   <span class="number">0.39032258</span>  <span class="number">0.47419355</span>  <span class="number">0.21322581</span>  <span class="number">0.16129032</span>]</span><br><span class="line"> [-<span class="number">0.57913043</span>  <span class="number">0.70695652</span>  <span class="number">0.55217391</span>  <span class="number">0.59521739</span>  <span class="number">1.11130435</span>  <span class="number">0.91608696</span></span><br><span class="line">   <span class="number">1.8326087</span>   <span class="number">0.71521739</span>  <span class="number">1.23130435</span>  <span class="number">1.29086957</span>  <span class="number">1.73695652</span>  <span class="number">3.23869565</span></span><br><span class="line">   <span class="number">3.33608696</span>  <span class="number">3.50521739</span>  <span class="number">4.50695652</span>  <span class="number">3.38652174</span>  <span class="number">2.71173913</span>  <span class="number">1.58913043</span></span><br><span class="line">   <span class="number">1.32434783</span>  <span class="number">1.0573913</span>   <span class="number">0.06608696</span>  <span class="number">0.52173913</span>]</span><br><span class="line"> [ <span class="number">0.56333333</span>  <span class="number">0.22777778</span>  <span class="number">1.39777778</span>  <span class="number">1.62666667</span>  <span class="number">1.97166667</span>  <span class="number">2.52888889</span></span><br><span class="line">   <span class="number">3.37111111</span>  <span class="number">2.64666667</span>  <span class="number">2.01611111</span>  <span class="number">1.95</span>        <span class="number">1.60555556</span>  <span class="number">1.56888889</span></span><br><span class="line">   <span class="number">2.40555556</span>  <span class="number">2.01555556</span>  <span class="number">2.97277778</span>  <span class="number">2.33055556</span>  <span class="number">2.20944444</span>  <span class="number">1.59333333</span></span><br><span class="line">   <span class="number">1.20611111</span>  <span class="number">0.66777778</span>  <span class="number">0.08222222</span>  <span class="number">0.</span>        ]</span><br><span class="line"> [-<span class="number">0.35111111</span>  <span class="number">0.43777778</span>  <span class="number">0.35111111</span>  <span class="number">0.60111111</span>  <span class="number">1.68888889</span>  <span class="number">1.59</span></span><br><span class="line">   <span class="number">2.60777778</span>  <span class="number">2.73111111</span>  <span class="number">1.46444444</span>  <span class="number">1.9</span>         <span class="number">2.70111111</span>  <span class="number">2.50222222</span></span><br><span class="line">   <span class="number">1.77888889</span>  <span class="number">2.82777778</span>  <span class="number">3.32111111</span>  <span class="number">2.25111111</span>  <span class="number">1.80444444</span>  <span class="number">1.69111111</span></span><br><span class="line">   <span class="number">1.83777778</span>  <span class="number">1.02333333</span> -<span class="number">0.81777778</span>  <span class="number">0.</span>        ]</span><br><span class="line"> [ <span class="number">0.13974359</span>  <span class="number">0.03769231</span> -<span class="number">0.19538462</span> -<span class="number">0.03897436</span>  <span class="number">0.06948718</span>  <span class="number">0.30487179</span></span><br><span class="line">   <span class="number">0.94025641</span>  <span class="number">1.81025641</span>  <span class="number">2.21564103</span>  <span class="number">2.92897436</span>  <span class="number">4.26564103</span>  <span class="number">4.30051282</span></span><br><span class="line">   <span class="number">3.85358974</span>  <span class="number">3.62333333</span>  <span class="number">3.78410256</span>  <span class="number">2.80692308</span>  <span class="number">1.69282051</span>  <span class="number">1.52538462</span></span><br><span class="line">   <span class="number">1.12794872</span>  <span class="number">0.55102564</span> -<span class="number">0.08230769</span>  <span class="number">2.</span>        ]</span><br><span class="line"> [ <span class="number">0.27111111</span> -<span class="number">0.21111111</span>  <span class="number">0.24088889</span>  <span class="number">0.47222222</span> -<span class="number">0.22355556</span>  <span class="number">0.66466667</span></span><br><span class="line">   <span class="number">0.25977778</span>  <span class="number">0.54777778</span>  <span class="number">1.01555556</span>  <span class="number">1.72822222</span>  <span class="number">2.55888889</span>  <span class="number">3.07777778</span></span><br><span class="line">   <span class="number">3.85911111</span>  <span class="number">4.78444444</span>  <span class="number">5.672</span>       <span class="number">4.64822222</span>  <span class="number">3.32355556</span>  <span class="number">2.85711111</span></span><br><span class="line">   <span class="number">1.46044444</span>  <span class="number">0.83622222</span>  <span class="number">0.00777778</span>  <span class="number">1.42222222</span>]</span><br><span class="line"> [ <span class="number">0.38176471</span>  <span class="number">0.59882353</span>  <span class="number">0.895</span>       <span class="number">2.25941176</span>  <span class="number">2.44352941</span>  <span class="number">3.32911765</span></span><br><span class="line">   <span class="number">4.81647059</span>  <span class="number">4.02794118</span>  <span class="number">3.63352941</span>  <span class="number">3.83470588</span>  <span class="number">3.34117647</span>  <span class="number">2.41088235</span></span><br><span class="line">   <span class="number">1.30147059</span>  <span class="number">0.83588235</span>  <span class="number">0.90970588</span>  <span class="number">0.585</span>       <span class="number">0.13470588</span> -<span class="number">0.05617647</span></span><br><span class="line">   <span class="number">0.10294118</span> -<span class="number">0.23382353</span> -<span class="number">0.06294118</span>  <span class="number">0.82352941</span>]</span><br><span class="line"> [-<span class="number">0.084</span>       <span class="number">1.168</span>       <span class="number">2.10333333</span>  <span class="number">2.54066667</span>  <span class="number">3.858</span>       <span class="number">4.87866667</span></span><br><span class="line">   <span class="number">5.49433333</span>  <span class="number">4.91</span>        <span class="number">4.08633333</span>  <span class="number">3.16633333</span>  <span class="number">2.175</span>       <span class="number">1.17433333</span></span><br><span class="line">   <span class="number">0.554</span>       <span class="number">0.12933333</span>  <span class="number">0.15466667</span>  <span class="number">0.12266667</span>  <span class="number">0.01733333</span>  <span class="number">0.14733333</span></span><br><span class="line">  -<span class="number">0.47633333</span>  <span class="number">0.00633333</span>  <span class="number">0.173</span>       <span class="number">0.63333333</span>]</span><br><span class="line"> [-<span class="number">0.10057143</span>  <span class="number">0.44885714</span>  <span class="number">0.00542857</span>  <span class="number">0.09514286</span>  <span class="number">0.19742857</span>  <span class="number">0.86142857</span></span><br><span class="line">   <span class="number">1.98857143</span>  <span class="number">2.93914286</span>  <span class="number">3.95371429</span>  <span class="number">4.702</span>       <span class="number">5.82428571</span>  <span class="number">5.14028571</span></span><br><span class="line">   <span class="number">3.702</span>       <span class="number">3.64314286</span>  <span class="number">2.28428571</span>  <span class="number">1.14228571</span>  <span class="number">0.34742857</span>  <span class="number">0.16857143</span></span><br><span class="line">   <span class="number">0.04457143</span> -<span class="number">0.09171429</span>  <span class="number">0.222</span>       <span class="number">1.65714286</span>]]</span><br></pre></td></tr></table></figure>

<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待处理文件</strong>：<a href="../../../../uploads/waveform.data">waveform.data</a><br><strong>源代码</strong>：<a href="../../../../uploads/kmeans.py">kmeans.py</a></p>
</div>


<h1 id="2-K-means算法对一副无噪图像进行分割"><a href="#2-K-means算法对一副无噪图像进行分割" class="headerlink" title="2. K-means算法对一副无噪图像进行分割"></a>2. K-means算法对一副无噪图像进行分割</h1><p><strong>加载图片数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取图片的rgb列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImageRGB</span>(<span class="params">file</span>):</span></span><br><span class="line">    image = img.imread(file)</span><br><span class="line">    width, height, x = image.shape</span><br><span class="line">    <span class="comment"># 创建与照片像素规模同大小rgb列表，存rgb数据</span></span><br><span class="line">    rgb = np.zeros((width, height, x))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            rgb[i][j] = image[i, j]</span><br><span class="line">    <span class="keyword">return</span> rgb</span><br></pre></td></tr></table></figure>
<p><strong>修改k个随机种子生成函数，使返回k个随机像素点坐标</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机生成k个种子，返回k个随机像素点坐标</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span>(<span class="params">imageRGB, k</span>):</span></span><br><span class="line">    center = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        x, y = random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">0</span>]), random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">1</span>])</span><br><span class="line">        center += [[x, y]]</span><br><span class="line">    <span class="keyword">return</span> center</span><br></pre></td></tr></table></figure>
<p><strong>修改欧式距离的计算公式，按对第一步随机产生的k个变量的欧式距离分簇</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caclEucDistance</span>(<span class="params">imageRGB, centers</span>):</span></span><br><span class="line">    region = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">0</span>]): <span class="comment">#行</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">1</span>]): <span class="comment">#列</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centers)): <span class="comment">#计算k个像素点与k个中心点的欧式距离</span></span><br><span class="line">                dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(imageRGB[i, j] - imageRGB[centers[k][<span class="number">0</span>], centers[k][<span class="number">1</span>]])))</span><br><span class="line">                temp += [dist] <span class="comment">#添加到temp临时数组中</span></span><br><span class="line">            x.append(np.argmin(temp)) <span class="comment">#距离最小的集群的下标，按距离分簇</span></span><br><span class="line">        region.append(x)</span><br><span class="line">    <span class="keyword">return</span> region <span class="comment">#返回与数组同大小的 像素与簇对应关系</span></span><br></pre></td></tr></table></figure>
<p><strong>迭代循环中计算每个像素点与k个簇平均值的欧式距离，并分簇</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loopCaclEucDistance</span>(<span class="params">imageRGB, CalCentercolor</span>):</span></span><br><span class="line">    region = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">0</span>]): <span class="comment">#行</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">1</span>]): <span class="comment">#列</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(CalCentercolor)): <span class="comment">#计算k个像素点与k个中心点的欧式距离</span></span><br><span class="line">                dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(imageRGB[i, j] - CalCentercolor[k])))</span><br><span class="line">                temp += [dist] <span class="comment">#添加到temp临时数组中</span></span><br><span class="line">            x.append(np.argmin(temp))  <span class="comment">#距离最小的集群的下标，按距离分簇</span></span><br><span class="line">        region.append(x)</span><br><span class="line">    <span class="keyword">return</span> region <span class="comment">#返回与数组同大小的 像素与簇对应关系</span></span><br></pre></td></tr></table></figure>
<p><strong>计算集群内所有样本的平均值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calNewCenter</span>(<span class="params">features, imageRGB, k</span>):</span></span><br><span class="line">    temp = [] <span class="comment">#一位数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> features:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            temp.append(j)</span><br><span class="line">    centercolor = [<span class="number">0</span>] * k</span><br><span class="line">    <span class="comment"># 累加 每个集群中所包含的 像素点的RGB值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features)): <span class="comment">#Rows</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features[i])): <span class="comment">#Columns</span></span><br><span class="line">            centercolor[features[i][j]] += imageRGB[i, j]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centercolor)):</span><br><span class="line">        centercolor[i] /= temp.count(i) <span class="comment">#求每个集群的RGB 均值</span></span><br><span class="line">        <span class="comment"># 将求得的均值[取整]</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centercolor[i])):  <span class="comment">#Columns</span></span><br><span class="line">            centercolor[i][j] = <span class="built_in">int</span>(centercolor[i][j])</span><br><span class="line">    <span class="keyword">return</span> centercolor</span><br></pre></td></tr></table></figure>
<p><strong>显示分割前后对比图程序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showImage</span>(<span class="params">imageRGB, centercolor, features, k, iteration</span>):</span></span><br><span class="line">    NewImage = np.empty((<span class="built_in">len</span>(features), <span class="built_in">len</span>(features[<span class="number">0</span>]), <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features[i])):</span><br><span class="line">            NewImage[i, j] = centercolor[features[i][j]]</span><br><span class="line">    <span class="comment"># 绘制图片</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&#x27;k=&#x27;</span>+<span class="built_in">str</span>(k)+<span class="string">&#x27;, iteration=&#x27;</span>+<span class="built_in">str</span>(iteration), fontsize=<span class="number">12</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    fig.gca().xaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">    fig.gca().yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图1: 绘制原图</span></span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    ax1.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    ax1.imshow(imageRGB / <span class="number">255</span>)</span><br><span class="line">    ax1.set_title(<span class="string">&#x27;Original image&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图2: 绘制分割图</span></span><br><span class="line">    ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ax2.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    ax2.imshow(NewImage / <span class="number">255</span>)</span><br><span class="line">    ax2.set_title(<span class="string">&#x27;Split graph&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示绘制图像</span></span><br><span class="line">    pylab.show()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="2-1-使用K-means算法对一副无噪图像进行分割完整主程序"><a href="#2-1-使用K-means算法对一副无噪图像进行分割完整主程序" class="headerlink" title="2.1. 使用K-means算法对一副无噪图像进行分割完整主程序"></a>2.1. 使用K-means算法对一副无噪图像进行分割完整主程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">#加载图片数据</span></span><br><span class="line">    imageRGB = getImageRGB(<span class="string">&#x27;picture.jpg&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Finish load image RGB data...&#x27;</span>)</span><br><span class="line">    <span class="comment">#设置集群数：k=3</span></span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    <span class="comment"># 生成k个随机像素点坐标</span></span><br><span class="line">    InitialCenter = initCentroids(imageRGB, k)</span><br><span class="line">    <span class="comment"># 计算样本中每个像素点与k个中心点的欧式距离，并重新分类</span></span><br><span class="line">    features = caclEucDistance(imageRGB, InitialCenter)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置k-means算法执行的最大迭代次数：iteration = 20</span></span><br><span class="line">    iteration = <span class="number">20</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;iteration = &#x27;</span>, i)</span><br><span class="line">        CalCentercolor = calNewCenter(features, imageRGB, k) <span class="comment"># 得到每个簇的均值</span></span><br><span class="line">        <span class="comment"># 根据簇中的新均值，并重新分簇</span></span><br><span class="line">        features = loopCaclEucDistance(imageRGB, CalCentercolor)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>+<span class="string">&#x27;Center[k] = &#x27;</span>, CalCentercolor, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#显示分割前后对比图</span></span><br><span class="line">    showImage(imageRGB, CalCentercolor, features, k, iteration)</span><br></pre></td></tr></table></figure>

<h2 id="2-2-K-means算法分割图片效果图"><a href="#2-2-K-means算法分割图片效果图" class="headerlink" title="2.2. K-means算法分割图片效果图"></a>2.2. K-means算法分割图片效果图</h2><h3 id="2-2-1-当最大迭代次数限制为20次时："><a href="#2-2-1-当最大迭代次数限制为20次时：" class="headerlink" title="2.2.1. 当最大迭代次数限制为20次时："></a>2.2.1. 当最大迭代次数限制为20次时：</h3><ul>
<li><p><strong>k&#x3D;3时的效果图如下</strong>：<br>（只用“平均后”的3种颜色替代原图）<br><img data-src="/../../../../uploads/DataMining_Kmeans_result_k=3_iteration=20.png" alt="iteration=20,k=3时的效果图"></p>
</li>
<li><p><strong>k&#x3D;8时的效果图如下</strong>：<br>（只用“平均后”的8种颜色替代原图）<br><img data-src="/../../../../uploads/DataMining_Kmeans_result_k=8_iteration=20.png" alt="iteration=20,k=8时的效果图"></p>
</li>
</ul>
<h3 id="2-2-2-当最大迭代次数限制为50次时："><a href="#2-2-2-当最大迭代次数限制为50次时：" class="headerlink" title="2.2.2. 当最大迭代次数限制为50次时："></a>2.2.2. 当最大迭代次数限制为50次时：</h3><ul>
<li><p><strong>k&#x3D;3时的效果图如下</strong>：<br>（只用“平均后”的3种颜色替代原图）<br><img data-src="/../../../../uploads/DataMining_Kmeans_result_k=3_iteration=50.png" alt="iteration=50,k=3时的效果图"></p>
</li>
<li><p><strong>k&#x3D;8时的效果图如下</strong>：<br>（只用“平均后”的8种颜色替代原图）<br><img data-src="/../../../../uploads/DataMining_Kmeans_result_k=8_iteration=50.png" alt="iteration=50,k=8时的效果图"></p>
</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>通过反复测试，得出在一定的迭代次数限制下，设置的种子数越多，图像分割越明显，细节越丰富；</li>
<li>在一定种子数范围内，最大迭代次数越多，图像分割效果并不一定更好。</li>
<li>并且程序的运行时间会随着集群k、最大迭代次数iteration的增加而增加。</li>
</ul>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待聚类图片</strong>：<a href="../../../../uploads/KmeansTestPicture.jpg">KmeansTestPicture.jpg</a><br><strong>源代码</strong>：<a href="../../../../uploads/kmeansPicture.py">kmeansPicture.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>PAM算法——数据挖掘</title>
    <url>/2018/10/26/DataMining_PAM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DataMining_PAM.png" class="full-image" />

<h1 id="1-实现PAM算法对部分含有高斯噪声的waveform数据集进行聚类"><a href="#1-实现PAM算法对部分含有高斯噪声的waveform数据集进行聚类" class="headerlink" title="1. 实现PAM算法对部分含有高斯噪声的waveform数据集进行聚类"></a>1. 实现PAM算法对部分含有高斯噪声的waveform数据集进行聚类</h1><h2 id="1-1-PAM算法简介"><a href="#1-1-PAM算法简介" class="headerlink" title="1.1. PAM算法简介"></a>1.1. PAM算法简介</h2><ul>
<li>PAM方法于1987年提出，用于l1范数和其他距离的工作。 </li>
<li>k-medoid是一种经典的聚类分割技术，它将n个对象的数据集聚为k个聚类，假设聚类的数量k是先验的。如果未知，则可以使用诸如轮廓的方法来确定k。 与k均值相比，它对噪声和异常值更具鲁棒性，因为它最小化了成对差异的总和，而不是欧几里德距离的平方和。</li>
<li>可以将medoid定义为群集的对象，其与群集中的所有对象的平均差异最小。即，它是群集中位于最中心的点（迭代选取最中心的点，而非Kmeans的中心计算值，抗噪声能力更强）。</li>
</ul>
<a id="more"></a>

<h2 id="1-2-编写Python程序实现PAM算法"><a href="#1-2-编写Python程序实现PAM算法" class="headerlink" title="1.2. 编写Python程序实现PAM算法"></a>1.2. 编写Python程序实现PAM算法</h2><p><strong>PAM算法主要分为以下步骤实现</strong>：</p>
<ul>
<li>S1. 随机生成 k 个 “种子” 作为中心点</li>
<li>S2. 将其余的对象划分至距离这k个类别中的最近的一个簇</li>
<li>S3. 计算此时损失值cost。计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost0</li>
<li>S4. 随机选择一个非中心对象Oi分别临时试替换k个簇中心对象中的一个，重新分簇，计算得到一个损失值cost</li>
<li>S5. 如果这个损失值cost小于S3中得到的cost0，则将这个最小损失值计算时对应的非中心点和中心点交换，更新cost0</li>
<li>S6. 重复S4~S6步骤，重复迭代直至收敛</li>
</ul>
<h2 id="1-3-对部分含有高斯噪声的waveform数据集进行聚类"><a href="#1-3-对部分含有高斯噪声的waveform数据集进行聚类" class="headerlink" title="1.3. 对部分含有高斯噪声的waveform数据集进行聚类"></a>1.3. 对部分含有高斯噪声的waveform数据集进行聚类</h2><h3 id="1-3-1-加载’waveform-noise-data’文件中的含噪声的数据"><a href="#1-3-1-加载’waveform-noise-data’文件中的含噪声的数据" class="headerlink" title="1.3.1. 加载’waveform-+noise.data’文件中的含噪声的数据"></a>1.3.1. 加载’waveform-+noise.data’文件中的含噪声的数据</h3><p>通过以下代码读取Waveform Database Generator (Version 2) Data Set中’waveform-+noise.data’文件内的所有数据，可看到数据的最后一列为类属性的标识号，由网页介绍可知,noise waveform数据规模为：5000 x 41，取含噪声waveform数据集的前500个数据样本进行聚类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 含噪声数据加载</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数据加载...\n&#x27;</span>)</span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;waveform.data&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, header=<span class="literal">None</span>, skiprows=<span class="number">0</span>, names=<span class="literal">None</span>) <span class="comment"># waveform.data</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-PAM算法对waveform数据集进行聚类"><a href="#1-3-2-PAM算法对waveform数据集进行聚类" class="headerlink" title="1.3.2. PAM算法对waveform数据集进行聚类"></a>1.3.2. PAM算法对waveform数据集进行聚类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PAM算法实现</span></span><br><span class="line"><span class="comment"># iteration:最大迭代次数，k:&#x27;种子&#x27;集群个数，data:待聚类数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PAM</span>(<span class="params">iteration, k, data</span>):</span></span><br><span class="line">    data_numSamples, data_dim = data.shape</span><br><span class="line">    <span class="comment"># print(data_numSamples, &#x27; &#x27;, data_dim)</span></span><br><span class="line"></span><br><span class="line">    data_new = copy.deepcopy(data)  <span class="comment"># 前40列存放数据，不可变。最后1列即第41列存放标签，标签列随着每次迭代而更新。</span></span><br><span class="line">    data_now = copy.deepcopy(data)  <span class="comment"># data_now用于存放中间过程的数据</span></span><br><span class="line"></span><br><span class="line">    center_point = np.random.choice(data_numSamples, k, replace=<span class="literal">False</span>)</span><br><span class="line">    center = data_new[center_point, :(data_dim-<span class="number">2</span>)]  <span class="comment"># 随机形成的k个中心，维度为（3，40）</span></span><br><span class="line"></span><br><span class="line">    distance = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    distance_now = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]  <span class="comment"># distance_now用于存放中间过程的距离</span></span><br><span class="line">    lost = np.ones([data_numSamples, k]) * <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 初始lost为维度为（numSamples，3）的无穷大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):  <span class="comment"># 首先完成第一次划分，即第一次根据距离划分所有点到k个类别中</span></span><br><span class="line">        distance[j] = np.sqrt(np.<span class="built_in">sum</span>(np.square(data_new[:, :(data_dim-<span class="number">2</span>)] - np.array(center[j])), axis=<span class="number">1</span>))</span><br><span class="line">    data_new[:, data_dim-<span class="number">1</span>] = np.argmin(np.array(distance), axis=<span class="number">0</span>)  <span class="comment"># data_new 的最后一列，即标签列随之改变，变为距离某中心点最近的标签，例如与第0个中心点最近，则为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):  <span class="comment"># 假设迭代n次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(k):  <span class="comment"># 每一次都要分别替换k=k个中心点，所以循环k次。这层循环结束即算出利用所有点分别替代k个中心点后产生的i个lost值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(data_numSamples):  <span class="comment"># 替换某个中心点时都要利用全部点进行替换，所以循环numSamples次。这层循环结束即算出利用所有点分别替换1个中心点后产生的numSamples个lost值</span></span><br><span class="line"></span><br><span class="line">                center_now = copy.deepcopy(center)  <span class="comment"># center_now用于存放中间过程的中心点</span></span><br><span class="line">                center_now[m] = data_now[l, :(data_dim-<span class="number">2</span>)]  <span class="comment"># 用第l个点替换第m个中心点</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):  <span class="comment"># 计算暂时替换1个中心点后的距离值</span></span><br><span class="line">                    distance_now[j] = np.sqrt(np.<span class="built_in">sum</span>(np.square(data_now[:, :(data_dim-<span class="number">2</span>)] - np.array(center_now[j])), axis=<span class="number">1</span>))</span><br><span class="line">                data_now[:, (data_dim-<span class="number">1</span>)] = np.argmin(np.array(distance),</span><br><span class="line">                                            axis=<span class="number">0</span>)  <span class="comment"># data_now的标签列更新，注意data_now时中间过程，所以这里不能选择更新data_new的标签列</span></span><br><span class="line"></span><br><span class="line">                lost[l, m] = (caclEucDistance(data_now[:, :(data_dim-<span class="number">2</span>)], center_now[data_now[:, (data_dim-<span class="number">1</span>)].astype(<span class="built_in">int</span>)]) \</span><br><span class="line">                              - caclEucDistance(data_now[:, :(data_dim-<span class="number">2</span>)], center[data_new[:, (data_dim-<span class="number">1</span>)].astype(</span><br><span class="line">                            <span class="built_in">int</span>)])).<span class="built_in">sum</span>()  <span class="comment"># 这里很好理解lost的维度为什么为numSamples*3了。lost[l,m]的值代表用第l个点替换第m个中心点的损失值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">min</span>(lost) &lt; <span class="number">0</span>:  <span class="comment"># lost意味替换代价，选择代价最小的来完成替换</span></span><br><span class="line">            index = np.where(np.<span class="built_in">min</span>(lost) == lost)  <span class="comment"># 即找到min(lost)对应的替换组合</span></span><br><span class="line">            index_l = index[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># index_l指将要替代某个中心点的候选点</span></span><br><span class="line">            index_m = index[<span class="number">1</span>][<span class="number">0</span>]  <span class="comment"># index_m指将要被替代的某个中心点，即用index_l来替代index_m</span></span><br><span class="line"></span><br><span class="line">        center[index_m] = data_now[index_l, :data_dim-<span class="number">2</span>]  <span class="comment"># 更新聚类中心</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            distance[j] = np.sqrt(np.<span class="built_in">sum</span>(np.square(data_now[:, :(data_dim-<span class="number">2</span>)] - np.array(center[j])), axis=<span class="number">1</span>))</span><br><span class="line">        data_new[:, (data_dim-<span class="number">1</span>)] = np.argmin(np.array(distance), axis=<span class="number">0</span>)  <span class="comment"># 更新参考矩阵,至此data_new的标签列得以更新，即完成了一次迭代</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> center ,data_new  <span class="comment"># 最后返回center：集群中心对象，data_new：其最后一列即为最终聚好的标签</span></span><br></pre></td></tr></table></figure>
<p>设置最大迭代次数teration &#x3D; 10, ‘种子’集群个数k &#x3D; 3,对提取的500个含有高斯噪声的waveform数据集分类结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">center</span><br><span class="line"> [[ <span class="number">1.24</span>  <span class="number">1.75</span>  <span class="number">3.09</span>  <span class="number">3.08</span>  <span class="number">3.39</span>  <span class="number">3.22</span>  <span class="number">5.38</span>  <span class="number">4.55</span>  <span class="number">3.24</span>  <span class="number">2.52</span>  <span class="number">2.66</span>  <span class="number">1.15</span></span><br><span class="line">   <span class="number">0.69</span>  <span class="number">0.43</span>  <span class="number">0.84</span>  <span class="number">0.11</span>  <span class="number">1.25</span>  <span class="number">0.64</span> -<span class="number">0.14</span>  <span class="number">0.78</span> -<span class="number">0.75</span> -<span class="number">0.02</span>  <span class="number">0.14</span>  <span class="number">0.97</span></span><br><span class="line">   <span class="number">0.95</span>  <span class="number">0.91</span>  <span class="number">0.06</span>  <span class="number">0.78</span>  <span class="number">0.27</span> -<span class="number">2.38</span> -<span class="number">0.38</span> -<span class="number">0.04</span> -<span class="number">1.44</span>  <span class="number">0.89</span> -<span class="number">1.91</span>  <span class="number">0.04</span></span><br><span class="line">   <span class="number">0.66</span> -<span class="number">0.05</span>  <span class="number">0.74</span>]</span><br><span class="line"> [ <span class="number">1.24</span>  <span class="number">0.32</span>  <span class="number">0.19</span>  <span class="number">1.38</span>  <span class="number">0.16</span>  <span class="number">3.28</span>  <span class="number">4.65</span>  <span class="number">4.72</span>  <span class="number">2.97</span>  <span class="number">5.05</span>  <span class="number">4.05</span>  <span class="number">3.99</span></span><br><span class="line">   <span class="number">3.17</span>  <span class="number">1.06</span>  <span class="number">0.36</span> -<span class="number">0.23</span> -<span class="number">0.22</span>  <span class="number">1.4</span>   <span class="number">1.33</span>  <span class="number">0.72</span>  <span class="number">0.63</span> -<span class="number">0.05</span>  <span class="number">0.45</span>  <span class="number">0.68</span></span><br><span class="line">  -<span class="number">0.19</span> -<span class="number">1.13</span> -<span class="number">0.76</span> -<span class="number">0.01</span>  <span class="number">0.81</span>  <span class="number">0.3</span>   <span class="number">1.81</span>  <span class="number">0.15</span>  <span class="number">0.89</span>  <span class="number">0.31</span>  <span class="number">1.11</span> -<span class="number">0.51</span></span><br><span class="line">   <span class="number">0.42</span>  <span class="number">0.52</span> -<span class="number">0.01</span>]</span><br><span class="line"> [ <span class="number">0.05</span>  <span class="number">0.27</span>  <span class="number">1.3</span>  -<span class="number">0.72</span> -<span class="number">0.6</span>   <span class="number">1.16</span>  <span class="number">1.29</span>  <span class="number">1.59</span>  <span class="number">0.54</span>  <span class="number">2.19</span>  <span class="number">3.77</span>  <span class="number">3.77</span></span><br><span class="line">   <span class="number">3.76</span>  <span class="number">4.55</span>  <span class="number">4.48</span>  <span class="number">3.07</span>  <span class="number">2.65</span>  <span class="number">1.12</span>  <span class="number">1.09</span>  <span class="number">0.47</span>  <span class="number">1.47</span>  <span class="number">0.72</span> -<span class="number">0.02</span>  <span class="number">1.14</span></span><br><span class="line">  -<span class="number">1.04</span>  <span class="number">1.16</span>  <span class="number">0.81</span>  <span class="number">1.63</span> -<span class="number">0.57</span>  <span class="number">0.33</span> -<span class="number">0.2</span>  -<span class="number">0.18</span>  <span class="number">0.2</span>  -<span class="number">0.22</span> -<span class="number">0.77</span>  <span class="number">0.05</span></span><br><span class="line">   <span class="number">0.03</span> -<span class="number">0.36</span>  <span class="number">0.96</span>]]</span><br><span class="line">[<span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span>]</span><br></pre></td></tr></table></figure>

<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>含高斯噪声文件</strong>：<a href="../../../../uploads/waveform-+noise.data">waveform-+noise.data</a><br><strong>源代码</strong>：<a href="../../../../uploads/pam.py">pam.py</a></p>
</div>

<h1 id="2-编写Python程序实现PAM算法并对一副噪声图像进行分割"><a href="#2-编写Python程序实现PAM算法并对一副噪声图像进行分割" class="headerlink" title="2. 编写Python程序实现PAM算法并对一副噪声图像进行分割"></a>2. 编写Python程序实现PAM算法并对一副噪声图像进行分割</h1><h2 id="2-1-加载含高斯噪声的图片的rgb数据"><a href="#2-1-加载含高斯噪声的图片的rgb数据" class="headerlink" title="2.1. 加载含高斯噪声的图片的rgb数据"></a>2.1. 加载含高斯噪声的图片的rgb数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImageRGB</span>(<span class="params">file</span>):</span></span><br><span class="line">    image = img.imread(file)</span><br><span class="line">    width, height, x = image.shape</span><br><span class="line">    <span class="comment"># 创建与照片像素规模同大小rgb列表，存rgb数据</span></span><br><span class="line">    rgb = np.zeros((width, height, x))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            rgb[i][j] = image[i, j]</span><br><span class="line">    <span class="keyword">return</span> rgb</span><br></pre></td></tr></table></figure>
<h2 id="2-2-随机生成k个种子，返回k个随机像素点坐标"><a href="#2-2-随机生成k个种子，返回k个随机像素点坐标" class="headerlink" title="2.2. 随机生成k个种子，返回k个随机像素点坐标"></a>2.2. 随机生成k个种子，返回k个随机像素点坐标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span>(<span class="params">imageRGB, k</span>):</span></span><br><span class="line">    center = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        x, y = random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">0</span>]), random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">1</span>])</span><br><span class="line">        center += [[x, y]]</span><br><span class="line">    <span class="keyword">return</span> center</span><br></pre></td></tr></table></figure>
<h2 id="2-3-随机选择一个非中心点Oi"><a href="#2-3-随机选择一个非中心点Oi" class="headerlink" title="2.3. 随机选择一个非中心点Oi"></a>2.3. 随机选择一个非中心点Oi</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseOneNoCenterSample</span>(<span class="params">imageRGB, centers</span>):</span></span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    isChooseACenterSampleFlag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span>(isChooseACenterSampleFlag):</span><br><span class="line">        isExist = <span class="literal">False</span></span><br><span class="line">        x, y = random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">0</span>]), random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 判断与k个中心 是否有重复样本,</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centers)):</span><br><span class="line">            <span class="keyword">if</span>(x==centers[k][<span class="number">0</span>] <span class="keyword">and</span> y==centers[k][<span class="number">1</span>]):</span><br><span class="line">                isExist = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">#若无重复，则退出while,并返回[x,y]</span></span><br><span class="line">        <span class="keyword">if</span>( isExist == <span class="literal">False</span> ):</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">#若重复则继续while</span></span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br></pre></td></tr></table></figure>
<h2 id="2-4-计算变量中每个像素点与k个中心点的欧式距离，并分簇"><a href="#2-4-计算变量中每个像素点与k个中心点的欧式距离，并分簇" class="headerlink" title="2.4. 计算变量中每个像素点与k个中心点的欧式距离，并分簇"></a>2.4. 计算变量中每个像素点与k个中心点的欧式距离，并分簇</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caclEucDistance</span>(<span class="params">imageRGB, centers</span>):</span></span><br><span class="line">    region = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">0</span>]): <span class="comment">#行</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">1</span>]): <span class="comment">#列</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centers)): <span class="comment">#计算k个像素点与k个中心点的欧式距离</span></span><br><span class="line">                dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(imageRGB[i, j] - imageRGB[centers[k][<span class="number">0</span>], centers[k][<span class="number">1</span>]])))</span><br><span class="line">                temp += [dist] <span class="comment">#添加到temp临时数组中</span></span><br><span class="line">            x.append(np.argmin(temp)) <span class="comment">#添加[i,j]像素距离k个‘种子’最小的距离于region</span></span><br><span class="line">        region.append(x)</span><br><span class="line">    <span class="keyword">return</span> region <span class="comment">#返回与数组同大小的最小欧式距离数组</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost"><a href="#2-5-计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost" class="headerlink" title="2.5. 计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost"></a>2.5. 计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcCost</span>(<span class="params">imageRGB, features, centers</span>):</span></span><br><span class="line">    cost = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">0</span>]): <span class="comment">#行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">1</span>]): <span class="comment">#列</span></span><br><span class="line">            dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(imageRGB[i, j] - imageRGB[centers[features[i][j]][<span class="number">0</span>], centers[features[i][j]][<span class="number">1</span>]])))</span><br><span class="line">            cost = cost + dist</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>
<h2 id="2-6-显示分割前后对比图程序"><a href="#2-6-显示分割前后对比图程序" class="headerlink" title="2.6. 显示分割前后对比图程序"></a>2.6. 显示分割前后对比图程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showImage</span>(<span class="params">imageRGB, centercolor, features, k, iteration</span>):</span></span><br><span class="line">    NewImage = np.empty((<span class="built_in">len</span>(features), <span class="built_in">len</span>(features[<span class="number">0</span>]), <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features[i])):</span><br><span class="line">            NewImage[i, j] = centercolor[features[i][j]]</span><br><span class="line">    <span class="comment"># 绘制图片</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&#x27;k=&#x27;</span>+<span class="built_in">str</span>(k)+<span class="string">&#x27;, iteration=&#x27;</span>+<span class="built_in">str</span>(iteration), fontsize=<span class="number">12</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    fig.gca().xaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">    fig.gca().yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图1: 绘制原图</span></span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    ax1.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    ax1.imshow(imageRGB / <span class="number">255</span>)</span><br><span class="line">    ax1.set_title(<span class="string">&#x27;Original image&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图2: 绘制分割图</span></span><br><span class="line">    ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ax2.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    ax2.imshow(NewImage / <span class="number">255</span>)</span><br><span class="line">    ax2.set_title(<span class="string">&#x27;Split graph&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示绘制图像</span></span><br><span class="line">    pylab.show()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="2-7-PAM算法对图片数据聚类实现"><a href="#2-7-PAM算法对图片数据聚类实现" class="headerlink" title="2.7. PAM算法对图片数据聚类实现"></a>2.7. PAM算法对图片数据聚类实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PAM</span>(<span class="params">imageRGB, features, centers</span>):</span></span><br><span class="line">    <span class="comment"># 计算初始cost0</span></span><br><span class="line">    cost0 = calcCost(imageRGB, features, centers)</span><br><span class="line">    <span class="comment"># print(&#x27;cost0=&#x27;, cost0)</span></span><br><span class="line">    <span class="comment"># 随机选择一个非中心点Oi</span></span><br><span class="line">    aNoCenterSample = chooseOneNoCenterSample(imageRGB, centers)</span><br><span class="line">    <span class="comment"># print(&#x27;Center = &#x27;, centers)</span></span><br><span class="line">    <span class="comment"># print(&#x27;aNoCenterSample = &#x27;, aNoCenterSample)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 替换该随机对象所属的第k个中心对象</span></span><br><span class="line">    belongsK = features[aNoCenterSample[<span class="number">0</span>]][aNoCenterSample[<span class="number">1</span>]]</span><br><span class="line">    TempCenters = centers</span><br><span class="line">    TempCenters[belongsK][<span class="number">0</span>] = aNoCenterSample[<span class="number">0</span>]  <span class="comment"># Rows下标</span></span><br><span class="line">    TempCenters[belongsK][<span class="number">1</span>] = aNoCenterSample[<span class="number">1</span>]  <span class="comment"># Columns下标</span></span><br><span class="line">    <span class="comment"># 重新分簇</span></span><br><span class="line">    TempFeatures = caclEucDistance(imageRGB, TempCenters)</span><br><span class="line">    <span class="comment"># 计算代价cost</span></span><br><span class="line">    Tempcost = calcCost(imageRGB, TempFeatures, TempCenters)</span><br><span class="line">    <span class="comment"># 比较替换后的 cost</span></span><br><span class="line">    <span class="keyword">if</span> (Tempcost &lt; cost0):</span><br><span class="line">        <span class="comment"># 若比最初损失值cost0小，则确认替换</span></span><br><span class="line">        centers = TempCenters</span><br><span class="line">        features = TempFeatures</span><br><span class="line">        cost0 = Tempcost</span><br><span class="line">    <span class="keyword">return</span> features, centers</span><br></pre></td></tr></table></figure>

<h2 id="2-8-使用PAM算法对一副有噪图像进行分割完整主程序"><a href="#2-8-使用PAM算法对一副有噪图像进行分割完整主程序" class="headerlink" title="2.8. 使用PAM算法对一副有噪图像进行分割完整主程序"></a>2.8. 使用PAM算法对一副有噪图像进行分割完整主程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">#加载图片数据</span></span><br><span class="line">    imageRGB = getImageRGB(<span class="string">&#x27;picture.jpg&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Finish load image RGB data...\n&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置集群数：k=3</span></span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    <span class="comment">#设置k-means算法执行的最大迭代次数：iteration = 20</span></span><br><span class="line">    iteration = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成k个随机像素点坐标，作为中心点</span></span><br><span class="line">    centers = initCentroids(imageRGB, k)</span><br><span class="line">    <span class="comment"># 计算样本中每个像素点与k个中心点的欧式距离，并根据距离分到最近簇</span></span><br><span class="line">    features = caclEucDistance(imageRGB, centers)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;PAM start...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;iteration = &#x27;</span>, i)</span><br><span class="line">        features, centers = PAM(imageRGB, features, centers) <span class="comment">#PAM迭代</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;Centers = &#x27;</span>, centers, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    centercolor = getCenterColor(imageRGB, centers, k)</span><br><span class="line">    <span class="comment">#显示分割前后对比图</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Show the Comparison images...&#x27;</span>)</span><br><span class="line">    showImage(imageRGB, centercolor, features, k, iteration)</span><br></pre></td></tr></table></figure>

<h2 id="2-9-PAM算法分割图片效果图"><a href="#2-9-PAM算法分割图片效果图" class="headerlink" title="2.9. PAM算法分割图片效果图"></a>2.9. PAM算法分割图片效果图</h2><h3 id="2-9-1-当最大迭代次数限制为10次时："><a href="#2-9-1-当最大迭代次数限制为10次时：" class="headerlink" title="2.9.1. 当最大迭代次数限制为10次时："></a>2.9.1. 当最大迭代次数限制为10次时：</h3><p><strong>k&#x3D;3时的效果图如下</strong>：<br><img data-src="/../../../../uploads/DataMining_Pam_result_k=3_iteration=10.png" alt="PAMiteration=10,k=3时的效果图"><br><strong>k&#x3D;8时的效果图如下</strong>：<br><img data-src="/../../../../uploads/DataMining_Pam_result_k=8_iteration=10.png" alt="PAMiteration=10,k=8时的效果图"></p>
<h3 id="2-9-2-当最大迭代次数限制为30次时："><a href="#2-9-2-当最大迭代次数限制为30次时：" class="headerlink" title="2.9.2. 当最大迭代次数限制为30次时："></a>2.9.2. 当最大迭代次数限制为30次时：</h3><p><strong>k&#x3D;3时的效果图如下</strong>：<br><img data-src="/../../../../uploads/DataMining_Pam_result_k=3_iteration=30.png" alt="PAMiteration=30,k=3时的效果图"><br><strong>k&#x3D;8时的效果图如下</strong>：<br><img data-src="/../../../../uploads/DataMining_Pam_result_k=8_iteration=30.png" alt="PAMiteration=30,k=8时的效果图"><br>通过反复运行测试，得出的结论基本与K-mean算法一致：在一定的迭代次数限制下，设置的种子数越多，图像分割越明显，细节越丰富；在一定种子数范围内，最大迭代次数越多，图像分割效果并不一定更好。并且程序的运行时间会随着集群k、最大迭代次数iteration的增加而增加。</p>
<h1 id="3-对比PAM算法与Kmeans算法"><a href="#3-对比PAM算法与Kmeans算法" class="headerlink" title="3. 对比PAM算法与Kmeans算法"></a>3. 对比PAM算法与Kmeans算法</h1><p>虽然经过反复测试运行代码，PAM与Kmeans算法对图片的分割效果与集群数k和最大迭代次数iteration的关系结论基本一致，总的来说PAM算法运行时间较长，复杂度也较高。但相比与K-means算法，PAM算法又有一定优势。由于选择的是中心对象而非平均值，所以如结果所示，受样本中的噪声的影响相对较小。</p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>含噪声图片</strong>：<a href="../../../../uploads/PamTestPicture.jpg">PamTestPicture.jpg</a><br><strong>源代码</strong>：<a href="../../../../uploads/pamPicture.py">pamPicture.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装及简单应用</title>
    <url>/2018/11/19/DockerSimpleUsing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/DockerSimpleUsing.png" class="full-image" />

<h1 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h1><h2 id="1-1-一键安装Docker"><a href="#1-1-一键安装Docker" class="headerlink" title="1.1. 一键安装Docker"></a>1.1. 一键安装Docker</h2><p>Manjaro系统下pacman命令一键安装Docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S docker</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="1-2-配置镜像加速器"><a href="#1-2-配置镜像加速器" class="headerlink" title="1.2. 配置镜像加速器"></a>1.2. 配置镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如:</p>
<ul>
<li>Docker 官方提供的中国 registry mirror <a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li>
<li>七牛云加速器 <a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com/</a></li>
</ul>
<h3 id="1-2-1-新建-x2F-etc-x2F-docker-x2F-daemon-json-文件"><a href="#1-2-1-新建-x2F-etc-x2F-docker-x2F-daemon-json-文件" class="headerlink" title="1.2.1. 新建 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件"></a>1.2.1. 新建 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">sudo vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-在文件中添加如下命令"><a href="#1-2-2-在文件中添加如下命令" class="headerlink" title="1.2.2. 在文件中添加如下命令"></a>1.2.2. 在文件中添加如下命令</h3><figure class="highlight plain"><figcaption><span>文件位置：/etc/docker/daemon.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-重新启动服务"><a href="#1-2-3-重新启动服务" class="headerlink" title="1.2.3. 重新启动服务"></a>1.2.3. 重新启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-检查加速器是否生效"><a href="#1-2-4-检查加速器是否生效" class="headerlink" title="1.2.4. 检查加速器是否生效"></a>1.2.4. 检查加速器是否生效</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>
<p>若最后有如下信息，则国内镜像服务（加速器）已生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure>

<h1 id="2-Docker简单应用"><a href="#2-Docker简单应用" class="headerlink" title="2. Docker简单应用"></a>2. Docker简单应用</h1><h2 id="2-1-运行hello-word小例子"><a href="#2-1-运行hello-word小例子" class="headerlink" title="2.1. 运行hello-word小例子"></a>2.1. 运行hello-word小例子</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>运行hello-world容器，尽管此时没有hello-world镜像，docker会自动拉取hello-world的镜像，然后运行hello-world容器。</p>
<h2 id="2-2-获取镜像"><a href="#2-2-获取镜像" class="headerlink" title="2.2. 获取镜像"></a>2.2. 获取镜像</h2><p>在 <a href="https://store.docker.com/">Docker Store</a> 上有非常多的高质量的官方镜像</p>
<h3 id="2-2-1-拉取Python镜像"><a href="#2-2-1-拉取Python镜像" class="headerlink" title="2.2.1. 拉取Python镜像"></a>2.2.1. 拉取Python镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull python:3.5</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-拉取Ubuntu16-04镜像"><a href="#2-2-2-拉取Ubuntu16-04镜像" class="headerlink" title="2.2.2. 拉取Ubuntu16.04镜像"></a>2.2.2. 拉取Ubuntu16.04镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-列出已经下载下来的镜像"><a href="#2-2-3-列出已经下载下来的镜像" class="headerlink" title="2.2.3. 列出已经下载下来的镜像"></a>2.2.3. 列出已经下载下来的镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image ls</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-删除镜像"><a href="#2-2-4-删除镜像" class="headerlink" title="2.2.4. 删除镜像"></a>2.2.4. 删除镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image rm [镜像名/镜像ID]</span><br></pre></td></tr></table></figure>

<h1 id="3-使用python镜像"><a href="#3-使用python镜像" class="headerlink" title="3. 使用python镜像"></a>3. 使用python镜像</h1><h2 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1. 准备工作"></a>3.1. 准备工作</h2><p>在宿主操作系统～目录下新建文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p DockerTest/Pythonapp <span class="comment">#新建Pythonapp文件夹</span></span><br><span class="line">touch helloworld.py <span class="comment">#创建 python程序文件</span></span><br></pre></td></tr></table></figure>
<p>helloworld.py 文件，代码如下：</p>
<figure class="highlight plain"><figcaption><span>文件位置：~/DockerTest/Pythonapp/helloworld.py</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    print(i， &#39; hello world!&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="3-2-运行容器"><a href="#3-2-运行容器" class="headerlink" title="3.2. 运行容器"></a>3.2. 运行容器</h2><p>跳转到上一目录~&#x2F;DockerTest，并执行以下命令运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -v <span class="variable">$PWD</span>/Pythonapp:/usr/src/Pythonapp -w /usr/src/Pythonapp python:3.5 python helloworld.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令说明：</span></span><br><span class="line"></span><br><span class="line">-v <span class="variable">$PWD</span>/Pythonapp:/usr/src/Pythonapp <span class="comment">#将主机中当前目录下的Pythonapp挂载到容器的/usr/src/Pythonapp</span></span><br><span class="line">-w /usr/src/Pythonapp <span class="comment">#指定容器的/usr/src/Pythonapp目录为工作目录</span></span><br><span class="line">python helloworld.py <span class="comment">#使用容器的python命令来执行工作目录中的helloworld.py文件</span></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> hello world!</span><br><span class="line"><span class="number">1</span> hello world!</span><br><span class="line"><span class="number">2</span> hello world!</span><br><span class="line"><span class="number">3</span> hello world!</span><br><span class="line"><span class="number">4</span> hello world!</span><br></pre></td></tr></table></figure>

<h1 id="4-使用Ubuntu16-04镜像"><a href="#4-使用Ubuntu16-04镜像" class="headerlink" title="4. 使用Ubuntu16.04镜像"></a>4. 使用Ubuntu16.04镜像</h1><h2 id="4-1-容器与宿主机对比"><a href="#4-1-容器与宿主机对比" class="headerlink" title="4.1. 容器与宿主机对比"></a>4.1. 容器与宿主机对比</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个Ubuntu16.04容器并在内运行bash</span></span><br><span class="line">sudo docker run -t -i ubuntu:16.04 /bin/bash</span><br><span class="line"><span class="comment"># 显示当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment"># 显示正在使用的内核版本</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="comment"># 显示Docker的进程</span></span><br><span class="line">ps a | grep docker</span><br></pre></td></tr></table></figure>
<p><img data-src="/../../../../uploads/DockerContainerAndHostComparison.png" alt="Docker容器&amp;宿主机对比"></p>
<p><strong>左图</strong>为Docker运行的Ubuntu16.04容器； <strong>右图</strong>为宿主操作系统</p>
<p><strong>分析</strong>：执行<strong>pwd</strong> (#显示当前目录)<strong>命令</strong>时可看到容器的当前目录为<code>/</code>，而非运行容器的宿主目录<code>~</code>；均跳转到根目录<code>/</code>后运行<code>ls</code>命令可看到容器与宿主操作系统有两套不同的文件系统。正如前面介绍的那样，Docker会虚拟一整套文件系统。</p>
<p><strong>分析</strong>：两边执行<code><strong>uname -r</strong></code>&gt;            # 显示正在使用的内核版本<strong>命令</strong>，两边内核版本一致，正如前面介绍的那样，Docker无模拟硬件，无内核。</p>
<h2 id="4-2-创建一个Ubuntu16-04容器并在内运行bash小程序"><a href="#4-2-创建一个Ubuntu16-04容器并在内运行bash小程序" class="headerlink" title="4.2. 创建一个Ubuntu16.04容器并在内运行bash小程序"></a>4.2. 创建一个Ubuntu16.04容器并在内运行bash小程序</h2><p>小程序功能：每隔一秒输出一次hello world</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run ubuntu:16.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>按 Ctrl + C 可退出小程序循环</p>
</div>

<h2 id="4-3-显示当前容器"><a href="#4-3-显示当前容器" class="headerlink" title="4.3. 显示当前容器"></a>4.3. 显示当前容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container ls <span class="comment">#显示当前正在运行的容器</span></span><br><span class="line">sudo docker container ls -a <span class="comment">#显示所有容器，包括终止状态的容器</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-清理所有处于终止状态的容器"><a href="#4-4-清理所有处于终止状态的容器" class="headerlink" title="4.4. 清理所有处于终止状态的容器"></a>4.4. 清理所有处于终止状态的容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container prune</span><br></pre></td></tr></table></figure>

<h1 id="5-Docker镜像、容器常用命令"><a href="#5-Docker镜像、容器常用命令" class="headerlink" title="5. Docker镜像、容器常用命令"></a>5. Docker镜像、容器常用命令</h1><h2 id="5-1-每次启动docker-重新启动服务"><a href="#5-1-每次启动docker-重新启动服务" class="headerlink" title="5.1. 每次启动docker 重新启动服务"></a>5.1. 每次启动docker 重新启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>##（容器对比）linux命令：<br>显示当前目录:                 pwd<br>显示正在使用的内核版本:        uname -r<br>显示Docker的进程：            ps a | grep docker</p>
<h2 id="5-2-从-Docker-镜像仓库获取镜像："><a href="#5-2-从-Docker-镜像仓库获取镜像：" class="headerlink" title="5.2. 从 Docker 镜像仓库获取镜像："></a>5.2. 从 Docker 镜像仓库获取镜像：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure>

<h2 id="5-3-列出本地镜像："><a href="#5-3-列出本地镜像：" class="headerlink" title="5.3. 列出本地镜像："></a>5.3. 列出本地镜像：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image ls</span><br></pre></td></tr></table></figure>

<h2 id="5-4-删除本地镜像："><a href="#5-4-删除本地镜像：" class="headerlink" title="5.4. 删除本地镜像："></a>5.4. 删除本地镜像：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>

<h1 id="6-容器-常用命令"><a href="#6-容器-常用命令" class="headerlink" title="6. 容器 常用命令"></a>6. 容器 常用命令</h1><h2 id="6-1-显示当前容器："><a href="#6-1-显示当前容器：" class="headerlink" title="6.1. 显示当前容器："></a>6.1. 显示当前容器：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container ls <span class="comment">#显示当前正在运行的容器</span></span><br><span class="line">sudo docker container ls -a <span class="comment">#显示所有状态的容器（包括终止状态的容器）</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-新建并启动"><a href="#6-2-新建并启动" class="headerlink" title="6.2. 新建并启动:"></a>6.2. 新建并启动:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -t -i ubuntu:16.04 /bin/bash <span class="comment"># 创建一个Ubuntu16.04容器并在内运行bash</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-后台运行容器-d-参数："><a href="#6-3-后台运行容器-d-参数：" class="headerlink" title="6.3. 后台运行容器 -d 参数："></a>6.3. 后台运行容器 -d 参数：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -d ubuntu:16.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span>    <span class="comment">#容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比缺少 -d 参数的运行容器</span></span><br><span class="line">sudo docker run ubuntu:16.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span>    <span class="comment">#容器会把输出的结果 (STDOUT) 打印到宿主机上面</span></span><br></pre></td></tr></table></figure>

<h2 id="6-4-终止容器："><a href="#6-4-终止容器：" class="headerlink" title="6.4. 终止容器："></a>6.4. 终止容器：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container stop [容器名/容器ID]</span><br></pre></td></tr></table></figure>
<p>例如对于上面中只启动了一个ubuntu:16.04终端的容器，用户通过 exit 命令或Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<h2 id="6-5-删除容器"><a href="#6-5-删除容器" class="headerlink" title="6.5. 删除容器"></a>6.5. 删除容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container rm [容器名/容器ID] <span class="comment">#删除一个处于终止状态的容器</span></span><br><span class="line">sudo docker container rm -f [容器名/容器ID] <span class="comment">#删除一个运行中的容器</span></span><br><span class="line">sudo docker container prune <span class="comment">#清理所有处于终止状态的容器</span></span><br></pre></td></tr></table></figure>

<h2 id="6-6-进入容器"><a href="#6-6-进入容器" class="headerlink" title="6.6. 进入容器"></a>6.6. 进入容器</h2><p>在使用 -d 参数时，容器启动后会进入后台。<br>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker attach [容器名/容器ID]</span><br><span class="line">sudo docker <span class="built_in">exec</span> -it [容器名/容器ID] bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#eg.</span></span><br><span class="line">sudo docker run -d ubuntu:16.04 <span class="comment">#后台运行ubuntu:16.04容器</span></span><br><span class="line">sudo docker container ls -a <span class="comment">#显示所有状态的容器（包括终止状态的容器）</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it [容器名/容器ID] bash <span class="comment">#进入ubuntu:16.04容器，并执行bash</span></span><br></pre></td></tr></table></figure>

<h2 id="6-7-导出和导入容器"><a href="#6-7-导出和导入容器" class="headerlink" title="6.7. 导出和导入容器"></a>6.7. 导出和导入容器</h2><h3 id="6-7-1-导出容器"><a href="#6-7-1-导出容器" class="headerlink" title="6.7.1. 导出容器"></a>6.7.1. 导出容器</h3><p>如果要导出本地某个容器，可以使用 docker export 命令，将导出容器快照到本地文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container ls -a <span class="comment">#显示所有状态的容器（包括终止状态的容器）</span></span><br><span class="line">sudo docker <span class="built_in">export</span> [容器名/容器ID] &gt; FileName.tar</span><br></pre></td></tr></table></figure>

<h3 id="6-7-2-导入容器快照"><a href="#6-7-2-导入容器快照" class="headerlink" title="6.7.2. 导入容器快照"></a>6.7.2. 导入容器快照</h3><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cat FileName.tar | docker import - <span class="built_in">test</span>/FileName:v1.0</span><br><span class="line">sudo docker image ls</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>高效地阅读文献--《文献检索与论文写作》</title>
    <url>/2017/03/25/Efficient-reading-of-the-literature/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/Efficient-reading-of-the-literature.jpg" class="full-image" />

<p>你是否时常苦于获取不到精确且优质的信息？据统计科研人员花费在文献阅读的时间占比总科研时间超过一半。在信息时代，如何从海量的数据中快速筛选出有用的信息已成为当代人的一项重要技能，博主收集了几项对高效地阅读文献、提升检索信息效率有积极作用的方法，或将提升信息检索的效率。</p>
<a id="more"></a>

<h1 id="1-勤加练习，养成习惯"><a href="#1-勤加练习，养成习惯" class="headerlink" title="1. 勤加练习，养成习惯"></a>1. <strong>勤加练习，养成习惯</strong></h1><p>据美国科学基金会统计，一个科研人员花费在*查找和消化科技资料上的时间需占全部科研时间的51%*，计划思考占8%，实验研究占32%,书面益结占9%,由这些统计数字可以看出，科研人员花费在科技文献出版物上的时间为全部科研时间的60%。作为科研工作者及相关高校师生，随时了解外界信息十分必要。在当前的信息时代，获取信息的途径和手段正在变得越来越容易，如何从海量的数据中查找、获取到与研究课题相关度高的文献，并高效地阅读文献、消化文献也变得越来越重要。</p>
<p>科研人员需要通过勤加练习，逐渐把阅读文献培养成一种习惯。阅读文献非常重要，从文献中可以看到前人的研究成果，站得高看得远；从文献中可以学习别人的工作，启迪思维，抛砖引玉。同时，阅读文献也是一个烦琐的工作，应日复一日，年复一年地阅读，不断积累自已研究领域所需要的阅读量以及形成新的研究点子，以促进科学研究的顺利进展。</p>
<h1 id="2-集中时间，研究经典"><a href="#2-集中时间，研究经典" class="headerlink" title="2. 集中时间，研究经典"></a>2. <strong>集中时间，研究经典</strong></h1><p>由于科学研究都有周期时间，阅读文献要集中时间，主要阅读与论文主题相关的文献。一个有用的<code>小技巧是：首先找出研究领域中那些最经典和研究前沿的文献</code>。例如：可以通过万方数据库，就某个研究领域进行知识脉络分析。根据其检索出来的图示结果，可以看出以论文发表情况为代表的本领域历年来的研究趋势情况，本领域的经典文献和研究前沿文献，以及相关学者的情况(发文数、被引、H指数等）。另外，还可以参考一些有用的书目，例如导师推荐的阅读书目列表、相关专业课程表等，这些可以让科研人员对研究领域有一个初步的印象。如果对自己研究的某个子领域感兴趣，则可以向该领域的前辈或专家请教本领域最重要的几篇论文是什么，如果允许的话，可以向其要求获取相关的文献。回顾最近几年的出版物，将那些非常感兴趣的复制下来。这不仅是由于其中很多都是意义重大的论文，对于研究工作进展也是很重要的。定期到学校的图书馆，翻阅其他院校出版的以及自己相关领域的技术报告，并选出自己感兴趣的仔细加以阅读，并注意归纳、整理资料与数据。</p>
<h1 id="3-阅读分析，注重技巧"><a href="#3-阅读分析，注重技巧" class="headerlink" title="3. 阅读分析，注重技巧"></a>3. <strong>阅读分析，注重技巧</strong></h1><p>一般来说，<code><strong>核心及重要期刊</strong></code>上的论文会<code>有比较多的创新、创意</code>。因此，虽然阅读起来比较累，但收获较多而深入，值得花心思去阅读分析。在阅读文献的第一阶段，总是习惯于从头到尾地阅读文献，看论文中是否有感兴趣的东西，这样的做法浪费时间而且看多了会迷失了当初的阅读目标。大多数论文完全可以通过查看题目和摘要来判断这篇论文和自己的研究有没有直接的关联，由此决定是否要把论文全部读完整。如果研究人员有能力只根据<strong>摘要和题目</strong>就能締选出其中最密切相关的几篇论文，其学术研究及做事的效率就会比其他人高出好几倍。再者，论文主要内容也不需要完全看懂。除了其中两三个关键公式以外，其他公式都可以看不懂。公式之间的推导工程也可以完全忽略。如果要看公式，重点是要看明白公式推导过程中引人的假设条件，而不是恒等式的转换。甚至有些论文通篇都可以粗略地跳跃式阅读，阅读时只要把觉得有需要的部分看明白，其他不需要的部分只要了解它的主要点子就可以了。</p>
<p>在看了大约30〜40篇文献后，将进入到下一个阶段—-<code>找出论文真正有价值的部分</code>。也就是把文献读薄的过程，不少二十多更的论文可以重新整理后形成一页左右的篇幅。从文献中找出那些真正对研究有作用的地方。论文作者从其工作中所发现的感兴趣的地方，未必是你感兴趣的，反之亦然。当然，如果觉得该论文确实有价值，则需要通篇甚至反复精读，务必理解论文。理解论文得到了什么结论并不等同于理解了该论文。理解论文，就要了解论义的目的，作者所做的选择，假设和形式化是否可行，论文指出了怎样的方向，论文所涉及领域都有哪些问题，作者的研究中持续出现的难点模式是什么，论文所丧达的策略观点是什么，诸如此类。当阅读文献达到了对本研究领域的主要内容、主要方法、文献之间的关系等相肖熟练之后，就表示已经基本掌握了本领域主要的论文。</p>
<h1 id="4-科研利器，助力科研"><a href="#4-科研利器，助力科研" class="headerlink" title="4. 科研利器，助力科研"></a>4. <strong>科研利器，助力科研</strong></h1><p>主要指在科研选题、思路整理、文献管理、论文撰写过程中比较好用的相关软件。</p>
<h2 id="4-1-思路整理或知识管理的工具软件"><a href="#4-1-思路整理或知识管理的工具软件" class="headerlink" title="4.1. 思路整理或知识管理的工具软件"></a>4.1. 思路整理或知识管理的工具软件</h2><p>代表性工具软件包括：<code>EverNote</code>、<code>有道云笔记</code>、<code>one Note</code>、<code>为知笔记</code>等。这几款软件各有千秋，用户可以按个人使用巧惯来选择使用。</p>
<ul>
<li><code><strong>EverNote</strong></code>就是Logo是一个大象标志的印象笔记，是目前较为火热的笔记软件之一，除了可以处理常规的文字信息外，还可以记录语音、阁片等，好处就在于一处编辑，多平台之间可以同步，还有网页剪辑功能，让科研人员可以随时随地记录并收藏好的idea</li>
<li><code><strong>有道云笔记</strong></code>功能与其类似，是网易旗下的有道推出的产品，使用时所占内存会比EverNote小一些，而且重要的是上手快，操作起来更贴近中国人习惯，可随手记录下Idea。也支持多平台同步，可以实现实时增量式同步。缺点在于需要定期整理，否则存储内容会过于杂乱</li>
<li><code>one Note</code>作为一款收集笔记和信息的软件，功能强大。它提供了一种灵活的方式，将文本、图片、数字手写墨迹、录音和录像等信息全部收集并组织到计算机上的一个数字笔记本中。但是one Note不少扩展功能是要收费的，同时由于对系统内存的占用比较大，还可能会出现运行速度慢等现象</li>
</ul>
<h2 id="4-2-文献生产和管理工具软件"><a href="#4-2-文献生产和管理工具软件" class="headerlink" title="4.2. 文献生产和管理工具软件"></a>4.2. <strong>文献</strong>生产和管理工具软件</h2><p>代表性工具软件包括：<code>NoteExpress</code>、<code>NoteFirst</code>、<code>EndNote</code>等。这几款软件各有千秋，用户可以按个人使用习惯来选择使用。</p>
<ul>
<li><code><strong>NoteExpress</strong></code>是国内主流的文献管理软件，其核心功能包括知识采集、管理、应用、挖掘等知识管理的几乎所有的环节，可以有效推进学术研究，知识管理</li>
<li><code><strong>NoteFirst</strong></code>于2009年年底正式发布，是国内唯一的网络版文献管理软件。针对个人用户，它集成了文献收集与管理，论文参考文献的自动生成，参考文献自动校对等功能，支持多种其他软件的文件格式；针对学术性困队，它推出了团队科研协作的功能，帮助科研团队收集和管理知识，实现科研文献管理和开放存取、科研资源交流共享相结合，由此更好地管理团队以及促进团队成长</li>
<li><code><strong>EndNote</strong></code>支持国际期刊的参考文献格式有3776 种，写作模板几百种，涵盖各个领域的杂志，可以方便地使用这些格式和模板。还具有管理文献、在线搜索文献、建立文献库和图片库、定制文稿、引文编排等主要功能</li>
</ul>
<h1 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h1><ul>
<li>《文献检索与论文写作》</li>
</ul>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>以太帧与MAC</title>
    <url>/2021/07/23/EthernetAndMac/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-以太网数据帧结构"><a href="#1-以太网数据帧结构" class="headerlink" title="1. 以太网数据帧结构"></a>1. 以太网数据帧结构</h1><h2 id="1-1-802-3-Type-以太帧数据结构（又称-Ethernet-II-封装，目前使用最广泛）："><a href="#1-1-802-3-Type-以太帧数据结构（又称-Ethernet-II-封装，目前使用最广泛）：" class="headerlink" title="1.1. 802.3 Type 以太帧数据结构（又称 Ethernet II 封装，目前使用最广泛）："></a>1.1. 802.3 Type 以太帧数据结构（又称 Ethernet II 封装，目前使用最广泛）：</h2><a id="more"></a>

<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>字段名</th>
        <th>字段长度(Bytes)</th>
        <th>说明</th>
    </tr>
    <tr>
        <td align="center">Preamble</td>
        <td align="center">7</td>
        <td>与SFD共同构成前导码，内容为"101010..."1和0交替，通知接收方有数据帧到来；<br>同时同步时钟</td>
    <tr>
        <td align="center">SFD</td>
        <td align="center">1</td>
        <td>与Preamble共同构成前导码，内容为0xAB，标识下一字段为目的MAC；<br>物理层添加，非帧的一部分</td>
    </tr>
    <tr>
        <td align="center">DA</td>
        <td align="center">6</td>
        <td>目的MAC地址</td>
    </tr>
    <tr>
        <td align="center">SA</td>
        <td align="center">6</td>
        <td>源MAC地址</td>
    </tr>
    <tr>
        <td align="center">Type/Length</td>
        <td align="center">2</td>
        <td>若取值为0x0000 ~ 0x05DC，表示字段长度（0x05DC = 1500）；<br>若取值为0x0600 ~ 0xFFFF，表示该字段为Type</td>
    </tr>
    <tr>
        <td align="center">Payload</td>
        <td align="center">46 ~ 1500</td>
        <td>有效负荷（帧携带数据）</td>
    </tr>
    <tr>
        <td align="center">FCR</td>
        <td align="center">4</td>
        <td>校验和</td>
    </tr>
</table>

<p>除上述Ethernet II封装格式外，以太网还有如下几种封装格式：</p>
<h2 id="1-2-802-3-x2F-802-2-LLC封装"><a href="#1-2-802-3-x2F-802-2-LLC封装" class="headerlink" title="1.2. 802.3&#x2F;802.2 LLC封装"></a>1.2. 802.3&#x2F;802.2 LLC封装</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>字段名</th>
        <th>DA</th>
        <th>SA</th>
        <th>Length</th>
        <th>DSAP</th>
        <th>SSAP</th>
        <th>Ctrl</th>
        <th>Data</th>
    </tr>
    <tr>
        <td>字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">2</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">46 ~ 1500</td>
    </tr>
</table>

<p>DSAP、SSAP用来标志上层协议，eg.NetBios时均为0xF0, IPX时均为0xE0</p>
<h2 id="1-3-802-3-x2F-802-2-SNAP封装"><a href="#1-3-802-3-x2F-802-2-SNAP封装" class="headerlink" title="1.3. 802.3&#x2F;802.2 SNAP封装"></a>1.3. 802.3&#x2F;802.2 SNAP封装</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>字段名/固定内容</th>
        <th>DA</th>
        <th>SA</th>
        <th>Length</th>
        <th>0xAA</th>
        <th>0xAA</th>
        <th>0x03</th>
        <th>Org Code</th>
        <th>PID</th>
        <th>Data</th>
    </tr>
    <tr>
        <td>字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">2</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">3</td>
        <td align="center">2</td>
        <td align="center">46 ~ 1500</td>
    </tr>
</table>

<p>Org Code代表机构编码；PID为协议标志，很少使用</p>
<h2 id="1-4-802-3-x2F-802-2-SNAP-RFC-1042封装"><a href="#1-4-802-3-x2F-802-2-SNAP-RFC-1042封装" class="headerlink" title="1.4. 802.3&#x2F;802.2 SNAP RFC 1042封装"></a>1.4. 802.3&#x2F;802.2 SNAP RFC 1042封装</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>字段名/固定内容</th>
        <th>DA</th>
        <th>SA</th>
        <th>Length</th>
        <th>0xAA</th>
        <th>0xAA</th>
        <th>0x03</th>
        <th>00-00-00</th>
        <th>Type</th>
        <th>Data</th>
    </tr>
    <tr>
        <td>字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">2</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">3</td>
        <td align="center">2</td>
        <td align="center">46 ~ 1500</td>
    </tr>
</table>

<p>一般说SNAP封装都指SNAP RFC1042封装</p>
<p>IP协议支持两种封装（<strong>Ethernet II</strong> 和 <strong>SNAP RFC1042</strong>封装，Type均为<strong>0x0800</strong>）。</p>
<h1 id="2-MAC地址简介"><a href="#2-MAC地址简介" class="headerlink" title="2. MAC地址简介"></a>2. MAC地址简介</h1><p>MAC（Media Access Control）地址，是OSI模型第二层（数据链路层）数据包转发的依据，一个MAC地址有6字节，足以标识281万亿台设备，一般联网设备在出厂时会打上具有唯一标识的物理MAC地址。</p>
<h2 id="2-1-MAC地址应用"><a href="#2-1-MAC地址应用" class="headerlink" title="2.1. MAC地址应用"></a>2.1. MAC地址应用</h2><p>上文介绍了传输中的以太网数据帧的各类封装结构，它们都包含一个目的MAC地址和一个源MAC地址，它的作用是标志帧的源节点和目的节点的<strong>物理地址</strong>。一个MAC地址有48bit（<strong>6个字节</strong>），从应用上可以分为<strong>单播地址</strong>、<strong>组播地址</strong>、<strong>广播地址</strong>：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>地址类型</th>
        <th>格式</th>
        <th>示例</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>单播地址</td>
        <td>第1字节的最低位为0</td>
        <td>00-AA-AA-AA-AA-AA</td>
        <td>用于标志唯一的设备</td>
    </tr>
    <tr>
        <td>组播地址</td>
        <td>第1字节的最低位为1</td>
        <td>01-BB-BB-BB-BB-BB</td>
        <td>用于标志同属一组的多个设备</td>
    </tr>
    <tr>
        <td>广播地址</td>
        <td>所有bit全为1</td>
        <td>FF-FF-FF-FF-FF-FF</td>
        <td>用于标志同一网段的所有设备</td>
    </tr>
</table>


<h1 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3. 参考文献"></a>3. 参考文献</h1><ul>
<li>《H3C网络之路第六期——交换专题》</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进程执行Shell命令问题总结</title>
    <url>/2020/06/15/ExecShellCMD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/execShellCMD.jpg" class="full-image" />

<p>在大部分Java开发过程中需要调用一些Shell脚本命令来实现某些功能，如：文本处理过程中调脚本使开发更便捷、其他组件只提供了Shell脚本调用方式或调脚本与系统直接交互等场景。<br>博主总结了一些Java进程执行Shell命令的常见问题及解决方法，或能在大家开发过程中避坑有积极作用。</p>
<p>关键词: Java调Shell、问题总结</p>
<a id="more"></a>

<h1 id="1-“No-such-file-or-directory”问题的原因分析及解决方法"><a href="#1-“No-such-file-or-directory”问题的原因分析及解决方法" class="headerlink" title="1. “No such file or directory”问题的原因分析及解决方法"></a>1. “No such file or directory”问题的原因分析及解决方法</h1><h2 id="1-1-若执行的是Shell脚本文件，可能是由于执行脚本的换行符不正确导致的"><a href="#1-1-若执行的是Shell脚本文件，可能是由于执行脚本的换行符不正确导致的" class="headerlink" title="1.1. 若执行的是Shell脚本文件，可能是由于执行脚本的换行符不正确导致的"></a>1.1. 若执行的是Shell脚本文件，可能是由于执行脚本的换行符不正确导致的</h2><p><strong>原因分析：</strong>文件明明存在但Java仍然报“No such file or directory”，可能由于Linux与Windows系统字符差异（主要是换行符\n,\r\n）导致的，即待执行脚本文件的换行符为\r\n，导致win下编写的脚本文件无法被在Linux环境中Java执行，而报“No such file or directory”IO异常。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li><p>重新在Windows上用文本编辑器改好格式后上传到Linux服务器再执行（简单直观）<br>在Windows上用文本编辑器(eg.VS code、Notepad++)打开脚本，更改右下角的行位序列: CRLF –&gt; LF，保存。将改好的脚本文件Sftp上传到Linux后重新执行。</p>
</li>
<li><p>若觉得从Windows到Linux上传太折腾，也可通过vim更改字符格式（dos -&gt; unix），在Linux环境上用vim去掉多出的’\r’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim查看文本格式，确定脚本文档格式（dos(Windows)--\r\n; unix(Linux)--\n）</span></span><br><span class="line">:set ff</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim查看不可见字符，确认脚本结尾字符问题</span></span><br><span class="line">:set invlist</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式1：命令行模式<span class="built_in">set</span> fileformat(推荐)</span></span><br><span class="line">:set fileformat=unix</span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式2：删除多的\r字符（下方替换命令没写错，用/r）</span></span><br><span class="line">:%s//r//g</span><br></pre></td></tr></table></figure>
</li>
<li><p>若需要修改多个脚本文件格式，也可通过dos2unix命令批量修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo find YourScriptsDir/ -name &quot;*.sh&quot; | xargs dos2unix</span><br><span class="line">可选参数备注：</span><br><span class="line">-k：保持输出文件的日期不变 </span><br><span class="line">-q：安静模式，不提示任何警告信息</span><br><span class="line">-V：查看版本</span><br><span class="line">-c：转换模式，模式有：ASCII, 7bit, ISO, Mac, 默认是：ASCII</span><br><span class="line">-o：写入到源文件</span><br><span class="line">-n：写入到新文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-手动在bash中能够执行，但Java中调用Shell却报“No-such-file-or-directory”"><a href="#1-2-手动在bash中能够执行，但Java中调用Shell却报“No-such-file-or-directory”" class="headerlink" title="1.2. 手动在bash中能够执行，但Java中调用Shell却报“No such file or directory”"></a>1.2. 手动在bash中能够执行，但Java中调用Shell却报“No such file or directory”</h2><p><strong>原因分析：</strong>Java在调用Shell的时候，默认是用在系统的&#x2F;bin&#x2F;目录下的指令（不加载环境变量），可能是找不到命令的路径。如：要用Java执行Shell命令为”node helloworld.js”，可能是不能识别”node”这个命令。<br><strong>解决方法：</strong>在&#x2F;bin&#x2F;目录下创所调用命令软链接 或 用命令全路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建所调用命令软链接到/bin/目录</span></span><br><span class="line">ln -s /home/admin/node/bin/node node;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  或调用时用node的绝对地址</span></span><br><span class="line">/home/admin/node/bin/node helloworld.js</span><br></pre></td></tr></table></figure>

<h2 id="1-3-若脚本文件换行符正确、有脚本执行权限，无命令识别问题，却依然无法执行shell"><a href="#1-3-若脚本文件换行符正确、有脚本执行权限，无命令识别问题，却依然无法执行shell" class="headerlink" title="1.3. 若脚本文件换行符正确、有脚本执行权限，无命令识别问题，却依然无法执行shell"></a>1.3. 若脚本文件换行符正确、有脚本执行权限，无命令识别问题，却依然无法执行shell</h2><p><strong>原因分析：</strong>推测可能是在调用Runtime.getRuntime().exec(“CMD”)时，传递Shell命令字符串的某个实现环节出了问题。<br><strong>解决方法：</strong>实例化一个数据输出流，通过dataoutputstream对象的写字节方法往process写待执行的Shell命令字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line">Process process = <span class="keyword">null</span>;</span><br><span class="line">DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime().exec(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">    dataOutputStream = <span class="keyword">new</span> DataOutputStream(process.getOutputStream());</span><br><span class="line">    dataOutputStream.writeBytes(command + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    dataOutputStream.writeBytes(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">    dataOutputStream.flush();</span><br><span class="line">    readStdStream(process);</span><br><span class="line">    resultValue = process.waitFor();</span><br><span class="line">    System.out.println(<span class="string">&quot;resultValue = &quot;</span> + resultValue);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        process.destroy();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-脚本无执行权限问题及解决方法"><a href="#2-脚本无执行权限问题及解决方法" class="headerlink" title="2. 脚本无执行权限问题及解决方法"></a>2. 脚本无执行权限问题及解决方法</h1><p><strong>原因分析：</strong>Java执行某些程序解压的脚本，因没及时赋权限导致无法执行<br><strong>解决方法：</strong>Java中调用shell命令赋权</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(<span class="string">&quot;/bin/chmod&quot;</span>, <span class="string">&quot;a+x&quot;</span>, shFile.getPath());</span><br><span class="line">Process process = processBuilder.start();</span><br><span class="line"><span class="keyword">int</span> exitValue = process.waitFor();</span><br></pre></td></tr></table></figure>

<h1 id="3-Java进程阻塞-一直等待Shell返回-问题及解决方法"><a href="#3-Java进程阻塞-一直等待Shell返回-问题及解决方法" class="headerlink" title="3. Java进程阻塞(一直等待Shell返回)问题及解决方法"></a>3. Java进程阻塞(一直等待Shell返回)问题及解决方法</h1><p><strong>原因分析：</strong>调用Shell命令后Java业务进程阻塞，根因是在执行的Shell脚本中含print或echo输出，未能读取缓存区导致缓存区用尽。<br><strong>解决方法：</strong>及时将标准输出流和错误流读取出来，也方便后续问题定位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String readLine;</span><br><span class="line">BufferedReader stdInput = <span class="keyword">null</span>;</span><br><span class="line">BufferedReader stdError = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取Shell进程标准输出流</span></span><br><span class="line">    stdInput = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">    <span class="keyword">while</span> ((readLine = stdInput.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[stdInputStream]:&quot;</span> + readLine);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取Shell进程标准错误流</span></span><br><span class="line">    stdError = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">    <span class="keyword">while</span> ((readLine = stdError.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[stdErrorStream]:&quot;</span> + readLine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stdInput.close();</span><br><span class="line">        stdError.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-附录：简易的Java执行Shell命令类"><a href="#4-附录：简易的Java执行Shell命令类" class="headerlink" title="4. 附录：简易的Java执行Shell命令类"></a>4. 附录：简易的Java执行Shell命令类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecShellCMD</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java执行shell命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">execShellCommand</span><span class="params">(<span class="keyword">final</span> String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line">        Process process = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process = Runtime.getRuntime().exec(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">            dataOutputStream = <span class="keyword">new</span> DataOutputStream(process.getOutputStream());</span><br><span class="line">            dataOutputStream.writeBytes(command + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            dataOutputStream.writeBytes(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">            dataOutputStream.flush();</span><br><span class="line">            readStdStream(process);</span><br><span class="line">            resultValue = process.waitFor();</span><br><span class="line">            System.out.println(<span class="string">&quot;resultValue = &quot;</span> + resultValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">                process.destroy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取Shell进程标准输出流和错误流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> process</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readStdStream</span><span class="params">(<span class="keyword">final</span> Process process)</span> </span>&#123;</span><br><span class="line">        String readLine;</span><br><span class="line">        BufferedReader stdInput = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader stdError = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取Shell进程标准输出流</span></span><br><span class="line">            stdInput = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> ((readLine = stdInput.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;[stdInputStream]:&quot;</span> + readLine);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 读取Shell进程标准错误流</span></span><br><span class="line">            stdError = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">            <span class="keyword">while</span> ((readLine = stdError.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;[stdErrorStream]:&quot;</span> + readLine);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;close std stream&quot;</span>);</span><br><span class="line">                stdInput.close();</span><br><span class="line">                stdError.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java exec shell command running...&quot;</span>);</span><br><span class="line">        String command = <span class="string">&quot;/home/admin/node/bin/node helloworld.js&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (times &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                times = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;\nNo.&quot;</span> + (++times) + <span class="string">&quot; times to exec shell command...&quot;</span>);</span><br><span class="line">            execShellCommand(command);</span><br><span class="line">            <span class="comment">// 进程等待10s</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 实用命令记录</title>
    <url>/2021/07/24/GitUsefullCmd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/gitRevert.jpg" style="zoom:45%;"  />

<p>记录Git生僻进阶用法，以备不时之需</p>
<a id="more"></a>

<p>常用基础命令速查：<br><img data-src="../../../../uploads/gitUsuallyUseCmd.png" style="zoom:35%;" /></p>
<h1 id="1-Git-实用命令记录"><a href="#1-Git-实用命令记录" class="headerlink" title="1. Git 实用命令记录"></a>1. Git 实用命令记录</h1><h2 id="1-1-Git-取出暂存区文件（保留文件更改）"><a href="#1-1-Git-取出暂存区文件（保留文件更改）" class="headerlink" title="1.1. Git 取出暂存区文件（保留文件更改）"></a>1.1. Git 取出暂存区文件（保留文件更改）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将缓存区中文件取出到工作区，保留文件变更</span></span><br><span class="line">git checkout -- file_path</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不保留文件变更</span></span><br><span class="line">git reset HEAD file_path</span><br></pre></td></tr></table></figure>

<h2 id="1-2-Git-取消对某个文件的跟踪"><a href="#1-2-Git-取消对某个文件的跟踪" class="headerlink" title="1.2. Git 取消对某个文件的跟踪"></a>1.2. Git 取消对某个文件的跟踪</h2><p>PS: 解决 .gitignore 文件对已跟踪的文件失效问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出需要取消跟踪的文件（未执行，检查）</span></span><br><span class="line">git rm -r -n --cached &lt;文件或目录&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消（不想跟踪文件）的缓存</span></span><br><span class="line">git rm -r --cached &lt;文件或目录&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改根目录 .gitignore 文件，添加</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-丢弃文件修改（恢复文件）"><a href="#1-3-丢弃文件修改（恢复文件）" class="headerlink" title="1.3. 丢弃文件修改（恢复文件）"></a>1.3. 丢弃文件修改（恢复文件）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout HEAD file_path</span><br></pre></td></tr></table></figure>

<h2 id="1-4-克隆子模块"><a href="#1-4-克隆子模块" class="headerlink" title="1.4. 克隆子模块"></a>1.4. 克隆子模块</h2><p>默认不会在 clone 时下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h2 id="1-5-统计代码提交行数"><a href="#1-5-统计代码提交行数" class="headerlink" title="1.5. 统计代码提交行数"></a>1.5. 统计代码提交行数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --author=&quot;user&quot; --since==2000-01.01 --pretty=tformat: --numstat | gawk &#x27;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s removed lines : %s total lines: %s\n&quot;,add,subs,loc &#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-提取当前-commit-到指定-commit-之前的所有提交"><a href="#1-6-提取当前-commit-到指定-commit-之前的所有提交" class="headerlink" title="1.6. 提取当前 commit 到指定 commit 之前的所有提交"></a>1.6. 提取当前 commit 到指定 commit 之前的所有提交</h2><blockquote>
<p>每此 commit 生成一个 *.patch 补丁文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git format-patch 上一提交 ID</span><br><span class="line">git format-patch b6c3a8bf</span><br></pre></td></tr></table></figure>

<h2 id="1-7-补丁文件的制作、安装与取消"><a href="#1-7-补丁文件的制作、安装与取消" class="headerlink" title="1.7. 补丁文件的制作、安装与取消"></a>1.7. 补丁文件的制作、安装与取消</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成差异文件（补丁）</span></span><br><span class="line">git diff -- filepath &gt; differences.patch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打补丁</span></span><br><span class="line">git apply differences.patch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消补丁</span></span><br><span class="line">git reset -hard HEAD</span><br></pre></td></tr></table></figure>

<h2 id="1-8-cherry-pick"><a href="#1-8-cherry-pick" class="headerlink" title="1.8. cherry pick"></a>1.8. cherry pick</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -x 参数：在提交信息的末尾追加一行 (cherry picked from commit ...)</span></span><br><span class="line">git cherry-pick -e -x &lt;commit_id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-分支更名"><a href="#1-9-分支更名" class="headerlink" title="1.9. 分支更名"></a>1.9. 分支更名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m 原名 新名</span><br></pre></td></tr></table></figure>

<h2 id="1-10-忽略部分本地修改"><a href="#1-10-忽略部分本地修改" class="headerlink" title="1.10. 忽略部分本地修改"></a>1.10. 忽略部分本地修改</h2><p>eg. 个人定制 IDE 或者 Build 工具的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Git 忽略本地对这个文件的所有修改</span></span><br><span class="line">git update-index --skip-worktree /path/to/file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复</span></span><br><span class="line">git update-index --no-skip-worktree /path/to/file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看被忽略的文件项目</span></span><br><span class="line">git ls-files -v | grep -E -i /path/to/file</span><br><span class="line">git ls-files -v | Select-String -Pattern /path/to/file</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li><a href="https://mengqi92.github.io/2020/07/17/hide-files-from-git/">Git 四种忽略本地文件修改的方法对比</a>：<ul>
<li><a href="https://git-scm.com/docs/gitignore">gitignore 文件</a></li>
<li>.git&#x2F;info&#x2F;exclude 文件</li>
<li><a href="https://www.git-scm.com/docs/git-update-index">git update-index –assume-unchanged</a></li>
<li><a href="https://www.git-scm.com/docs/git-update-index">git update-index –skip-worktree</a></li>
</ul>
</li>
</ul>
<h2 id="1-11-对比指定文件在本地分支与远端分支的差异"><a href="#1-11-对比指定文件在本地分支与远端分支的差异" class="headerlink" title="1.11. 对比指定文件在本地分支与远端分支的差异"></a>1.11. 对比指定文件在本地分支与远端分支的差异</h2><p><b><font color="#7E3D76" style="">1. 对比指定【单个文件】在【本地分支与远端】分支的差异</font></b></p>
<p>可以识别到暂存区中未提交的修改（其他跨分支的比较均无法识别暂存区中未提交的修改）。</p>
<p>前置条件：本地当前分支在远端有相对应分支。</p>
<p>示例代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat -- src/file1.cpp src/file1.cpp</span><br></pre></td></tr></table></figure>

<p>–stat 参数作用：显示简要信息（精度到文件），默认 diff 会显示精度到行的差异信息</p>
<p>只需填写需对比的文件路径分别在本地和远端分支各自的地址即可，第一个路径为本地文件地址，第二个路径为远端仓库文件地址（此示例两文件路径相同）</p>
<p><b><font color="#7E3D76" style="">2. 对比指定的多个文件在两分支间的差异</font></b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat master dev  -- file1.md src/file2.java</span><br></pre></td></tr></table></figure>

<h2 id="1-12-对比俩分支文件差异"><a href="#1-12-对比俩分支文件差异" class="headerlink" title="1.12. 对比俩分支文件差异"></a>1.12. 对比俩分支文件差异</h2><p><b><font color="#7E3D76" style="">1. 对比【本地两分支】差异</font></b></p>
<p>比较本地 master 和 dev 分支所有文件的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat master dev</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">2. 对比【本地两分支】差异（限定文件）</font></b></p>
<p>只比较关注的指定文件，在本地 master 和 dev 分支的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat master dev -- filepath1 filepath2 filepath3</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">3. 对比【本地分支与远端分支】差异</font></b></p>
<p>比较本地 dev 分支和远端 master 分支所有文件的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat dev origin/master</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">4. 对比【本地分支与远端分支】差异（限定文件）</font></b></p>
<p>比较指定文件，在本地 dev 分支和远端 master 分支的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat dev origin/master -- filepath1 filepath2 filepath3</span><br></pre></td></tr></table></figure>

<h2 id="1-13-对比两分支的”commit-差异”"><a href="#1-13-对比两分支的”commit-差异”" class="headerlink" title="1.13. 对比两分支的”commit 差异”"></a>1.13. 对比两分支的”commit 差异”</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --left-right --stat master...dev</span><br><span class="line">git log --left-right --oneline master...dev</span><br></pre></td></tr></table></figure>

<h2 id="1-14-在远端仓库新建一个分支"><a href="#1-14-在远端仓库新建一个分支" class="headerlink" title="1.14. 在远端仓库新建一个分支"></a>1.14. 在远端仓库新建一个分支</h2><p>实现方式：本地建分支后同步到远端仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b newBranch origin/master</span><br><span class="line">git push --set-upstream origin newBranch</span><br></pre></td></tr></table></figure>

<h2 id="1-15-删除远端分支"><a href="#1-15-删除远端分支" class="headerlink" title="1.15. 删除远端分支"></a>1.15. 删除远端分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -r -d origin/newBranch</span><br></pre></td></tr></table></figure>

<h2 id="1-16-本地分支与远端分支关联"><a href="#1-16-本地分支与远端分支关联" class="headerlink" title="1.16. 本地分支与远端分支关联"></a>1.16. 本地分支与远端分支关联</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout --track origin/branchName</span><br></pre></td></tr></table></figure>

<h2 id="1-17-Cherry-pick"><a href="#1-17-Cherry-pick" class="headerlink" title="1.17. Cherry pick"></a>1.17. Cherry pick</h2><p>常用用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cherry-pick [Option] &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">git cherry-pick -e -x 123456</span><br></pre></td></tr></table></figure>

<p>附加参数：</p>
<ul>
<li><code>-e，--edit</code> 。打开外部编辑器，编辑提交信息。</li>
<li><code>-n，--no-commit</code> 。只更新工作区和暂存区，不产生新的提交。</li>
<li><code>-x</code> 。在提交信息的末尾追加一行 (cherry picked from commit …)，方便以后查到这个提交是如何产生的。</li>
<li><code>-s，--signoff</code> 。在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</li>
<li><code>-m parent-number，--mainline parent-number</code> 。如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。-m 配置项告诉 Git，应该采用哪个分支的变动。它的参数 parent-number 是一个从 1 开始的整数，代表原始提交的父分支编号。</li>
</ul>
<p>若发生 Cherry-pick 冲突：</p>
<ul>
<li><p>若能成功解决冲突，则继续 cherry-pick 过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;成功处理后的冲突文件&gt;</span><br><span class="line">git cherry-pick --continue</span><br></pre></td></tr></table></figure>
</li>
<li><p>若未能成功解决冲突，可终止 cherry-pick 过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 终止 cherry-pick 过程，且恢复到操作之前的状态</span></span><br><span class="line">git cherry-pick --abort</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注：quit 虽能退出 Cherry pick ，但不能恢复到操作之前的状态。</span></span><br><span class="line">git cherry-pick --quit</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-18-git-分支改名"><a href="#1-18-git-分支改名" class="headerlink" title="1.18. git 分支改名"></a>1.18. git 分支改名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m $&#123;原分支名&#125; $&#123;新分支名&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-19-撤销暂存区文件（git-add-的逆向，保留修改）"><a href="#1-19-撤销暂存区文件（git-add-的逆向，保留修改）" class="headerlink" title="1.19. 撤销暂存区文件（git add 的逆向，保留修改）"></a>1.19. 撤销暂存区文件（git add 的逆向，保留修改）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD files</span><br></pre></td></tr></table></figure>

<h1 id="2-Git-命令进阶用法"><a href="#2-Git-命令进阶用法" class="headerlink" title="2. Git 命令进阶用法"></a>2. Git 命令进阶用法</h1><h2 id="2-1-reset-回滚"><a href="#2-1-reset-回滚" class="headerlink" title="2.1. reset 回滚"></a>2.1. reset 回滚</h2><p>reset 参数说明：</p>
<ul>
<li>–hard：重置时清空工作目录的所有改动</li>
<li>–soft：重置时保留工作目录和暂存区的内容；</li>
<li>–mixed（默认）：重置时保留工作目录的内容，并清空暂存区。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^          # 方式 1：回滚到上一次提交</span><br><span class="line">git reset --hard $&#123;commitID&#125;    # 方式 2：回滚到指定 commit 处，丢弃其后所有 commit</span><br><span class="line">git reflog                      # 方式 3：撤销历史操作（如撤销上一次回滚操作）</span><br><span class="line">git reset --hard $&#123;历史操作 ID&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-amend-修复上次提交的操作"><a href="#2-2-amend-修复上次提交的操作" class="headerlink" title="2.2. amend 修复上次提交的操作"></a>2.2. amend 修复上次提交的操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add $&#123;changeFiles&#125;  # s1. 将修复错误的文件添加到提交</span><br><span class="line">git commit --amend      # s2. 修复上次提交，注意 amend 只适用于还处于评审中的 CR。</span><br></pre></td></tr></table></figure>

<h2 id="2-3-恢复单个文件到最新提交"><a href="#2-3-恢复单个文件到最新提交" class="headerlink" title="2.3. 恢复单个文件到最新提交"></a>2.3. 恢复单个文件到最新提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout HEAD path_to_file</span><br></pre></td></tr></table></figure>

<h2 id="2-4-rebase-变基的操作步骤"><a href="#2-4-rebase-变基的操作步骤" class="headerlink" title="2.4. rebase 变基的操作步骤"></a>2.4. rebase 变基的操作步骤</h2><p>前置条件：dev 分支拉取自 master（eg.dev 分支拉取时间：20210715），且在之后（eg.20210720）master 又有新提交（或合入），且现在（eg.20210730）dev 分支需要在引入该新提交（或合入）后再开发。</p>
<p>变基操作成功执行后，dev 分支相当于是从变基操作时（eg.20210730）新拉取的分支，且 (20210715 ~ 20210730) 之间的提交和修改仍保留。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev        # s1. 切换到待变基分支 dev</span><br><span class="line">git rebase master       # s2. 将分支的起点移动到想要合并的分支的 HEAD 上</span><br><span class="line"></span><br><span class="line">git checkout master     # s3. 切换到主分支（本地）</span><br><span class="line">git merge dev           # s4. 移到最新的提交</span><br></pre></td></tr></table></figure>

<h2 id="2-5-rebase-修改完善之前某次提交的操作步骤"><a href="#2-5-rebase-修改完善之前某次提交的操作步骤" class="headerlink" title="2.5. rebase 修改完善之前某次提交的操作步骤"></a>2.5. rebase 修改完善之前某次提交的操作步骤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> s1. 触发 git 修改弹窗，将对应 commit 标记为 edit。</span></span><br><span class="line">git rebase -i $&#123;commitID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s2. 修改完善某次提交的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s3. 添加已修改的文件</span></span><br><span class="line">git add changedFiles</span><br><span class="line"><span class="meta">#</span><span class="bash"> s4. 将修正应用到当前最新的 commit</span></span><br><span class="line">git commit --amend</span><br><span class="line"><span class="meta">#</span><span class="bash"> s5. 继续 rebase 过程。</span></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<h2 id="2-6-rebase-撤销过往提交命令的两种方式"><a href="#2-6-rebase-撤销过往提交命令的两种方式" class="headerlink" title="2.6. rebase 撤销过往提交命令的两种方式"></a>2.6. rebase 撤销过往提交命令的两种方式</h2><p><b><font color="#7E3D76" style="">1. 方式 1——触发 git 修改并在弹出 git 编辑界面中删除想撤销的 commits</font></b><br>实现原理：在触发的 git 编辑界面中添加 drop ${待删除 commitID}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> s1. 触发 rebase 编辑界面</span></span><br><span class="line">git rebase -i $&#123;待删除的前一条 commitID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s2. 在修改文件中 pick commitId.. 下方将 pick 命令改为丢弃命令</span></span><br><span class="line">pick $&#123;待删除 commitID&#125;  ==》  drop $&#123;待删除 commitID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s3. 手动解决<span class="variable">$&#123;冲突 files&#125;</span>的冲突</span></span><br><span class="line">vi $&#123;冲突 files&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s4. 添加已修改的文件</span></span><br><span class="line">git add $&#123;冲突 files&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s5. 继续 rebase 过程</span></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">2. 方式 2——将修正应用到当前最新的 commit</font></b></p>
<p>实现原理：对本地当前分支，将左开右闭区间 (commitID_B, commitID_C] 的提交覆盖到 commitID_A 之后。相当于原左开右闭区间 (commitID_A, commitID_B] 的提交被删除了。</p>
<p>示例代码：</p>
<p>当前分支提交记录顺序为：commitID_A, … , commitID_B , … , commitID_C。现要删除左开右闭区间 (commitID_A, commitID_B] 的提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> s1. 触发 rebase</span></span><br><span class="line">git rebase --onto $&#123;目标 commitID_A&#125; $&#123;起点 commitID_B&#125; $&#123;终点 commitID_C&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s2. 手动解决<span class="variable">$&#123;冲突 files&#125;</span>的冲突</span></span><br><span class="line">vi $&#123;冲突 files&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s3. 添加已修改的文件</span></span><br><span class="line">git add $&#123;冲突 files&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s4. 继续 rebase 过程</span></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<h2 id="2-7-根据操作历史回退"><a href="#2-7-根据操作历史回退" class="headerlink" title="2.7. 根据操作历史回退"></a>2.7. 根据操作历史回退</h2><p>根据 git 操作历史记录回退，eg. 撤销上一步 git reset –hard 操作，以恢复到执行该操作前的状态（需确保 git 全局配置中 core.logallrefupdates 已打开 true）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> s1. 查询 git 操作命令历史记录对应的<span class="variable">$&#123;上一步操作 ID&#125;</span></span></span><br><span class="line">git reflog</span><br><span class="line"><span class="meta">#</span><span class="bash"> s2. 恢复到执行该操作的前一个操作状态</span></span><br><span class="line">git reset --hard $&#123;上一步操作 ID&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h1><ul>
<li><a href="https://www.cnblogs.com/zhaoyingjie/p/10259715.html">Git 合并多次 commit 、 删除某次 commit</a></li>
<li><a href="https://blog.csdn.net/weixin_34268843/article/details/92032933">git diff 比较本地文件记录和远程文件记录的修改项</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>基于C++的B树的数据结构设计与编码实现</title>
    <url>/2020/12/03/ImplementationOfBTreeBasedOnCpp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/BTreeNodeStruct1.png" class="full-image" />

<h1 id="1-B树的原理及性能"><a href="#1-B树的原理及性能" class="headerlink" title="1. B树的原理及性能"></a>1. B树的原理及性能</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1. 定义"></a>1.1. 定义</h2><p>1970年，R.Bayer和E.mccreight提出了一种适用于外查找的树，它是一种平衡的多叉树，称为<a href="https://baike.baidu.com/item/B%E6%A0%91/5411672?fr=aladdin">B树</a>。</p>
<a id="more"></a>

<p>一棵m阶B树是一棵平衡的m路搜索树。当m取2时，就是我们常见的二叉搜索树。它或者是空树，或者是满足下列性质的树：</p>
<ul>
<li>根结点至少有两个子女；</li>
<li>每个非根节点所包含的关键字个数 j 满足：┌m&#x2F;2┐ - 1 &lt;&#x3D; j &lt;&#x3D; m - 1；（┌，向上取整）</li>
<li>除根结点以外的所有非叶子结点的度数正好是关键字总数加1；故<strong>内部子树</strong>个数 k 满足：┌m&#x2F;2┐ &lt;&#x3D; k &lt;&#x3D; m ；</li>
<li>所有叶子节点都位于同一层</li>
</ul>
<p>备注：</p>
<ul>
<li>每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划</li>
<li><strong>叶子结点</strong>的数目正好等于树中所包含的<strong>关键字</strong>总个数加1</li>
<li>B-树中的一个包含n个<strong>关键字</strong>，n+1个<strong>指针</strong>的结点的一般形式为： （n,P0,K1,P1,K2,P2,…,Kn,Pn）</li>
</ul>
<h2 id="1-2-B树的查询性能"><a href="#1-2-B树的查询性能" class="headerlink" title="1.2. B树的查询性能"></a>1.2. B树的查询性能</h2><p>设B树包含N个关键字，有N+1个叶子节点。B树高为：1 +  log┌m&#x2F;2┐((N+1)&#x2F;2 )，（叶子节点层不在计算内），每次查询只需要┌m&#x2F;2┐的对数时间，当m&gt;2时查询效率优于二叉搜索树，故B树数据结构具备较高的查询性能。</p>
<h1 id="2-基于C-实现B树能带来哪些优势？"><a href="#2-基于C-实现B树能带来哪些优势？" class="headerlink" title="2. 基于C++实现B树能带来哪些优势？"></a>2. 基于C++实现B树能带来哪些优势？</h1><ul>
<li>设计数据结构时，可采用面向对象设计思路，可根据数据特征灵活自定义每个 BTree 对象的阶数 m</li>
<li>可利用C++的模板类进行设计，可在实例化时自定义 &lt;KEY_TYPE, VALUE_TYPE&gt; 的具体类型</li>
<li>具备面向对象设计的传统优势：易维护、质量高、效率高、易扩展</li>
</ul>
<h1 id="3-B树的数据结构设计"><a href="#3-B树的数据结构设计" class="headerlink" title="3. B树的数据结构设计"></a>3. B树的数据结构设计</h1><p>由B树的定义可知它是一种多叉树的结构，而组成多叉树的基本单位为节点（中间节点、叶子节点），故实现B数的数据结构设计的关键点在于对B树节点的设计</p>
<h2 id="3-1-B树节点的数据结构设计"><a href="#3-1-B树节点的数据结构设计" class="headerlink" title="3.1. B树节点的数据结构设计"></a>3.1. B树节点的数据结构设计</h2><h3 id="3-1-1-最大m-1个关键字及m个关键字对应值的存放"><a href="#3-1-1-最大m-1个关键字及m个关键字对应值的存放" class="headerlink" title="3.1.1. 最大m-1个关键字及m个关键字对应值的存放"></a>3.1.1. 最大m-1个关键字及m个关键字对应值的存放</h3><p><img data-src="/../../../../uploads/BTreeNodeStruct1.png" alt="myBtree"></p>
<ul>
<li><p>在一个m阶的B树（多叉树）中，每个节点最多包含m-1个关键字及m个关键字指向的值。其中关键字指向的值可能非值的地址（依然为中间节点的地址），则该关键字对应的值采取逐层下放到下一节点Ptr0所指向的值（可能依然为中间节点），直至叶子节点Ptr0指向的值；同理，其他关键字：Key0 ~ Key(m-2)对应的值为：Ptr1 ~ Ptr(m-1)，若非叶子节点则逐层下放直至叶子节点的Ptr0所指向的值。</p>
</li>
<li><p>考虑到不是每个节点都存满m-1个关键字，故还需要一个变量记录当前节点已有关键字数。尽管可以通过遍历Ptrs1~Ptr(m-1)，统计为NULL的个数cnt，从而得到已有关键字数：m - 1 - cnt，但当m阶数过大(实际应用阶数m一般大于100)时，浪费很多不必要的CPU资源计算现有关键字数，故采用4字节int直接记录当前节点所包含关键字数</p>
</li>
<li><p>对于中间节点，其Ptrs指针指向的子节点可能为：叶子节点或中间节点，故还需要一个bool值来记录当前节点指向的是叶子节点还是中间节点</p>
</li>
<li><p>分析至此可知，只需对叶子节点类定义：包含关键字数变量和两成员数组变量: 关键字数组KEY_TYPE[m - 1]、值指针数组VALUE_TYPE[m]；中间节点类定义：指向的下一节点是否是叶子节点、包含关键字数变量和两成员数组变量：关键字数组KEY_TYPE[m - 1]、子节点指针数组BTreeNode*[m]</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 叶子节点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeLeafNode</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> keyNum;<span class="comment">// 当前节点所含关键字个数</span></span><br><span class="line">    KEY_TYPE* keys;<span class="comment">// 关键字数组</span></span><br><span class="line">    VALUE_TYPE* valuePtrs;<span class="comment">// 指向value的指针数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间节点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeMiddleNode</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isChildLeafNode;<span class="comment">// 指向的子节点是否是叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> keyNum;<span class="comment">// 当前节点所含关键字个数</span></span><br><span class="line">    KEY_TYPE* keys;<span class="comment">// 关键字数组</span></span><br><span class="line">    <span class="keyword">void</span>* childPtrs;<span class="comment">// isChildLeafNode(true)--强转为(BTreeLeafNode*);isChildLeafNode(false)--强转为(BTreeMiddleNode*);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-优化：融合叶子节点类和中间节点类"><a href="#3-1-2-优化：融合叶子节点类和中间节点类" class="headerlink" title="3.1.2. 优化：融合叶子节点类和中间节点类"></a>3.1.2. 优化：融合叶子节点类和中间节点类</h3><ul>
<li><p>比较叶子节点类与中间节点类易知，其大多数成员变量相同，为简化后续管理节点类管理及后续中间节点与叶子节点相互转换，尝试将叶子节点类与中间节点类融合。采用一个bool值(isLeaf)记录当前节点是否是叶子节点，则中间节点类的指向子节点类型(原: isChildLeafNode)可通过判断子节点的isLeaf的bool值判断。</p>
</li>
<li><p>进一步优化。叶子节点类的指向value的指针数组VALUE_TYPE*[m]与中间节点的指向下一节点子节点指针数组BTreeNode*[m]所占内存一致，且互斥不可能在融合类中同时使用这两个数组，故采用union使这两个数组复用同一块内存以节省内存开销。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isLeaf;<span class="comment">// 是否是叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> keyNum;<span class="comment">// 当前节点所含关键字个数</span></span><br><span class="line">    KEY_TYPE* keys;<span class="comment">// 关键字数组</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VALUE_TYPE* valuePtrs;<span class="comment">// 若为叶子节点，指向value的指针数组</span></span><br><span class="line">        BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;** childPtrs;<span class="comment">// 子节点指针数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>至此，存储节点信息已基本完成。但由于后续分裂节点，维持节点平衡需要用到该节点的父节点信息，若从根节点开始向下遍历较浪费CPU资源和时间开销，故在每个节点增加记录其父节点地址的指针变量parent，最终B树节点类的数据结构如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BTree</span>&lt;</span>KEY_TYPE, VALUE_TYPE&gt;;<span class="comment">// 申明友元类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isLeaf;<span class="comment">// 是否是叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> keyNum;<span class="comment">// 当前节点所含关键字个数</span></span><br><span class="line">    BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;* parent;<span class="comment">// 父指针</span></span><br><span class="line">    KEY_TYPE* keys;<span class="comment">// 关键字数组</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VALUE_TYPE* valuePtrs;<span class="comment">// 若为叶子节点，指向value的指针数组</span></span><br><span class="line">        BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;** childPtrs;<span class="comment">// 子节点指针数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-B树管理类的数据结构设计"><a href="#3-2-B树管理类的数据结构设计" class="headerlink" title="3.2. B树管理类的数据结构设计"></a>3.2. B树管理类的数据结构设计</h2><p>相比于B树节点类，B数管理类的数据结构则相对简单：维护3个变量分别记录该实例的阶数(m)，最少关键字数(minKeyNum)，最多关键字个数(maxKeyNum)以及根节点(root)便可，其数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m; <span class="comment">// m阶，┌m/2┐ - 1 &lt;= j &lt;= m - 1</span></span><br><span class="line">    <span class="keyword">int</span> maxKeyNum; <span class="comment">// 最多关键字个数 =  m - 1;</span></span><br><span class="line">    <span class="keyword">int</span> minKeyNum; <span class="comment">// 最少关键字个数 = ┌m/2┐ - 1 = (m - 1) / 2 == maxKeyNum / 2</span></span><br><span class="line">    BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;* root; <span class="comment">// 根节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-B树支持的操作及编码实现"><a href="#4-B树支持的操作及编码实现" class="headerlink" title="4. B树支持的操作及编码实现"></a>4. B树支持的操作及编码实现</h1><h2 id="4-1-实例化一个m阶的B树实例"><a href="#4-1-实例化一个m阶的B树实例" class="headerlink" title="4.1. 实例化一个m阶的B树实例"></a>4.1. 实例化一个m阶的B树实例</h2><p><img data-src="/../../../../uploads/newBTree.png" alt="myBtree"></p>
<ol>
<li>实例化BTree，申请BTree类所需内存，根据输入的阶数m初始化成员变量: 阶数(m)，最少关键字数(minKeyNum)，最多关键字个数(maxKeyNum)</li>
<li>实例化一个B树节点BTreeNode作为根节点(根节点为叶子节点)，初始化BTreeNode成员变量，并根据此实例化B树的阶数申请关键字数组keys 和 指向value的指针数组valuePtrs所需内存。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B树管理类，构造函数</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="built_in">BTree</span>(<span class="keyword">int</span> m = <span class="number">3</span>) : <span class="built_in">m</span>(m), <span class="built_in">maxKeyNum</span>(m - <span class="number">1</span>), <span class="built_in">minKeyNum</span>((m - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例化空树根节点（也是叶子节点）</span></span><br><span class="line">    root = <span class="keyword">new</span> BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;(maxKeyNum);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;create a BTree, which max Key num = &quot;</span> &lt;&lt; maxKeyNum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B树节点类，构造函数</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> * @param maxKeyNum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="built_in">BTreeNode</span>(<span class="keyword">int</span> maxKeyNum, <span class="keyword">bool</span> isLeaf = <span class="literal">true</span>) : <span class="built_in">isLeaf</span>(isLeaf), <span class="built_in">keyNum</span>(<span class="number">0</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    keys = <span class="keyword">new</span> KEY_TYPE[maxKeyNum];</span><br><span class="line">    <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">        valuePtrs = <span class="keyword">new</span> VALUE_TYPE[maxKeyNum + <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        childPtrs = <span class="keyword">new</span> BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;*[maxKeyNum + <span class="number">1</span>]&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-释放一个m阶的B树实例"><a href="#4-2-释放一个m阶的B树实例" class="headerlink" title="4.2. 释放一个m阶的B树实例"></a>4.2. 释放一个m阶的B树实例</h2><ol>
<li><p>释放BTree实例，会调用BTree类的析构函数释放普通类型的成员变量和B树节点BTreeNode指针(root)指向的内存。</p>
</li>
<li><p>释放BTreeNode实例(eg. root)，会调用BTreeNode类的析构函数释放普通类型的成员变量，手动申请的关键字数组keys，会根据当前节点是否是叶子节点遍历释放申请的value的指针数组或遍历并递归释放中间节点的子节点指针数组指向的内存。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B树管理类，析构函数</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line">~<span class="built_in">BTree</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B树节点类，析构函数</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line">~<span class="built_in">BTreeNode</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> []keys;</span><br><span class="line">    <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">        <span class="keyword">delete</span> []valuePtrs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清理释放子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyNum + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (childPtrs[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> childPtrs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> []childPtrs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-二分法查询关键字"><a href="#4-3-二分法查询关键字" class="headerlink" title="4.3. 二分法查询关键字"></a>4.3. 二分法查询关键字</h2><p>在一个m阶的B树（多叉树）中，每个节点最多包含m-1个关键字（实际使用为减少层高，一般m会较大eg. m &gt; 100），且这些关键字严格递增。从根节点开始查询某key时，若只是采用从左至右线性遍历节点的关键字数组将浪费较多的Cpu资源：O(m)，且没有利用好严格递增的特性，故在查询关键字时，一般采用二分法以减少每个节点检索关键字时间：O(log(m))。</p>
<p>由于B树满足二叉搜索树特性（值：右 &lt; 根 &lt; 左），在从根节点开始查询关键字时，若无法在本节点找到关键字 k，则k有可能在以本节点**不超过k关键字**指向节点为根的子树中（此节点非叶节点），故搜索关键字可简化为：对当前节点，返回keys[i] &gt;&#x3D; key对应的子节点可能所在下标 i，外层判断keys[i] 的值与key，直至找到key，或下降至叶子节点都未找到。</p>
<h3 id="4-3-1-对每个节点，二分法返回第一个-keys-i-gt-x3D-key-的下标-i"><a href="#4-3-1-对每个节点，二分法返回第一个-keys-i-gt-x3D-key-的下标-i" class="headerlink" title="4.3.1. 对每个节点，二分法返回第一个 keys[i]  &gt;&#x3D;  key 的下标 i"></a>4.3.1. 对每个节点，二分法返回第一个 keys[i]  &gt;&#x3D;  key 的下标 i</h3><p>其中，返回当前节点第一个 keys[i]  &gt;&#x3D;  key 对应的子节点可能所在下标 i 伪代码如下：</p>
<ul>
<li>若本节点若无关键字且非叶子节点，则返回下标0</li>
<li>二分法找到不超过 key 值所对应的下标 i<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查询关键字数组中，第一个keys[i] &gt;= key对应的子节点可能所在下标 i</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> * @tparam VALUE_TYPE</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @return i -- 可能的子节点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;::<span class="built_in">binarySearchKey</span>(KEY_TYPE key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (keyNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = keyNum - <span class="number">1</span>, mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right &amp;&amp; keys[mid] != key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys[mid] &gt; key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key &gt; keys[mid] ? mid + <span class="number">1</span> : mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-3-2-外层二分查询关键字key"><a href="#4-3-2-外层二分查询关键字key" class="headerlink" title="4.3.2. 外层二分查询关键字key"></a>4.3.2. 外层二分查询关键字key</h3><p>外层判断keys[i] 的值与key，若keys[i] 不等于 key，若非叶子节点，则将查找任务下降为子节点childPtrs[i]查找key，若直至叶子节点都未找到，则返回nullptr；若 keys[i] 等于 key，但此时节点非叶子节点，则依次下降遍历子节点的第0个指针数组指向的子节点，直至叶子节点ptr-&gt;valuePtrs[0]即为 key 对应值的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询以当前节点为根的BTree子树中，是否已经存在 Key，若存在返回其value指针</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @return nullptr -- 未找到key; others -- 其value指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line">VALUE_TYPE BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;::<span class="built_in">getValue</span>(KEY_TYPE key) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">binarySearchKey</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; keyNum &amp;&amp; keys[i] == key) &#123;</span><br><span class="line">        <span class="comment">// 若是叶子节点，则返回value指针，否则继续下落到叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">            <span class="keyword">return</span> valuePtrs[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;* ptr = childPtrs[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (!ptr-&gt;isLeaf) &#123;</span><br><span class="line">            ptr = ptr-&gt;childPtrs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;valuePtrs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是叶子节点（未找到），返回nullptr；若非叶子节点，继续向下寻找</span></span><br><span class="line">    <span class="keyword">return</span> isLeaf ? <span class="literal">nullptr</span> : childPtrs[i]-&gt;<span class="built_in">getValue</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-插入-lt-key-value-gt-键值对"><a href="#4-4-插入-lt-key-value-gt-键值对" class="headerlink" title="4.4. 插入&lt;key, value&gt;键值对"></a>4.4. 插入&lt;key, value&gt;键值对</h2><p>由于m阶的B树（多叉树）中，每个节点最多包含m-1个关键字（有限），故插入&lt;key, value&gt;键值对前，需判断待插入节点的关键字剩余容量后操作：若非零（未满插入），直接填充&lt;key, value&gt;到已有的keys数组尾部即可；若为零（已满插入），需要对节点进行分裂操作，为加速插入过程，博主实现时将节点分裂和插入融合为一个操作<strong>分裂插入</strong>。</p>
<h3 id="4-4-1-先找到要插入该key的节点"><a href="#4-4-1-先找到要插入该key的节点" class="headerlink" title="4.4.1. 先找到要插入该key的节点"></a>4.4.1. 先找到要插入该key的节点</h3><ul>
<li>从根节点开始，查找key</li>
<li>若key已存在，则只需下降到叶节点，将其value指针指向新value地址即可</li>
<li>若向下搜索到叶节点都未找到key，则该叶子节点即为我们要插入&lt;key, value&gt;键值对的节点</li>
</ul>
<h3 id="4-4-2-未满节点插入-lt-key-value-gt-键值对"><a href="#4-4-2-未满节点插入-lt-key-value-gt-键值对" class="headerlink" title="4.4.2. 未满节点插入&lt;key, value&gt;键值对"></a>4.4.2. 未满节点插入&lt;key, value&gt;键值对</h3><p><img data-src="/../../../../uploads/BTreeNotFullInsert.png" alt="BTreeNotFullInsert"></p>
<p>对于节点关键字节点未满插入，只需将新的&lt;key, value&gt;键值对对应插入尾部即可。</p>
<h3 id="4-4-3-已满节点插入-lt-key-value-gt-键值对"><a href="#4-4-3-已满节点插入-lt-key-value-gt-键值对" class="headerlink" title="4.4.3. 已满节点插入&lt;key, value&gt;键值对"></a>4.4.3. 已满节点插入&lt;key, value&gt;键值对</h3><p><img data-src="/../../../../uploads/BTreeSplitInsert.png" alt="BTreeSplitInsert"><br>对于关键字已满的节点，需新增右兄弟节点，将原已满节点的后半部分挪到右兄弟节点（“<strong>分裂</strong>”），会上升一个key到其父节点作为新增右兄弟节点对应的key（若无则创建新父节点），再插入新节点。博主这里将这两步操作(分裂 + 插入)合为一步以提高效率：</p>
<ul>
<li>新增右兄弟节点 rightBrotherPtr</li>
<li>下标变换以模拟过载1插入该key后的数组分裂</li>
<li>记录模拟过载1后的数组对应 midKey，作为新增右兄弟节点在父节点的key值&lt;midKey, rightBrotherPtr&gt;</li>
<li>将 midKey 之后的后半部分key及其对应valuePtr挪到右兄弟节点</li>
<li>刷新分裂后两兄弟节点的关键字容量 keyNum 的数值</li>
<li>最后将新增的右兄弟节点和其对应的Key值: &lt;rightBrotherKey, rightBrotherPtr&gt;，插入共同的父节点（无父节点则需新增父节点&#x2F;root节点）</li>
</ul>
<h2 id="4-5-删除-lt-key-value-gt-键值对"><a href="#4-5-删除-lt-key-value-gt-键值对" class="headerlink" title="4.5. 删除&lt;key, value&gt;键值对"></a>4.5. 删除&lt;key, value&gt;键值对</h2><ul>
<li>对于&lt;key, value&gt;键值对的删除，若B树中查无该key，则不多讨论直接返回false。由于所有的记录valuePtr的指针数组都在叶子节点层，若在叶子节点查到该key，则还好，若在中间节点查到该key，意味着该key对应的value的地址记录在其子树下降直至叶子节点层的第0个元素内，对该key删除后，若子树非空，还需在最初找到该key的位置补充一个key作为新子树的key。</li>
<li>B树作为一颗m阶搜索树，存在搜索树的缺陷——退化为链表的，另一方面为了降低层高，B树还要求了每个节点的最少关键字数(m&#x2F;2, m阶)，以保证查询效率，若删除键值对后发现关键字数小于m&#x2F;2，还需进行一系列平衡操作。</li>
</ul>
<h3 id="4-5-1-删除-lt-key-value-gt-键值对-假设删除后-keyNum-gt-m-x2F-2，无需考虑平衡"><a href="#4-5-1-删除-lt-key-value-gt-键值对-假设删除后-keyNum-gt-m-x2F-2，无需考虑平衡" class="headerlink" title="4.5.1. 删除&lt;key, value&gt;键值对 (假设删除后 keyNum &gt; m&#x2F;2，无需考虑平衡)"></a>4.5.1. 删除&lt;key, value&gt;键值对 (假设删除后 keyNum &gt; m&#x2F;2，无需考虑平衡)</h3><p><img data-src="/../../../../uploads/BTreeRemoveWithoutBalance.png" alt="BTreeRemoveWithoutBalance"></p>
<ul>
<li>若此节点非叶子节点，记录该key地址recordKey，继续下落到叶子节点执行删除（若子树非空，需更新整个子树的key，若子树为空，还需递归上层删除）</li>
<li>若下落的到叶子节点，关键字数为0，释放该叶子节点，并执行递归向上删除</li>
<li>若下落到叶子节点，关键字数非0，则截取下一个key以更新recordKey，删除叶子节点对应的valuePtr值，其他key及对应记录的value地址前挪。</li>
</ul>
<h2 id="4-6-删除-lt-key-value-gt-键值对后的平衡操作"><a href="#4-6-删除-lt-key-value-gt-键值对后的平衡操作" class="headerlink" title="4.6. 删除&lt;key, value&gt;键值对后的平衡操作"></a>4.6. 删除&lt;key, value&gt;键值对后的平衡操作</h2><h3 id="4-6-1-尝试从左、右兄弟节点挪借关键字"><a href="#4-6-1-尝试从左、右兄弟节点挪借关键字" class="headerlink" title="4.6.1. 尝试从左、右兄弟节点挪借关键字"></a>4.6.1. 尝试从左、右兄弟节点挪借关键字</h3><p><img data-src="/../../../../uploads/BTreeBalanceBrowFromBro.png" alt="BTreeBalanceBrowFromBro"></p>
<ul>
<li>若无左（或右）兄弟节点，或左右节点无法提供可挪借关键字，则挪借失败</li>
<li>若存在左（或右）兄弟节点 且 左（或右）兄弟节点关键字字数大于 minKeyNum，则可从左（或右）兄弟挪借关键字</li>
<li>若左、右兄弟节点均可挪借关键字数，从平衡角度选择可挪借关键字数较多的一方挪借</li>
</ul>
<h3 id="4-6-2-尝试与左或右兄弟节点合并"><a href="#4-6-2-尝试与左或右兄弟节点合并" class="headerlink" title="4.6.2. 尝试与左或右兄弟节点合并"></a>4.6.2. 尝试与左或右兄弟节点合并</h3><p><img data-src="/../../../../uploads/BTreeBalanceMergeWithBro.png" alt="BTreeBalanceMergeWithBro"></p>
<ul>
<li>若存在左兄弟节点，且左兄弟节点关键字 + 本节点关键字 + 1 &lt;&#x3D; 最大关键字数，则可与左兄弟节点合并</li>
<li>若存在右兄弟节点，且右兄弟节点关键字 + 本节点关键字 + 1 &lt;&#x3D; 最大关键字数，则可与右兄弟节点合并</li>
<li>若左、右兄弟节点均不可合并，则返回合并失败</li>
<li>若均可合并，选取左右兄弟节点中，从平衡角度选择关键字数较少的一方合并</li>
</ul>
<h3 id="4-6-3-若节点的关键词数为0，且非叶子节点（降层）"><a href="#4-6-3-若节点的关键词数为0，且非叶子节点（降层）" class="headerlink" title="4.6.3. 若节点的关键词数为0，且非叶子节点（降层）"></a>4.6.3. 若节点的关键词数为0，且非叶子节点（降层）</h3><p><img data-src="/../../../../uploads/BTreeBalanceReduceLevel.png" alt="BTreeBalanceReduceLevel"></p>
<ul>
<li>若当前节点关键字数大于0，或为叶子节点，不进行降层</li>
<li>若其兄弟节点与其node-&gt;childPtrs[0] 是否是叶子节点属性不同，则不降层</li>
<li>降层处理，将其父节点指向其的childPtrs[i]指针，指向其node-&gt;childPtrs[0]指向的值，后释放node节点</li>
<li>若该节点为根节点，则将root指针指向node-&gt;childPtrs[0]（更新root节点），清除父节点指向node指针的值后释放node节点</li>
</ul>
<h2 id="4-7-更多详细的实现细节，请阅读我上传到Git的源码吧"><a href="#4-7-更多详细的实现细节，请阅读我上传到Git的源码吧" class="headerlink" title="4.7. 更多详细的实现细节，请阅读我上传到Git的源码吧:)"></a>4.7. 更多详细的实现细节，请阅读我上传到Git的源码吧:)</h2><div class="note success"><p> 博主基于C++的B树的数据结构设计与编码实现源码详见：<br><a href="https://github.com/haoleeson/Cpp_Learning/blob/master/myBTree.h">https://github.com/haoleeson/Cpp_Learning/blob/master/myBTree.h</a></p>
</div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>曾国藩的“六戒五勤”（深度好文）</title>
    <url>/2017/11/12/GuofanZeng-six-rings/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/GuofanZeng-six-rings.jpg" class="full-image" />

<blockquote class="blockquote-center">
<p>一勤天下无难事<br>– by 曾国藩</p>

</blockquote>

<a id="more"></a>
<div class="note success"><p><a href="http://www.cnki.com.cn/Article/CJFDTotal-WSYK201406021.htm">来源：《文史月刊》2014年06期 曾国藩的“五勤”之道 – 作者:罗日荣</a></p>
</div>

<h1 id="1-六戒"><a href="#1-六戒" class="headerlink" title="1. 六戒"></a>1. 六戒</h1><ul>
<li>第一戒：久利之事勿为，众争之地勿往</li>
<li>第二戒：勿以小恶弃人大美，勿以小怨忘人大恩</li>
<li>第三戒：说人之短乃护己之短，夸己之长乃忌人之长</li>
<li>第四戒：利可共而不可独，谋可寡而不可众</li>
<li>第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败</li>
<li>第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半</li>
</ul>
<h2 id="1-1-第一戒：久利之事勿为，众争之地勿往"><a href="#1-1-第一戒：久利之事勿为，众争之地勿往" class="headerlink" title="1.1. 第一戒：久利之事勿为，众争之地勿往"></a>1.1. 第一戒：久利之事勿为，众争之地勿往</h2><p>一直都能获利的事不要做，所有人都想得到的地方不要前去。危城莫入！所有人都向往渴求的，可能有有害。</p>
<p>前半句说：不可贪求过多！日中则移，月满则亏，物盛则衰。世界上没有一劳永逸的事情，也不可能有长久获利的事情，如果有这种能够一直获利的事情，那只能说这种事是表面现象或者骗局，这时候一定要保持头脑清。</p>
<p>后半句是说的安全，众人争执、争斗的地方你不要去，容易惹麻烦或者招致祸患。《论语》上说，“危邦不入，乱邦不居”就是这个意思。当然，这句话里的争，也可以理解为，争利。意思是说，大家都去争抢的利益，你就不要去争抢了，因为那肯定是薄利。</p>
<h2 id="1-2-第二戒：勿以小恶弃人大美，勿以小怨忘人大恩"><a href="#1-2-第二戒：勿以小恶弃人大美，勿以小怨忘人大恩" class="headerlink" title="1.2. 第二戒：勿以小恶弃人大美，勿以小怨忘人大恩"></a>1.2. 第二戒：勿以小恶弃人大美，勿以小怨忘人大恩</h2><p>不要因为别人小的缺点就忽视他的优点，不要因为小小的恩怨就忽略了别人的大恩。</p>
<p>人只要做事就会犯错，这两句话都是告诉我们，不要因为别人的一点小过失，一点道德上的小瑕疵，一点小恩怨，就全盘否定别人的好，忘记别人的恩情。</p>
<p>《礼记》上说， “好而知其恶，恶而知其美者，天下鲜矣。”意思是喜爱一个人而知道其缺点，厌恶而知道其优点。这就是告诫我们，在待人接物的时候，一定不要太感情用事，一定要客观、公正地看待别人的缺点和不足。</p>
<h2 id="1-3-第三戒：说人之短乃护己之短，夸己之长乃忌人之长"><a href="#1-3-第三戒：说人之短乃护己之短，夸己之长乃忌人之长" class="headerlink" title="1.3. 第三戒：说人之短乃护己之短，夸己之长乃忌人之长"></a>1.3. 第三戒：说人之短乃护己之短，夸己之长乃忌人之长</h2><p>经常说别人短处的人，经常夸耀自己长处的人，可以说是“存心不厚，识量太狭。”俗话说，“打人不打脸，揭人不揭短。”经常谈论别人的短处，夸耀自己的长处，不仅是情商低的表现，也必然给自己招来怨恨，埋下祸乱的种子。</p>
<p>汉高祖刘邦曾经随便和韩信讨论各位将领的才能。刘邦问道：“像我自己，能带多少士兵？”韩信说：“陛下不过能带十万人。”刘邦说：“那对你来说呢？”韩信回答：“像我，越多越好。”韩信后来被杀，不能说与他这种性格无关。</p>
<p>曾国藩这句话的意思，入目三分地画出了可这种人的精神肖像。那种经常谈论别人缺点的人，内心其实是借此在掩饰自己的缺点；经常夸耀自己长处的人，内心其实是嫉妒或者想掩盖别人的长处罢了。</p>
<h2 id="1-4-第四戒：利可共而不可独，谋可寡而不可众"><a href="#1-4-第四戒：利可共而不可独，谋可寡而不可众" class="headerlink" title="1.4. 第四戒：利可共而不可独，谋可寡而不可众"></a>1.4. 第四戒：利可共而不可独，谋可寡而不可众</h2><p>利益，往往是众人都渴望得到的，如果谁独占了利益而不与大家分享，那么一定会招致怨恨，甚至成为众矢之的。刘邦攻破咸阳，却不敢占据其地；曹操能够“挟天子以令诸侯”，却终其一生不敢篡汉自立，他们都是怕成为众矢之的。所以，面对利益，一定要权衡取舍之道。</p>
<p>谋划事情，一定要跟有主见的几个人一起，而不要与众人一起谋划事情。正如《战国策》上说，“论至德者不和于俗，成大功者不谋于众。”通俗地说，就是谋求特别重大的事情，不必与众人商量。因为谋求大事的人，自己必定有非同一般的眼光、心胸与气度，自己看准了，去做就是了，如果和别人商量，反倒麻烦。如果别人见识低下，心胸狭小，气度平凡，必定不理解你的想法。七嘴八舌，会动摇你的意志，也会破坏你的信心和情绪。</p>
<h2 id="1-5-第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败"><a href="#1-5-第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败" class="headerlink" title="1.5. 第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败"></a>1.5. 第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败</h2><p>庸人，就是普通人，一般的人。对于一般的人来说，没有什么才气，只有勤奋工作才能成就事业，所以最忌讳一个“懒”字。而那些有才的人呢，虽然可凭才气走捷径，更容易成功，但也容易孤傲自大，故步自封，不肯向别人学习，这也是容易失败的。</p>
<p>曾国藩是勤劳的好例子，他其实并不聪明，但是却能以“勤”成就大学问和大事业，可以说正是普通人的榜样。而如项羽、李自成等，占尽天时地利，却因为骄傲而败亡。</p>
<h2 id="1-6-第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半"><a href="#1-6-第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半" class="headerlink" title="1.6. 第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半"></a>1.6. 第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半</h2><p>凡是办大事，首先需要有深厚的阅历和识见，并以才能作为辅助；凡是要成就大事的，一半在于人的谋划，另一半就要看天意了，看时机会不会来到。所谓谋事在人，成事在天。</p>
<p>曾国藩明确告诉我们，办大事要以“识”为主，才气、才能不过是辅助罢了。所以恃才傲物的人，往往难以成就大事。当然这里的“识”，不单单指知识，更指的是经验和见识。</p>
<p>而“人谋居半，天意居半。”则是说，我们无论做什么事情，都要抱着“尽人事以听天命”的态度。不要因为有自己不能左右的的因素就不去努力，更不能因为自己努力了，最终却失败了而去怨天尤人。</p>
<h1 id="2-五勤"><a href="#2-五勤" class="headerlink" title="2. 五勤"></a>2. 五勤</h1><p>曾国藩说为官者当有五勤：</p>
<ul>
<li>一曰身勤：险远之路，身往验之；艰苦之境，身亲尝之。</li>
<li>二曰眼勤：遇一人，必详细察看；接一文，必反复审阅。</li>
<li>三曰手勤：易弃之物，随手收拾；易忘之事，随笔记载。</li>
<li>四曰口勤：待同僚，则互相规劝；待下属，则再三训导。</li>
<li>五曰心勤：精诚所至，金石亦开；苦思所积，鬼神迹通。<br>曾国藩的“五勤”之道虽是为官之道，同时也是为人处世之道。</li>
</ul>
<h2 id="2-1-一曰身勤："><a href="#2-1-一曰身勤：" class="headerlink" title="2.1. 一曰身勤："></a>2.1. 一曰身勤：</h2><p>身体力行、以身作则<br>曾国藩曾说“余谓天子或可不亲细事，为大臣者则断不可不亲”。</p>
<p>曾国藩是这么说的，也是这么做的。曾国藩在军中要求自己早起，不论是什么样的天气，不论是什么样的环境，他一定“闻鸡起舞”，练兵督训，办理各项事务。曾国藩对军中将士说：“练兵之道，必须官弁昼夜从事，乃可渐几于熟。如鸡孵卵，如炉炼丹，未可须臾稍离。”《论语》有曰：“其身正，不令而行；其身不正，虽令不从。”</p>
<p>言传不如身教，曾国藩就是这样影响手下的幕僚、将领的。不管是个人修行还是管理团队，这一点至关重要，要给周围的人和下属做一个好榜样。</p>
<h2 id="2-2-二曰眼勤："><a href="#2-2-二曰眼勤：" class="headerlink" title="2.2. 二曰眼勤："></a>2.2. 二曰眼勤：</h2><p>从细微之处识人</p>
<p>曾国藩指派李鸿章训练淮军时，李鸿章带了三个人求见，请曾国藩分配职务给他们。不巧曾刚好饭后出外散步，李命三人在室外等候，自己则进入室内。等到曾散步回来，李请曾传见三人。</p>
<p>曾说不用再召见了，并对李说：“站在右边的是个忠厚可靠的人，可委派后勤补给工作；站在中间的是个阳奉险违之人，只能给他无足轻重的工作；站在左边的人是个上上之材，应予重用。”</p>
<p>李惊问道：“您是如何看出来的呢？”</p>
<p>曾笑道：“刚才我散步回来，走过三人的面前时，右边那人垂首不敢仰视，可见他恭谨厚重，故可委派补给工作。中间那人表面上必恭必敬，但我一走过，立刻左顾右盼，可见他阳奉阴违，故不可用。左边那人始终挺直站立，双目正视，不亢不卑，乃大将之材。”</p>
<p>曾国藩所指左边那位“大将之材”，就是后来担任台湾巡抚鼎鼎有名的刘铭传。</p>
<p>曾国藩从细微之处识人，练就了他的一双慧眼，曾府幕僚鼎盛一时，幕僚在曾国藩平定太平军的过程中出谋划策，立下了赫赫功勋。</p>
<h2 id="2-3-三曰手勤："><a href="#2-3-三曰手勤：" class="headerlink" title="2.3. 三曰手勤："></a>2.3. 三曰手勤：</h2><p>其实就是要养成一个好习惯<br>曾国藩一生养成了三个好习惯：</p>
<ul>
<li>一是反省的习惯：曾国藩每一天都写日记，曾国藩说：“吾人只有进德、修业两事靠得住。进德，则孝弟仁义是也；修业，则诗文作字是也。此二者由我作主，得尺则我之尺也，得寸则我之寸也。今日进一分德，便算积了一升谷；明日修一分业，又算馀了一文钱；德业并增，则家私日起。至于功名富贵，悉由命走，丝毫不能自主。”曾国藩通过写日记进行修身，反思自己在为人处世等方面存在的不足，通过这样的反省，不断修炼自己。</li>
<li>第二个好习惯就是读书习惯，他规定自己每一天必须坚持看历史不下十页，饭后写字不下半小时。曾国藩说“人之气质，由于天生，很难改变，唯读书则可以变其气质。古之精于相法者，并言读书可以变换骨相。”通过坚持读书，曾国藩不仅改变了气质，更磨练了他持之以恒的精神，同时也增长了他的才干，懂得不少为人处世的道理，也让他成了一代大儒。</li>
<li>第三个好习惯就是写家书，据说曾国藩仅在1861年就写了不下253封家书，通过写家书不断训导教育弟弟和子女，在曾国藩的言传身教之下，曾家后人人才辈出。</li>
</ul>
<p>正所谓习惯决定性格，性格决定命运。曾国藩养成很好的习惯，不仅成就了曾国藩自己，也影响了曾家后人。</p>
<h2 id="2-4-四曰口勤："><a href="#2-4-四曰口勤：" class="headerlink" title="2.4. 四曰口勤："></a>2.4. 四曰口勤：</h2><p>他与人的相处之道<br>曾国藩认为同僚相处“两虎相斗，胜者也哀”。</p>
<p>据说曾国藩开始同湖南巡抚骆秉章的关系并不好，咸丰三年，曾国藩在长沙初办团练时，骆秉章压根儿就没把曾国藩放在眼里，对曾国藩的工作也不是十分支持。当绿营与团练闹矛盾时，他总是把偏向着绿营。</p>
<p>让曾国藩特别愤愤不平的是，在靖港兵败，湘军退驻长沙城郊的水陆洲时，骆秉章来到离曾国藩座船仅数十米之遥的码头送客，曾国藩以为他是特意来看望和安慰自己的，内心正十分感激，谁知他送完客人之后竟然转身便走，就当没有看到曾国藩！并且还同长沙官员一起对曾国藩的兵败百般讥讽。</p>
<p>尽管如此，曾国藩并没有逞口舌之争，而是采取曲意忍让的态度，在他为父守孝后第二次出山之时，他特意拜访了骆秉章，态度十分谦恭又十分热情，之前的那点事就当没发生一样。这让骆秉章大感意外，当场表态，以后湘军有什么困难，我们湖南当倾力相助。</p>
<p>“己预立而立人，己欲达而达人”，曾国藩口勤不仅仅是对同僚和上级，对下属也会耐心地训导，曾国藩秉持的这种为人处世之道，不仅让他成就了自己，也成就了如李鸿章、左宗棠、张之洞、刘铭传、胡林翼等名臣，实现了清末短暂的中兴。</p>
<h2 id="2-5-五曰心勤："><a href="#2-5-五曰心勤：" class="headerlink" title="2.5. 五曰心勤："></a>2.5. 五曰心勤：</h2><p>坚定的意志品质</p>
<p>曾国藩不管是从科考还是在平定太平军时“屡败屡战”，都有一种精诚所至的信念在支撑他。从各方面下足工夫，功到自然成。</p>
<p>曾国藩说“天下古今之庸人，皆以一惰字致败。”以勤治惰，以勤治庸，不管是修身自律，还是为人处世，一勤天下无难事。</p>
<p>摘抄于此，与君共勉！</p>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>深度好文</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 C++ 的 SkipList 数据结构设计与编码实现</title>
    <url>/2022/06/12/ImplementationOfSkipListByCpp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/SkipList_search.jpg" class="full-image" />

<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>1990 年，William Pugh 提出了一种用于替换平衡树的数据结构 Skip lists: a probabilistic alternative to balanced trees，即跳表。</p>
<a id="more"></a>

<p>众所周知，AVL 树的查询时间复杂度严格为 O(logN)，但节点插入过程中需要多次旋转，会导致插入效率降低。后来出现的红黑树解决了节点插入的效率问题，但由于其在更新节点时需要多节点参与自身的平衡过程，故在并发场景时就需锁住更多的节点，使得并发效率降低。而 SkipList 由于实现简单，在更新数据时所需参与的节点较少，在并发场景应用较广，比如 Redis 和 Google 的 BigTable。</p>
<h1 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h1><p><a href="https://en.wikipedia.org/wiki/Skip_list">Skip_list</a> 在 wikipedia 的描述为”a skip list is a probabilistic data structure that allows O(logN) search complexity as well as O(logN) insertion complexity within an ordered sequence of n elements. “，即跳表是一种概率数据结构，它在 n 个元素的有序序列中实现了 O(logN) 的查询复杂度和 O(logN) 的插入复杂度。</p>
<h1 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h1><blockquote>
<p>不同于一般单链表各节点只有 1 个 next 指针，SkipList 各节点有 x 个 next 指针（x 为随机生成），且这 x 个 next 指针还有“层级概念”</p>
</blockquote>
<img data-src="../../../../uploads/SkipList.png" class="full-image" />

<ul>
<li>如上图所示，跳表在递增链表各节点的第 i&#x2F;x 层 next 指针（1 &lt;&#x3D; i &lt;&#x3D; x），记录了后续首个层数不低于 i 的节点的地址。</li>
<li>查询时从首节点顶层开始查找：<ul>
<li>（若本层 next 指向节点的值为空，未找到且无跳转节点，则降层继续查找）</li>
<li>（若本层 next 指向节点的值等于目标值，则查询结束，找到）</li>
<li>若本层 next 指向节点的值小于目标值，则跳到指向节点继续查找，而中间层数较矮的节点会被“跳过”（因为链表递增，中间节点一定也小于目标值，故可跳过），从而缩小查询范围</li>
<li>若本层 next 指向节点的值大于目标值，则降层继续查找（因为链表递增，next 指向节点的后续节点一定也大于目标值，故可通过降层排除后续节点），从而缩小查找范围<ul>
<li>若此时层数已为 1，无层可降，则查询结束，未找到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-数据结构设计"><a href="#4-数据结构设计" class="headerlink" title="4. 数据结构设计"></a>4. 数据结构设计</h1><p>由上述 SkipList 原理可知其查询主要围绕节点的 x 层 next 指针，后续的增删改也是建立在此基础上，故这 x 层 next 指针数据结构的实现非常关键。首先需要一个成员变量来记录节点具有多少 next 指针（节点层数 x），其次考虑到层数 x 需要随机生成，故将 next 指针变量设计为双重指针，然后再加上传统单链表的 K，V 成员变量即可（为了方便扩展复用，博主这里采用了模板类实现），具体数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span>&lt;</span>K, V&gt;; <span class="comment">// 申明友元类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>();</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> level);</span><br><span class="line">    <span class="built_in">Node</span>(K key, V val, <span class="keyword">int</span> level);</span><br><span class="line">    ~<span class="built_in">Node</span>();</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node&lt;K, V&gt;&amp; another);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_next_nodes</span><span class="params">(<span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _level;</span><br><span class="line">    K _key;</span><br><span class="line">    V _val;</span><br><span class="line">    Node&lt;K, V&gt;** _next_nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 SkipList 对象的数据结构设计则较为简单：一个首节点变量、一个记录对象最大生成层数变量及一个记录节点个数变量即可，支持的方法除增删改查外增加了随机生成层数方法，备份加载 SkipList 对象数据方法，及一个图形化打印方法，具体数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SkipList</span>();</span><br><span class="line">    ~<span class="built_in">SkipList</span>();</span><br><span class="line">    Node&lt;K, V&gt;* find(const K key);              // 查找位置（未找到，得到其上一个位置）</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(K key, V val, <span class="keyword">int</span> level = <span class="number">-1</span>)</span></span>;  <span class="comment">// 增/改值</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(K key)</span></span>;                            <span class="comment">// 删值</span></span><br><span class="line">    <span class="function">V* <span class="title">get</span><span class="params">(K key)</span></span>;                              <span class="comment">// 取值</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dump</span><span class="params">(std::string file_path_to_dump = DEFAULT_DUMP_FILE_PATH)</span></span>;  <span class="comment">// 备份</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">load</span><span class="params">(std::string file_path_to_load = DEFAULT_DUMP_FILE_PATH)</span></span>;  <span class="comment">// 加载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">graphical_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;                 <span class="comment">// 可视化打印</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">stringSplit</span><span class="params">(<span class="keyword">const</span> std::string&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gen_rand_Level</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;K, V&gt;* _pre_header;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _node_cnt;</span><br><span class="line">    <span class="keyword">int</span> _max_level;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="5-编码实现"><a href="#5-编码实现" class="headerlink" title="5. 编码实现"></a>5. 编码实现</h1><h2 id="5-1-查询"><a href="#5-1-查询" class="headerlink" title="5.1. 查询"></a>5.1. 查询</h2><img data-src="../../../../uploads/SkipList_search.jpg" class="full-image" />

<p>如上图所示，查询节点 key 为 7 的步骤如下：</p>
<ul>
<li>以首节点顶层起，此时层数为 4 且本层 next 指针指向节点的 key 为 1（小于目标 7），则跳转到 next 指向的 1 节点</li>
<li>此时在 1 节点 4 层，本层 next 指针指向节点为空，降层</li>
<li>此时在 1 节点 3 层，本层 next 指针指向节点的 key 为 4（小于目标 7），则跳转到 next 指向的 4 节点</li>
<li>此时在 4 节点 3 层，本层 next 指针指向节点的 key 为 6（小于目标 7），则跳转到 next 指向的 6 节点</li>
<li>此时在 6 节点 3 层，本层 next 指针指向节点为空，降层</li>
<li>此时在 6 节点 2 层，本层 next 指针指向节点的 key 为 9（小于目标 7），降层</li>
<li>此时在 6 节点 1 层，本层 next 指针指向节点的 key 为 7（找到）</li>
</ul>
<p>查询方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">Node&lt;K, V&gt;* SkipList&lt;K, V&gt;::<span class="built_in">find</span>(<span class="keyword">const</span> K key) &#123;</span><br><span class="line">    Node&lt;K, V&gt;* node_ptr = _pre_header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按“从左至右 从上至下”的顺序，自 head 节点起，查找目标 key</span></span><br><span class="line">    <span class="keyword">while</span> (node_ptr) &#123;</span><br><span class="line">        <span class="keyword">int</span> level_i = node_ptr-&gt;_level - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; level_i &gt;= <span class="number">0</span>; --level_i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node_ptr-&gt;_next_nodes[level_i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// a. 若后一节点的 key 等于目标 key（找到），则返回后一节点的指针</span></span><br><span class="line">            <span class="keyword">if</span> (node_ptr-&gt;_next_nodes[level_i]-&gt;_key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> node_ptr-&gt;_next_nodes[level_i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// b. 若后一节点的 key 小于目标 key，则“跳至”同层后一节点，继续查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node_ptr-&gt;_next_nodes[level_i]-&gt;_key &lt; key) &#123;</span><br><span class="line">                node_ptr = node_ptr-&gt;_next_nodes[level_i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// c. 若后一节点的 key 大于目标 key，则降低层级 level_i，继续查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到，跳出</span></span><br><span class="line">        <span class="keyword">if</span> (level_i == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-新增节点"><a href="#5-2-新增节点" class="headerlink" title="5.2. 新增节点"></a>5.2. 新增节点</h2><img data-src="../../../../uploads/Skiplist_add_element.gif" class="full-image" />

<p>如上图插入的动图所示，新增节点的过程大致可分为两步：第一步是与上文查找类似的需要先“查找”到节点的拟插入位置，找到其前后节点、第二步是插入节点后根据其“层高”更新相关节点的第 1 到 x 层 next 指针指向（这里可通过事先记录其查找走过的节点层级“路径”，然后根据记录值找到应该修改哪部分 next 指针），具体编码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;K, V&gt;::<span class="built_in">insert</span>(K key, V val, <span class="keyword">int</span> level) &#123;</span><br><span class="line">    <span class="comment">// 查找 key 所在节点（或应插入位置的前一节点），并记录“途经”节点（用于更新指向）</span></span><br><span class="line">    Node&lt;K, V&gt;* record_find_path[MAX_LEVEL] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    Node&lt;K, V&gt;* cur_ptr = _pre_header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按“从左至右 从上至下”的顺序，自 head 节点起，查找目标 key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level_i = cur_ptr-&gt;_level - <span class="number">1</span>; level_i &gt;= <span class="number">0</span>; --level_i) &#123;</span><br><span class="line">        record_find_path[level_i] = cur_ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若节点当前层的后节点指针为空，继续降层寻找</span></span><br><span class="line">        <span class="keyword">if</span> (!cur_ptr-&gt;_next_nodes[level_i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. 若后一节点的 key 等于目标 key（已存在），则更新 val</span></span><br><span class="line">        <span class="keyword">if</span> (cur_ptr-&gt;_next_nodes[level_i]-&gt;_key == key) &#123;</span><br><span class="line">            cur_ptr-&gt;_next_nodes[level_i]-&gt;_val = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b. 若后一节点的 key 小于目标 key，则“跳至”同层后一节点，继续查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur_ptr-&gt;_next_nodes[level_i]-&gt;_key &lt; key) &#123;</span><br><span class="line">            cur_ptr = cur_ptr-&gt;_next_nodes[level_i];</span><br><span class="line">            ++level_i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c. 若后一节点的 key 大于目标 key，则降低层级 level_i，继续降层查找</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到，则新建节点</span></span><br><span class="line">    Node&lt;K, V&gt;* gen_node = <span class="keyword">new</span> Node&lt;K, V&gt;(key, val, level &gt; <span class="number">0</span> ? level : <span class="built_in">gen_rand_Level</span>());</span><br><span class="line">    <span class="built_in">assert</span>(gen_node);</span><br><span class="line">    <span class="built_in">log_debug</span>(<span class="string">&quot;gen node(%s) success, level = %d\n&quot;</span>, std::<span class="built_in">to_string</span>(gen_node-&gt;_key).<span class="built_in">c_str</span>(), gen_node-&gt;_level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新新增节点后变动的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level_i = gen_node-&gt;_level - <span class="number">1</span>; level_i &gt;= <span class="number">0</span>; --level_i) &#123;</span><br><span class="line">        <span class="comment">// 更新新增节点应指向的指针</span></span><br><span class="line">        <span class="keyword">if</span> (level_i &lt; _max_level &amp;&amp; record_find_path[level_i]) &#123;</span><br><span class="line">            gen_node-&gt;_next_nodes[level_i] = record_find_path[level_i]-&gt;_next_nodes[level_i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新指向新增节点的指针</span></span><br><span class="line">        <span class="keyword">if</span> (level_i &lt; _max_level) &#123;</span><br><span class="line">            record_find_path[level_i]-&gt;_next_nodes[level_i] = gen_node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _pre_header-&gt;_next_nodes[level_i] = gen_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++_node_cnt;</span><br><span class="line">    <span class="keyword">if</span> (gen_node-&gt;_level &gt; _max_level) &#123;</span><br><span class="line">        _max_level = gen_node-&gt;_level;</span><br><span class="line">        _pre_header-&gt;_level = _max_level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-删除节点"><a href="#5-3-删除节点" class="headerlink" title="5.3. 删除节点"></a>5.3. 删除节点</h2><p>与上文新增过程类似，删除节点也可大致分为查询和更新删除后相关 next 指针两步，不过需要注意两点，一是可能存在待删除节点不存在的情况（层数为 0 及时退出）、以及删除节点可能为“最高节点”还调整最大层层数，具体编码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;K, V&gt;::<span class="built_in">del</span>(K key) &#123;</span><br><span class="line">    <span class="comment">// 查找 key 所在节点（或应插入位置的前一节点），并记录“途经”节点（用于更新指向）</span></span><br><span class="line">    Node&lt;K, V&gt;* record_find_path[MAX_LEVEL] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    Node&lt;K, V&gt;* cur_ptr = _pre_header;</span><br><span class="line">    Node&lt;K, V&gt;* target_node_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按“从左至右 从上至下”的顺序，自 head 节点起，查找目标 key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level_i = cur_ptr-&gt;_level - <span class="number">1</span>; level_i &gt;= <span class="number">0</span>; --level_i) &#123;</span><br><span class="line">        record_find_path[level_i] = cur_ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若当前节点的遍历层对应的后节点为空，则继续降层寻找</span></span><br><span class="line">        <span class="keyword">if</span> (!cur_ptr-&gt;_next_nodes[level_i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. 若后一节点的 key 等于目标 key（已找到），标记并继续降层遍历以记录删除后受影响节点（用于更新指向）</span></span><br><span class="line">        <span class="keyword">if</span> (cur_ptr-&gt;_next_nodes[level_i]-&gt;_key == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!target_node_ptr) &#123;</span><br><span class="line">                target_node_ptr = cur_ptr-&gt;_next_nodes[level_i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b. 若后一节点的 key 小于目标 key，则“跳至”同层后一节点，继续查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur_ptr-&gt;_next_nodes[level_i]-&gt;_key &lt; key) &#123;</span><br><span class="line">            cur_ptr = cur_ptr-&gt;_next_nodes[level_i];</span><br><span class="line">            ++level_i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c. 若后一节点的 key 大于目标 key，则降低层级 level_i，继续降层查找</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!target_node_ptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若将删除节点为最大层数节点（或之一），则调整最大层层数</span></span><br><span class="line">    <span class="keyword">while</span> (_max_level &gt; <span class="number">0</span> &amp;&amp; _pre_header-&gt;_next_nodes[_max_level - <span class="number">1</span>] == target_node_ptr) &#123;</span><br><span class="line">        _pre_header-&gt;_next_nodes[_max_level - <span class="number">1</span>] = target_node_ptr-&gt;_next_nodes[_max_level - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (target_node_ptr-&gt;_next_nodes[_max_level - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pre_header-&gt;_level = --_max_level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变更受&quot;删除&quot;操作影响节点的指向并删除节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level_i = <span class="number">0</span>; level_i &lt; target_node_ptr-&gt;_level; ++level_i) &#123;</span><br><span class="line">        record_find_path[level_i]-&gt;_next_nodes[level_i] = target_node_ptr-&gt;_next_nodes[level_i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点内存</span></span><br><span class="line">    <span class="keyword">delete</span> target_node_ptr;</span><br><span class="line">    target_node_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    --_node_cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-备份"><a href="#5-4-备份" class="headerlink" title="5.4. 备份"></a>5.4. 备份</h2><p>备份一个 SkipList 对象的关键在于记录其每个节点随机生成的层数，博主实现较简单，是通过简单地按照 key,level,value 固定格式将各节点逐行存入文件中，详细实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;K, V&gt;::<span class="built_in">dump</span>(std::string file_path_to_dump) &#123;</span><br><span class="line">    Node&lt;K, V&gt;* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    std::ofstream ofs;</span><br><span class="line">    <span class="comment">// 覆盖之前缓存（若存在）</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(file_path_to_dump, std::ios::out | std::ios::trunc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ofs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="built_in">log_error</span>(<span class="string">&quot;Open file failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = _pre_header-&gt;_next_nodes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr) &#123;</span><br><span class="line">        ofs &lt;&lt; ptr-&gt;_key &lt;&lt; DELIMITER &lt;&lt; ptr-&gt;_level &lt;&lt; DELIMITER &lt;&lt; ptr-&gt;_val &lt;&lt; std::endl;</span><br><span class="line">        ptr = ptr-&gt;_next_nodes[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-加载"><a href="#5-5-加载" class="headerlink" title="5.5. 加载"></a>5.5. 加载</h2><p>加载过程是备份的逆向，只需逐行读取并按序解析到对应的 key,level,value 三个值，然后调用 insert() 函数添加即可，由于唯一的随机变量 level 以固定，故可重新生成与备份前结构相同的 SkipList 对象，详细实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;K, V&gt;::<span class="built_in">load</span>(std::string file_path_to_load) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">access</span>(file_path_to_load.<span class="built_in">c_str</span>(), F_OK ) != FILE_EXIST) &#123;</span><br><span class="line">        <span class="built_in">log_error</span>(<span class="string">&quot;Loading file is not exist!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::ifstream ifs;</span><br><span class="line">    std::string line;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">open</span>(file_path_to_load, std::ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="built_in">log_error</span>(<span class="string">&quot;Open file failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ifs, line)) &#123;</span><br><span class="line">        std::vector&lt;std::string&gt; elems = <span class="built_in">stringSplit</span>(line, DELIMITER);</span><br><span class="line">        <span class="keyword">if</span> (elems.<span class="built_in">size</span>() != <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assume K is Int and V is string</span></span><br><span class="line">        <span class="keyword">int</span> key = std::<span class="built_in">stoi</span>(elems[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> level = std::<span class="built_in">stoi</span>(elems[<span class="number">1</span>]);</span><br><span class="line">        std::string val = elems[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;key: &quot; &lt;&lt; key &lt;&lt; &quot;, level: &quot; &lt;&lt; level &lt;&lt; &quot;, val: &quot; &lt;&lt; val.c_str() &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="built_in">insert</span>(key, val, level);</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-可视化打印"><a href="#5-6-可视化打印" class="headerlink" title="5.6. 可视化打印"></a>5.6. 可视化打印</h2><p>通过由顶向下、由左至右的逐层打印的方式，以直观地显示 SkipList 对象的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> SkipList&lt;K, V&gt;::<span class="built_in">graphical_print</span>() &#123;</span><br><span class="line">    Node&lt;K, V&gt;* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> PRINT_WIDTH = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (_node_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log_info</span>(<span class="string">&quot;graphical print:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level_i = _max_level - <span class="number">1</span>; level_i &gt;= <span class="number">0</span>; --level_i) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(PRINT_WIDTH) &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> + std::<span class="built_in">to_string</span>(_pre_header-&gt;_next_nodes[level_i]-&gt;_key) + <span class="string">&quot; |:&quot;</span>;</span><br><span class="line">        ptr = _pre_header-&gt;_next_nodes[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (ptr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;_level &gt; level_i) &#123;</span><br><span class="line">                std::cout &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(PRINT_WIDTH) &lt;&lt; ptr-&gt;_key;</span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;_next_nodes[level_i]) &#123;</span><br><span class="line">                    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(PRINT_WIDTH) &lt;&lt; <span class="string">&quot; (-&gt;&quot;</span> + std::<span class="built_in">to_string</span>(ptr-&gt;_next_nodes[level_i]-&gt;_key) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cout &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(PRINT_WIDTH * <span class="number">2</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;_next_nodes[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可视化打印效果如下：<br><img data-src="../../../../uploads/SkipList_graphical_print.png" class="full-image" /></p>
<div class="note success"><p> 欢迎访问我的 Git 仓库阅读更多详细实现细节<br><a href="https://github.com/haoleeson/MyWorkspace/MyCpp/SkipList/src/skip_list/skip_list_node.h">https://github.com/haoleeson/MyWorkspace/MyCpp/SkipList/src/skip_list/skip_list_node.h</a><br><a href="https://github.com/haoleeson/MyWorkspace/MyCpp/SkipList/src/skip_list/skip_list.h">https://github.com/haoleeson/MyWorkspace/MyCpp/SkipList/src/skip_list/skip_list.h</a></p>
</div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2019/04/05/JavaStudyNote/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/JavaStudyNote.png" class="full-image" />

<h1 id="1-Java基础知识"><a href="#1-Java基础知识" class="headerlink" title="1. Java基础知识"></a>1. Java基础知识</h1><h2 id="1-1-引用-amp-对象"><a href="#1-1-引用-amp-对象" class="headerlink" title="1.1. 引用 &amp; 对象"></a>1.1. 引用 &amp; 对象</h2><ul>
<li><strong>对象</strong>：类的实例化，实质为运行时堆内为类内各属性值顺序分配的一组内存空间。<br>类变量(static)只在堆内分配一次，类内方法只在代码段内存一次。<a id="more"></a></li>
<li><strong>引用</strong>：传递消息的入口（通过引用访问与之关联的对象的各属性值或调用对象的方法，类似方法调用），引用可不指向对象单独存在（但仅声明无意义）</li>
</ul>
<p>备注：Java中除基本类型外，其他类型都是类<strong>class</strong>，都能实例化为对象，eg. String</p>
<h3 id="1-1-1-Java引用与C-x2F-C-指针的区别"><a href="#1-1-1-Java引用与C-x2F-C-指针的区别" class="headerlink" title="1.1.1. Java引用与C&#x2F;C++指针的区别"></a>1.1.1. Java引用与C&#x2F;C++指针的区别</h3><ul>
<li><p>相同点：<br>Java中的引用和C&#x2F;C++中的指针本质上都是通过一个别名，找到要操作的目标（变量对象等），方便在程序里操作</p>
</li>
<li><p>不同点：</p>
<ul>
<li>指针可以改变所指向的对象；引用一旦绑定某个对象后总是指向该对象不可改变。原因：在编译时，<ul>
<li>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。</li>
<li>符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的地址值可以改），而引用对象不能改。</li>
</ul>
</li>
<li>指针在32位系统中占4字节（64位系统中占8字节）；引用为被Java封装后的所指向对象的实际地址</li>
<li>指针声明时不会占内存，用到时才会分配内存；引用（编译时被确定为对象的实际地址）没有实体不占空间</li>
<li>指针可能产生越界访问；引用通过’.’访问所属类的属性值，有边界控制，不会出现越界</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-equals-的引用和对象区别（忽视将会造成重大问题）"><a href="#1-1-2-equals-的引用和对象区别（忽视将会造成重大问题）" class="headerlink" title="1.1.2. equals()的引用和对象区别（忽视将会造成重大问题）"></a>1.1.2. equals()的引用和对象区别（忽视将会造成重大问题）</h3><ul>
<li>equals()默认行为是比较引用（而非对象的内容），如自定义类调用</li>
<li>大多数Java类库实现了equals()可比较对象的内容<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test t1 = <span class="keyword">new</span> Test(<span class="number">10</span>);</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test(<span class="number">10</span>);</span><br><span class="line">System.out.println(t1.equals(t2));<span class="comment">//输出false，equals()默认行为是比较引用</span></span><br><span class="line"></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">//输出true，Java的String类库实现了equals()比较对象的内容</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-String-用法小记"><a href="#1-2-String-用法小记" class="headerlink" title="1.2. String 用法小记"></a>1.2. String 用法小记</h2><h3 id="1-2-1-String-当作对象处理需要new"><a href="#1-2-1-String-当作对象处理需要new" class="headerlink" title="1.2.1. String 当作对象处理需要new"></a>1.2.1. String 当作对象处理需要new</h3><p>Java将String视为一个对象，而非C&#x2F;C++中的数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String();</span><br><span class="line">String str2;<span class="comment">//只是声明引用，但未与对象关联</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-初始化字符串的其他方法"><a href="#1-2-2-初始化字符串的其他方法" class="headerlink" title="1.2.2. 初始化字符串的其他方法"></a>1.2.2. 初始化字符串的其他方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello World&quot;</span>;<span class="comment">//静态初始化</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//创建对象初始化</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="keyword">char</span> Array[]);<span class="comment">//将字符数组转化为字符串</span></span><br><span class="line">String str = <span class="keyword">new</span> String(str1 + str2);</span><br><span class="line">String str = str1;<span class="comment">//实测也是可以的，是根据str1重新分配内存并复制值，并非引用str1</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-访问字符串指定下标的字符"><a href="#1-2-3-访问字符串指定下标的字符" class="headerlink" title="1.2.3. 访问字符串指定下标的字符"></a>1.2.3. 访问字符串指定下标的字符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.charAt(<span class="number">1</span>);<span class="comment">//访问索引为1的字符（返回&quot;Hello&quot;中的&#x27;e&#x27;）</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-判断两个字符串是否相等"><a href="#1-2-4-判断两个字符串是否相等" class="headerlink" title="1.2.4. 判断两个字符串是否相等"></a>1.2.4. 判断两个字符串是否相等</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str1.equals(str2);<span class="comment">//严格区分大小写</span></span><br><span class="line">str1.equalsIgnoreCase(str2);<span class="comment">//不区分大小写</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-5-比较两个字符串"><a href="#1-2-5-比较两个字符串" class="headerlink" title="1.2.5. 比较两个字符串"></a>1.2.5. 比较两个字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str1.compareTo(str2);<span class="comment">//只有当str1与str2完全相等时才返回0, 否则返回按次序比较第一个不同字符的计算差值 eg:  &quot;aB&quot;.compareTo(&quot;aC&quot;);//会返回&#x27;B&#x27;-&#x27;C&#x27;的值-1</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-6-分割字符串"><a href="#1-2-6-分割字符串" class="headerlink" title="1.2.6. 分割字符串"></a>1.2.6. 分割字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello world xiao ming&quot;</span>;</span><br><span class="line">String[] strArray = str.split(<span class="string">&quot; &quot;</span>);<span class="comment">//用空格字符串将上述字符串分割</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">    System.out.println(strArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果：</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">xiao</span></span><br><span class="line"><span class="comment">ming</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String str = <span class="string">&quot;Hello world xiao ming&quot;</span>;</span><br><span class="line">String[] strArray = str.split(<span class="string">&quot; &quot;</span>, <span class="number">3</span>);<span class="comment">//用空格字符串将上述字符串分割, 最多分3个子串（按空格正常分前两个，最后一个为剩余字符子串）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">    System.out.println(strArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果：</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">xiao ming</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-7-查找子串"><a href="#1-2-7-查找子串" class="headerlink" title="1.2.7. 查找子串"></a>1.2.7. 查找子串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.indexOf(String s);<span class="comment">//返回子串s第一次出现的下标</span></span><br><span class="line">str.lastIndexOf(String s);<span class="comment">//返回子串s最后出现的下标</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-8-返回字符串去除前后空格的子串的副本"><a href="#1-2-8-返回字符串去除前后空格的子串的副本" class="headerlink" title="1.2.8. 返回字符串去除前后空格的子串的副本"></a>1.2.8. 返回字符串去除前后空格的子串的副本</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = str.trim();<span class="comment">//忽略字符串前后空格字符</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-9-替换子串"><a href="#1-2-9-替换子串" class="headerlink" title="1.2.9. 替换子串"></a>1.2.9. 替换子串</h3><p>将字符串内的部分子串替换为另外子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String newStr = str.replace(<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;abc&quot;</span>);<span class="comment">//将字符串str内所有“ABC”子串全部替换为“abc”</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-10-判断字符串是否以目标子串开始或结束"><a href="#1-2-10-判断字符串是否以目标子串开始或结束" class="headerlink" title="1.2.10. 判断字符串是否以目标子串开始或结束"></a>1.2.10. 判断字符串是否以目标子串开始或结束</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> a = str.startsWith(<span class="string">&quot;He&quot;</span>);<span class="comment">//字符串是否以子串“He”开头，返回true</span></span><br><span class="line"><span class="keyword">boolean</span> b = str.endsWith(<span class="string">&quot;llo&quot;</span>);<span class="comment">//字符串是否以子串“llo”结尾，返回true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-11-转换大小写字符"><a href="#1-2-11-转换大小写字符" class="headerlink" title="1.2.11. 转换大小写字符"></a>1.2.11. 转换大小写字符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = str.toLowerCase();<span class="comment">//将字符串内所有大写字符全转换为对应小写字符</span></span><br><span class="line">str = str.toUpperCase();<span class="comment">//将字符串内所有小写字符全转换为对应大写字符</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-数组用法小记"><a href="#1-3-数组用法小记" class="headerlink" title="1.3. 数组用法小记"></a>1.3. 数组用法小记</h2><h3 id="1-3-1-声明初始化二维数组"><a href="#1-3-1-声明初始化二维数组" class="headerlink" title="1.3.1. 声明初始化二维数组"></a>1.3.1. 声明初始化二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array1[][] = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> array2[<span class="number">3</span>][];</span><br><span class="line">array2[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">array2[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">array2[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-填充数组"><a href="#1-3-2-填充数组" class="headerlink" title="1.3.2. 填充数组"></a>1.3.2. 填充数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(array, <span class="number">8</span>);<span class="comment">//将array1数组的所有元素值更改为8</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-排序数组"><a href="#1-3-3-排序数组" class="headerlink" title="1.3.3. 排序数组"></a>1.3.3. 排序数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(array);<span class="comment">//用Java自带的(快排算法)对array1进行排序，默认从小到大</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-复制数组"><a href="#1-3-4-复制数组" class="headerlink" title="1.3.4. 复制数组"></a>1.3.4. 复制数组</h3><h4 id="1-3-4-1-copyOf-int-a-int-length"><a href="#1-3-4-1-copyOf-int-a-int-length" class="headerlink" title="1.3.4.1. copyOf(int a[], int length);"></a>1.3.4.1. copyOf(int a[], int length);</h4><ul>
<li>若length小于a.length，创建length大小的数组，然后复制a的前length长度的元素</li>
<li>若length大于a.length，创建length大小的数组，复制整个数组a，其后部分默认值0填充<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newArray[] = Arrays.copyOf(array, <span class="number">5</span>);<span class="comment">//复制array前5个元素组成一个新数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-4-2-copyOfRange-int-a-int-fromIndex-int-toIndex"><a href="#1-3-4-2-copyOfRange-int-a-int-fromIndex-int-toIndex" class="headerlink" title="1.3.4.2. copyOfRange(int a[], int fromIndex, int toIndex);"></a>1.3.4.2. copyOfRange(int a[], int fromIndex, int toIndex);</h4><p>创建toIndex-fromIndex大小的数组（可大于原始数组，其后用0填充），复制数组a从下标fromIndex到下标toIndex-1的元素<br><strong>备注</strong>：</p>
<ul>
<li>若toIndex-1 &gt; a.length-1，只复制到a[a.length-1]且其后填0</li>
<li>fromIndex 必须在取值范围[0, a.length-1]内，否则报错</li>
</ul>
<h4 id="1-3-4-3-特殊用法，给已固定数组扩容"><a href="#1-3-4-3-特殊用法，给已固定数组扩容" class="headerlink" title="1.3.4.3. 特殊用法，给已固定数组扩容"></a>1.3.4.3. 特殊用法，给已固定数组扩容</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array = Arrays.copyOf(array, array.length*<span class="number">2</span>);<span class="comment">//扩容array一倍，其后扩容的元素默认值为0</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-产生随机数小记"><a href="#1-4-产生随机数小记" class="headerlink" title="1.4. 产生随机数小记"></a>1.4. 产生随机数小记</h2><p>Java产生随机数的方式有两种：调用Math类的random()方法、调用Random类</p>
<h3 id="1-4-1-调用Math类的random-方法"><a href="#1-4-1-调用Math类的random-方法" class="headerlink" title="1.4.1. 调用Math类的random()方法"></a>1.4.1. 调用Math类的random()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> num = Math.random();<span class="comment">//产生 [0, 1.0) 之间的随机数</span></span><br><span class="line"><span class="keyword">double</span> num2 = a + Math.random() * (b - a);<span class="comment">//产生 [a, b) 之间的随机数</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-调用Random类"><a href="#1-4-2-调用Random类" class="headerlink" title="1.4.2. 调用Random类"></a>1.4.2. 调用Random类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();<span class="comment">//Java运行时JVM以当前系统时间为随机数生成器的种子</span></span><br><span class="line">Random r2 = <span class="keyword">new</span> Random(SeedValue);<span class="comment">//手动设置种子数值</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();<span class="comment">//Java运行时JVM以当前系统时间为随机数生成器的种子</span></span><br><span class="line"><span class="keyword">int</span> b = r.nextInt(<span class="number">100</span>);<span class="comment">//产生一个在 [0, 100)范围内的整数</span></span><br><span class="line"><span class="keyword">boolean</span> c = r.nextBoolean();<span class="comment">//产生一个随机布尔值</span></span><br><span class="line"><span class="keyword">float</span> d = r.nextFloat();<span class="comment">//产生一个随机单精度浮点数</span></span><br><span class="line"><span class="keyword">double</span> e = r.nextDouble();<span class="comment">//产生一个随机双精度浮点数</span></span><br><span class="line"><span class="keyword">double</span> f = r.nextGaussian();<span class="comment">//产生一个概率密度为高斯分布的随机双精度浮点数（连续调用一组）</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：两次函数调用的时间间隔过小，可能返回相同的随机数。</p>
<h1 id="2-Java核心技术"><a href="#2-Java核心技术" class="headerlink" title="2. Java核心技术"></a>2. Java核心技术</h1><h2 id="2-1-Java类的继承小记"><a href="#2-1-Java类的继承小记" class="headerlink" title="2.1. Java类的继承小记"></a>2.1. Java类的继承小记</h2><p>用代码更亲切地展示继承相关细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//爷爷类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandParents</span> </span>&#123;</span><br><span class="line">    GrandParents()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用爷爷类的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;<span class="comment">//无特殊要求非必须，Java垃圾回收机制会自动回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;销毁爷爷类实例&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.finalize();<span class="comment">//爷爷类的父类是Object类，Java每个类都直接或间接继承于java.lang.Object类，爷爷类定义等价于class GrandParents extends Object &#123;...&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类（继承于爷爷类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parents</span> <span class="keyword">extends</span> <span class="title">GrandParents</span> </span>&#123;</span><br><span class="line">    Parents(String name)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用父类:&quot;</span>+name+<span class="string">&quot;的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;<span class="comment">//无特殊要求非必须，Java垃圾回收机制会自动回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;销毁父类实例&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类（继承于父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Childron</span> <span class="keyword">extends</span> <span class="title">Parents</span> </span>&#123;</span><br><span class="line">    Childron()&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;Parents&quot;</span>);<span class="comment">//父类构造函数有参数时，不能自动调用，只能通过super显示调用父类构造函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用子类的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//重写父类doSomething函数，但修改权限只能不变或放大，不能缩小（若改为private会报错）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;<span class="comment">//【方法的重载】参数类型不同、参数个数不同、参数顺序不同均可构成重载(仅返回值不同不能构成重载)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span>... a)</span> </span>&#123;<span class="comment">//定义不定长方法</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            sum += a[i];<span class="comment">//当作数组来操作参数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;<span class="comment">//无特殊要求非必须，Java垃圾回收机制会自动回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;销毁子类实例&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Childron c = <span class="keyword">new</span> Childron();</span><br><span class="line">        System.out.println(c.doSomething(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.finalize();<span class="comment">//手动调用finalize销毁子类实例</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先实例化父类对象，再实例化子类对象；销毁时先销毁子类再逐级销毁父类实例</span></span><br><span class="line"><span class="comment">/* 运行结果：</span></span><br><span class="line"><span class="comment">调用爷爷类的构造函数</span></span><br><span class="line"><span class="comment">调用父类:Parents的构造函数</span></span><br><span class="line"><span class="comment">调用子类的构造函数</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">销毁子类实例</span></span><br><span class="line"><span class="comment">销毁父类实例</span></span><br><span class="line"><span class="comment">销毁爷爷类实例</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Object类"><a href="#2-2-Object类" class="headerlink" title="2.2. Object类"></a>2.2. Object类</h2><p>Java每个类都直接或间接继承于java.lang.Object类。在Object类中主要包括: clone(), finalize(), equals(), toString()等可重写的方法，及getClass(), notify(), notifyAll(), wait()等不可重写方法（Object中被定义为final类型）</p>
<h3 id="2-2-1-getClass-方法"><a href="#2-2-1-getClass-方法" class="headerlink" title="2.2.1. getClass()方法"></a>2.2.1. getClass()方法</h3><p>返回对象执行时的Class实例，一般于获取类的名称getName()方法连用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = c.getClass().getName();<span class="comment">//将返回实例c的类名“Childron”</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-Java-接口小记"><a href="#2-3-Java-接口小记" class="headerlink" title="2.3. Java 接口小记"></a>2.3. Java 接口小记</h2><p>接口是抽象类的延伸，可以将它看作是纯粹的抽象类，接口中的所有方法都没有方法体。接口的可以在子类中更灵活地选择方法功能，一个子类可以选择多个接口，然后每个接口类的方法都在该子类中有具体实现，不需要的方法直接不用接口就行，相比于在父类定义虚函数造成代码冗余和不能多继承，接口的出现更方便在子类中按需添加自定义方法。</p>
<h3 id="2-3-1-对比接口与抽象父类"><a href="#2-3-1-对比接口与抽象父类" class="headerlink" title="2.3.1. 对比接口与抽象父类"></a>2.3.1. 对比接口与抽象父类</h3><h4 id="2-3-1-1-1-先定义抽象父类实现子类不同方法的需求"><a href="#2-3-1-1-1-先定义抽象父类实现子类不同方法的需求" class="headerlink" title="2.3.1.1. 1.先定义抽象父类实现子类不同方法的需求"></a>2.3.1.1. 1.先定义抽象父类实现子类不同方法的需求</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义抽象四边形类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Quadrangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//声明抽象draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span></span>;<span class="comment">//声明抽象ba方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个平行四边形类（假设需要draw方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rhomboid</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//重写draw方法以满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//虽然不需要ba方法，但却不得不重写ba，否则报错，造成极大代码冗余</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个正方形类（假设需要draw方法和ba方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//重写draw方法以满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//重写ba方法以满足要求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个长方形类（不需要其他方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//虽然不需要draw方法，但却不得不重写draw，否则报错，造成极大代码冗余</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//虽然不需要ba方法，但却不得不重写ba，否则报错，造成极大代码冗余</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-2-抽象父类缺点："><a href="#2-3-1-2-抽象父类缺点：" class="headerlink" title="2.3.1.2. 抽象父类缺点："></a>2.3.1.2. 抽象父类缺点：</h4><ul>
<li>造成极大代码冗余</li>
<li>引发逻辑问题，不需要某些方法的子类必须重写抽象父类的所有虚函数，与逻辑不符</li>
</ul>
<h4 id="2-3-1-3-2-定义接口，子类灵活选择接口即可"><a href="#2-3-1-3-2-定义接口，子类灵活选择接口即可" class="headerlink" title="2.3.1.3. 2.定义接口，子类灵活选择接口即可"></a>2.3.1.3. 2.定义接口，子类灵活选择接口即可</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口 1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">drwaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//接口内的方法（类型只能是public或abstract）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义接口 2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">bala</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义四边形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quadrangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个平行四边形类（假设需要draw方法），并实现 drwaTest 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rhomboid</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span> <span class="keyword">implements</span> <span class="title">drwaTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制平行四边形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个正方形类（假设需要draw方法和ba方法），并实现drwaTest接口与bala接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span> <span class="keyword">implements</span> <span class="title">drwaTest</span>, <span class="title">bala</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制正方形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;balabala&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个长方形类（不需要其他方法，单纯继承四边形类即可）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-4-接口优点："><a href="#2-3-1-4-接口优点：" class="headerlink" title="2.3.1.4. 接口优点："></a>2.3.1.4. 接口优点：</h4><ul>
<li>逻辑清晰，随意加减接口，灵活实现</li>
<li>精简代码，只需将子类所需的接口中的方法重写即可</li>
<li>子类不能继承多个抽象父类（不能多重继承），但子类却可添加多个接口</li>
</ul>
<h2 id="2-4-异常"><a href="#2-4-异常" class="headerlink" title="2.4. 异常"></a>2.4. 异常</h2><p>常见异常：空指针，数组溢出，被除数为0，……，自定义异常等。</p>
<h3 id="2-4-1-自定义异常"><a href="#2-4-1-自定义异常" class="headerlink" title="2.4.1. 自定义异常"></a>2.4.1. 自定义异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMessage);<span class="comment">//调用父类构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.message = errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-捕获异常"><a href="#2-4-2-捕获异常" class="headerlink" title="2.4.2. 捕获异常"></a>2.4.2. 捕获异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义可能会抛出异常的方法，在方法中抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 &lt; <span class="number">0</span> || num2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;数字不能为负&quot;</span>);<span class="comment">//若条件为真执行到throw，在throw抛出异常后，此函数后续部分都不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1 &gt; <span class="number">100</span> || num2 &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;数字不能超过100&quot;</span>);<span class="comment">//若条件为真执行到throw，在throw抛出异常后，此函数后续部分都不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (num1 + num2) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">102</span>, y=<span class="number">5</span>, z=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isExceptionFlag = <span class="keyword">true</span>;<span class="comment">//是否发生异常标志</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            z = average(x, y);<span class="comment">//可能抛出异常的代码，放在try&#123;&#125;内执行，若异常发生就不会执行try&#123;&#125;内的下方代码</span></span><br><span class="line">            z += x / y;<span class="comment">//可能会抛出除数为0异常</span></span><br><span class="line">            isExceptionFlag = <span class="keyword">false</span>;<span class="comment">//当执行到此处，说明上方函数未发生异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            <span class="comment">// 若捕获到抛出的自定义异常，会执行下面代码</span></span><br><span class="line">            System.out.println(e.getMessage());<span class="comment">//输出异常携带的消息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获异常类型2（除数为0异常），异常处理代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//无论是否抛出异常，都会执行此块内代码</span></span><br><span class="line">            <span class="keyword">if</span> (isExceptionFlag)</span><br><span class="line">                System.out.println(<span class="string">&quot;发生异常&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;未发生异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1）当x=102, y=5时，运行结果：</span></span><br><span class="line"><span class="comment">数字不能超过100</span></span><br><span class="line"><span class="comment">发生异常</span></span><br><span class="line"><span class="comment">2）当x=10，y=0时，运行结果：</span></span><br><span class="line"><span class="comment">除数不能为0</span></span><br><span class="line"><span class="comment">发生异常</span></span><br><span class="line"><span class="comment">3）当x=10，y=5时，运行结果：</span></span><br><span class="line"><span class="comment">未发生异常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-Swing程序设计（跳过）"><a href="#2-5-Swing程序设计（跳过）" class="headerlink" title="2.5. Swing程序设计（跳过）"></a>2.5. Swing程序设计（跳过）</h2><h2 id="2-6-集合类"><a href="#2-6-集合类" class="headerlink" title="2.6. 集合类"></a>2.6. 集合类</h2><p>集合类，又称容器。常见的集合类有：List集合, Set集合, Map集合，其中List与Set继承了Collection接口。<br><img data-src="/../../../../uploads/Inheritance-relationship-of-common-collection-classes.jpg" alt="常见集合类的继承关系"><br><strong>与数组区别</strong>：</p>
<ul>
<li>数组的长度固定，而集合的长度可变；</li>
<li>数组存放基本类型的数据，集合存放对象的引用。</li>
</ul>
<h3 id="2-6-1-List集合"><a href="#2-6-1-List集合" class="headerlink" title="2.6.1. List集合"></a>2.6.1. List集合</h3><p>List的接口常用的实现类有：<strong>ArrayList</strong>与<strong>LinkedList</strong>。<br><strong>ArrayList</strong>：实现了可变长数组，允许保存所有元素，包括null，可根据索引快速访问数组内元素，但插入或删除元素时间较长。<br><strong>LinkedList</strong>：采用链表结构存储元素（数组元素上限仅受可用内存限制），类似链表，插入删除元素较快，但随机访问都会从头结点开始顺序向下遍历，故随机访问较慢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list1.add(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//添加元素&#x27;a&#x27;，List元素下标与数组一样从0开始</span></span><br><span class="line">list1.add(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//添加元素&#x27;b&#x27;</span></span><br><span class="line">list1.remove(<span class="number">1</span>);<span class="comment">//删除索引为1的元素</span></span><br><span class="line">System.out.println(list1);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-Set接口"><a href="#2-6-2-Set接口" class="headerlink" title="2.6.2. Set接口"></a>2.6.2. Set接口</h3><p>Set接口的常用实现类有：<strong>HashSet</strong>与<strong>TreeSet</strong><br><strong>HashSet</strong>：由哈希表支持（实际上是一个HashMap实例），不保证Set的迭代顺序（不稳定），允许使用null元素<br><strong>TreeSet</strong>：TreeSet实现的Set集合在遍历集合时按照自然顺序递增排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">tree.add(<span class="string">&quot;ZhangSan&quot;</span>);</span><br><span class="line">tree.add(<span class="string">&quot;LiSi&quot;</span>);</span><br><span class="line">tree.add(<span class="string">&quot;WangWu&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = tree.iterator();<span class="comment">//Set集合中的所有对象的迭代器</span></span><br><span class="line"><span class="comment">//遍历Set集合</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">  String tmp = (String)it.next();</span><br><span class="line">  System.out.println(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果（与插入顺序无关，自然递增）</span></span><br><span class="line"><span class="comment">LiSi</span></span><br><span class="line"><span class="comment">WangWu</span></span><br><span class="line"><span class="comment">ZhangSan</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-List集合-vs-Set集合"><a href="#2-6-3-List集合-vs-Set集合" class="headerlink" title="2.6.3. List集合 vs Set集合"></a>2.6.3. List集合 vs Set集合</h3><ul>
<li>List集合允许元素重复，而Set集合<strong>不能包含重复对象</strong></li>
<li>List集合元素顺序为插入顺序（类似数组），而Set集合不保证顺序</li>
<li>List访问指定索引的元素<code>get(int index)</code>或<code>set<int index, Object obj></code>，而Set集合不能访问指定索引元素</li>
</ul>
<h3 id="2-6-4-Map集合"><a href="#2-6-4-Map集合" class="headerlink" title="2.6.4. Map集合"></a>2.6.4. Map集合</h3><p>Map接口的常用实现类有<strong>HashMap</strong>(无序，允许null值)和<strong>TreeMap</strong>(升序，不允许null值)。<br> Map提供key到value的映射，Map中不能包含相同的key，每个key只能映射一个value。Key还决定了存储对象在映射中的存储位置，但不是由key本身决定的，而是由key根据”散列技术”产生的散列码整数值（作为偏移量）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;ZhangSan&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;LiSi&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;WangWu&quot;</span>);</span><br><span class="line"><span class="comment">//遍历Map的Key值集合</span></span><br><span class="line">Set&lt;Integer&gt; s = map.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = s.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历Map的Value值集合</span></span><br><span class="line">Collection&lt;String&gt; c = map.values();</span><br><span class="line">Iterator&lt;String&gt; it2 = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (it2.hasNext())&#123;</span><br><span class="line">    System.out.println(it2.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">ZhangSan</span></span><br><span class="line"><span class="comment">LiSi</span></span><br><span class="line"><span class="comment">WangWu</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-文件File"><a href="#2-7-文件File" class="headerlink" title="2.7. 文件File"></a>2.7. 文件File</h2><h3 id="2-7-1-文件的创建与删除"><a href="#2-7-1-文件的创建与删除" class="headerlink" title="2.7.1. 文件的创建与删除"></a>2.7.1. 文件的创建与删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/haoleeson/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中）,绝对路径</span></span><br><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;/Users/haoleeson/Test/&quot;</span>, <span class="string">&quot;test2.txt&quot;</span>);<span class="comment">//在目录下 创建文件对象（于内存中）,绝对路径</span></span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">    file.delete();<span class="comment">//删除文件</span></span><br><span class="line">    System.out.println(file.getName() + <span class="string">&quot;文件已存在, 故删除&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();<span class="comment">//创建该文件（于磁盘中）</span></span><br><span class="line">        System.out.println(file.getName() + <span class="string">&quot;文件不存在，故创建&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-File文件的常用方法"><a href="#2-7-2-File文件的常用方法" class="headerlink" title="2.7.2. File文件的常用方法"></a>2.7.2. File文件的常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String FileName = file.getName();<span class="comment">//获取文件名</span></span><br><span class="line"><span class="keyword">boolean</span> isReadable = file.canRead();<span class="comment">//返回文件是否可读</span></span><br><span class="line"><span class="keyword">boolean</span> isWriteable = file.canWrite();<span class="comment">//返回文件是否可写</span></span><br><span class="line"><span class="keyword">boolean</span> isFileExisted = file.exists();<span class="comment">//返回文件是否在该目录（File类型记录路径）存在</span></span><br><span class="line"><span class="keyword">long</span> FileLength = file.length();<span class="comment">//文件的大小（单位：字节）</span></span><br><span class="line">String FileAbsolutePath = file.getAbsolutePath();<span class="comment">//文件的绝对路径</span></span><br><span class="line">String FileParentPath = file.getParent();<span class="comment">//获取文件所在目录</span></span><br><span class="line"><span class="keyword">boolean</span> isAFile = file.isFile();<span class="comment">//是否为普通文件（而非目录文件，或链接文件）</span></span><br><span class="line"><span class="keyword">boolean</span> isADirectory = file.isDirectory();<span class="comment">//是否为一个目录文件</span></span><br><span class="line"><span class="keyword">boolean</span> isHiddened = file.isHidden();<span class="comment">//判断文件是否为隐藏文件</span></span><br><span class="line"><span class="keyword">long</span> lastChangeTime = file.lastModified();<span class="comment">//文件最后修改时间</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;lastChangeTime = &quot;</span> + lastChangeTime);</span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(file.getName() + <span class="string">&quot;文件的最近修改时间为：&quot;</span> + dateFormat.format(<span class="keyword">new</span> Date(lastChangeTime)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">lastChangeTime = 1555158024000</span></span><br><span class="line"><span class="comment">test.txt文件的最近修改时间为：2019-04-13 20:20:24</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-3-文件输入输出流"><a href="#2-7-3-文件输入输出流" class="headerlink" title="2.7.3. 文件输入输出流"></a>2.7.3. 文件输入输出流</h3><h4 id="2-7-3-1-FileInputStream与FileOutputStream类"><a href="#2-7-3-1-FileInputStream与FileOutputStream类" class="headerlink" title="2.7.3.1. FileInputStream与FileOutputStream类"></a>2.7.3.1. FileInputStream与FileOutputStream类</h4><p>操作磁盘文件，可满足简单的文件读写需求。但由于读写操作以字节或字节数组为单位，由于汉字占两个字节，若读取readBuff[]容量设置为单字节，或正好错开一字节会导致汉字乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/haoleeson/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中）,绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件测试</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileOutputStream简单文件输出流对象</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    <span class="comment">//创建byte数组</span></span><br><span class="line">    <span class="keyword">byte</span> writeBuff[] = <span class="string">&quot;写入如下字符串以测试简单文件输出流功能。&quot;</span>.getBytes();</span><br><span class="line">    out.write(writeBuff);<span class="comment">//将数组中内容写入磁盘</span></span><br><span class="line">    out.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件测试</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileOutputStream简单文件读取流对象</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    <span class="keyword">byte</span> readBuff[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">//创建大小为1KB的读取缓存</span></span><br><span class="line">    <span class="keyword">int</span> len = in.read(readBuff);<span class="comment">//从文件中读取内容到readBuff数组，并返回读取的内容大小（单位：字节）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取到的内容如下：\n&quot;</span> + <span class="keyword">new</span> String(readBuff, <span class="number">0</span>, len) + <span class="string">&quot;&lt;END&gt;&quot;</span>);<span class="comment">//将读到的readBuff数组内Byte类型数据转换为String输出</span></span><br><span class="line">    in.close();<span class="comment">//关闭读取流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">读取到的内容如下：</span></span><br><span class="line"><span class="comment">写入如下字符串以测试简单文件输出流功能。</span></span><br><span class="line"><span class="comment">&lt;END&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-2-FileReader与FileWriter类"><a href="#2-7-3-2-FileReader与FileWriter类" class="headerlink" title="2.7.3.2. FileReader与FileWriter类"></a>2.7.3.2. FileReader与FileWriter类</h4><p>能够避免FileInputStream与FileOutputStream类可能出现的汉字读写乱码现象。FileReader流顺序地读取文件，只要不关闭流，每次调用read()方法就顺序地读取源中的内容，直到源的末尾或流被关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/haoleeson/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中）,绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileWriter文件输出流对象</span></span><br><span class="line">    FileWriter out = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">    String writerStr = <span class="string">&quot;尝试写入如下字符串以测试FileWriter文件输入流功能。\n&quot;</span>;</span><br><span class="line">    out.write(writerStr);<span class="comment">//将writerStr内容写入磁盘文件中(会清空原文件所有内容)</span></span><br><span class="line">    out.close();<span class="comment">//关闭写文件流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileReader文件读取流对象</span></span><br><span class="line">    FileReader in = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="keyword">char</span> readBuff[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>]; <span class="comment">//创建char类型读取内容数组</span></span><br><span class="line">    <span class="keyword">int</span> len = in.read(readBuff);<span class="comment">//从文件中读取内容到readBuff数组，并返回读取的内容char数组长度</span></span><br><span class="line">    in.close();<span class="comment">//关闭读文件流</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取到的内容如下：\n&quot;</span> + <span class="keyword">new</span> String(readBuff, <span class="number">0</span>, len) + <span class="string">&quot;&lt;END&gt;&quot;</span>);<span class="comment">//将读到的readBuff数组内数据转换为String输出</span></span><br><span class="line">    in.close();<span class="comment">//关闭读取流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">读取到的内容如下：</span></span><br><span class="line"><span class="comment">尝试写入如下字符串以测试FileWriter文件输入流功能。</span></span><br><span class="line"><span class="comment">&lt;END&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-3-带缓存的输入-x2F-输出流"><a href="#2-7-3-3-带缓存的输入-x2F-输出流" class="headerlink" title="2.7.3.3. 带缓存的输入&#x2F;输出流"></a>2.7.3.3. 带缓存的输入&#x2F;输出流</h4><p><strong>BufferedInputStream</strong>与<strong>BufferedOutputStream</strong>类。BufferedInputStream类可以对所有的InputStream类进行带缓存区的包装以达到性能的优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedInputStream(InputStream in);<span class="comment">//创建一个带有32个字节的缓存流</span></span><br><span class="line">BufferedInputStream(InputStream in, <span class="keyword">int</span> size);<span class="comment">//创建一个自定义大小的读取流缓存区</span></span><br></pre></td></tr></table></figure>
<p>BufferedOutputStream类有一个flush()方法可以将缓存区内的数据强制输出到磁盘（无论缓存区满否）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedOutputStream(OutputStream out);<span class="comment">//创建一个带有32字节的缓存区</span></span><br><span class="line">BufferedOutputStream(OutputStream out, <span class="keyword">int</span> size);<span class="comment">//创建一个自定义大小的写出流缓存区</span></span><br></pre></td></tr></table></figure>
<p><strong>BufferedReader</strong>与<strong>BufferedWriter</strong>类<br>BufferedReader与BufferedWriter类分别继承Reader类与Writer类。这两个类同样具有内部缓存机制，并可以以行为为单位进行输入输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/haoleeson/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中）,绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带缓存写文件操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileWriter文件输出流对象</span></span><br><span class="line">    FileWriter fileWriter = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">    <span class="comment">//创建带缓存区的输出流</span></span><br><span class="line">    BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(fileWriter);</span><br><span class="line">    String writerStr = <span class="string">&quot;尝试写入如下字符串以测试带缓存区的输出流功能。&quot;</span>;</span><br><span class="line">    bufferedWriter.write(writerStr);<span class="comment">//将writerStr内容写入缓存区（自动控制，缓存区满自动写入磁盘，避免频繁读写磁盘）</span></span><br><span class="line">    bufferedWriter.newLine();<span class="comment">//将换行符写入文件</span></span><br><span class="line">    bufferedWriter.close();<span class="comment">//关闭写缓存区流</span></span><br><span class="line">    fileWriter.close();<span class="comment">//关闭输出流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带缓存区读文件操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileReader文件读取流对象</span></span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="comment">//创建带缓存区的读取流</span></span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    String readStr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果文件的文本行不为null，则进入循环</span></span><br><span class="line">    <span class="keyword">while</span>((readStr = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        row++;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取到第&quot;</span>+ row + <span class="string">&quot;行的内容为：&quot;</span> + readStr);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&lt;END&gt;&quot;</span>);</span><br><span class="line">    bufferedReader.close();<span class="comment">//关闭读缓存区流</span></span><br><span class="line">    fileReader.close();<span class="comment">//关闭读取流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">读取到第1行的内容为：尝试写入如下字符串以测试带缓存区的输出流功能。</span></span><br><span class="line"><span class="comment">&lt;END&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>BufferedReader</strong>类的常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = bufferedReader.read();<span class="comment">//读取单个字符(unicode两字节)</span></span><br><span class="line">System.out.println(<span class="string">&quot;ch = &quot;</span> + (<span class="keyword">char</span>)ch);<span class="comment">//输出结果为：尝</span></span><br><span class="line">String readStr = bufferedReader.readLine();<span class="comment">//读取一行</span></span><br></pre></td></tr></table></figure>
<p><strong>BufferedWriter</strong>类的常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bufferedWriter.write(writerStr, <span class="number">0</span>, writerStr.length());<span class="comment">//写入字符串的某一索引区间内容（此处为全部写入）</span></span><br><span class="line">bufferedWriter.flush();<span class="comment">//强制将缓存区的内容写入到磁盘（不管缓存区满否）</span></span><br><span class="line">bufferedWriter.newLine();<span class="comment">//将换行符写入文件</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-4-数据输入输出流"><a href="#2-7-3-4-数据输入输出流" class="headerlink" title="2.7.3.4. 数据输入输出流"></a>2.7.3.4. 数据输入输出流</h4><p><strong>DataInputStream</strong>与<strong>DataOutputStream</strong>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/haoleeson/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中），绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试数据输出流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(fileOutputStream);</span><br><span class="line">    <span class="comment">//dataOutputStream.writeBytes(&quot;尝试以Byte格式写入内容。&quot;);</span></span><br><span class="line">    <span class="comment">//dataOutputStream.writeChars(&quot;尝试以Char格式写入内容。&quot;);</span></span><br><span class="line">    dataOutputStream.writeUTF(<span class="string">&quot;尝试以UTF格式写入内容。&quot;</span>);</span><br><span class="line">    dataOutputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试数据输入流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(fileInputStream);</span><br><span class="line">    String readStr = dataInputStream.readUTF();<span class="comment">//尝试以UTF格式读取文件内容</span></span><br><span class="line">    System.out.println(<span class="string">&quot;以UTF格式读取的内容为: &quot;</span> + readStr + <span class="string">&quot;&lt;END&gt;&quot;</span>);</span><br><span class="line">    dataInputStream.close();<span class="comment">//关闭数据输入流</span></span><br><span class="line">    fileInputStream.close();<span class="comment">//关闭文件写入流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">以UTF格式读取的内容为: 尝试以UTF格式写入内容。&lt;END&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-5-ZIP压缩输入-x2F-输出流（压缩-x2F-解压文件）"><a href="#2-7-3-5-ZIP压缩输入-x2F-输出流（压缩-x2F-解压文件）" class="headerlink" title="2.7.3.5. ZIP压缩输入&#x2F;输出流（压缩&#x2F;解压文件）"></a>2.7.3.5. ZIP压缩输入&#x2F;输出流（压缩&#x2F;解压文件）</h4><p>ZIP压缩管理文件（Zip archive）是一种十分典型的文件压缩形式。常用<strong>ZipOutputStream</strong>与<strong>ZipInputStream</strong>类来实现文件的<strong>压缩</strong>&#x2F;<strong>解压缩</strong>。</p>
<h5 id="2-7-3-5-1-压缩文件（ZipOutputStream类）"><a href="#2-7-3-5-1-压缩文件（ZipOutputStream类）" class="headerlink" title="2.7.3.5.1. 压缩文件（ZipOutputStream类）"></a>2.7.3.5.1. <strong>压缩文件（ZipOutputStream类）</strong></h5><p>若要将某个文件添加到ZIP压缩管理文件内，必须先写入待添加文件的目录进入点（待添加文件在ZIP文件内的位置），并且把待添加文件内容的位置移到此进入点说指的位置，然后再写入文件内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 压缩文件类</span></span><br><span class="line"><span class="comment"> * coder：haoleeson</span></span><br><span class="line"><span class="comment"> * Java</span></span><br><span class="line"><span class="comment"> * 20190414*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加壳压缩文件函数</span></span><br><span class="line"><span class="comment">     * 输入参数：zipFileName -- 压缩后的文件名，inputFile -- 待压缩文件</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String zipFileName, File inputFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File unzipFile = <span class="keyword">new</span> File(zipFileName);<span class="comment">//获取待压缩文件 对象</span></span><br><span class="line">        String Base = inputFile.getName();<span class="comment">//得到待压缩文件名</span></span><br><span class="line">        ZipOutputStream out = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(zipFileName));<span class="comment">//新建ZipOutputStream对象</span></span><br><span class="line">        zip(out, inputFile, Base); <span class="comment">//相对目录进入点为空</span></span><br><span class="line">        out.close();<span class="comment">//关闭压缩流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩文件核心函数</span></span><br><span class="line"><span class="comment">     * 输入参数：zipout - 压缩流、file - 待压缩文件、base - 目录进入点</span></span><br><span class="line"><span class="comment">     * 若为单个文件 - 直接拷贝压缩，若为目录文件 - 递归调用自身</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zip</span><span class="params">(ZipOutputStream zipout, File file, String base)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//判断文件是否为目录文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">//若问文件夹，列出待压缩文件夹内所有文件</span></span><br><span class="line">            File[] fl = file.listFiles();<span class="comment">//获取路径数组</span></span><br><span class="line">            <span class="comment">//循环遍历待压缩文件夹内的所有文件(可能存在多级文件夹)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fl.length; i++) &#123;</span><br><span class="line">                String tmpBase = base + <span class="string">&quot;/&quot;</span> + fl[i].getName();<span class="comment">//路径写入点为</span></span><br><span class="line">                zip(zipout, fl[i], tmpBase);<span class="comment">//递归调</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若为单个文件，直接拷贝压缩</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            zipout.putNextEntry(<span class="keyword">new</span> ZipEntry(base));<span class="comment">//创建新的进入点</span></span><br><span class="line">            <span class="comment">//创建FileInputStream写出流对象</span></span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            System.out.println(<span class="string">&quot;压缩 &quot;</span> + base + <span class="string">&quot; 位置的 &quot;</span> + file.getName() + <span class="string">&quot; 文件 ...&quot;</span>);<span class="comment">//打印当前目录进入点</span></span><br><span class="line">            <span class="comment">//逐一字节拷贝压缩</span></span><br><span class="line">            <span class="keyword">while</span> ((ch = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                zipout.write(ch);<span class="comment">//将字节写入当前ZIP条目</span></span><br><span class="line">            &#125;</span><br><span class="line">            in.close();<span class="comment">//关闭读取流</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZipTest zipTest = <span class="keyword">new</span> ZipTest();</span><br><span class="line">        <span class="comment">//尝试压缩</span></span><br><span class="line">        String zipFileName = <span class="string">&quot;/Users/haoleeson/Downloads/Test.zip&quot;</span>;<span class="comment">//压缩后得到的文件名</span></span><br><span class="line">        String inputFile = <span class="string">&quot;/Users/haoleeson/Test/&quot;</span>;<span class="comment">//待压缩文件（可谓普通文件 或 目录文件）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;尝试压缩 &quot;</span> + inputFile + <span class="string">&quot; 到 &quot;</span> + zipFileName + <span class="string">&quot; ...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zipTest.zipFile(zipFileName, <span class="keyword">new</span> File(inputFile));<span class="comment">//调用加壳压缩文件函数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;压缩完成:)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">尝试压缩 /Users/haoleeson/Test/ 到 /Users/haoleeson/Downloads/Test.zip ...</span></span><br><span class="line"><span class="comment">压缩 Test/test2.txt 位置的 test2.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/Second/test3.txt 位置的 test3.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/Second/Third/test4.txt 位置的 test4.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/Second/test3的副本.txt 位置的 test3的副本.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/test2的副本.txt 位置的 test2的副本.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/test.txt 位置的 test.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩完成:)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="2-7-3-5-2-解压缩文件（ZipInputStream类）"><a href="#2-7-3-5-2-解压缩文件（ZipInputStream类）" class="headerlink" title="2.7.3.5.2. 解压缩文件（ZipInputStream类）"></a>2.7.3.5.2. <strong>解压缩文件（ZipInputStream类）</strong></h5><p>若要从ZIP压缩管理文件内提取某个文件，要先找到待提取文件的目录进入点（该文件在ZIP文件内的位置），才能读取这个文件的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipFile;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 解压缩类</span></span><br><span class="line"><span class="comment"> * coder：haoleeson</span></span><br><span class="line"><span class="comment"> * Java</span></span><br><span class="line"><span class="comment"> * 20190414*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnzipTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压缩文件方法，解压到当前目录</span></span><br><span class="line"><span class="comment">     * 参数：unZipFileName -- 待解压缩文件名（含路径）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Unzip</span><span class="params">(String unZipFileName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File unzipFile = <span class="keyword">new</span> File(unZipFileName);<span class="comment">//获取待压缩文件 对象</span></span><br><span class="line">        String finalPath = unzipFile.getParentFile() + <span class="string">&quot;/&quot;</span>;<span class="comment">//得到待解压缩文件的绝对路径</span></span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(unzipFile);<span class="comment">//创建Zip压缩文件 对象</span></span><br><span class="line">        ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(unzipFile));<span class="comment">//实例化解压缩ZipInputStream对象</span></span><br><span class="line">        ZipEntry entry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代解压缩所有目录树上的文件（包括目录文件）</span></span><br><span class="line">        <span class="keyword">while</span> ((entry=zipInputStream.getNextEntry())!=<span class="keyword">null</span> &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">            File tmp = <span class="keyword">new</span> File(finalPath + entry.getName());<span class="comment">//解压出的文件路径</span></span><br><span class="line">            <span class="comment">//如果文件不存在</span></span><br><span class="line">            <span class="keyword">if</span> (!tmp.exists()) &#123;</span><br><span class="line">                tmp.getParentFile().mkdirs();<span class="comment">//创建父类文件夹路径</span></span><br><span class="line">                OutputStream writeStream = <span class="keyword">new</span> FileOutputStream(tmp);<span class="comment">//将文件目录中的文件放入输出流</span></span><br><span class="line">                System.out.println(<span class="string">&quot;解压缩 &quot;</span> + tmp.getAbsolutePath() + <span class="string">&quot; 文件 ...&quot;</span>);</span><br><span class="line">                <span class="comment">//用输入流读取压缩文件中制定目录中的文件</span></span><br><span class="line">                InputStream readStream = zipFile.getInputStream(entry);</span><br><span class="line">                <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((ch = readStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    writeStream.write(ch);</span><br><span class="line">                &#125;</span><br><span class="line">                writeStream.close();<span class="comment">//关闭写文件流</span></span><br><span class="line">                readStream.close();<span class="comment">//关闭读文件流</span></span><br><span class="line">            &#125;</span><br><span class="line">            zipInputStream.closeEntry();<span class="comment">//关闭当前Entry</span></span><br><span class="line">        &#125;</span><br><span class="line">        zipInputStream.close();<span class="comment">//关闭解压缩流</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解压缩已完成:)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnzipTest unzipTest = <span class="keyword">new</span> UnzipTest();</span><br><span class="line">        String unzipFileName = <span class="string">&quot;/Users/haoleeson/Downloads/Test.zip&quot;</span>;<span class="comment">//待解压缩文件名（含路径）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unzipTest.Unzip(unzipFileName);<span class="comment">//尝试解压缩</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">解压缩 /Users/haoleeson/Downloads/Test/test2.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/haoleeson/Downloads/Test/Second/test3.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/haoleeson/Downloads/Test/Second/Third/test4.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/haoleeson/Downloads/Test/Second/test3的副本.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/haoleeson/Downloads/Test/test2的副本.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/haoleeson/Downloads/Test/test.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩已完成:)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-多线程"><a href="#2-8-多线程" class="headerlink" title="2.8. 多线程"></a>2.8. 多线程</h2><p>在Java中可通过继承java.lang.Thread类与实现java.lang.Runnable接口两种方式。</p>
<h3 id="2-8-1-Theard类与Runnable类实现线程区别"><a href="#2-8-1-Theard类与Runnable类实现线程区别" class="headerlink" title="2.8.1. Theard类与Runnable类实现线程区别"></a>2.8.1. Theard类与Runnable类实现线程区别</h3><p>Thread实现必须继承Thread类，而继承Runnable接口则更方便</p>
<h3 id="2-8-2-继承Thread类"><a href="#2-8-2-继承Thread类" class="headerlink" title="2.8.2. 继承Thread类"></a>2.8.2. 继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);<span class="comment">//调用父类Thread构造函数，给线程命名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写run()方法实现线程执行的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (++i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">            <span class="comment">//延时方式1：</span></span><br><span class="line"><span class="comment">//            for (long k=0; k&lt;100000000; k++);//阻塞式延时，不推荐（占CPU）</span></span><br><span class="line">            <span class="comment">//延时方式2：</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//线程休眠1秒，推荐（让出CPU）</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Thread test1 = <span class="keyword">new</span> TestThread(<span class="string">&quot;A&quot;</span>);<span class="comment">//定义线程&quot;A&quot;</span></span><br><span class="line">        Thread test2 = <span class="keyword">new</span> TestThread(<span class="string">&quot;BBB&quot;</span>);<span class="comment">//定义线程&quot;BBB&quot;</span></span><br><span class="line">        test1.start();<span class="comment">//启动线程&quot;A&quot;</span></span><br><span class="line">        test2.start();<span class="comment">//启动线程&quot;BBB&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//主线程在while死循环内</span></span><br><span class="line">            System.out.println((i++) + <span class="string">&quot;:Main&quot;</span>);<span class="comment">//Main主线程执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">600</span>);<span class="comment">//主线程延时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">1:A</span></span><br><span class="line"><span class="comment">1:BBB</span></span><br><span class="line"><span class="comment">0:Main</span></span><br><span class="line"><span class="comment">1:Main</span></span><br><span class="line"><span class="comment">2:BBB</span></span><br><span class="line"><span class="comment">2:A</span></span><br><span class="line"><span class="comment">2:Main</span></span><br><span class="line"><span class="comment">3:Main</span></span><br><span class="line"><span class="comment">3:A</span></span><br><span class="line"><span class="comment">3:BBB</span></span><br><span class="line"><span class="comment">4:Main</span></span><br><span class="line"><span class="comment">4:A</span></span><br><span class="line"><span class="comment">4:BBB</span></span><br><span class="line"><span class="comment">5:Main</span></span><br><span class="line"><span class="comment">6:Main</span></span><br><span class="line"><span class="comment">7:Main</span></span><br><span class="line"><span class="comment">...(主函数仍在while循环)...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>由此可知同一进程内的子线程，它们的运行先后顺序是随机的。</p>
<h3 id="2-8-3-实现Runnable接口"><a href="#2-8-3-实现Runnable接口" class="headerlink" title="2.8.3. 实现Runnable接口"></a>2.8.3. 实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runnable;</span><br><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dosomething</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Dosomething</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重写run()方法实现线程执行的操作</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">                System.out.println(i+ <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">//线程休眠1秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序：测试Runnable多线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dosomething t1 = <span class="keyword">new</span> Dosomething(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Dosomething t2 = <span class="keyword">new</span> Dosomething(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        Thread test1 = <span class="keyword">new</span> Thread(t1);<span class="comment">//创建Thread对象，并与继承了Runnable接口的对象关联</span></span><br><span class="line">        Thread test2 = <span class="keyword">new</span> Thread(t2);</span><br><span class="line">        test1.start();<span class="comment">//启动线程1（关联的对象“A”）</span></span><br><span class="line">        test2.start();<span class="comment">//启动线程2（关联的对象“BBB”）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">1:A</span></span><br><span class="line"><span class="comment">1:BBB</span></span><br><span class="line"><span class="comment">2:A</span></span><br><span class="line"><span class="comment">2:BBB</span></span><br><span class="line"><span class="comment">3:A</span></span><br><span class="line"><span class="comment">3:BBB</span></span><br><span class="line"><span class="comment">4:BBB</span></span><br><span class="line"><span class="comment">4:A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-8-4-操作线程的方法"><a href="#2-8-4-操作线程的方法" class="headerlink" title="2.8.4. 操作线程的方法"></a>2.8.4. 操作线程的方法</h3><h4 id="2-8-4-1-线程休眠"><a href="#2-8-4-1-线程休眠" class="headerlink" title="2.8.4.1. 线程休眠"></a>2.8.4.1. 线程休眠</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">//线程休眠1秒</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep()方法通常在run()方法内循环使用，因sleep()方法的执行有可能抛出InterruptedException异常，所以需放在try-catch块中，该线程在1秒休眠结束后会进入<strong>就绪态</strong>（不一定是<strong>运行态</strong>）。</p>
<h4 id="2-8-4-2-线程的加入（join-方法）"><a href="#2-8-4-2-线程的加入（join-方法）" class="headerlink" title="2.8.4.2. 线程的加入（join()方法）"></a>2.8.4.2. 线程的加入（join()方法）</h4><p>在当前线程A新建一个线程B，线程B调用join()方法，当线程A放弃CPU使用后执行线程B，只有线程B执行完毕后，才继续执行线程A。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runnable;</span><br><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line">    Thread threadA;<span class="comment">//声明线程A</span></span><br><span class="line">    Thread threadB;<span class="comment">//声明线程B</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestJoin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">//使用匿名内部类型形式初始化Thread实例</span></span><br><span class="line">        threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">int</span> countA = <span class="number">0</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;A: &quot;</span> + countA);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);   <span class="comment">// 线程A休眠0.1秒</span></span><br><span class="line">                        threadB.join();      <span class="comment">// 线程B调用join()方法</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++countA &gt; <span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();                     <span class="comment">// 启动线程A</span></span><br><span class="line"></span><br><span class="line">        threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">int</span> countB = <span class="number">0</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B: &quot;</span> + countB);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>); <span class="comment">//线程B休眠0.1秒</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++countB &gt; <span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadB.start();                   <span class="comment">// 启动线程B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestJoin t = <span class="keyword">new</span> TestJoin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">A: 0</span></span><br><span class="line"><span class="comment">B: 0</span></span><br><span class="line"><span class="comment">B: 1</span></span><br><span class="line"><span class="comment">B: 2</span></span><br><span class="line"><span class="comment">B: 3</span></span><br><span class="line"><span class="comment">B: 4</span></span><br><span class="line"><span class="comment">B: 5</span></span><br><span class="line"><span class="comment">A: 1</span></span><br><span class="line"><span class="comment">A: 2</span></span><br><span class="line"><span class="comment">A: 3</span></span><br><span class="line"><span class="comment">A: 4</span></span><br><span class="line"><span class="comment">A: 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>线程的中断</strong><br>提倡在线程run()方法中使用无限循环的形式，用一个布尔型标记控制循环的停止。（而不是JDK已废除的stop()方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStop = <span class="keyword">false</span>;<span class="comment">//设置一个标记变量（默认值为false）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStop) <span class="keyword">break</span>;<span class="comment">//当isStop为true时，停止线程</span></span><br><span class="line">            <span class="comment">/** Do something **/</span></span><br><span class="line">            System.out.println((++count) + <span class="string">&quot;. Hello...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义设置停止线程标志位的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isStop = <span class="keyword">true</span>;<span class="comment">//设置isStop为true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InterruptedTest interruptedTest = <span class="keyword">new</span> InterruptedTest();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(interruptedTest);</span><br><span class="line">        t.start();<span class="comment">//启动线程t</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">1500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        interruptedTest.setStop();<span class="comment">//设置停止线程的标志位（停止线程t）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">1. Hello...</span></span><br><span class="line"><span class="comment">2. Hello...</span></span><br><span class="line"><span class="comment">3. Hello...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-8-5-线程的优先级"><a href="#2-8-5-线程的优先级" class="headerlink" title="2.8.5. 线程的优先级"></a>2.8.5. 线程的优先级</h3><p>每个线程都具有各自的优先级，系统会从多个处于<strong>就绪状态</strong>选择优先级最高的线程进入运行状态（优先级较低的线程也有机会运行）。可用setPriority()方法调整线程优先级（优先级范围：1～10，设置需在线程执行start()前）</p>
<h3 id="2-8-6-线程同步"><a href="#2-8-6-线程同步" class="headerlink" title="2.8.6. 线程同步"></a>2.8.6. 线程同步</h3><h4 id="2-8-6-1-线程安全"><a href="#2-8-6-1-线程安全" class="headerlink" title="2.8.6.1. 线程安全"></a>2.8.6.1. 线程安全</h4><p>线程安全问题源于：多个线程同时存取单一对象的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试线程不安全实例</span></span><br><span class="line"><span class="comment"> * -- 多个线程同时读写单一对象数据时，可能引发的安全问题</span></span><br><span class="line"><span class="comment"> * eg. 未考虑线程安全的对线程买票（不安全）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadUnsafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftNum = <span class="number">5</span>;<span class="comment">//设置剩余票数</span></span><br><span class="line">    <span class="keyword">int</span> purchaseTime = <span class="number">0</span>;<span class="comment">//统计买票次数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readValue;<span class="comment">//定义读取值</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((readValue = leftNum) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);<span class="comment">//线程休眠0.1秒, 模仿买票操作用时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;ReadLeftNum = &quot;</span> + readValue + <span class="string">&quot;, After Purchase leftNum = &quot;</span> + --leftNum);<span class="comment">//购票，将剩余票数减一</span></span><br><span class="line">                purchaseTime++;<span class="comment">//统计已购买票次数变量 +1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadUnsafe testThreadUnsafe = <span class="keyword">new</span> TestThreadUnsafe();<span class="comment">//实例化类对象</span></span><br><span class="line">        <span class="comment">//以下实例化四个子线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(testThreadUnsafe);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(testThreadUnsafe);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(testThreadUnsafe);</span><br><span class="line">        Thread threadD = <span class="keyword">new</span> Thread(testThreadUnsafe);</span><br><span class="line">        System.out.println(<span class="string">&quot;不安全的多线程演示：\n总票数：&quot;</span> + testThreadUnsafe.leftNum);</span><br><span class="line">        <span class="comment">//启动四个子线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">        threadD.start();</span><br><span class="line">        <span class="comment">//主线程休眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">//主线程休眠3秒(足够这四个子线程买票)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总共买票次数：&quot;</span> + testThreadUnsafe.purchaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">不安全的多线程演示：</span></span><br><span class="line"><span class="comment">总票数：5</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 4</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 3</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 2</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 1</span></span><br><span class="line"><span class="comment">ReadLeftNum = 4, After Purchase leftNum = 0</span></span><br><span class="line"><span class="comment">ReadLeftNum = 3, After Purchase leftNum = -1</span></span><br><span class="line"><span class="comment">ReadLeftNum = 1, After Purchase leftNum = -2</span></span><br><span class="line"><span class="comment">ReadLeftNum = 1, After Purchase leftNum = -3</span></span><br><span class="line"><span class="comment">总共买票次数：8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从运行结果可看出最后打印的剩余票数值为负值，这时因为有两个线程读取值的时候leftNum值时为1（满足leftNum&gt;0）的时刻，已有其他线程进入”购票操作”只不过还未修改值，这就导致当最终这两个线程此时读到还有票，但等到其他线程完成修改值后（票数已为负），仍然执行-1操作导致票数为负。</p>
<h4 id="2-8-6-2-线程同步机制"><a href="#2-8-6-2-线程同步机制" class="headerlink" title="2.8.6.2. 线程同步机制"></a>2.8.6.2. 线程同步机制</h4><h5 id="2-8-6-2-1-synchronized-“”-同步块"><a href="#2-8-6-2-1-synchronized-“”-同步块" class="headerlink" title="2.8.6.2.1. synchronized (“”){}同步块"></a>2.8.6.2.1. synchronized (“”){}同步块</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;同步锁</span><br><span class="line">synchronized (Object)&#123;</span><br><span class="line">    &#x2F;&#x2F;Do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑线程同步机制的多线程买票程序实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试线程安全-1</span></span><br><span class="line"><span class="comment"> * -- 多个线程同时读写单一对象数据时(加同步锁)，避免引发安全问题</span></span><br><span class="line"><span class="comment"> * eg. 对于多线程买票问题，考虑线程同步机制（安全）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadSafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftNum = <span class="number">5</span>;<span class="comment">//设置剩余票数</span></span><br><span class="line">    <span class="keyword">int</span> purchaseTime = <span class="number">0</span>;<span class="comment">//统计买票次数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readValue;<span class="comment">//定义读取值</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((readValue = leftNum) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);<span class="comment">//线程休眠0.1秒, 模仿买票操作用时</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;ReadLeftNum = &quot;</span> + readValue + <span class="string">&quot;, After Purchase leftNum = &quot;</span> + --leftNum);<span class="comment">//购票，将剩余票数减一</span></span><br><span class="line">                    purchaseTime++;<span class="comment">//统计已购买票次数变量 +1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadSafe testThreadSafe = <span class="keyword">new</span> TestThreadSafe();<span class="comment">//实例化类对象</span></span><br><span class="line">        <span class="comment">//以下实例化四个子线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadD = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        System.out.println(<span class="string">&quot;安全的有线程同步机制的多线程演示：\n总票数：&quot;</span> + testThreadSafe.leftNum);</span><br><span class="line">        <span class="comment">//启动四个子线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">        threadD.start();</span><br><span class="line">        <span class="comment">//主线程休眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">//主线程休眠3秒(足够这四个子线程买票)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总共买票次数：&quot;</span> + testThreadSafe.purchaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">安全的有线程同步机制的多线程演示：</span></span><br><span class="line"><span class="comment">总票数：5</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 4</span></span><br><span class="line"><span class="comment">ReadLeftNum = 4, After Purchase leftNum = 3</span></span><br><span class="line"><span class="comment">ReadLeftNum = 3, After Purchase leftNum = 2</span></span><br><span class="line"><span class="comment">ReadLeftNum = 2, After Purchase leftNum = 1</span></span><br><span class="line"><span class="comment">ReadLeftNum = 1, After Purchase leftNum = 0</span></span><br><span class="line"><span class="comment">总共买票次数：5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>相比于上一个未考虑线程同步的例子来说，这个考虑线程同步只是将线程对关键的单一对象数据的存取操作放在了synchronized (“”){}同步块内，Java的同步机制会保证单位时刻最多只有一个线程在执行同步块内的操作，所以能达到线程同步效果避免不安全。<br>synchronized关键字修饰的同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> ElementType <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑线程同步机制的多线程买票程序实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试线程安全-2</span></span><br><span class="line"><span class="comment"> * -- 多个线程同时读写单一对象数据时(加同步锁)，避免引发安全问题</span></span><br><span class="line"><span class="comment"> * eg. 对于多线程买票问题，考虑线程同步机制（安全）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadSafe2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftNum = <span class="number">5</span>;<span class="comment">//设置剩余票数</span></span><br><span class="line">    <span class="keyword">int</span> purchaseTime = <span class="number">0</span>;<span class="comment">//统计买票次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//synchronized关键字修饰的&quot;买一张票&quot;的同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">purchaseAticket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readValue;<span class="comment">//定义读取值</span></span><br><span class="line">        <span class="keyword">if</span>((readValue = leftNum) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);<span class="comment">//线程休眠0.1秒, 模仿买票操作用时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReadLeftNum = &quot;</span> + readValue + <span class="string">&quot;, After Purchase leftNum = &quot;</span> + --leftNum);<span class="comment">//购票，将剩余票数减一</span></span><br><span class="line">            purchaseTime++;<span class="comment">//统计已购买票次数变量 +1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//成功买票，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//买票失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(purchaseAticket());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadSafe2 testThreadSafe = <span class="keyword">new</span> TestThreadSafe2();<span class="comment">//实例化类对象</span></span><br><span class="line">        <span class="comment">//以下实例化四个子线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadD = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        System.out.println(<span class="string">&quot;安全的有线程同步机制的多线程演示：\n总票数：&quot;</span> + testThreadSafe.leftNum);</span><br><span class="line">        <span class="comment">//启动四个子线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">        threadD.start();</span><br><span class="line">        <span class="comment">//主线程休眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">//主线程休眠3秒(足够这四个子线程买票)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总共买票次数：&quot;</span> + testThreadSafe.purchaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">安全的有线程同步机制的多线程演示：</span></span><br><span class="line"><span class="comment">总票数：5</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 4</span></span><br><span class="line"><span class="comment">ReadLeftNum = 4, After Purchase leftNum = 3</span></span><br><span class="line"><span class="comment">ReadLeftNum = 3, After Purchase leftNum = 2</span></span><br><span class="line"><span class="comment">ReadLeftNum = 2, After Purchase leftNum = 1</span></span><br><span class="line"><span class="comment">ReadLeftNum = 1, After Purchase leftNum = 0</span></span><br><span class="line"><span class="comment">总共买票次数：5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>与第二种用<strong>synchronized (“”){}<strong>同步块用修饰不同之处在于，这种是通过</strong>synchronized</strong>关键字修饰的同步方法，单位时间内，最多只有一个线程执行该方法purchaseAticket()，所以能达到线程同步效果避免不安全。</p>
<h2 id="2-9-网络通信"><a href="#2-9-网络通信" class="headerlink" title="2.9. 网络通信"></a>2.9. 网络通信</h2><h3 id="2-9-1-网络协议"><a href="#2-9-1-网络协议" class="headerlink" title="2.9.1. 网络协议"></a>2.9.1. 网络协议</h3><h4 id="2-9-1-1-IP协议"><a href="#2-9-1-1-IP协议" class="headerlink" title="2.9.1.1. IP协议"></a>2.9.1.1. IP协议</h4><p>IP是Internet Protocol的简称，它是一种网络协议。Internet采用的协议是TCP&#x2F;IP协议。</p>
<h4 id="2-9-1-2-TCP传输控制协议-Transmission-Control-Protocol"><a href="#2-9-1-2-TCP传输控制协议-Transmission-Control-Protocol" class="headerlink" title="2.9.1.2. TCP传输控制协议(Transmission Control Protocol)"></a>2.9.1.2. TCP传输控制协议(Transmission Control Protocol)</h4><p>TCP协议是一种 以固接线为基础的协议，它提供两台计算机间可靠的数据传送。</p>
<p>特征：</p>
<ul>
<li>保证数据能够确实送达</li>
<li>抵达的数据排列顺序与送出时的顺序相同</li>
</ul>
<p>因此，TCP协议适合可靠性要求较高的场合（HTTP、FTP和Telnet等都需要使用可靠的通信频道）</p>
<h4 id="2-9-1-3-UDP用户数据协议-User-Datagram-Protocol"><a href="#2-9-1-3-UDP用户数据协议-User-Datagram-Protocol" class="headerlink" title="2.9.1.3. UDP用户数据协议(User Datagram Protocol)"></a>2.9.1.3. UDP用户数据协议(User Datagram Protocol)</h4><p>UDP是无线连接通信协议，不保证可靠数据的传输。</p>
<p>特征：</p>
<ul>
<li>能够向若干个目标发送数据</li>
<li>能够接收发自若干个源的数据</li>
<li>接收多个数据包时不保证接收数据包的顺序与源发送顺序相同</li>
</ul>
<p>因此 ，UDP协议适合一些对数据准确性要求不高，对传输速度和时效要求非常高但允许小部分数据包丢失或传送顺序有所不同也不会严重损害需求的场合(如：网络聊天室、在线影片等)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>日志服务器未收到日志可能原因小记</title>
    <url>/2021/08/27/LogServerUnworkNote/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>咱们的日志上报是CS架构，下方任一原因都可能导致日志服务器无法收到日志：</p>
<p><strong>设备端：</strong></p>
<ul>
<li>Rsyslog 服务未运行？（检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status rsyslog | grep Active</span><br></pre></td></tr></table></figure></li>
</ul>
<a id="more"></a>

<ul>
<li>设备上是否配置 远程日志服务器IP （检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -A 2 &#x27;remote syslog server&#x27; /etc/rsyslog.conf</span><br></pre></td></tr></table></figure></li>
<li>日志服务器不可达？（检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping $(grep -A 1 &#x27;remote syslog server&#x27; /etc/rsyslog.conf  | tail -n +2) </span><br></pre></td></tr></table></figure></li>
<li>防火墙 配置？514 端口未打开？（检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -L -n</span><br><span class="line">sudo lsof -i:514</span><br></pre></td></tr></table></figure></li>
<li>设备无异常日志输出？ （检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -E &#x27;NOTICE|WARNING|ERROR&#x27; /var/log/syslog | grep local2 | tail -20</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>日志服务器端：</strong></p>
<ul>
<li>Rsyslog 服务未运行？（检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status rsyslog | grep Active</span><br></pre></td></tr></table></figure></li>
<li>防火墙 配置？514 端口未打开？（检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -L -n</span><br><span class="line">sudo lsof -i:514</span><br></pre></td></tr></table></figure></li>
<li>Rsyslog 配置中 $UDPServerAddress 127.0.0.1 被打开了？服务器端需注释，否则只能接收本地日志（检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;UDPServerAddress&#x27; /etc/rsyslog.conf</span><br></pre></td></tr></table></figure></li>
<li>服务器端配置了日志全转发？ （检查指令）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -A 2 &#x27;remote syslog server&#x27; /etc/rsyslog.conf </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>syslog</tag>
      </tags>
  </entry>
  <entry>
    <title>logrotate日志轮转工具简介</title>
    <url>/2021/08/23/Logrotate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日志轮转 log rotation 解读：日志轮转是系统管理中使用的一个自动化过程，在此过程中，一旦日志文件太旧或太大，就会对其进行压缩、移动（存档）、重命名或删除。</p>
<a id="more"></a>

<h1 id="1-logrotate-简介"><a href="#1-logrotate-简介" class="headerlink" title="1. logrotate 简介"></a>1. logrotate 简介</h1><ul>
<li>管理系统所产生的日志文件。可自动对日志进行截断（或轮转）、压缩以及删除旧的日志文件。</li>
<li>可周期性（按天&#x2F;周&#x2F;月）或当所监控文本文件大小超过阈值时（eg. 100MB），对文件进行截断（轮转）、压缩或删除过于老旧备份文件等处理。</li>
<li>Linux系统默认安装logrotate工具，判断有无安装logrotate方式：<code>which logrotate</code></li>
<li>logrotate自身为一个命令行工具，需要手动调用或基于计划任务cron调起logrotate工作<br>（默认情况已在<code>/etc/cron.daily/logrotate</code>配置了其每天定时执行）</li>
</ul>
<h2 id="1-1-logrotate-配置文件说明"><a href="#1-1-logrotate-配置文件说明" class="headerlink" title="1.1. logrotate 配置文件说明"></a>1.1. logrotate 配置文件说明</h2><p>logrotate 配置文件包括：</p>
<ul>
<li><b><font color="#7E3D76" style="">logrotate 自身的配置文件: &#x2F;etc&#x2F;logrotate.conf</font></b></li>
<li><b><font color="#7E3D76" style="">需要轮转管理的日志文件各自的配置文件: &#x2F;etc&#x2F;logrotate.d&#x2F;*</font></b>（统一放置于&#x2F;etc&#x2F;logrotate.d&#x2F;目录下）</li>
</ul>
<h2 id="1-2-logrotate-手动运行命令"><a href="#1-2-logrotate-手动运行命令" class="headerlink" title="1.2. logrotate 手动运行命令"></a>1.2. logrotate 手动运行命令</h2><p>在完成&#x2F;修改 logrotate 配置后，需重启 logrotate 以使配置生效。</p>
<p><b><font color="#7E3D76" style="">手动运行logrotate的命令：</font></b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/sbin/logrotate /etc/logrotate.conf</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">手动执行某个日志的轮转配置文件的命令：</font></b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/sbin/logrotate -vf /etc/logrotate.d/log-file</span><br></pre></td></tr></table></figure>

<h2 id="1-3-添加-logrotate-工具的计划任务"><a href="#1-3-添加-logrotate-工具的计划任务" class="headerlink" title="1.3. 添加 logrotate 工具的计划任务"></a>1.3. 添加 logrotate 工具的计划任务</h2><p>&#x2F;etc&#x2F;cron.daily目录下，有个logrotate的脚本，系统每天会执行&#x2F;etc&#x2F;cron.daily内的脚本，这样只需我们按上述&#x2F;etc&#x2F;logrotate.d&#x2F;example中的配置，即可保证每天日志的生成。</p>
<p><b><font color="#7E3D76" style="">配置宿主机计划任务：以天为周期启动日志轮转工具logrotate工具（无守护进程），内容如下：</font></b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">admin@host:~$ cat /etc/cron.daily/logrotate</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">test -x /usr/sbin/logrotate || exit 0</span><br><span class="line">/usr/sbin/logrotate /etc/logrotate.conf</span><br><span class="line">admin@host:~$</span><br></pre></td></tr></table></figure>

<h2 id="1-4-logrotate-命令格式"><a href="#1-4-logrotate-命令格式" class="headerlink" title="1.4. logrotate 命令格式"></a>1.4. logrotate 命令格式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logrotate [OPTION...] &lt;configfile&gt;</span><br></pre></td></tr></table></figure>
<p>OPTION参数说明：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">参数（简写）</th>
        <th align="center">参数（详细）</th>
        <th align="center">功能</th>
    </tr>
    <tr>
        <td align="center">-d</td>
        <td align="center">--debug</td>
        <td align="center">debug模式，测试配置文件是否有错误。</td>
    </tr>
    <tr>
        <td align="center">-f</td>
        <td align="center">--force</td>
        <td align="center">强制转储文件。</td>
    </tr>
    <tr>
        <td align="center">-m</td>
        <td align="center">--mail=command</td>
        <td align="center">压缩日志后，发送日志到指定邮箱。</td>
    </tr>
    <tr>
        <td align="center">-s</td>
        <td align="center">--state=statefile</td>
        <td align="center">使用指定的状态文件。</td>
    </tr>
    <tr>
        <td align="center">-v</td>
        <td align="center">--verbose</td>
        <td align="center">显示转储过程。</td>
    </tr>
</table>


<h1 id="2-logrotate-轮转参数配置示例"><a href="#2-logrotate-轮转参数配置示例" class="headerlink" title="2. logrotate 轮转参数配置示例"></a>2. logrotate 轮转参数配置示例</h1><p>示例配置文件<code>（/etc/logrotate.d/log-file</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;log&#x2F;log-file &#123;</span><br><span class="line">    monthly</span><br><span class="line">    rotate 5</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    create 644 root root</span><br><span class="line">    postrotate</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;killall -HUP rsyslogd</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b><font color="red" style="">轮转参数解释如下：</font></b></p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center"><b>配置参数</b></th>
        <th align="center"><b>说明</b></th>
    </tr>
    <tr>
        <td>monthly</td>
        <td>日志文件将按月轮转。其它可用值为'daily'，'weekly'或者'yearly'。</td>
    </tr>
    <tr>
        <td>rotate 5</td>
        <td>一次将存储5个归档日志。对于第六个归档，时间最久的归档将被删除。</td>
    </tr>
    <tr>
        <td>compress</td>
        <td>在轮转任务完成后，已轮转的归档将使用gzip进行压缩。</td>
    </tr>
    <tr>
        <td>delaycompress</td>
        <td>总是与compress选项一起用，delaycompress选项指示logrotate不要将最近的归档压缩，<br>压缩将在下一次轮转周期进行。这在你或任何软件仍然需要读取最新归档时很有用。</td>
    </tr>
    <tr>
        <td>missingok</td>
        <td>在日志轮转期间，任何错误将被忽略，例如“文件无法找到”之类的错误。</td>
    </tr>
    <tr>
        <td>notifempty</td>
        <td>如果日志文件为空，轮转不会进行。</td>
    </tr>
    <tr>
        <td>create 644 root root</td>
        <td>以指定的权限创建全新的日志文件，同时logrotate也会重命名原始日志文件。</td>
    </tr>
    <tr>
        <td>postrotate/endscript</td>
        <td>在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行。<br>在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。</td>
    </tr>
</table>

<p><b><font color="red" style="">其他参数说明：</font></b></p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center"><b>配置参数</b></th>
        <th align="center"><b>说明</b></th>
    </tr>
    <tr>
        <td>nocompress</td>
        <td>不压缩</td>
    </tr>
    <tr>
        <td>copytruncate</td>
        <td>用于还在打开中的日志文件，把当前日志备份并截断</td>
    </tr>
    <tr>
        <td>nocopytruncate</td>
        <td>备份日志文件但是不截断</td>
    </tr>
    <tr>
        <td>create mode owner group</td>
        <td>转储文件，使用指定的文件模式创建新的日志文件</td>
    </tr>
    <tr>
        <td>nocreate</td>
        <td>不建立新的日志文件</td>
    </tr>
    <tr>
        <td>nodelaycompress</td>
        <td>覆盖 delaycompress 选项，转储同时压缩。</td>
    </tr>
    <tr>
        <td>nosharedscripts</td>
        <td>（默认项）对于每一个轮转的日志文件都执行prerotate和postrotate脚本。</td>
    </tr>
    <tr>
        <td>errors address</td>
        <td>专储时的错误信息发送到指定的Email 地址</td>
    </tr>
    <tr>
        <td>ifempty</td>
        <td>即使是空文件也转储，这个是 logrotate 的缺省选项。</td>
    </tr>
    <tr>
        <td>mail address</td>
        <td>把转储的日志文件发送到指定的E-mail 地址</td>
    </tr>
    <tr>
        <td>nomail</td>
        <td>转储时不发送日志文件</td>
    </tr>
    <tr>
        <td>olddir directory</td>
        <td>转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统</td>
    </tr>
    <tr>
        <td>noolddir</td>
        <td>转储后的日志文件和当前日志文件放在同一个目录下</td>
    <tr>
        <td>prerotate/endscript</td>
        <td>在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行</td>
    </tr>
    <tr>
        <td>postrotate/endscript</td>
        <td>该对字段间的脚本将在日志轮转结束后执行</td>
    </tr>
    <tr>
        <td>firstaction/endscript</td>
        <td>区间内的脚本在轮转之前、prerotate之前，且至少有一个待轮转日志时，才执行（限制：需要轮转的日志数必须大于1才执行；若此区间出错，将不会执行下方的脚本）</td>
    </tr>
    <tr>
        <td>rotate count</td>
        <td>指定日志文件删除之前转储的次数，0指没有备份，5指保留5个备份</td>
    </tr>
    <tr>
        <td>tabooext [+] list</td>
        <td>让logrotate不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~</td>
    </tr>
    <tr>
        <td>size size</td>
        <td>当日志文件到达指定的大小时才转储，bytes(缺省)及KB(sizek)或MB(sizem)
    </tr>
</table>

<h1 id="3-项目中-logrotate-配置"><a href="#3-项目中-logrotate-配置" class="headerlink" title="3. 项目中 logrotate 配置"></a>3. 项目中 logrotate 配置</h1><h2 id="3-1-logrotate-工具自身配置（宿主机，容器内无）"><a href="#3-1-logrotate-工具自身配置（宿主机，容器内无）" class="headerlink" title="3.1. logrotate 工具自身配置（宿主机，容器内无）"></a>3.1. logrotate 工具自身配置（宿主机，容器内无）</h2><p><b><font color="red" style="">宿主机的 logrotate 工具自身配置文件&#x2F;etc&#x2F;logrotate.conf如下：</font></b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># see &quot;man logrotate&quot; for details</span><br><span class="line"># rotate log files weekly</span><br><span class="line">weekly</span><br><span class="line"></span><br><span class="line"># keep 4 weeks worth of backlogs</span><br><span class="line">rotate 4</span><br><span class="line"></span><br><span class="line"># create new (empty) log files after rotating old ones</span><br><span class="line">create</span><br><span class="line"></span><br><span class="line"># uncomment this if you want your log files compressed</span><br><span class="line">#compress</span><br><span class="line"></span><br><span class="line"># packages drop log rotation information into this directory</span><br><span class="line">include &#x2F;etc&#x2F;logrotate.d</span><br><span class="line"></span><br><span class="line"># no packages own wtmp, or btmp -- we&#39;ll rotate them here</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;wtmp &#123;</span><br><span class="line">    missingok</span><br><span class="line">    monthly</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;log&#x2F;btmp &#123;</span><br><span class="line">    missingok</span><br><span class="line">    monthly</span><br><span class="line">    create 0660 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># system-specific logs may be configured here</span><br></pre></td></tr></table></figure>


<h2 id="3-2-各需日志轮转文件的配置（宿主机中）"><a href="#3-2-各需日志轮转文件的配置（宿主机中）" class="headerlink" title="3.2. 各需日志轮转文件的配置（宿主机中）"></a>3.2. 各需日志轮转文件的配置（宿主机中）</h2><p><b><font color="red" style="">各需日志轮转文件的配置文件 &#x2F;etc&#x2F;logrotate.d&#x2F;rsyslog 内容如下：</font></b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># These logs should no longer get created. However, in case they do get created,</span><br><span class="line"># we should keep them to a small size and rotate them also.</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;log&#x2F;auth.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;cli.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;debug</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;telemetry.log</span><br><span class="line">&#123;</span><br><span class="line">    size 10M</span><br><span class="line">    rotate 1</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        &#x2F;bin&#x2F;kill -HUP $(cat &#x2F;var&#x2F;run&#x2F;rsyslogd.pid)</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;log&#x2F;kern.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;quagga&#x2F;bgpd.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;quagga&#x2F;zebra.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;syslog</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;teamd.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;user.log</span><br><span class="line">&#123;</span><br><span class="line">    size 100M</span><br><span class="line">    rotate 10</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        &#x2F;bin&#x2F;kill -HUP $(cat &#x2F;var&#x2F;run&#x2F;rsyslogd.pid)</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;log&#x2F;cron.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;daemon.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">&#123;</span><br><span class="line">    size 200M</span><br><span class="line">    rotate 10</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    sharedscripts</span><br><span class="line">    firstaction</span><br><span class="line">        # Adjust NUM_LOGS_TO_ROTATE to reflect number of log files that trigger this block specified above</span><br><span class="line">        NUM_LOGS_TO_ROTATE&#x3D;5</span><br><span class="line"></span><br><span class="line">        # Adjust LOG_FILE_ROTATE_SIZE_KB to reflect the &quot;size&quot; parameter specified above, in kB</span><br><span class="line">        LOG_FILE_ROTATE_SIZE_KB&#x3D;204800</span><br><span class="line"></span><br><span class="line">        # Reserve space for btmp, wtmp, dpkg.log, monit.log, etc., as well as logs that</span><br><span class="line">        # should be disabled, just in case they get created and rotated</span><br><span class="line">        RESERVED_SPACE_KB&#x3D;4096</span><br><span class="line"></span><br><span class="line">        VAR_LOG_SIZE_KB&#x3D;$(df -k &#x2F;var&#x2F;log | sed -n 2p | awk &#39;&#123; print $2 &#125;&#39;)</span><br><span class="line"></span><br><span class="line">        # Limit usable space to 90% of the partition minus the reserved space for other logs</span><br><span class="line">        USABLE_SPACE_KB&#x3D;$(( (VAR_LOG_SIZE_KB * 90 &#x2F; 100) - RESERVED_SPACE_KB))</span><br><span class="line"></span><br><span class="line">        # Set our threshold so as to maintain enough space to write all logs from empty to full</span><br><span class="line">        # Most likely, some logs will have non-zero size when this is called, so this errs on the side</span><br><span class="line">        # of caution, giving us a bit of a cushion if a log grows quickly and passes its rotation size</span><br><span class="line">        THRESHOLD_KB&#x3D;$((USABLE_SPACE_KB - (NUM_LOGS_TO_ROTATE * LOG_FILE_ROTATE_SIZE_KB * 2)))</span><br><span class="line"></span><br><span class="line">        # First, delete any *.1 or *.11~20.gz files that might be left around from a prior incomplete</span><br><span class="line">        find &#x2F;var&#x2F;log -type f | egrep &#39;.+\.1?$|.+\.1[1-9]+\.gz?$|.+\.20+\.gz?$&#39; | xargs rm -f</span><br><span class="line"></span><br><span class="line">        # logrotate execution, otherwise logrotate will fail to do its job</span><br><span class="line">        while true; do</span><br><span class="line">            USED_KB&#x3D;$(du -s &#x2F;var&#x2F;log | awk &#39;&#123; print $1; &#125;&#39;)</span><br><span class="line"></span><br><span class="line">            if [ $USED_KB -lt $THRESHOLD_KB ]; then</span><br><span class="line">                break</span><br><span class="line">            else</span><br><span class="line">                OLDEST_ARCHIVE_FILE&#x3D;$(find &#x2F;var&#x2F;log -type f -printf &#39;%T+ %p\n&#39; | grep -E &#39;.+\.[0-9]+(\.gz)?$&#39; | sort | head -n 1 | awk &#39;&#123; print $2; &#125;&#39;)</span><br><span class="line"></span><br><span class="line">                if [ -z &quot;$OLDEST_ARCHIVE_FILE&quot; ]; then</span><br><span class="line">                    logger -p syslog.err -t &quot;logrotate&quot; &quot;No archive file to delete -- potential for filling up &#x2F;var&#x2F;log partition!&quot;</span><br><span class="line">                    break</span><br><span class="line">                fi</span><br><span class="line"></span><br><span class="line">                logger -p syslog.info -t &quot;logrotate&quot; &quot;Deleting archive file $OLDEST_ARCHIVE_FILE to free up space&quot;</span><br><span class="line">                rm -rf &quot;$OLDEST_ARCHIVE_FILE&quot;</span><br><span class="line">            fi</span><br><span class="line">        done</span><br><span class="line">    endscript</span><br><span class="line">    postrotate</span><br><span class="line">        &#x2F;bin&#x2F;kill -HUP $(cat &#x2F;var&#x2F;run&#x2F;rsyslogd.pid) 2&gt;&#x2F;dev&#x2F;null || true</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;log&#x2F;swss&#x2F;swss.rec</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;swss&#x2F;sairedis.rec</span><br><span class="line">&#123;</span><br><span class="line">    size 200M</span><br><span class="line">    rotate 10</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        pgrep -x orchagent | xargs &#x2F;bin&#x2F;kill -HUP 2&gt;&#x2F;dev&#x2F;null || true</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-各需日志轮转文件的配置（容器中）"><a href="#3-3-各需日志轮转文件的配置（容器中）" class="headerlink" title="3.3. 各需日志轮转文件的配置（容器中）"></a>3.3. 各需日志轮转文件的配置（容器中）</h2><p><b><font color="red" style="">容器各需日志轮转文件的配置文件 &#x2F;etc&#x2F;logrotate.d&#x2F;rsyslog 内容如下：</font></b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;log&#x2F;syslog</span><br><span class="line">&#123;</span><br><span class="line">	rotate 7</span><br><span class="line">	daily</span><br><span class="line">	missingok</span><br><span class="line">	notifempty</span><br><span class="line">	delaycompress</span><br><span class="line">	compress</span><br><span class="line">	postrotate</span><br><span class="line">		invoke-rc.d rsyslog rotate &gt; &#x2F;dev&#x2F;null</span><br><span class="line">	endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;log&#x2F;mail.info</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;mail.warn</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;mail.err</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;mail.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;daemon.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;kern.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;auth.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;user.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;lpr.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;cron.log</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;debug</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">&#123;</span><br><span class="line">	rotate 4</span><br><span class="line">	weekly</span><br><span class="line">	missingok</span><br><span class="line">	notifempty</span><br><span class="line">	compress</span><br><span class="line">	delaycompress</span><br><span class="line">	sharedscripts</span><br><span class="line">	postrotate</span><br><span class="line">		invoke-rc.d rsyslog rotate &gt; &#x2F;dev&#x2F;null</span><br><span class="line">	endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-容器中-supervisor-守护进程的配置文件（容器中，宿主机无）"><a href="#4-容器中-supervisor-守护进程的配置文件（容器中，宿主机无）" class="headerlink" title="4. 容器中 supervisor 守护进程的配置文件（容器中，宿主机无）"></a>4. 容器中 supervisor 守护进程的配置文件（容器中，宿主机无）</h1><p>配置文件：&#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;supervisord.conf</p>
<p><b><font color="red" style="">容器中，守护进程配置（各程序的kill重启策略）</font></b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@host:&#x2F;var# cat &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;supervisord.conf</span><br><span class="line">[supervisord]</span><br><span class="line">logfile_maxbytes&#x3D;1MB</span><br><span class="line">logfile_backups&#x3D;2</span><br><span class="line">nodaemon&#x3D;true</span><br><span class="line"></span><br><span class="line">[eventlistener:supervisor-proc-exit-listener]</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;bin&#x2F;supervisor-proc-exit-listener</span><br><span class="line">events&#x3D;PROCESS_STATE_EXITED</span><br><span class="line">autostart&#x3D;true</span><br><span class="line">autorestart&#x3D;unexpected</span><br><span class="line"></span><br><span class="line">[program:start.sh]</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;bin&#x2F;start.sh</span><br><span class="line">priority&#x3D;1</span><br><span class="line">autostart&#x3D;true</span><br><span class="line">autorestart&#x3D;false</span><br><span class="line">stdout_logfile&#x3D;syslog</span><br><span class="line">stderr_logfile&#x3D;syslog</span><br><span class="line"></span><br><span class="line">[program:rsyslogd]</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;sbin&#x2F;rsyslogd -n</span><br><span class="line">priority&#x3D;2</span><br><span class="line">autostart&#x3D;false</span><br><span class="line">autorestart&#x3D;unexpected</span><br><span class="line">stdout_logfile&#x3D;syslog</span><br><span class="line">stderr_logfile&#x3D;syslog</span><br><span class="line"></span><br><span class="line">[program:syncd]</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;bin&#x2F;syncd_start.sh</span><br><span class="line">priority&#x3D;3</span><br><span class="line">autostart&#x3D;false</span><br><span class="line">autorestart&#x3D;false</span><br><span class="line">stdout_logfile&#x3D;syslog</span><br><span class="line">stderr_logfile&#x3D;syslog</span><br><span class="line"></span><br><span class="line">[program:ledinit]</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;bin&#x2F;bcmcmd -t 60 &quot;rcload &#x2F;usr&#x2F;share&#x2F;host&#x2F;platform&#x2F;led_proc_init.soc&quot;</span><br><span class="line">priority&#x3D;4</span><br><span class="line">autostart&#x3D;false</span><br><span class="line">autorestart&#x3D;false</span><br><span class="line">startsecs&#x3D;0</span><br><span class="line">stdout_logfile&#x3D;syslog</span><br><span class="line">stderr_logfile&#x3D;syslog</span><br><span class="line"></span><br><span class="line">[program:linecardd]</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;bin&#x2F;linecardd</span><br><span class="line">priority&#x3D;5</span><br><span class="line">autostart&#x3D;false</span><br><span class="line">autorestart&#x3D;false</span><br><span class="line">stdout_logfile&#x3D;syslog</span><br><span class="line">stderr_logfile&#x3D;syslog</span><br><span class="line"></span><br><span class="line">[program:averagerated]</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;bin&#x2F;averated</span><br><span class="line">priority&#x3D;6</span><br><span class="line">autostart&#x3D;true</span><br><span class="line">autorestart&#x3D;false</span><br><span class="line">stdout_logfile&#x3D;syslog</span><br><span class="line">stderr_logfile&#x3D;syslog</span><br></pre></td></tr></table></figure>

<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/clsn/p/8428257.html">日志切割之Logrotate</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>syslog</tag>
      </tags>
  </entry>
  <entry>
    <title>logrotate 日志轮转未生效排障思路总结</title>
    <url>/2021/09/03/LogrotateTroubleshootingNote/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>logrotate 工具不会自启动，依赖 cron 定时任务工具调起或其他程序调用执行</p>
</blockquote>
<h1 id="1-检查-logrotate-运行记录"><a href="#1-检查-logrotate-运行记录" class="headerlink" title="1. 检查 logrotate 运行记录"></a>1. 检查 logrotate 运行记录</h1><h2 id="1-1-查看待切分日志是否被切分"><a href="#1-1-查看待切分日志是否被切分" class="headerlink" title="1.1. 查看待切分日志是否被切分"></a>1.1. 查看待切分日志是否被切分</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l -A /var/log/yourLogName.log</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-2-检查环境有无安装-logrotate"><a href="#1-2-检查环境有无安装-logrotate" class="headerlink" title="1.2. 检查环境有无安装 logrotate"></a>1.2. 检查环境有无安装 logrotate</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which logrotate</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">ls -l /usr/sbin/logrotate</span><br></pre></td></tr></table></figure>
<h2 id="1-3-检查-logrotate-自身配置"><a href="#1-3-检查-logrotate-自身配置" class="headerlink" title="1.3. 检查 logrotate 自身配置"></a>1.3. 检查 logrotate 自身配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/logrotate.conf</span><br></pre></td></tr></table></figure>
<h2 id="1-4-检查有无对待切分日志文件的切分规则配置"><a href="#1-4-检查有无对待切分日志文件的切分规则配置" class="headerlink" title="1.4. 检查有无对待切分日志文件的切分规则配置"></a>1.4. 检查有无对待切分日志文件的切分规则配置</h2><p>检查有无 logrotate 对应文件的日志切分规则配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l -A /etc/logrotate.d/</span><br><span class="line">cat /etc/logrotate.d/yourLogName</span><br></pre></td></tr></table></figure>
<h2 id="1-5-测试该文件对应的日志切分配置是否正确"><a href="#1-5-测试该文件对应的日志切分配置是否正确" class="headerlink" title="1.5. 测试该文件对应的日志切分配置是否正确"></a>1.5. 测试该文件对应的日志切分配置是否正确</h2><p>手动（加载配置）执行日志切分：</p>
<ul>
<li>先用 debug 参数测试（不会真正执行日志切分）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 调试执行 /etc/logrotate.d/frr 配置，为满足条件日志不会被轮转</span></span><br><span class="line">/usr/sbin/logrotate -d /etc/logrotate.d/frr</span><br><span class="line"><span class="meta">#</span><span class="bash"> -f 参数强制转储日志文件</span></span><br><span class="line">/usr/sbin/logrotate -d -f /etc/logrotate.d/frr</span><br></pre></td></tr></table></figure>
<ul>
<li>手动调 logrotate 执行对应日志文件的切分（强制执行）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/sbin/logrotate -vf /etc/logrotate.d/frr</span><br></pre></td></tr></table></figure>

<h2 id="1-6-查看-logrotate-的切分状态记录"><a href="#1-6-查看-logrotate-的切分状态记录" class="headerlink" title="1.6. 查看 logrotate 的切分状态记录"></a>1.6. 查看 logrotate 的切分状态记录</h2><p>logrotate 自身的日志：<code>/var/lib/logrotate/status</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/lib/logrotate/status</span><br></pre></td></tr></table></figure>



<h1 id="2-cron-是否正常工作？"><a href="#2-cron-是否正常工作？" class="headerlink" title="2. cron 是否正常工作？"></a>2. cron 是否正常工作？</h1><h2 id="2-1-检查有无安装-cron"><a href="#2-1-检查有无安装-cron" class="headerlink" title="2.1. 检查有无安装 cron"></a>2.1. 检查有无安装 cron</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /usr/sbin/cron</span><br></pre></td></tr></table></figure>

<h2 id="2-2-检测-cron-运行状态"><a href="#2-2-检测-cron-运行状态" class="headerlink" title="2.2. 检测 cron 运行状态"></a>2.2. 检测 cron 运行状态</h2><h3 id="2-2-1-检查-cron-计划任务工具是否正在运行"><a href="#2-2-1-检查-cron-计划任务工具是否正在运行" class="headerlink" title="2.2.1. 检查 cron 计划任务工具是否正在运行"></a>2.2.1. 检查 cron 计划任务工具是否正在运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep cron | grep -v grep</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-检查-cron-有无定时调起logrotate的日志"><a href="#2-2-2-检查-cron-有无定时调起logrotate的日志" class="headerlink" title="2.2.2. 检查 cron 有无定时调起logrotate的日志"></a>2.2.2. 检查 cron 有无定时调起logrotate的日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;logrotate&quot; /var/log/cron.log  | tail -n 10</span><br></pre></td></tr></table></figure>

<h2 id="2-3-检测-cron-中-logrotate-的定时配置文件？"><a href="#2-3-检测-cron-中-logrotate-的定时配置文件？" class="headerlink" title="2.3. 检测 cron 中 logrotate 的定时配置文件？"></a>2.3. 检测 cron 中 logrotate 的定时配置文件？</h2><h3 id="2-3-1-查看-cron-的定时调起配置"><a href="#2-3-1-查看-cron-的定时调起配置" class="headerlink" title="2.3.1. 查看 cron 的定时调起配置"></a>2.3.1. 查看 cron 的定时调起配置</h3><p>配置文件：<code>/etc/anacrontab</code>（老版本为：<code>/etc/crontab</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/crontab</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-手动执行-cron-配置中-logrotate-的每日计划任务配置"><a href="#2-3-2-手动执行-cron-配置中-logrotate-的每日计划任务配置" class="headerlink" title="2.3.2. 手动执行 cron 配置中 logrotate 的每日计划任务配置"></a>2.3.2. 手动执行 cron 配置中 logrotate 的每日计划任务配置</h3><ul>
<li>查看每日任务对应 logrotate 的每日计划任务配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l -A /etc/cron.daily/</span><br><span class="line">cat /etc/cron.daily/logrotate</span><br></pre></td></tr></table></figure>

<ul>
<li>手动执行 cron 配置中 logrotate 的每日计划任务，检查能否成功调 logrotate 执行日志切分</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /etc/cron.daily/logrotate</span><br></pre></td></tr></table></figure>

<ul>
<li>查看自定义对应 logrotate 计划任务配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /etc/cron.d/</span><br><span class="line">cat /etc/cron.d/your_logrotate_cfg</span><br></pre></td></tr></table></figure>

<h2 id="2-4-检测-cron-能否准时自行调起-logrotate-计划任务"><a href="#2-4-检测-cron-能否准时自行调起-logrotate-计划任务" class="headerlink" title="2.4. 检测 cron 能否准时自行调起 logrotate 计划任务"></a>2.4. 检测 cron 能否准时自行调起 logrotate 计划任务</h2><blockquote>
<p>通过上文查看 cron 的定时调起配置可知，cron 每天的定时任务会在 6:25 执行</p>
</blockquote>
<ul>
<li>在 <code>/etc/cron.daily/logrotate</code> logrotate 计划任务配置文件末追加打日志代码：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;$(date) logrotate runing&quot; &gt;&gt;/tmp/logrotate.out</span><br></pre></td></tr></table></figure>

<ul>
<li>更改系统时间到 6:24:30，测试 cron 能否自动调起logrotate</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -s &quot;2021-08-26 10:06:30&quot;   # 设置系统时间</span><br><span class="line">hwclock --systohc               # 将系统时间同步到硬件</span><br></pre></td></tr></table></figure>

<h2 id="2-5-重启-cron-服务"><a href="#2-5-重启-cron-服务" class="headerlink" title="2.5. 重启 cron 服务"></a>2.5. 重启 cron 服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启 cron 服务方式1</span></span><br><span class="line">service crond start     # 启动服务</span><br><span class="line">service crond stop      # 关闭服务</span><br><span class="line">service crond restart   # 重启服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 cron 服务方式2</span></span><br><span class="line">/etc/init.d/cron stop       # 关闭服务</span><br><span class="line">/etc/init.d/cron start      # 启动服务</span><br><span class="line">/etc/init.d/cron restart    # 重启服务</span><br></pre></td></tr></table></figure>

<h1 id="3-参考文档"><a href="#3-参考文档" class="headerlink" title="3. 参考文档"></a>3. 参考文档</h1><ul>
<li><a href="https://serverfault.com/questions/302020/logrotate-wont-rotate-my-logs-automatically">logrotate won’t rotate my logs automatically</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>syslog</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习概述（简单了解）</title>
    <url>/2019/11/23/MachineLearningOverview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录机器学习基础与框架的简单介绍</p>
<h1 id="1-机器学习是什么"><a href="#1-机器学习是什么" class="headerlink" title="1. 机器学习是什么"></a>1. 机器学习是什么</h1><ul>
<li>机器从数据中学习</li>
<li>机器学习（≈ 寻找一个函数）</li>
</ul>
<a id="more"></a>

<p>f( 一段语音 ) &#x3D; 语义</p>
<p>f( 一张图片 ) &#x3D; 识别对象</p>
<p>f( 棋局 ) &#x3D; 最优解</p>
<p>f( 语义 ) &#x3D; 反馈语义</p>
<h1 id="2-机器学习的三种分类"><a href="#2-机器学习的三种分类" class="headerlink" title="2. 机器学习的三种分类"></a>2. 机器学习的三种分类</h1><ul>
<li><strong>监督学习（有标签）</strong></li>
</ul>
<p>任务驱动：识别、分类、回归</p>
<ul>
<li><strong>非监督学习（无标签）</strong></li>
</ul>
<p>数据驱动：聚类</p>
<ul>
<li><strong>强化学习</strong></li>
</ul>
<p>与环境互动</p>
<h1 id="3-理解机器学习的框架"><a href="#3-理解机器学习的框架" class="headerlink" title="3. 理解机器学习的框架"></a>3. 理解机器学习的框架</h1><p>以图像识别为例，讲解监督学习框架的四个步骤：</p>
<ul>
<li>收集数据</li>
<li>选择模型。模型：函数的集合（无穷个）</li>
<li>调整参数。定义模型中函数的好坏</li>
<li>找到最优（函数 f*）</li>
</ul>
<h1 id="4-机器学习应用实例与方法"><a href="#4-机器学习应用实例与方法" class="headerlink" title="4. 机器学习应用实例与方法"></a>4. 机器学习应用实例与方法</h1><ul>
<li>线性回归。房价预测</li>
<li>梯度下降</li>
<li>判决树</li>
<li>逻辑回归</li>
<li>神经网络</li>
<li>支持向量机</li>
<li>朴素贝叶斯</li>
<li>聚类</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>龙应台与儿子对话--“读书的理解”</title>
    <url>/2017/11/12/Meanning-reading/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/Meanning-reading.jpg" class="full-image" />

<p>孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利。选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。</p>
<a id="more"></a>

<p>你说：“妈，你要清楚接受一个事实，就是你有一个极其平庸的儿子。我觉得你将来的事业一定比不上你，也比不上爸爸–你们俩都有博士学位，我可能会变成一个很普通的人，有很普通的学历，很普通的职业，不太有钱，也没有名。一个最最平庸的人。”</p>
<p>我可以现在告诉你：我真的不在乎你是否有成就。对我最重要的，不是你有否成就，而是你是否快乐。假如横在你眼前的选择是到华尔街做银行经理或者到动物园做照顾狮子河马的管理员，而你是一个喜欢动物研究的人，我就完全不认为银行经理比较有成就，或者狮子河马的管理员“平庸”。每天为钱的数字起伏而紧张而斗争，很可能不如每天给大象洗澡，给河马刷牙。</p>
<p>那么，在什么情况下我们才会与别人比名利？</p>
<p>最好的答案是：在我们内心无处寄托的情况之下。</p>
<p>怎么才能让我们的心灵有一个寄托，要么你经历过很多很多的事，要么你读过很多很多的书。水木然认为，作为年轻的一代，我们虽然无法像上一代那么淡定，因为经历是无法安装的，但是我们却可以的很多很多的书，让自己变的淡定而优雅。</p>
<p>再换一个角度来看：我们活在这个世界上，最划算的上就是读书，因为那都是前人智慧的积累，很多东西经历的几百年才成为真理，变成白纸黑字流传下来，而我们只需要几天时间就消化成自己的知识、见识，变成智慧储存起来，何乐而不为？</p>
<blockquote class="blockquote-center">
<p>阅读，才是这个世界上收益最高的买卖！<br>很多有成就的人，也都是因为站在了巨人的肩膀上，吸纳了前人的大智慧。</p>

</blockquote>

<div align = right>----龙应台</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>深度好文</tag>
      </tags>
  </entry>
  <entry>
    <title>最小堆与最大堆</title>
    <url>/2018/10/16/MinHeapAndMaxHeap/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/MinHeapAndMaxHeap.jpg" class="full-image" />

<ul>
<li>堆是一种经过排序的完全二叉树，对其中任一非终端节点，其数据值不大于（或不小于）其左右子节点的值。</li>
<li>最小堆(最大堆)堆能保证堆顶元素最小(最大)，相比于用数组存放数据，如果要查找所有数据中最小(最大)的数据时，数组的时间复杂度为O(n)，而最小堆(最大堆)的时间复杂度为O(1)。</li>
<li>而数据增删数据时，需要保证最小堆(最大堆)的动态可维护性仅需O(logN)。因此在特定的需求环境，最小堆(最大堆)这种数据结构非常高效。</li>
</ul>
<a id="more"></a>

<h1 id="1-最小堆"><a href="#1-最小堆" class="headerlink" title="1. 最小堆"></a>1. 最小堆</h1><h2 id="1-1-最小堆概念"><a href="#1-1-最小堆概念" class="headerlink" title="1.1. 最小堆概念"></a>1.1. 最小堆概念</h2><p>最小堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节点的值。堆内的所有数据中最小的元素始终在堆顶，而增删一个元素而动态维护最小堆性质的时间复杂度仅为O(logN)</p>
<h2 id="1-2-最小堆实现思路"><a href="#1-2-最小堆实现思路" class="headerlink" title="1.2. 最小堆实现思路"></a>1.2. 最小堆实现思路</h2><p>将最小堆二叉树存储到数组内，非根节点元素的父节点下标为(i-1)&#x2F;2，若子节点存在则下标为2*i+1。</p>
<ul>
<li><strong>插入操作</strong>：每当插入一个元素，将元素插入到容器（数组）尾部，然后执行迭代的上升操作，将插入的元素与其父节点比较，若比父节点小则交换，然后再与交换后节点的父节点相互比较交换，直到放置到合适位置。（最坏递归到根节点终止迭代）</li>
<li><strong>取出操作</strong>：弹出最小值（即数组首地址元素a[0]）。先交换交换堆顶与堆末，再弹出堆末（最小值），然后再将现堆顶元素执行迭代的下降操作，若其子节点存在与其子节点比较，若比子节点小则交换，然后再与交换后的子节点相互比较交换，直到放置在合适位置。（最坏递归到叶子节点）</li>
</ul>
<h2 id="1-3-最小堆C-实现完整代码"><a href="#1-3-最小堆C-实现完整代码" class="headerlink" title="1.3. 最小堆C++实现完整代码"></a>1.3. 最小堆C++实现完整代码</h2><h3 id="1-3-1-最小堆-h文件"><a href="#1-3-1-最小堆-h文件" class="headerlink" title="1.3.1. 最小堆.h文件"></a>1.3.1. 最小堆.h文件</h3><figure class="highlight c++"><figcaption><span>文件名：MinHeap.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MINHEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINHEAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造小顶堆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;ElementType&gt; a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造小顶堆</span></span><br><span class="line">    <span class="built_in">MinHeap</span>(ElementType elements[], <span class="keyword">int</span> number)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=a.<span class="built_in">size</span>()/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">down</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换i,j下标对应元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ElementType temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上升操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa =(i<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//f表示父节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; a[i]&lt;a[fa])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(i, fa);</span><br><span class="line">            <span class="built_in">up</span>(fa);<span class="comment">//如果一直比父节点小，递归到根节点(下标0)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(ElementType p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(p);</span><br><span class="line">        <span class="built_in">up</span>(a.<span class="built_in">size</span>()<span class="number">-1</span>);<span class="comment">//上升操作 直到合适位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下降操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> son = <span class="number">2</span>*i+<span class="number">1</span>;<span class="comment">//son表示子节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (son &lt; a.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (son+<span class="number">1</span> &lt; a.<span class="built_in">size</span>() &amp;&amp; a[son] &gt; a[son+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                son++; <span class="comment">//取值两个子节点 值更小的节点下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若子节点小，交换</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[son])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(i, son);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">down</span>(son);<span class="comment">//递归调用，直到叶子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出堆顶节点（最小）</span></span><br><span class="line">    <span class="function">ElementType <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ElementType result = a[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">swap</span>(<span class="number">0</span>, a.<span class="built_in">size</span>()<span class="number">-1</span>);<span class="comment">//交换堆顶与堆末</span></span><br><span class="line">        a.<span class="built_in">pop_back</span>();<span class="comment">//弹出</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">0</span>);<span class="comment">//再将原来的最末元素（现在的堆顶元素）下降操作，使之到合适位置</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出堆(顺序输出)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-最小堆-cpp范例代码"><a href="#1-3-2-最小堆-cpp范例代码" class="headerlink" title="1.3.2. 最小堆.cpp范例代码"></a>1.3.2. 最小堆.cpp范例代码</h3><figure class="highlight c++"><figcaption><span>文件名：MinHeap.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">13</span>, <span class="number">43</span>, <span class="number">84</span>, <span class="number">96</span>, <span class="number">22</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">47</span>&#125;;</span><br><span class="line">    MinHeap* m = <span class="keyword">new</span> <span class="built_in">MinHeap</span>(a, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;显示当前最小堆:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;弹出最小堆顶的元素:&quot;</span> &lt;&lt; m-&gt;<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;显示当前最小堆:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入一个节点30:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m-&gt;<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;显示当前最小堆:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-最大堆"><a href="#2-最大堆" class="headerlink" title="2. 最大堆"></a>2. 最大堆</h1><h2 id="2-1-最大堆概念"><a href="#2-1-最大堆概念" class="headerlink" title="2.1. 最大堆概念"></a>2.1. 最大堆概念</h2><p>最大堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不小于其左子节点和右子节点的值。</p>
<h2 id="2-2-最大堆实现思路"><a href="#2-2-最大堆实现思路" class="headerlink" title="2.2. 最大堆实现思路"></a>2.2. 最大堆实现思路</h2><p>将最大堆二叉树存储到数组内，非根节点元素的父节点下标为(i-1)&#x2F;2，若子节点存在则下标为2*i+1。</p>
<ul>
<li><strong>插入操作</strong>：每当插入一个元素，将元素插入到容器（数组）尾部，然后执行迭代的上升操作，将插入的元素与其父节点比较，若比父节点大则交换，然后再与交换后节点的父节点相互比较交换，直到放置到合适位置。（最坏递归到根节点终止迭代）</li>
<li><strong>取出操作</strong>：弹出最大值（即数组首地址元素a[0]）。先交换交换堆顶与堆末，再弹出堆末（最大值），然后再将现堆顶元素执行迭代的下降操作，若其子节点存在与其子节点比较，若比子节点小则交换，然后再与交换后的子节点相互比较交换，直到放置在合适位置。（最坏递归到叶子节点）</li>
</ul>
<h2 id="2-3-最大堆C-实现完整代码"><a href="#2-3-最大堆C-实现完整代码" class="headerlink" title="2.3. 最大堆C++实现完整代码"></a>2.3. 最大堆C++实现完整代码</h2><h3 id="2-3-1-最大堆-h代码"><a href="#2-3-1-最大堆-h代码" class="headerlink" title="2.3.1. 最大堆.h代码"></a>2.3.1. 最大堆.h代码</h3><figure class="highlight c++"><figcaption><span>文件名：MaxHeap.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAXHEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXHEAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造大顶堆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;ElementType&gt; a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造大顶堆</span></span><br><span class="line">    <span class="built_in">MaxHeap</span>(ElementType elements[], <span class="keyword">int</span> number)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=a.<span class="built_in">size</span>()/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">down</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换i,j下标对应元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ElementType temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上升操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = (i<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//f表示父节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; a[i] &gt; a[fa])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(i, fa);</span><br><span class="line">            <span class="built_in">up</span>(fa);<span class="comment">//如果一直比父节点大，递归到根节点(下标0)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(ElementType p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(p);</span><br><span class="line">        <span class="built_in">up</span>(a.<span class="built_in">size</span>()<span class="number">-1</span>);<span class="comment">//上升操作 直到合适位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下降操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> son = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//son表示子节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (son &lt; a.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (son+<span class="number">1</span> &lt; a.<span class="built_in">size</span>() &amp;&amp; a[son] &lt; a[son+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                son++; <span class="comment">//取值两个子节点 值更大的节点下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若子节点大，交换</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[son])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(i, son);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">down</span>(son);<span class="comment">//递归调用，直到叶子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出堆顶节点（最大）</span></span><br><span class="line">    <span class="function">ElementType <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ElementType result = a[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">swap</span>(<span class="number">0</span>, a.<span class="built_in">size</span>()<span class="number">-1</span>);<span class="comment">//交换堆顶与堆末</span></span><br><span class="line">        a.<span class="built_in">pop_back</span>();<span class="comment">//弹出</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">0</span>);<span class="comment">//再将原来的最末元素（现在的堆顶元素）下降操作，使之到合适位置</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出堆(顺序输出)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-最大堆-cpp范例代码"><a href="#2-3-2-最大堆-cpp范例代码" class="headerlink" title="2.3.2. 最大堆.cpp范例代码"></a>2.3.2. 最大堆.cpp范例代码</h3><figure class="highlight c++"><figcaption><span>文件名：MaxHeap.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MaxHeap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">13</span>,<span class="number">43</span>,<span class="number">84</span>,<span class="number">96</span>,<span class="number">22</span>,<span class="number">65</span>,<span class="number">70</span>,<span class="number">47</span>&#125;;</span><br><span class="line">    MaxHeap* m = <span class="keyword">new</span> <span class="built_in">MaxHeap</span>(a, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;显示当前最大堆:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;弹出最大堆顶的元素:&quot;</span> &lt;&lt; m-&gt;<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;显示当前最大堆:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入一个节点90:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m-&gt;<span class="built_in">push</span>(<span class="number">90</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;显示当前最大堆:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层网络模型</title>
    <url>/2021/07/20/OSISevenLevelModel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-OSI网络模型优势"><a href="#1-OSI网络模型优势" class="headerlink" title="1. OSI网络模型优势"></a>1. OSI网络模型优势</h1><ul>
<li>定义了模型每层执行的功能功能，促成行业网络组件标准化，让满足模型的不同类型网络硬件和软件能够彼此通信，也能让各厂商能够协作开发</li>
<li>将网络通信过程划分成更小、更简单的组件，这有助于组件的开发、设计和故障排除</li>
<li>避免让对一层的修改影响其他层，从而避免妨碍开发工作</li>
</ul>
<a id="more"></a>

<h1 id="2-OSI七层网络模型"><a href="#2-OSI七层网络模型" class="headerlink" title="2. OSI七层网络模型"></a>2. OSI七层网络模型</h1><table  border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>层级</th>
        <th>OSI模型层级</th>
        <th>功能</th>
        <th>说明</th>
    </tr>
    <tr>
        <td align="center">7</td>
        <td align="center">应用层</td>
        <td>针对特定应用的协议</td>
        <td>电子邮件协议、远程登录协议、文件传输协议...</td>
    <tr>
        <td align="center">6</td>
        <td align="center">表示层</td>
        <td>设备固有数据格式与网络标准数据格式的转换</td>
        <td>将接收到的不同表现形式的信息。<br>如文字流、图像、声音等，转换为网络标准格式</td>
    </tr>
    <tr>
        <td align="center">5</td>
        <td align="center">会话层</td>
        <td>通信管理，负责建立和断开通信连接；<br>管理传输层以下的分层</td>
        <td>何时建立、断开连接，以及连接保持多久</td>
    </tr>
    <tr>
        <td align="center">4</td>
        <td align="center">传输层</td>
        <td>管理两个节点间数据传输。负责可靠传输<br>（确保数据被可靠地传送到目标地址）</td>
        <td>确保无数据丢失</td>
    </tr>
    <tr>
        <td align="center">3</td>
        <td align="center">网络层</td>
        <td>地址管理与路由选择</td>
        <td>明确经过哪些路由传递数据到目标地址</td>
    </tr>
    <tr>
        <td align="center">2</td>
        <td align="center">数据链路层</td>
        <td>互连设备之间传送和识别数据帧</td>
        <td>比特流与数据帧之间的转换</td>
    </tr>
    <tr>
        <td align="center">1</td>
        <td align="center">物理层</td>
        <td>以电压的高低、灯光的闪灭代表"0"、"1"。<br>界定连接器和网线的规格</td>
        <td>电子信号与比特流之间的转换</td>
    </tr>
</table>

<h2 id="2-1-物理层"><a href="#2-1-物理层" class="headerlink" title="2.1. 物理层"></a>2.1. 物理层</h2><p>负责发送和接收”0”、”1”比特功能。物理层直接与各种通信介质交流。不同类型的介质以不同方式表示比特值，如光的闪灭，电压高低或状态的切换一一从高电平变成低电平以及从低电平变成高电平。对于每种类型的介质，都需要特定的协议，这些协议描述了正确的比特模式、如何将数据编码成介质信号以及物理介质连接头的各种特征</p>
<h2 id="2-2-数据链路层"><a href="#2-2-数据链路层" class="headerlink" title="2.2. 数据链路层"></a>2.2. 数据链路层</h2><p>负责数据的物理传输，并处理错误通知、网络拓扑和流量控制功能。这意味着数据链路层需确保报文被传输到LAN中的正确设备（使用硬件地址），也能把来自网络层的报文转换为比特，以供物理层传输</p>
<p>数据链路层使用硬件地址，以便主机能够给本地网络中的其他主机发送分组以及穿越路由器发送分组。每当在路由器之间传输分组时，分组都将被封装成帧，而接收路由器会将这些信息剥离，只保留完整的原始分组。在每一跳都将重复这种将分组封装成帧的过程，直到分组最终到达目的接收机。注意，在整个传输过程中，分组本身从未被修改过，而只是被必要的控制信息封装，以便能够通过不同的介质进行传输</p>
<p>IEEE 以太网数据链路层包含两个子层，如下：</p>
<ul>
<li>**介质访问控制子层 (MAC，802.3)**：它定义了如何通过介质传输分组。它采用”先到先服务”的访问方式，带宽由大家共享，因此称为竟用介质访问（contention media access）。 这个子层定义了物理地址和逻辑拓扑。其中，逻辑拓扑指信号在物理拓扑中的传输路径。在这个子层，还可使用线路控制、错误通知(不纠错)、顺序传递帧以及可选的流量控制</li>
<li>**逻辑链路控制子层 (LLC，802.2)**：负责识别网络层协议并对其进行封装。 LLC报头说明数据链路层收到帧后如何对分组进行处理。其工作原理类似于：收到帧后，主机查看LLC报头以确定要将分组交给谁一一如网络层的IP协议 。LLC还可提供流量控制以及控制比特排序</li>
</ul>
<h2 id="2-3-网络层"><a href="#2-3-网络层" class="headerlink" title="2.3. 网络层"></a>2.3. 网络层</h2><p>负责将分组数据从源端传输到目的端。功能：为网络设备提供逻辑地址；进行路由选择和分组转发，即管理设备编址、跟踪设备在网络中的位置并确定最佳的数据传输路径</p>
<p><strong>流程：</strong></p>
<ol>
<li>在其接口上收到分组后，路由器首先检查分组的目标F地址 </li>
<li>若分组目的地是当前路由，则将分组封装成帧后在本地网络中传输</li>
<li>若分组目的地不是当前路由器，路由器将在路由选择表中查找目标网络地址对应端口</li>
<li>若找不到目标网络对应的记录，则丢弃分组</li>
<li>若能找到目标网络对应的记录，则将分组发送到该记录中的端口</li>
</ol>
<h2 id="2-4-传输层"><a href="#2-4-传输层" class="headerlink" title="2.4. 传输层"></a>2.4. 传输层</h2><p>传输层将数据进行分段并重组为数据流。位于传输层的服务将来自上层应用的数据进行分段和重 组，并将它们合并到同一个数据流中。它们提供了端到端的数据传输服务，并可在互联网络上的发送 主机和目标主机之间建立逻辑连接</p>
<p>传输层负责提供如下机制:对上层应用程序进行多路复用、建立会话以及拆除虚电路。它还提供 透明的数据传输，从而对高层隐藏随网络而异的信息</p>
<p>在传输层，可使用术语可靠的联网，这意味着将使用确认、排序和流量控制</p>
<h2 id="2-5-会话层"><a href="#2-5-会话层" class="headerlink" title="2.5. 会话层"></a>2.5. 会话层</h2><p>会话层负责建立、维护、管理应用程序之间的会话。它协调和组织系统之间的通信，为此提供了 3种不同的模式:单工、半双工和全双工。总之，会话层的基本功能是将不同应用程序的数据分离</p>
<h2 id="2-6-表示层"><a href="#2-6-表示层" class="headerlink" title="2.6. 表示层"></a>2.6. 表示层</h2><p>它向应用层提供数据，并负责数据转换和代码格式化</p>
<p>从本质上说，该层是一个转换器，提供编码和转换功能。一种成功的数据传输方法是，将数据转 换为标准格式再进行传输。计算机被配置成能够接受这种通用格式的数据，然后将其转换为本机格式 以便读取(例如，从 EDCDIC 转换为 ASCII )。通过提供转换服务，表示层能够确保从一个系统的应 用层传输而来的数据可被另一个系统的应用层读取</p>
<p>OSI 制定了相关的协议标准，这些标准定义了如何格式化标准数据。诸如数据压缩、解压缩、加密和解密等任务都与表示层有关。有些表示层标准还涉及多媒体操作</p>
<h2 id="2-7-应用层"><a href="#2-7-应用层" class="headerlink" title="2.7. 应用层"></a>2.7. 应用层</h2><p>为用于通信的应用程序和用于消息传输的底层网络提供接口，组成一个信息报文，实际上，应用层让应用程序能够将信息沿协议横向下传输，从而充当了应用程序和下一层之间的接口</p>
<h1 id="3-TCP-x2F-IP协议簇和OSI模型的对应关系"><a href="#3-TCP-x2F-IP协议簇和OSI模型的对应关系" class="headerlink" title="3. TCP&#x2F;IP协议簇和OSI模型的对应关系"></a>3. TCP&#x2F;IP协议簇和OSI模型的对应关系</h1><table width="300" border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>DoD模型</th>
        <th>OSI模型</th>
    </tr>
    <tr>
        <td  align="center" rowspan="3">进程/应用层</td>
        <td align="center">应用层</td>
    </tr>
    <tr>
        <td align="center">表示层</td>
    </tr>
    <tr>
        <td align="center">会话层</td>
    </tr>
    <tr>
        <td align="center">主机到主机层</td>
        <td align="center">传输层</td>
    </tr>
    <tr>
        <td align="center">因特尔层</td>
        <td align="center">网络层</td>
    </tr>
    <tr>
        <td  align="center" rowspan="2">网络接入层</td>
        <td align="center">数据链路层</td>
    </tr>
    <tr>
        <td align="center">物理层</td>
    </tr>
</table>

<h1 id="4-TCP-x2F-IP协议簇"><a href="#4-TCP-x2F-IP协议簇" class="headerlink" title="4. TCP&#x2F;IP协议簇"></a>4. TCP&#x2F;IP协议簇</h1><table  border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>DoD模型</th>
        <th>协议</th>
        <th>说明</th>
    </tr>
    <tr>
        <td rowspan="10">进程/应用层</td>
        <td align="center">Telnet</td>
        <td>远程终端协议，远程登录并控制服务器的协议，SSH</td>
    </tr>
    <tr>
        <td align="center">DNS</td>
        <td>将域名转换为IP地址的协议，基于TCP/UDP，53端口</td>
    </tr>
    <tr>
        <td align="center">HTTP</td>
        <td>超文本传输协议，是一个简单的请求-响应协议，基于TCP/TLS</td>
    </tr>
    <tr>
        <td align="center">FTP</td>
        <td>20/21 文件传输协议，20用于传输数据，21用于传输控制信息</td>
    </tr>
    <tr>
        <td align="center">LPD</td>
        <td>等待接受客户使用行式打印机远程协议传来的打印工作的协议</td>
    </tr>
    <tr>
        <td align="center">SNMP</td>
        <td>简单网络管理协议，用于管理服务器、工作站、路由器、交换机和HUBS等，通常使用UDP</td>
    </tr>
    <tr>
        <td align="center">TFTP</td>
        <td>在客户机与服务器之间进行简单文件传输的协议，基于UDP实现，端口69</td>
    </tr>
    <tr>
        <td align="center">DHCP</td>
        <td>动态主机设置协议，基于UDP</td>
    </tr>
    <tr>
        <td align="center">SMTP</td>
        <td>建模在FTP文件传输服务上的一种邮件服务，主要用于传输系统之间的邮件信息并提供来信有关的通知</td>
    </tr>
    <tr>
        <td align="center">NFS</td>
        <td>UNIX表示层协议(presentation layer protocol)，能使使用者访问网络上别处的文件就像在使用自己的计算机一样</td>
    </tr>
    <tr>
        <td rowspan="2">主机到主机层</td>
        <td align="center">TCP</td>
        <td>面向连接的、可靠的、基于字节流的传输层通信协议</td>
    </tr>
    <tr>
        <td align="center">UDP</td>
        <td>用户数据报协议，提供了一种无需建立连接就可以发送封装的IP数据包的方法</td>
    </tr>
    <tr>
        <td rowspan="4">因特网层</td>
        <td align="center">ICMP</td>
        <td>互联网控制消息协议，ICMP 依靠IP来完成它的任务，它是IP的主要部分。<br>其通常不由网络程序直接使用，除了ping和traceroute这两个特别的例子</td>
    </tr>
    <tr>
        <td align="center">ARP</td>
        <td>地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址</td>
    </tr>
    <tr>
        <td align="center">RARP</td>
        <td>反地址解析协议</td>
    </tr>
    <tr>
        <td align="center">IP</td>
        <td>提供了不可靠，无连接的数据报传送服务。基本功能：寻址、分片。</td>
    </tr>
    <tr>
        <td rowspan="4">网络接入层</td>
        <td align="center">以太网</td>
        <td>属网络低层协议，通常在OSI模型的物理层和数据链路层操作。完成网络传输控制任务</td>
    </tr>
    <tr>
        <td align="center">快速以太网</td>
        <td>一种局域网（LAN）传输标准，它提供每秒100兆的数据传输率（100BASE-T）</td>
    </tr>
    <tr>
        <td align="center">令牌环</td>
        <td>令牌环协议是令牌环网（一种以环形网络拓扑结构为基础发展起来的局域网）的协议，谁有令牌谁就有传输权限</td>
    </tr>
    <tr>
        <td align="center">FDDI</td>
        <td>光纤数据在200公里内局域网内传输的标准，基于令牌环协议。支持长距离传输，支持多用户。<br>FDDI用于环型网数据传输速率可达100Mbit/s</td>
    </tr>
</table>


]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenConfig北向接口简介</title>
    <url>/2022/01/27/OpenConfigNorthboundInterface/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-北向接口简介"><a href="#1-北向接口简介" class="headerlink" title="1. 北向接口简介"></a>1. 北向接口简介</h1><h2 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1. 背景"></a>1.1. 背景</h2><p>SDN（Software-Defined Networking，软件定义网络）能够很好地实现网络服务的可定制化，包括网络的可编程性、控制与转发相分离和集中化控制。用户可通过 SDN 的北向接口对网络资源进行编排以定制出满足自身需求的服务</p>
<a id="more"></a>

<p>SDN控制器有南&#x2F;北向两个接口，其中:</p>
<ul>
<li>南向接口：用于连接底层网络。以 OpenFlow 为理论基础实现的南向接口已经在业内得到了广泛共识</li>
<li>北向接口：用于连接上层应用。由于网络资源的编排复杂度较高，各厂商技术积累和利益相关差异，导致北向接口尚未在业内形成统一标准</li>
</ul>
<h2 id="1-2-北向接口定义"><a href="#1-2-北向接口定义" class="headerlink" title="1.2. 北向接口定义"></a>1.2. 北向接口定义</h2><p>北向接口（Northbound Interface），为其他厂商或运营商提供的接入管理网络的接口。SDN北向接口的协议制定仍为当前SDN领域竞争的焦点，其标准化还处于起步阶段</p>
<h2 id="1-3-北向接口作用"><a href="#1-3-北向接口作用" class="headerlink" title="1.3. 北向接口作用"></a>1.3. 北向接口作用</h2><ul>
<li>可将不同的南向技术和协议进行归一化，为上层应用统一抽取南向视图</li>
<li>北向接口的标准化和开放接口传输，可克服传送网络设备的互操作困难，促进SDN网络的创新、自动化和智能管理</li>
<li>可提供开放的与设备供应商低相关的，可交互操作方式</li>
</ul>
<h1 id="2-北向接口应用场景介绍"><a href="#2-北向接口应用场景介绍" class="headerlink" title="2. 北向接口应用场景介绍"></a>2. 北向接口应用场景介绍</h1><p>北向接口在友商中的应用场景介绍：</p>
<ul>
<li>提升部署运维管理效率</li>
<li>赋能云网一体化平台</li>
<li>网络虚拟化——计算联动</li>
</ul>
<h2 id="2-1-应用场景1：提升部署运维管理效率"><a href="#2-1-应用场景1：提升部署运维管理效率" class="headerlink" title="2.1. 应用场景1：提升部署运维管理效率"></a>2.1. 应用场景1：提升部署运维管理效率</h2><p>华为开发了 AgileController-DCN，提供标准北向接口（支持协议：OpenFlow&#x2F;OVSDB&#x2F;NetConf&#x2F;SNMP），可实现：</p>
<ul>
<li>基于租户网络资源的动态发放</li>
<li>方便快捷的网络开通和资源调整</li>
<li>缩短业务上线周期</li>
</ul>
<p>（北向接口赋能OpenStack）解决的传统问题：</p>
<ul>
<li>业务部署效率低  –&gt;  网络资源的池化和自动化部署、网络的建模和实例化</li>
<li>资源利用率低  –&gt;  网络集中管控、协同虚拟与物理网络、应用到物理网络的自动映射</li>
<li>运维管理复杂  –&gt;  构建全网视图、可视化运维、网络业务动态调度</li>
</ul>
<h2 id="2-2-应用场景2：赋能云网一体化平台"><a href="#2-2-应用场景2：赋能云网一体化平台" class="headerlink" title="2.2. 应用场景2：赋能云网一体化平台"></a>2.2. 应用场景2：赋能云网一体化平台</h2><p>华为基于AgileController-DCN提供的标准北向接口，搭建了统一虚拟化平台FusionSphere。其优势为：</p>
<ul>
<li>统一资源管理</li>
<li>硬件兼容性强</li>
<li>业务调度自动化程度高</li>
</ul>
<h2 id="2-3-应用场景3：实现网络虚拟化-计算联动"><a href="#2-3-应用场景3：实现网络虚拟化-计算联动" class="headerlink" title="2.3. 应用场景3：实现网络虚拟化-计算联动"></a>2.3. 应用场景3：实现网络虚拟化-计算联动</h2><p>华为将 AgileController-DCN 提供的北向接口能力，应用于非云化数据中心，可实现计算与网络分开管理。其优势为：</p>
<ul>
<li>基于AgileController-DCN提供的标准北向接口，进行网络自动化配置</li>
<li>与计算资源平台联动，协同分配调度资源，进行灵活而便捷的资源管理和业务下发</li>
</ul>
<h1 id="3-网络设备可编程方式对比"><a href="#3-网络设备可编程方式对比" class="headerlink" title="3. 网络设备可编程方式对比"></a>3. 网络设备可编程方式对比</h1><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">优势</th>
<th align="left">不足</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CLI（命令行）</td>
<td align="left">开发、调用简便</td>
<td align="left">不同厂商、款型、软件版本的网络设备的CLI命令存在差异和兼容问题；<br>管理侧适配不同厂商、版本的cli命令工作量大，不适用于大规模、自动化管理与配置；<br>基于“cli命令翻译”的方式耦合度高，不便于维护（若命令发生变更，需指令变更-指令下发-设备全线适配）；</td>
</tr>
<tr>
<td align="left">SNMP</td>
<td align="left">应用广泛，在网络监控（信息采集、异常告警、可视化报表等）方面具有优势</td>
<td align="left">在配置方面能力较欠缺或相对复杂</td>
</tr>
<tr>
<td align="left">Netconf</td>
<td align="left">与设备的具体命令解耦，管理&#x2F;配置仅需关注各厂商提供Netconf内容层的配置和状态数据（Json、XML）</td>
<td align="left">不同厂商的配置数据结构不同，管理侧需适配不同厂商的Netconf配置数据结构;<br>管理侧无法基于一套JSON（或XML）数据结构适配所有厂商的设备</td>
</tr>
<tr>
<td align="left">NetConf 与结合 YANG</td>
<td align="left">与具体的配置数据结构解耦（YANG）。开发配置简单，仅需关注YANG模型定义的配置数据&#x2F;状态数据结构，并按需传入相应读取&#x2F;配置RESTful请求参数即可</td>
<td align="left">各设备厂商的私有YANG模型不兼容；<br>各设备厂商需使用自己的 SDN Controller 控制自己的设备，且互不兼容；<br>需适配各厂商SDN Controller或自研一个通用的SDN Controller（管理侧仍需须兼容维护各厂商设备）</td>
</tr>
<tr>
<td align="left">OpenConfig</td>
<td align="left">与设备厂商完全解耦，管理侧无需关注设备兼容及底层数据处理和传输，仅需基于“标准化”OpenConfig YANG及提供的gNMI接口，来管理和配置网络设备<br>（无需考虑底层数据传输、兼容适配等问题，由设备厂商来适配OC YANG）</td>
<td align="left">尚处于推广阶段</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Common</tag>
      </tags>
  </entry>
  <entry>
    <title>停车场仿真系统</title>
    <url>/2019/01/23/ParkingSimulationSystem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/showFunction.gif" class="full-image" />

<a id="more"></a>

<h1 id="1-停车场仿真系统"><a href="#1-停车场仿真系统" class="headerlink" title="1. 停车场仿真系统"></a>1. 停车场仿真系统</h1><p>Project：用面向对象方法和面向对象程序设计语言，设计并实现停车场仿真程序。</p>
<p>Platform：基于QT5.9.1开发，程序语言C++</p>
<p>desc: 西电课程大作业</p>
<p>coder: haoleeson</p>
<p>Time: 2019-01-23</p>
<div class="note success"><p>完整源码详见:<a href="https://github.com/haoleeson/ParkingSimulationSystem">我的Git仓库</a></p>
</div>
<h2 id="1-1-设计说明"><a href="#1-1-设计说明" class="headerlink" title="1.1. 设计说明"></a>1.1. 设计说明</h2><p>某企业欲为其内部停车场建设一套信息系统，已经调查到的需求如下：</p>
<ul>
<li>企业为每位员工均发放一张感应式IC卡，卡上记录员工号。该卡由专门的卡管理系统 M 制作和维护，本系统需通过 M 来验证卡的有效性。</li>
<li>在停车场的入口和出口处分别安装一个自动栏杆、一台感应式IC卡读卡器和一个车辆通过传感器。</li>
<li>入口处安装一个显示屏，显示当前空闲车位数量。若停车场当前没有空闲车位，则不允许汽车入场，只许场内的汽车出场。</li>
<li>当一辆入场汽车到达入口时，用读卡器读出驾驶员的卡上信息，系统根据读出内容检查该卡的合法性：若该卡有效（需问M）&amp;&amp; 未被记录于当前场内卡号集合(即其车在场内的员工集合)中，即为合法卡。若为合法卡，系统命令栏杆抬起；汽车通过入口后，入口传感器通知系统发出命令，栏杆放下，系统遂将该卡卡号记录于当前场内卡号集合中；若为非法卡，则系统不发出栏杆抬起的命令，并发出告警信号。</li>
<li>当一辆出场汽车到达出口时，用读入器读出驾驶员的卡上信息，系统根据读出内容检查该卡是否已经被记录在当前场内卡号集合中。若已被记录，系统命令栏杆抬起；汽车通过出口后，出口传感器通知系统发出命令，栏杆放下，系统遂将该卡从当前场内卡号集合中删除；若未被记录，系统不发出栏杆抬起的命令而发出告警信号，交由出口值班人员处理。</li>
</ul>
<h2 id="1-2-设计要求"><a href="#1-2-设计要求" class="headerlink" title="1.2. 设计要求"></a>1.2. 设计要求</h2><ul>
<li>程序开始时，停车场车位全空。此后随机产生要进场的汽车，并按上述描述进行入场仿真。</li>
<li>汽车在停车场中的停留时间随机产生（为仿真的方便，可限定在5分钟之内，并在入场后立即设置）。到达停车时间后汽车即按上述描述进行出场仿真。</li>
<li><strong>定时报告</strong>（为方便，每分钟报告一次），应至少包括：当前时刻（包括时、分、秒）、当前场内车数、到目前为止的本次仿真“累计入场车数”、本次仿真“累计出场车数”、“本次仿真汽车的平均停车时间”。</li>
<li>应将上条报告的每条信息均写入指定的运行<strong>记录文件</strong>。文件名格式为“仿真日期-仿真起始时间.TXT”。 其中&lt;仿真日期&gt;为yyyyMMdd格式，&lt;仿真起始时间&gt;为hhmmss格式。</li>
<li>先按E&#x3D;2<em>N进行上述仿真。达到预期目标后，再分别按E &lt; 2*N和E &gt; 2</em>N进行仿真。因此，要求E和N从命令行、或配置文件、或从界面上读入，不能写死在程序中。</li>
<li>为检验系统的<strong>控制功能</strong>，应<strong>随机</strong>产生以下三类<strong>事件</strong>，并将这些事件的细节记录到上述的运行记录文件。a)前文的两类争道冲突；b)非本单位员工汽车要求入场的情况；c)需按限定条件（8）处理的情况。</li>
</ul>
<h2 id="1-3-限定条件"><a href="#1-3-限定条件" class="headerlink" title="1.3. 限定条件"></a>1.3. 限定条件</h2><ul>
<li><p>该企业的员工总人数为E人，员工号为1~E。</p>
</li>
<li><p>该停车场可容纳2*N辆汽车；入口到出口的距离&#x3D;N+2个车位的宽度。</p>
</li>
<li><p>汽车入场、出场时的读卡均需1秒钟，栏杆抬起、放下均需2秒钟，汽车的长度为2个车位宽度，汽车的行驶速度为每秒1个车位宽度。</p>
</li>
<li><p>入场的汽车尾端通过入口传感器后，该传感器通知系统放下入口栏杆。出场的汽车尾端通过出口传感器后，该传感器通知系统放下出口栏杆。</p>
</li>
<li><p>汽车进入停车场后，总是选择离入口最近的一个<strong>空</strong>车位停车。</p>
</li>
<li><p>汽车入场到达停车位后，需再用2秒从行车道停到车位上。汽车出场时先用2秒从车位到达行车道，然后向出口行进。</p>
</li>
<li><p>行车道上不允许汽车并行。a)若有进场车与出场车争道冲突，让出场车先行；b)若有出场车争道冲突，让离出口较远者先行；若与出口距离相同，随机决定让其中一辆车先行。</p>
</li>
<li><p>出口值班人员处理不允许出场的汽车时，令该车返回原车位。若原车位已被占用，返回离出口最近的一个空车位。</p>
</li>
</ul>
<p>在整个仿真过程中不考虑驾驶员走入或走出停车场。</p>
<h2 id="1-4-设计模型说明"><a href="#1-4-设计模型说明" class="headerlink" title="1.4. 设计模型说明"></a>1.4. 设计模型说明</h2><h3 id="1-4-1-类图"><a href="#1-4-1-类图" class="headerlink" title="1.4.1. 类图"></a>1.4.1. 类图</h3><p><img data-src="/../../../../uploads/parkingSimulationSystemUMLClassDiagram.png" alt="parkingSimulationSystemUMLClassDiagram"></p>
<p>主要有：停车场类、汽车类、后台管理M系统类、IC读卡器类、栏杆类、传感器类。与栏杆类、传感器类是整体与部分关系。</p>
<h3 id="1-4-2-用例图"><a href="#1-4-2-用例图" class="headerlink" title="1.4.2. 用例图"></a>1.4.2. 用例图</h3><p><img data-src="/../../../../uploads/parkingSimulationSystemUMLUseCaseDiagram.png" alt="parkingSimulationSystemUMLUseCaseDiagram"></p>
<p>主要描述了汽车与系统与后台管理系统M、读卡器、传感器、栏杆等参与者的关系。</p>
<h2 id="1-5-仿真流程（运行流程）简介"><a href="#1-5-仿真流程（运行流程）简介" class="headerlink" title="1.5. 仿真流程（运行流程）简介"></a>1.5. 仿真流程（运行流程）简介</h2><p>操作简单。涉及用户的人机交互操作仅有：设定员工人数、设定总车位数(&#x2F;2)、“开始仿真”、“结束仿真”、“生成汽车”按钮。</p>
<h3 id="1-5-1-设定员工人数、设定总车位数-x2F-2-参数"><a href="#1-5-1-设定员工人数、设定总车位数-x2F-2-参数" class="headerlink" title="1.5.1. 设定员工人数、设定总车位数(&#x2F;2)参数"></a>1.5.1. 设定员工人数、设定总车位数(&#x2F;2)参数</h3><p>设定员工人数、设定总车位数(&#x2F;2) 或维持默认（10, 5）。</p>
<h3 id="1-5-2-点击“开始仿真”"><a href="#1-5-2-点击“开始仿真”" class="headerlink" title="1.5.2. 点击“开始仿真”"></a>1.5.2. 点击“开始仿真”</h3><p>点击“开始仿真”按钮。</p>
<h3 id="1-5-3-点击“生成汽车”"><a href="#1-5-3-点击“生成汽车”" class="headerlink" title="1.5.3. 点击“生成汽车”"></a>1.5.3. 点击“生成汽车”</h3><p>点击“生成汽车”按钮，此时在相对坐标(0,0)处生成汽车，添加该实例到MainWindow类的生成汽车容器中（QVector&lt;carClass*&gt; creatCarList），并进行各种行为控制。</p>
<h3 id="1-5-4-系统内部每1s中断响应函数"><a href="#1-5-4-系统内部每1s中断响应函数" class="headerlink" title="1.5.4. 系统内部每1s中断响应函数"></a>1.5.4. 系统内部每1s中断响应函数</h3><p>执行：获取时间并更新界面左侧显示窗口信息，仿真控制所有生成车的运动的函数，检测下1秒有无争道并处理(让弱势方延时1秒)，自动关前门，自动关后门</p>
<h3 id="1-5-5-点击“结束仿真”"><a href="#1-5-5-点击“结束仿真”" class="headerlink" title="1.5.5. 点击“结束仿真”"></a>1.5.5. 点击“结束仿真”</h3><p>点击“结束仿真”按钮，关闭右侧动画框，保存系统日志文件。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的四种多态</title>
    <url>/2018/10/14/PolymorphismTest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/PolymorphismTest.jpg" class="full-image" />

<h1 id="1-多态的意义"><a href="#1-多态的意义" class="headerlink" title="1. 多态的意义"></a>1. 多态的意义</h1><ul>
<li>使程序中的数学运算符合常规的数学运算规则，使程序提供更强的表达能力;</li>
<li>使得对不同类型的数据有同样的操作语义(程序的重用);</li>
<li>重用标识的资源，提高程序的可读性和可理解性。<a id="more"></a></li>
</ul>
<h1 id="2-多态的种类"><a href="#2-多态的种类" class="headerlink" title="2. 多态的种类"></a>2. 多态的种类</h1><p>在程序中多态分为：通用的多态(universal)及特定的多态。</p>
<ul>
<li>其中通用多态包含：参数多态(parametric)和包含多态(inclusion)，特点是对数据类型不加限制;允许对不同类型的值执行相同的代码。</li>
<li>特定的多态包含：过载多态(overloading)和强制多态(coercion)，特点是只对有限数量的类型有效、对不同类型的值可能要执行不同的代码。</li>
</ul>
<h2 id="2-1-参数多态-Parametric-polymorphism"><a href="#2-1-参数多态-Parametric-polymorphism" class="headerlink" title="2.1. 参数多态(Parametric polymorphism)"></a>2.1. 参数多态(Parametric polymorphism)</h2><ul>
<li>概念：采用参数化模板，通过给出不同的类型实参，使得一个程序结构有多种类型。</li>
<li>例如：Ada中的generic(类属)、C++中的template(模板)，二者均支持数据类型和函数的参数多态。</li>
<li>从C++的template 结构可以看出：<ul>
<li>对实参所取的类型不加限制，不同的实参执行的是相同的代码。所以参数多态是一种通用多态。</li>
<li>模板的特点有：<ul>
<li>在一个抽象结构中允许以参数形式来表示可变部分–包括：类型、函数、常数;</li>
<li>在编译时(静态)才进行实例化，结果是一个具体的结构(类型、函数等)。</li>
<li>类型的实例化(类型→变量)可以静态进行，也可以动态进行，但结果都是一个值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如以下代码，在.h文件中定义模板类shape时，将类中的变量类型暂时用”T”代替</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后在.cpp文件中实例化该shape类时再指定变量的类型。如以下代码实例化该shape时分别指定类中的成员变量bottomLength、height的类型为int、double</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="function">shape&lt;<span class="keyword">int</span>&gt; <span class="title">shape1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">shape&lt;<span class="keyword">double</span> &gt; <span class="title">shape2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-包含多态-inclusion-polymorphism"><a href="#2-2-包含多态-inclusion-polymorphism" class="headerlink" title="2.2. 包含多态(inclusion polymorphism)"></a>2.2. 包含多态(inclusion polymorphism)</h2><ul>
<li>概念：同样的操作可用于一个(基)类型及其派生类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//求图形面积</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (bottomLength * height);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：平行四边形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parallelogram</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态，可直接调用基类的getArea()方法**/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：矩形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态，可直接调用基类的getArea()方法**/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-重置"><a href="#2-3-重置" class="headerlink" title="2.3. 重置"></a>2.3. 重置</h2><p>类比与之相似的“重置”。如C++中在基类定义的virsual方法，在派生类中再进行不同实现。如以下代码，在.h文件中从基类shape派生了两个子类：Triangle和Rectangle，两个子类中对父类的同一方法getArea()进行了两种不同的再实现，此为C++中的另一种形式的多态（重置）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//求图形面积</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (bottomLength * height);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：三角形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态**/</span></span><br><span class="line">        <span class="function">T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;bottomLength * <span class="keyword">this</span>-&gt;height / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：矩形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态**/</span></span><br><span class="line">        <span class="function">T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;bottomLength * <span class="keyword">this</span>-&gt;height);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-过载多态-overloading-polymorphism"><a href="#2-4-过载多态-overloading-polymorphism" class="headerlink" title="2.4. 过载多态(overloading polymorphism)"></a>2.4. 过载多态(overloading polymorphism)</h2><ul>
<li>概念：同一个表示操作的名字(如操作符、函数名)在不同的上下文中有不同的类型。(相同抽象，不同细节)。</li>
<li>程序设计语言中基本类型的多数操作符都是过载多态的。如：一个过载多态的操作符或函数名，它通常对应多个不同的实现。</li>
</ul>
<p>如以下代码在定义shape类中，有两个shape()构造函数，仅形参不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**过载多态：不带参数**/</span></span><br><span class="line">        <span class="built_in">shape</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = <span class="number">0</span>;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**过载多态：带2个参数**/</span></span><br><span class="line">        <span class="built_in">shape</span>(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = value1;</span><br><span class="line">            height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-强制多态-coercion"><a href="#2-5-强制多态-coercion" class="headerlink" title="2.5. 强制多态(coercion)"></a>2.5. 强制多态(coercion)</h2><ul>
<li>概念：通过语义操作，把操作数的类型强行加以变换，以符合操作符或函数的要求。</li>
<li>程序设计语言中基本类型的大多数操作符，在发生不同类型的数据进行混合运算时，编译程序一般都会进行强制类型转换(强制多态)。这种强制转换通常是隐式的，但程序员也可以显式地进行强制多态的操作(Casting)。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**强制多态**/</span></span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>， b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    c = a + b; <span class="comment">//隐式强制多态 将int类型的a，b转换为double</span></span><br></pre></td></tr></table></figure>

<h1 id="3-尝试构建一个同时包含四种多态的范例"><a href="#3-尝试构建一个同时包含四种多态的范例" class="headerlink" title="3. 尝试构建一个同时包含四种多态的范例"></a>3. 尝试构建一个同时包含四种多态的范例</h1><p>构造了一个基于C++的包含参数多态、包含多态、过载多态和强制多态的范例， 其中参数多态用模板展现。</p>
<h2 id="3-1-h文件完整代码如下："><a href="#3-1-h文件完整代码如下：" class="headerlink" title="3.1. .h文件完整代码如下："></a>3.1. .h文件完整代码如下：</h2><figure class="highlight c++"><figcaption><span>文件名: PolymorphismTest.h</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POLYMORPHISMTEST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLYMORPHISMTEST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**过载多态：不带参数**/</span></span><br><span class="line">        <span class="built_in">shape</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = <span class="number">0</span>;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**过载多态：带1个参数**/</span></span><br><span class="line">        <span class="built_in">shape</span>(T value)</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = value;</span><br><span class="line">            height = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**过载多态：带2个参数**/</span></span><br><span class="line">        <span class="built_in">shape</span>(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = value1;</span><br><span class="line">            height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求图形面积</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (bottomLength * height);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：三角形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**重置**/</span></span><br><span class="line">        <span class="function">T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;bottomLength * <span class="keyword">this</span>-&gt;height / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Triangle</span>(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bottomLength = value1;</span><br><span class="line">            <span class="keyword">this</span>-&gt;height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：平行四边形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parallelogram</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态，可直接调用基类的getArea()方法**/</span></span><br><span class="line">        <span class="built_in">Parallelogram</span>(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">this</span>-&gt;bottomLength = value1;</span><br><span class="line">            <span class="keyword">this</span>-&gt;height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：矩形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**重置**/</span></span><br><span class="line">        <span class="function">T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;bottomLength * <span class="keyword">this</span>-&gt;height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Rectangle</span>(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bottomLength = value1;</span><br><span class="line">            <span class="keyword">this</span>-&gt;height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-2-cpp文件完整代码如下："><a href="#3-2-cpp文件完整代码如下：" class="headerlink" title="3.2. .cpp文件完整代码如下："></a>3.2. .cpp文件完整代码如下：</h2><figure class="highlight c++"><figcaption><span>文件名: PolymorphismTest.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PolymorphismTest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**参数多态**/</span></span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">int</span>&gt; <span class="title">shape1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">double</span> &gt; <span class="title">shape2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**过载多态**/</span></span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">double</span>&gt; <span class="title">shape3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">double</span>&gt; <span class="title">shape4</span><span class="params">(<span class="number">3.2</span>， <span class="number">5.7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**包含多态**/</span></span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">double</span>&gt; <span class="title">shape5</span><span class="params">(<span class="number">4</span>， <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Parallelogram&lt;<span class="keyword">double</span>&gt; <span class="title">parallelogram</span><span class="params">(<span class="number">4</span>， <span class="number">5</span>)</span></span>;</span><br><span class="line">    shape5.<span class="built_in">getArea</span>();</span><br><span class="line">    parallelogram.<span class="built_in">getArea</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**重置**/</span></span><br><span class="line">    <span class="keyword">int</span> a， b;</span><br><span class="line">    <span class="function">Rectangle&lt;<span class="keyword">int</span>&gt; <span class="title">rectangle1</span><span class="params">(<span class="number">4</span>， <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Triangle&lt;<span class="keyword">int</span>&gt; <span class="title">triangle1</span><span class="params">(<span class="number">4</span>， <span class="number">4</span>)</span></span>;</span><br><span class="line">    a = rectangle1.<span class="built_in">getArea</span>();</span><br><span class="line">    b = triangle1.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**强制多态**/</span></span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    c = a + b; <span class="comment">//隐式强制多态 将int类型a，b转换为double</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python查看本周口碑电影</title>
    <url>/2019/04/30/PythonSimpleWebC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/PythonSimpleWebCTest.jpg" class="full-image" />

<h1 id="1-查看豆瓣周口碑榜的电影列表"><a href="#1-查看豆瓣周口碑榜的电影列表" class="headerlink" title="1. 查看豆瓣周口碑榜的电影列表"></a>1. 查看豆瓣周口碑榜的电影列表</h1><p>执行结果展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查看豆瓣一周口碑榜:</span><br><span class="line">复仇者联盟<span class="number">4</span>：终局之战</span><br><span class="line">触不可及(美版)</span><br><span class="line">盗梦特攻队</span><br><span class="line">深红累之渊</span><br><span class="line">遇见女孩的感觉</span><br><span class="line">撞死了一只羊</span><br><span class="line">归家：碧昂斯电影作品</span><br><span class="line">西班牙之旅</span><br><span class="line">娑婆诃</span><br><span class="line">番石榴岛</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h1><ul>
<li>安装Python环境。详见<a href="https://eisenhao.cn/2018/09/23/AfterInstallManjaro/#%E5%AE%89%E8%A3%85Python3-7">安装Python3.7</a></li>
<li>使用pip3安装requests、lxml模块。参考<a href="https://eisenhao.cn/2018/09/23/AfterInstallManjaro/#%E4%BD%BF%E7%94%A8pip3%E5%AE%89%E8%A3%85Numpy%E6%A8%A1%E5%9D%97">使用pip3安装Numpy模块</a></li>
<li>运行平台：终端或Python IDE软件(eg.<a href="http://www.jetbrains.com/pycharm/">PyCharm</a>)</li>
</ul>
<h1 id="3-练习1：查看豆瓣一周口碑榜"><a href="#3-练习1：查看豆瓣一周口碑榜" class="headerlink" title="3. 练习1：查看豆瓣一周口碑榜"></a>3. 练习1：查看豆瓣一周口碑榜</h1><p>代码比较简单，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看豆瓣一周口碑榜 https://movie.douban.com/</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/&#x27;</span></span><br><span class="line">page = requests.Session().get(url)</span><br><span class="line">tree = html.fromstring(page.text)</span><br><span class="line">result = tree.xpath(<span class="string">&#x27;//td[@class=&quot;title&quot;]//a/text()&#x27;</span>)</span><br><span class="line"><span class="comment"># //td ：这个相当于指定是大目录；</span></span><br><span class="line"><span class="comment"># [@class=&quot;title&quot;]：这个相当于指定的小目录；</span></span><br><span class="line"><span class="comment"># //a ：这个相当于最小的目录；</span></span><br><span class="line"><span class="comment"># /text()：这个是提取其中的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查看豆瓣一周口碑榜:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>关键点总结：</p>
<ul>
<li>网址，eg.上述事例代码中的<code><a href="https://movie.douban.com/">https://movie.douban.com/</a></code></li>
<li>数据格式，eg.上述事例代码中的<code>'//td[@class="title"]//a/text()'</code><ul>
<li>具有一定规律，可通过查看 HTML 源码（浏览器 F12）得出<img data-src="../../../../uploads/PythonSimpleWebCTest2.jpg" class="full-image" /></li>
<li>其中：<ul>
<li><code>//td</code> ：相当于大目录；</li>
<li><code>[@class="title"]</code>：相当于小目录；</li>
<li><code>//a</code> ：这个相当于最小的目录；</li>
<li><code>/text()</code>：这个是提取其中的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-练习2：查看豆瓣-西安-影讯-上映内容"><a href="#4-练习2：查看豆瓣-西安-影讯-上映内容" class="headerlink" title="4. 练习2：查看豆瓣-西安-影讯-上映内容"></a>4. 练习2：查看豆瓣-西安-影讯-上映内容</h1><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/cinema/later/xian/&#x27;</span> <span class="comment"># 数据的网址：豆瓣-西安-影讯-即将上映内容</span></span><br><span class="line">page = requests.Session().get(url)</span><br><span class="line">tree = html.fromstring(page.text)</span><br><span class="line"><span class="comment"># //div ：这个相当于指定是大目录；</span></span><br><span class="line"><span class="comment"># [@class=&quot;intro&quot;]：这个相当于指定的小目录；</span></span><br><span class="line"><span class="comment"># //a ：这个相当于最小的目录；</span></span><br><span class="line"><span class="comment"># /text()：这个是提取其中的数据。</span></span><br><span class="line">result = tree.xpath(<span class="string">&#x27;//div[@class=&quot;intro&quot;]//a/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 格式输出</span></span><br><span class="line"><span class="comment"># print(&quot;查看豆瓣-西安-影讯-即将上映内容&quot;)</span></span><br><span class="line"><span class="comment"># for i in result:</span></span><br><span class="line"><span class="comment">#     print(i, end=&#x27;\n&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;港珠澳大桥&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;下一任：前任&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;悟空奇遇记&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;猫公主苏菲&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;国礼&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;大破天门阵&#x27;</span>, <span class="string">&#x27;柔情史&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;罗马&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;大侦探皮卡丘&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;进京城&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;一个母亲的复仇&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;欢迎来北方II&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;半边天&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;一路疯癫&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;周恩来回延安&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;海蒂和爷爷&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;企鹅公路&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;妈阁是座城&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;致命梦魇&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;音乐家&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;你好现任&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="5-备注"><a href="#5-备注" class="headerlink" title="5. 备注"></a>5. 备注</h1><p>虽然实例代码比较简单，但实际中运行时仍会面临很多问题，比如： </p>
<ul>
<li>网页数据内容的规则难以归纳 </li>
<li>查看的数据不规范（需进一步处理） </li>
<li>大部分网站拥有反Pa机制等</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>QuickSort</title>
    <url>/2018/10/23/QuickSort/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/QuickSort.jpg" class="full-image" />

<h1 id="1-快速排序概念"><a href="#1-快速排序概念" class="headerlink" title="1. 快速排序概念"></a>1. 快速排序概念</h1><p>快速排序（Quick Sort）由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br>快速排序是不稳定的算法，时间复杂度在最坏情况下是O(N^2)，平均的时间复杂度是O(N*lgN)。</p>
<a id="more"></a>
<h2 id="1-1-Quick-Sort-实现思想"><a href="#1-1-Quick-Sort-实现思想" class="headerlink" title="1.1. Quick Sort 实现思想"></a>1.1. Quick Sort 实现思想</h2><p>快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：</p>
<ul>
<li>1、从数列中取出一个数作为基准数（枢轴，pivot）。 </li>
<li>2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。</li>
<li>3、再对左右的子区间重复第2步的划分操作，直至每个子区间的元素个数不超过Cutoff（阈值）。</li>
<li>4、每个子区间内的元素执行插入排序（实践经验小于一定数量后插入排序快于快速排序），然后返回上一调用堆栈。</li>
</ul>
<h2 id="1-2-快速排序-h完整代码"><a href="#1-2-快速排序-h完整代码" class="headerlink" title="1.2. 快速排序.h完整代码"></a>1.2. 快速排序.h完整代码</h2><figure class="highlight c++"><figcaption><span>文件名：QuickSort.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUICKSORT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKSORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序（从小到大）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">(ElementType* PtrA, <span class="keyword">long</span> <span class="keyword">int</span> Number)</span></span>&#123;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//认为A[0]已经插入了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">int</span> P = <span class="number">1</span>; P &lt; Number; P++)&#123;</span><br><span class="line">        temp = *(PtrA + P);<span class="comment">//取待插入排序元素到temp</span></span><br><span class="line">        <span class="keyword">for</span>(i = P; i &gt; <span class="number">0</span> &amp;&amp; *(PtrA + i - <span class="number">1</span>) &gt; temp; i--)&#123;</span><br><span class="line">            <span class="comment">//从后往前循环，大的元素往后挪，直到不小于temp处退出循环</span></span><br><span class="line">            <span class="comment">//A[i] = A[i-1];</span></span><br><span class="line">            *(PtrA + i) = *(PtrA + i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(PtrA + i) = temp;<span class="comment">//此是i为不大于temp的下标，插入temp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swap two elements of the Array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(ElementType *A, ElementType *B)</span></span>&#123;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    <span class="comment">//三部曲</span></span><br><span class="line">    temp = *A; <span class="comment">// 存A</span></span><br><span class="line">    *A = *B; <span class="comment">//换A</span></span><br><span class="line">    *B = temp; <span class="comment">//换B</span></span><br><span class="line">    <span class="comment">//或利用异或性质原地交换</span></span><br><span class="line">    <span class="comment">//*B ^= *A;</span></span><br><span class="line">    <span class="comment">//*A ^= *B;</span></span><br><span class="line">    <span class="comment">//*B ^= *A;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序中生成pivot</span></span><br><span class="line"><span class="function">ElementType <span class="title">Median3</span><span class="params">(vector&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Left, <span class="keyword">long</span> <span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> Center = (Left + Right)/ <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span>(A[Left] &gt; A[Center])&#123;</span><br><span class="line">        <span class="built_in">Swap</span>(&amp;A[Left], &amp;A[Center]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[Left] &gt; A[Right])&#123;</span><br><span class="line">        <span class="built_in">Swap</span>(&amp;A[Left], &amp;A[Right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[Center] &gt; A[Right])&#123;</span><br><span class="line">        <span class="built_in">Swap</span>(&amp;A[Center], &amp;A[Right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在，左、中、右三个已经有序</span></span><br><span class="line">    <span class="built_in">Swap</span>(&amp;A[Center], &amp;A[Right<span class="number">-1</span>]);</span><br><span class="line">    <span class="comment">//现在只需考虑　Left+1 ~ Right-2</span></span><br><span class="line">    <span class="keyword">return</span> A[Right<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序算法实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cutoff 5 <span class="comment">//定义快速排序（递归）阈值，数组元素小于Cutoff直接插入排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(vector&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Left, <span class="keyword">long</span> <span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    ElementType pivot;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否进行快速排序，阈值判断</span></span><br><span class="line">    <span class="keyword">if</span>((Right - Left)&gt;= Cutoff)&#123;</span><br><span class="line">        <span class="comment">//选主元pivot，藏于A[Right-1]</span></span><br><span class="line">        pivot = <span class="built_in">Median3</span>(A, Left, Right);</span><br><span class="line">        i = Left ;</span><br><span class="line">        j = Right - <span class="number">1</span> ;</span><br><span class="line">        <span class="comment">//子集划分(pivot左边全小于pivot；pivot右边全大于pivot)</span></span><br><span class="line">        <span class="keyword">for</span>(; ;)&#123;</span><br><span class="line">            <span class="keyword">while</span>(A[++i] &lt; pivot)&#123;&#125; <span class="comment">//找到A[i] &gt; pivot, 跳出</span></span><br><span class="line">            <span class="keyword">while</span>(A[--j] &gt; pivot)&#123;&#125; <span class="comment">//找到A[j] &lt; pivot, 跳出</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="comment">//说明A[i]与A[j]之间还有其他元素，可交换</span></span><br><span class="line">                <span class="built_in">Swap</span>(&amp;A[i], &amp;A[j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Swap</span>(&amp;A[i], &amp;A[Right<span class="number">-1</span>]); <span class="comment">//将pivot 放到中间，即i下标处</span></span><br><span class="line">        <span class="built_in">Quicksort</span>(A, Left, i<span class="number">-1</span>);<span class="comment">//递归处理左边</span></span><br><span class="line">        <span class="built_in">Quicksort</span>(A, i+<span class="number">1</span>, Right);<span class="comment">//递归处理右边</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//低于阈值，直接调用插入排序</span></span><br><span class="line">        <span class="comment">//递归到最小一层用插入排序(每段的插入排序地址为：&amp;A + Left(即：绝对地址A 加相对地址Left)</span></span><br><span class="line">        <span class="comment">//最小一层插入排序元素个数Number = Right-Left+1</span></span><br><span class="line">        <span class="built_in">Insertion_Sort</span>( &amp;A[Left], Right-Left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序（统一接口，加壳）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(vector&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Number)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Quicksort</span>(A, <span class="number">0</span>, Number<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Prlong int the Array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Array</span><span class="params">(vector&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> NumberOfPreRows = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Number; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; A[i];</span><br><span class="line">        <span class="keyword">if</span>(i%NumberOfPreRows == (NumberOfPreRows<span class="number">-1</span>))&#123;</span><br><span class="line">        	cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-快速排序-cpp范例代码"><a href="#1-3-快速排序-cpp范例代码" class="headerlink" title="1.3. 快速排序.cpp范例代码"></a>1.3. 快速排序.cpp范例代码</h2><figure class="highlight c++"><figcaption><span>文件名：QuickSort.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QuickSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(x)(rand()%x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">int</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> Number = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//构造Number + 1大小的容器</span></span><br><span class="line">    <span class="function">vector&lt;ElementType&gt; <span class="title">A</span><span class="params">(Number + <span class="number">1</span>)</span></span>; <span class="comment">//build a vector to</span></span><br><span class="line">    <span class="comment">//产生Number个随机数并赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Number; i++)</span><br><span class="line">        A[i] = <span class="built_in">random</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//Print A</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Creat 100 random Num:&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Print_Array</span>(A, Number);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Execute Quick Sort&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Quick_Sort</span>(A, Number);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result:&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//Print A</span></span><br><span class="line">    <span class="built_in">Print_Array</span>(A, Number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-延伸思考："><a href="#1-4-延伸思考：" class="headerlink" title="1.4. 延伸思考："></a>1.4. 延伸思考：</h2><p>假设待排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？</p>
<p>最多需要遍历N次，至少需要遍历lg(N+1)次。</p>
<ul>
<li>(1).为什么最少是lg(N+1)次？<br>快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。</li>
<li>(2).为什么最多是N次？<br>将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>钱穆：读书与做人</title>
    <url>/2021/01/28/ReadingAndBeingAMan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/QianMu.jpg" class="full-image" />

<div class="note success"><p>钱穆（1895年7月30日-1990年8月30日），字宾四，笔名公沙，江苏省无锡人，中国现代历史学家。<br>其毕生弘扬中国传统文化，高举现代新儒家的旗帜，创办了新亚书院，与吕思勉、陈垣、陈寅恪并称为“史学四大家”，代表著作有《钱宾四先生全集》等。</p>
</div>

<p>本文转自钱穆先生在二十世纪六十年代应邀在复兴中国文化会第十次学术会议中发表的演讲《读书与做人》。原文如下，妄自在钱穆先生演讲中加上小标题以便网页快速定位，还望包涵！</p>
<a id="more"></a>

<h1 id="1-（引言）"><a href="#1-（引言）" class="headerlink" title="1. （引言）"></a>1. （引言）</h1><p>今天在这讲堂里有年青的同学，有中年人，更有老年人；真是一次很有价值、很有意义的盛会。如按年岁来排，便可分三班；所以讲话就比较难。因为所讲如是年青人比较喜欢的，可能年长的不大爱听；反之亦然。现在我准备所讲将以年长人为主，因为年青人将来还得做大人；但年老了，却不能复为青年人。并且年幼的都当敬重年老的，这将好让将来的青年人也敬重你们。至于年老的人，都抱着羡慕你们年青人的心情，自然已值得年青人骄傲了。</p>
<h1 id="2-（至死学做一个高标准的人）"><a href="#2-（至死学做一个高标准的人）" class="headerlink" title="2. （至死学做一个高标准的人）"></a>2. （至死学做一个高标准的人）</h1><p>我今天的讲题是“读书与做人”，实在对年青人也有关。婴孩一出世，就是一个人，但还不是我们理想中要做的一个人。我们也不能因为日渐长大成人了，就认为满足；人仍该要自己做。所谓做人，是要做一个理想标准高的人。这须自年幼时即学做；即使已届垂暮之年，仍当继续勉学、努力做。所谓“学到老，做到老”，做人工夫无止境。学生在学校读书，有毕业时期；但做人却永不毕业——临终一息尚存，他仍是一人，即仍该做；所以做人须至死才已。</p>
<h1 id="3-（读书与做人的关系）"><a href="#3-（读书与做人的关系）" class="headerlink" title="3. （读书与做人的关系）"></a>3. （读书与做人的关系）</h1><p>现在讲到读书。因为只有在书上可以告诉我们如何去做一个有理想高标准的人；诸位在学校读书，主要就是要学做人；即如做教师的亦然。固然做教师可当是一职业；但我们千万不要以为职业仅是为谋生，当知职业也在做人道理中。做人理当有职业，以此贡献于社会。人生不能无职业，这是从古到今皆然的。但做一职业，并不即是做人之全体，而只是其一部分。学生在校求学，为的是为他将来职业作准备。然而除在课堂以外；如在宿舍中，或是在运动场上，也都是在做人，亦当学。在课堂读书求学，那只是学做人的一部分；将来出了学校，有了职业，还得要做人。做人圈子大，职业圈子小。做人当有理想，有志愿。这种理想与志愿，藏在各人内心，别人不能见，只有他自己才知道。因此，读书先要有志；其次，当能养成习惯，离开了学校还能自己不断读书。读书亦就是做人之一部分，因从读书可懂得做人的道理，可使自己人格上进。</p>
<h1 id="4-（狭义读书与业余读书）"><a href="#4-（狭义读书与业余读书）" class="headerlink" title="4. （狭义读书与业余读书）"></a>4. （狭义读书与业余读书）</h1><p>惟在离开了学校以后的读书，实与在学校里读书有不同。在学校里读书，由学校课程硬性规定，要笔记、要考试，战战兢兢，担心不及格，不能升级、不能毕业，好像在为老师而读书，没有自己的自由；至于离了学校，有了职业，此时再也没有讲堂，也没有老师了，此时再读书，全是自由的，各人尽可读各人自己喜欢的书。当知：在学校中读书，只是为离学校求职业作准备。这种读书并不算真读书。如果想做一位专门学者，这是他想以读书为职业；当知此种读书，亦是做人中一小圈子。我们并不希望，而且亦不大可能要人人尽成为学者。我此所讲，乃指我们离开学校后，不论任何职业、任何环境而读书，这是一种业余读书，这种读书，始是属于人生的大圈子中尽人应有之一事；必需的，但又是自由的。今问此种读书应如何读法？下面我想提出两个最大的理想、最共同的目标来：</p>
<h1 id="5-（业余读书的最大理想与追求？）"><a href="#5-（业余读书的最大理想与追求？）" class="headerlink" title="5. （业余读书的最大理想与追求？）"></a>5. （业余读书的最大理想与追求？）</h1><h2 id="5-1-（培养情趣）"><a href="#5-1-（培养情趣）" class="headerlink" title="5.1. （培养情趣）"></a>5.1. （培养情趣）</h2><p>一是培养情趣。人生要过得愉快、有趣味，这需用工夫去培养。社会上甚至有很多人怕做人了，他觉得人生乏味，对人生发生厌倦，甚至于感到痛苦。譬如：我们当教师，有人觉得当教师是不得已，只是为谋生，只是枯燥沉闷，挨着过日子。但当知：这非教师做不得，只是他失了人生的情趣了。今试问：要如何才能扭转这心理，使他觉得人生还是有意义有价值？这便得先培养他对人生的情趣；而这一种培养人生情趣的工夫，莫如好读书。</p>
<h2 id="5-2-（提高境界）"><a href="#5-2-（提高境界）" class="headerlink" title="5.2. （提高境界）"></a>5.2. （提高境界）</h2><p>二是提高境界。所谓境界者，例如这讲堂，在调景岭村中，所处地势，既高又宽敞，背山面海；如此刻晴空万里，海面归帆遥驶，或海鸥三五，飞翔碧波之上；如开窗远眺，便觉眼前呈露的，乃是一片优美境界，令人心旷神怡。即或朗日已匿，阴雨晦冥，大雾迷蒙，亦仍别有一番好景。若说是风景好，当知亦从境界中得来；若换一境界，此种风景也便不可得。居住有境界，人生亦有境界；此两种境界并不同。并非住高楼美屋的便一定有高的、好的人生境界，住陋室茅舍的便没有。也许住高楼华屋，居住境界好，但他的人生境界并不好。或许住陋室茅舍，他的居住环境不好，而他的人生境界却尽好。要知人生境界别有存在。这一层，或许对青年人讲，一时不会领会，要待年纪大了、经验多、读书多才能体会到此。我们不是总喜欢过舒服快乐的日子吗？当知人生有了好的高的境界，他做人自会多情趣，觉得快活舒适。若我们希望能到此境界，便该好好学做人；要学做人，便得要读书。</p>
<h1 id="6-（读书为何能提高境界？）"><a href="#6-（读书为何能提高境界？）" class="headerlink" title="6. （读书为何能提高境界？）"></a>6. （读书为何能提高境界？）</h1><p>为什么读书便能学得做一个高境界的人呢？因为在书中可碰到很多人，这些人的人生境界高、情味深，好做你的榜样。目前在香港固然有三百几十万人之多，然而我们大家的做人境界却不一定能高，人生情味也不一定能深。我们都是普通人，但在书中遇见的人可不同；他们是由千百万人中选出，又经得起长时间的考验而保留以至于今日，像孔子，距今已有二千六百年，试问中国能有几个孔子呢？又如耶稣，也快达二千年；他如释迦牟尼、穆罕默德等人。为什么我们敬仰崇拜他们呢？便是由于他们的做人。当然，历史上有不少人物，他们都因做人有独到处，所以为后世人所记忆，而流传下来了。世间决没有中了一张马票，成为百万富翁而能流传后世的。即使做大总统或皇帝，亦没有很多人能流传让人记忆，令人向往。中国历代不是有很多皇帝吗？但其中大多数，全不为人所记忆，只是历史上有他一名字而已。哪里有读书专来记人姓名的呢？做皇帝亦尚无价值，其余可知。中马票固是不足道；一心想去外国留学、得学位，那又价值何在、意义何在呀？当知论做人，应别有其重要之所在。假如我们诚心想做一人，“培养情趣，提髙境界”，只此八个字，便可一生受用不尽；只要我们肯读书，能遵循此八个字来读，便可获得一种新情趣，进入一个新境界。各位如能在各自业余每天不断读书，持之以恒，那么长则十年二十年，短或三年五年，便能培养出人生情趣，提高了人生境界。那即是人生之最大幸福与最高享受了。</p>
<h1 id="7-（读书的选择？）"><a href="#7-（读书的选择？）" class="headerlink" title="7. （读书的选择？）"></a>7. （读书的选择？）</h1><p>说到此，我们当再进一层来谈一谈读书的选择。究竟当读哪些书好？我认为：业余读书，大致当分下列数类：</p>
<h2 id="7-1-（修养类的书）"><a href="#7-1-（修养类的书）" class="headerlink" title="7.1. （修养类的书）"></a>7.1. （修养类的书）</h2><p>一是修养类的书。所谓修养，犹如我们栽种一盆花，需要时常修剪枝叶，又得施肥浇水；如果偶有三五天不当心照顾，便决不会开出好花来，甚至根本不开花，或竟至枯死了。栽花尚然，何况做人！当然更须加倍修养。<br>中国有关人生修养的几部书是人人必读的。首先是论语。切不可以为我从前读过了，现在毋须再读。正如天天吃饭一样，不能说今天吃了，明天便不吃；好书也该时时读。再次是孟子。孔孟这两部书，最简单，但也最宝贵。如能把此两书经常放在身边，一天读一二条，不过化上三五分钟，但可得益无穷。此时的读书，是各人自愿的，不必硬求记得，也不为应考试，亦不是为着要做学问专家或是写博士论文；这是极轻松自由的，只如孔子所言“默而识之”便得。只这样一天天读下，不要以为没有什么用；如像诸位毎天吃下许多食品，不必也不能时时去计算在里面含有多少维他命，多少卡路里，只吃了便有益；读书也是一样。这只是我们一种私生活，同时却是一种高尚享受。</p>
<p>孟子曾说过：“君子有三乐，而王天下不与存焉。”连做皇帝王天下都不算乐事；那么，看电影、中马票，又算得什么？但究竟孟子所说的那三件乐事是什么？我们不妨翻读一下孟子，把他的话仔细想一想，那实在是有意义的。人生欲望是永远不会满足的；有人以为月入二百元能加至二百五十元就会有快乐；哪知等到你如愿以偿，你始觉得仍然不快乐——即使王天下，也一样会不快乐。我们试读历史，便知很多帝王比普通人活得更不快乐。做人确会有不快乐，但我们不能就此便罢，我们仍想寻求快乐。人生的真快乐，我劝诸位能从书本中去找；只化三两块钱到书店中去，便可买到论语孟子；即使一天读一条，久之也有无上享受。</p>
<p>还有一部老子，全书只五千字。一部庄子，篇幅较巨，文字较深，读来比较难；但我说的是业余读书，尽可不必求全懂。要知：即是一大学者，他读书也会有不懂的；何况我们是业余读书；等于放眼看窗外风景，或坐在巴士轮渡中欣赏四周景物，随你高兴看什么都好，不一定要全把外景看尽了，而且是谁也看不尽。还有一部佛教禅宗的六祖坛经，是用语体文写的，内中故事极生动，道理极深邃，化几小时就可一口气读完，但也可时常精读。其次，还有朱子的近思录与阳明先生的传习录。这两部书，篇幅均不多，而且均可一条条分开读。爱读几条便几条。我常劝国人能常读上述七部书。中国传统所讲修养精义，已尽在其内。而且此七书不论你做何职业，生活如何忙，都可读。今天在座年幼的同学们，只盼你们记住这几部书名，亦可准备将来长大了读。如果大家都能毎天抽出些时间来，有恒地去读这七部书，准可叫我们脱胎换骨，走上新人生的大道去。</p>
<h2 id="7-2-（欣赏类的书）"><a href="#7-2-（欣赏类的书）" class="headerlink" title="7.2. （欣赏类的书）"></a>7.2. （欣赏类的书）</h2><p>其次便是欣赏类的书。风景可以欣赏，电影也可以欣赏，甚至品茶喝咖啡，都可有一种欣赏。我们对人生本身也需要欣赏，而且需要能从高处去欣赏。最有效的莫如读文学作品，尤要在读诗。这并非要求大家都做一个文学家；只要能欣赏。谚语有云：“熟读唐诗三百首，不会做诗也会吟。”诗中境界，包罗万象；不论是自然部分，不论是人生部分，中国诗里可谓无所不包；一年四季，天时节令，一切气候景物，乃至飞潜动植，一枝柳，一瓣花，甚至一条村狗或一只令人讨厌的老鼠，都进入诗境，经过诗人笔下晕染，都显出一番甚深情意，趣味无穷；进入人生所遇喜怒哀乐，全在诗家作品中。当我们读诗时，便可培养我们欣赏自然，欣赏人生，把诗中境界成为我们心灵欣赏的境界。如能将我们的人生投放沉浸在诗中，那真趣味无穷。<br>如陶渊明诗：</p>
<blockquote class="blockquote-center">
<p><strong>犬吠深巷中，鸡鸣桑树巅。</strong></p>

</blockquote>
<p>这十个字，岂非我们在穷乡僻壤随时随地可遇到！但我们却忽略了其中情趣。经陶诗一描写，却把一幅富有风味的乡村闲逸景象活在我们眼前了。我们能读陶诗，尽在农村中过活，却可把我们带进人生最高境界中去，使你如在诗境中过活，那不好吗？</p>
<p>又如王维诗：</p>
<blockquote class="blockquote-center">
<p><strong>雨中山果落，灯下草虫鸣。</strong></p>

</blockquote>
<p>诸位此刻住山中，或许也会接触到这种光景：下雨了，宅旁果树上，一个个熟透了的果子掉下来，可以听到“扑”“扑”的声音；草堆里小青虫经着雨潜进窗户来了，在灯下唧唧地鸣叫着。这是一个萧瑟幽静的山中雨夜，但这诗中有人。上面所引陶诗，背后也有人。只是一在山中，一在村中；一在白天，一在晚上。诸位多读诗，不论在任何境遇中，都可唤起一种文学境界，使你像生活在诗中，这不好吗？</p>
<p>纵使我们也有不能亲历其境的，但也可以移情神游，于诗中得到一番另外境界，如唐诗：</p>
<blockquote class="blockquote-center">
<p><strong>松下问童子，言师采药去；只在此山中，云深不知处。</strong></p>

</blockquote>
<p>那不是一幅活的人生画像吗？那不是画的人，却是画的人生。那一幅人生画像，活映在我们眼前，让我们去欣赏。在我想，欣赏一首诗，应比欣赏一张电影片有味，因其更可使我们长日神游，无尽玩味。不仅诗如此，即中国散文亦然。诸位纵使只读一本唐诗三百首、只读一本古文观止也好；当知我们学文学，并不为自己要做文学家。因此，不懂诗韵平仄，仍可读诗。读散文更自由。学文学乃为自己人生享受之用，在享受中仍有提髙自己人生之收获，那真是人生一秘诀。</p>
<h2 id="7-3-（博闻类的书）"><a href="#7-3-（博闻类的书）" class="headerlink" title="7.3. （博闻类的书）"></a>7.3. （博闻类的书）</h2><p>第三是博闻类。这类书也没有硬性规定；只求自己爱读，史传也好，游记也好，科学也好，哲学也好，性之所近，自会乐读不倦，增加学识，广博见闻，年代一久，自不寻常。</p>
<h2 id="7-4-（新知类的书）"><a href="#7-4-（新知类的书）" class="headerlink" title="7.4. （新知类的书）"></a>7.4. （新知类的书）</h2><p>第四是新知类。我们生在这时代，应该随时在这时代中求新知。这类知识，可从现代出版的期刊杂志上，乃至报章上找到。这一类更不必详说了。</p>
<h2 id="7-5-（消遣类的书）"><a href="#7-5-（消遣类的书）" class="headerlink" title="7.5. （消遣类的书）"></a>7.5. （消遣类的书）</h2><p>第五是消遣类。其实广义说来，上面所提，均可作为消遣；因为这根本就是业余读书，也可说即是业余消遣。但就狭义说之，如小说、剧本、传奇等，这些书便属这一类。如诸位读水浒传、三国演义、红楼梦，可作是消遣。</p>
<h1 id="8-（何时读书？）"><a href="#8-（何时读书？）" class="headerlink" title="8. （何时读书？）"></a>8. （何时读书？）</h1><p>上面已大致分类说了业余所当读的书。但诸位或说生活忙迫，能在什么时读呢？其实人生忙，也是应该的；只在能利用空闲，如欧阳修的三上，即：枕上、厕上和马上。上床了，可有十分一刻钟睡不着；上洗手间，也可顺便带本书看看；今人不骑骡马，但在舟车上读书，实比在马上更舒适。古人又说三余：冬者岁之余，夜者日之余，阴者晴之余。现在我们生活和古人不同；但每人必有很多零碎时间，如：清晨早餐前，傍晚天黑前，又如临睡前；一天便有三段零碎时间了。恰如一块布，裁一套衣服以后，余下的零头，大可派作别的用场。另外，还有周末礼拜天，乃及节日和假期；尤其是做教师的还有寒暑假。这些都可充分利用，作为业余读书时间的。假如毎日能节约一小时，十年便可有三千六百个小时。又如一个人自三十岁就业算起，到七十岁，便可节余一万四千四百个小时，这不是一笔了不得的大数目吗？现在并不是叫你去吃苦做学问，只是以读书为娱乐和消遣，亦像打麻雀、看电影，哪会说没有时间的！如果我们读书也如打麻雀、看电影般有兴趣、有习惯，在任何环境任何情况下都可读书。这样，便有高的享受，有好的娱乐，岂非人生一大佳事！读书只要有恒心，自能培养出兴趣，自能养成为习惯，从此可以提髙人生境界。这是任何数量的金钱所买不到的。</p>
<h1 id="9-（倡导读书）"><a href="#9-（倡导读书）" class="headerlink" title="9. （倡导读书）"></a>9. （倡导读书）</h1><p>今日香港社会读书空气实在太不够，中年以上的人，有了职业，便不再想到要进修，也不再想到业余还可再读书。我希望诸位能看重此事，也不妨大家合作，有书不妨交换读，有意见可以互相倾谈。如此，更易培养出兴趣。只消一年时间，习惯也可养成。我希望中年以上有职业的人能如此，在校的青年们他日离了学校亦当能如此，那真是无上大佳事。循此以往，自然人生境界都会高，人生情味都会厚。人人如此，社会也自成为一好社会。我今天所讲，并不是一番空泛的理论，只是我个人的实际经验。今天贡献给各位，愿与大家都分享这一份人生的无上宝贵乐趣。</p>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>深度好文</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork仓库同步官方源仓库的更新</title>
    <url>/2019/11/18/RefreshForkRepositorie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/RefreshForkRepositorie.png" class="full-image" />

<p>Fork仓库是对应官方源仓库的一份完全备份（类似快照，但却不能再接收到官方源仓库的更新内容），然而有时咱们需要Fork仓库涵盖官方源仓库的最新提交代码。</p>
<a id="more"></a>

<p>本文总结介绍了从官方源仓库同步更新内容到Fork仓库的方法，过程大致如下：</p>
<ul>
<li>向本地Fork仓库添加官方源仓库远端</li>
<li>再获取(fetch)官方源仓库的更新内容到本地仓库</li>
<li>然后合并官方源仓库的更新内容到本地Fork仓库</li>
<li>最后推送到远端Fork仓库。</li>
</ul>
<h1 id="1-步骤一、添加官方源仓库远端"><a href="#1-步骤一、添加官方源仓库远端" class="headerlink" title="1. 步骤一、添加官方源仓库远端"></a>1. 步骤一、添加官方源仓库远端</h1><h2 id="1-1-查看远端仓库"><a href="#1-1-查看远端仓库" class="headerlink" title="1.1. 查看远端仓库"></a>1.1. 查看远端仓库</h2><p>查看本地Fork仓库的远端信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>一般此时查询的结果只有一个Fork仓库远端（共两行fetch + push）eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin      ssh:&#x2F;&#x2F;git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git (fetch)</span><br><span class="line">origin      ssh:&#x2F;&#x2F;git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git (push)</span><br></pre></td></tr></table></figure>
<p>其中 “origin” （默认值）为本地设置的Fork远端仓库的远端别名， 而“ssh:&#x2F;&#x2F;<a href="mailto:&#x67;&#x69;&#116;&#64;&#x78;&#120;&#120;&#120;&#120;&#x78;&#120;&#x78;&#120;&#x78;&#x78;&#x78;&#x78;&#x78;&#120;&#120;&#120;&#x78;&#x78;&#120;&#120;&#x78;&#120;&#x78;&#x78;&#120;&#120;&#x78;&#x78;&#x78;&#46;&#103;&#105;&#116;">&#x67;&#x69;&#116;&#64;&#x78;&#120;&#120;&#120;&#120;&#x78;&#120;&#x78;&#120;&#x78;&#x78;&#x78;&#x78;&#x78;&#120;&#120;&#120;&#x78;&#x78;&#120;&#120;&#x78;&#120;&#x78;&#x78;&#120;&#120;&#x78;&#x78;&#x78;&#46;&#103;&#105;&#116;</a>“ 对应为你的Fork仓库地址</p>
<h2 id="1-2-添加官方源仓库远端"><a href="#1-2-添加官方源仓库远端" class="headerlink" title="1.2. 添加官方源仓库远端"></a>1.2. 添加官方源仓库远端</h2><p>添加官方源仓库远端到本地Fork仓库，使具有两个远端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin_official https:&#x2F;&#x2F;oooooooooooooooooooooooooooooo.git</span><br></pre></td></tr></table></figure>
<p>其中 “origin_official” 为自定义官方源仓库在本地的远端别名， “<a href="https://oooooooooooooooooooooooooooooo.git&quot;/">https://oooooooooooooooooooooooooooooo.git&quot;</a> 为官方源仓库地址</p>
<h2 id="1-3-再次检查本地的远程信息"><a href="#1-3-再次检查本地的远程信息" class="headerlink" title="1.3. 再次检查本地的远程信息"></a>1.3. 再次检查本地的远程信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>此时查询本地Fork仓库应该有两个远端，一个Fork仓库远端和一个官方源仓库远端（共四行）eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin            ssh:&#x2F;&#x2F;git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git (fetch)</span><br><span class="line">origin            ssh:&#x2F;&#x2F;git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git (push)</span><br><span class="line">origin_official   https:&#x2F;&#x2F;oooooooooooooooooooooooooooooo.git(fetch)</span><br><span class="line">origin_official   https:&#x2F;&#x2F;oooooooooooooooooooooooooooooo.git(push)</span><br></pre></td></tr></table></figure>

<h1 id="2-步骤二、获取远程官方源仓库的更新内容"><a href="#2-步骤二、获取远程官方源仓库的更新内容" class="headerlink" title="2. 步骤二、获取远程官方源仓库的更新内容"></a>2. 步骤二、获取远程官方源仓库的更新内容</h1><h2 id="2-1-通过fetch命令获得一份官方源仓库的更新内容到本地Fork仓库"><a href="#2-1-通过fetch命令获得一份官方源仓库的更新内容到本地Fork仓库" class="headerlink" title="2.1. 通过fetch命令获得一份官方源仓库的更新内容到本地Fork仓库"></a>2.1. 通过fetch命令获得一份官方源仓库的更新内容到本地Fork仓库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin_official</span><br></pre></td></tr></table></figure>

<h2 id="2-2-检查并切换到想同步更新的分支-一般为master分支"><a href="#2-2-检查并切换到想同步更新的分支-一般为master分支" class="headerlink" title="2.2. 检查并切换到想同步更新的分支(一般为master分支)"></a>2.2. 检查并切换到想同步更新的分支(一般为master分支)</h2><h3 id="2-2-1-检查当前分支"><a href="#2-2-1-检查当前分支" class="headerlink" title="2.2.1. 检查当前分支"></a>2.2.1. 检查当前分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>一般此时查询结果为origin&#x2F;master分支（默认），其对应远端分支为Fork远端仓库的master分支。若当前本地Fork仓库有未提交的修改内容则需先推送修改内容到Fork仓库远端，否则可能为后面合并操作带来不必要的工作量。</p>
<h3 id="2-2-2-切换到非master分支（可选）"><a href="#2-2-2-切换到非master分支（可选）" class="headerlink" title="2.2.2. 切换到非master分支（可选）"></a>2.2.2. 切换到非master分支（可选）</h3><p>若待同步的源仓库更新内容不在master分支，则需手动切换到对应分支（如xxxxxx分支），否则可跳过此## 步骤。切换到待同步源仓库远端分支有更新内容对应的Fork仓库在本地仓库的分支（有点绕，如xxxxxx分支）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b xxxxxxFork origin&#x2F;master</span><br></pre></td></tr></table></figure>
<p>其中 “xxxxxxFork” 为自定义本地分支名，对应Fork仓库的xxxxxx分支， “origin” 对应Fork仓库远端别名</p>
<h1 id="3-步骤三、合并官方源仓库的更新内容到本地仓库"><a href="#3-步骤三、合并官方源仓库的更新内容到本地仓库" class="headerlink" title="3. 步骤三、合并官方源仓库的更新内容到本地仓库"></a>3. 步骤三、合并官方源仓库的更新内容到本地仓库</h1><p>合并官方源仓库的更新内容到本地仓库对应分支(一般为master分支)。如合并origin_official&#x2F;master的更新内容到本地Fork仓库的master分支（默认分支），若为其他分支则替换为对应分支便可（如：替换master为xxxxxx）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge origin_official&#x2F;master</span><br></pre></td></tr></table></figure>
<ul>
<li>若当前的本地仓库包含未提交的内容，则会提示合并失败，此时需要先推送本地修改内容到Fork仓库远端，再执行该合并操作。</li>
<li>若更新内容与本地仓库内容区别较大git合并时报冲突也会提示合并失败，处理冲突后便可完成合并</li>
</ul>
<h1 id="4-步骤四、推送本地代码到远端Fork仓库"><a href="#4-步骤四、推送本地代码到远端Fork仓库" class="headerlink" title="4. 步骤四、推送本地代码到远端Fork仓库"></a>4. 步骤四、推送本地代码到远端Fork仓库</h1><p>此时本地Fork仓库的master分支已包含官方源仓库master分支的更新内容，再执行push操作将这些更新内容推送到自己的远端Fork仓库即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>至此，已完成同步官方源仓库mater分支的所有更新到Fork仓库。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式语法记录</title>
    <url>/2021/10/22/RegularExpressionSyntax/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录常用正则表达式语法，以备不时之需</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 为非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">n 为非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o”</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">n 和 m 均为非负整数，且 n &lt;&#x3D; m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">当此字符紧随任何其他限定符（、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]“之类的模式</td>
</tr>
<tr>
<td align="left">(pattern)</td>
<td align="left">匹配 pattern 并捕获该匹配的子表达式。可以使用 0…0…9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，则需加反斜线”\(“, “\)”</td>
</tr>
<tr>
<td align="left">(?:pattern)</td>
<td align="left">匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (</td>
</tr>
<tr>
<td align="left">(?&#x3D;pattern)</td>
<td align="left">筛选符合 pattern 子表达式的匹配。例如，”win(?&#x3D;1)\d+” 能匹配 win10 和 win11，但排除了 win7,win8</td>
</tr>
<tr>
<td align="left">(?!pattern)</td>
<td align="left">排除符合 pattern 子表达式的匹配。例如，”win(?!1)\d+” 能匹配 win7 和 win8，但会排除 win10,win11</td>
</tr>
<tr>
<td align="left">[xyz]</td>
<td align="left">字符集。匹配包含的任一字符。例如，”[abc]“匹配”plain”中的”a”</td>
</tr>
<tr>
<td align="left">[^xyz]</td>
<td align="left">反向字符集。匹配未包含的任何字符。例如，”[^abc]“匹配”plain”中”p”，”l”，”i”，”n”</td>
</tr>
<tr>
<td align="left">[a-z]</td>
<td align="left">字符范围。匹配指定范围内的任何字符。例如，”[a-z]“匹配”a”到”z”范围内的任何小写字母</td>
</tr>
<tr>
<td align="left">[^a-z]</td>
<td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]“匹配任何不在”a”到”z”范围内的任何字符</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”</td>
</tr>
<tr>
<td align="left">\cx</td>
<td align="left">匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">数字字符匹配。等效于 [0-9]</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">非数字字符匹配。等效于 [^0-9]</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符匹配。等效于 \x0c 和 \cL</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符匹配。等效于 \x0a 和 \cJ</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等效于 \x0d 和 \cM</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符匹配。与 \x09 和 \cI 等效</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符匹配。与 \x0b 和 \cK 等效</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]“等效</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">与任何非单词字符匹配。与”[^A-Za-z0-9_]“等效</td>
</tr>
<tr>
<td align="left">\xn</td>
<td align="left">匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码</td>
</tr>
<tr>
<td align="left">\num</td>
<td align="left">匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码</td>
</tr>
<tr>
<td align="left">\nm</td>
<td align="left">标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)</td>
</tr>
<tr>
<td align="left">\nml</td>
<td align="left">当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml</td>
</tr>
<tr>
<td align="left">\un</td>
<td align="left">匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号</td>
</tr>
</tbody></table>
<p>备注：</p>
<ul>
<li>正则匹配中文文字：<code>[\u4e00-\u9fa5]</code></li>
<li>根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 “\b” 与单个退格字符匹配，而 “\b” 与单词边界匹配。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Common</tag>
      </tags>
  </entry>
  <entry>
    <title>资源池与线程池</title>
    <url>/2019/12/23/ResourcePoolAndThreadPool/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-资源池"><a href="#1-资源池" class="headerlink" title="1. 资源池"></a>1. 资源池</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h2><ul>
<li>是一种配置机制，用于对主机资源进行分区。当某一个资源使用完后，资源池把相关的资源的忙标示清除掉，以示该资源可以再被下一个请求使用</li>
<li>每个主机均具有一个默认的资源池，所有的进程最初均与该资源池绑定。新创建的资源池会从默认池中获取处理器</li>
</ul>
<a id="more"></a>

<h2 id="1-2-目的"><a href="#1-2-目的" class="headerlink" title="1.2. 目的"></a>1.2. 目的</h2><p>提高性能</p>
<h2 id="1-3-运作机制"><a href="#1-3-运作机制" class="headerlink" title="1.3. 运作机制"></a>1.3. 运作机制</h2><p>由资源池管理器提供一定数目的目标资源，当有请求该资源时，资源池分配给一个，然后给该资源标识为忙，标示为忙的资源不能再被分配使用</p>
<h2 id="1-4-参数"><a href="#1-4-参数" class="headerlink" title="1.4. 参数"></a>1.4. 参数</h2><ul>
<li>初始资源的数目。资源池启动时，一次建立的资源数目，资源池最少要保证在这个数目上</li>
<li>最大资源的数目。当请求的资源超出这个数目，就等待</li>
</ul>
<h2 id="1-5-常见的资源池"><a href="#1-5-常见的资源池" class="headerlink" title="1.5. 常见的资源池"></a>1.5. 常见的资源池</h2><ul>
<li>连接池。数据库连接池</li>
<li>对象池。web 容器中的 request, response 对象池</li>
<li>线程池（thread pool）</li>
</ul>
<h1 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h1><h2 id="2-1-背景"><a href="#2-1-背景" class="headerlink" title="2.1. 背景"></a>2.1. 背景</h2><ul>
<li>线程过多会带来调度开销（线程切换开销），进而影响缓存局部性和整体性能</li>
<li>在处理短时间任务时创建与销毁线程的代价过大</li>
</ul>
<h2 id="2-2-简介"><a href="#2-2-简介" class="headerlink" title="2.2. 简介"></a>2.2. 简介</h2><ul>
<li>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务</li>
<li>线程池线程都是后台线程</li>
<li>每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中</li>
<li>如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙</li>
<li>如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程，但线程的数目永远不会超过最大值</li>
<li>超过最大值的线程可以排队，但他们要等到其他线程完成后才启动</li>
</ul>
<h2 id="2-3-优点"><a href="#2-3-优点" class="headerlink" title="2.3. 优点"></a>2.3. 优点</h2><ul>
<li>避免在处理短时间任务时创建与销毁线程的代价</li>
<li>不仅能够保证内核的充分利用，还能防止过分调度</li>
</ul>
<h2 id="2-4-线程池结构"><a href="#2-4-线程池结构" class="headerlink" title="2.4. 线程池结构"></a>2.4. 线程池结构</h2><ul>
<li>线程池管理器。创建并管理线程池</li>
<li>工作线程。线程池中的线程</li>
<li>任务接口 taskHandle。每个任务必须实现接口以供工作线程调度执行任务</li>
<li>任务队列。用于暂存未处理任务（缓冲机制）</li>
</ul>
<h2 id="2-5-应用场景"><a href="#2-5-应用场景" class="headerlink" title="2.5. 应用场景"></a>2.5. 应用场景</h2><ul>
<li>需要大量的线程来完成任务，且完成任务的时间比较短。 eg. WEB 服务器完成网页请求这样的任务</li>
<li>对性能要求苛刻的应用。eg。 要求服务器迅速响应客户请求</li>
<li>可能出现突发性的大量请求（创建大量线程）。eg. 双 11，0:00 网页请求。利用线程池技术有效地调度线程资源，缓冲作用不至于使服务器突然产生大量线程的应用。短时间内产生大量线程可能使内存到达极限，并出现”OutOfMemory”的错误</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Common</tag>
      </tags>
  </entry>
  <entry>
    <title>开源白盒交换机系统 SONiC 简介</title>
    <url>/2021/09/12/SONIC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/SONICArchitecture.png" class="full-image" />

<a id="more"></a>

<h1 id="1-发展历程"><a href="#1-发展历程" class="headerlink" title="1. 发展历程"></a>1. 发展历程</h1><ul>
<li><b><font color="red" style="">2016 年</font></b>的 OCP 峰会上，由<b><font color="red" style="">微软</font></b>发布（基于** Debian** GNU&#x2F;Linux）</li>
<li>目标：完善<strong>白盒交换机</strong>生态链</li>
<li>2017 “凤凰项目”，推动“<strong>白盒+开源 OS</strong>”的网络生态发展，促进国内开放网络和 SDN 网络的进步。由阿里巴巴、腾讯、<strong>百度</strong>、京东、中国移动和中国联通共同参与的“凤凰项目”成立，<br>项目以** SONiC 开源社区<strong>为依托，选取社区稳定的 SONiC 版本软件，并将</strong> Base OS、SAI、平台驱动<strong>等共同打包制作成可直接加载运行在白盒交换机的</strong>网络 OS 映像文件<strong>，即</strong>凤凰发行版**。<br>其中各公司项目分工如下：阿里巴巴主要负责社区软件评估及发行版制作；腾讯主要负责发行版软硬件兼容性；百度主要负责运维管理体系；中国信息通信研究院主要完成测试验证工作。</li>
<li>2017 年微软对 SONiC 的<strong>性能</strong>进行了大幅升级，全面支持 IDV，并且融合了更多的<strong>容器特性</strong>。</li>
<li>2018 年微软又在<strong>管理性</strong>上下了大力气（如 ConfigDB），让使用者用起来更加从容。</li>
<li>此后，SONiC 又在<strong>深度学习</strong>等** AI 特性**上做了更多的尝试。</li>
</ul>
<h1 id="2-诞生基础——SAI"><a href="#2-诞生基础——SAI" class="headerlink" title="2. 诞生基础——SAI"></a>2. 诞生基础——SAI</h1><ul>
<li>交换机抽象端口（Switch Abstraction Interface，SAI）。在没有 SAI 之前所有芯片都要<strong>通过自己的 SDK 与上层的软件通信</strong>（相当于用芯片自己的“<strong>方言</strong>”跟上层的操作系统通信），<br>SAI 把这类“方言”<strong>标准化</strong>，大家的芯片用“<strong>标准化的语言</strong>”与上层的控制软件通信。</li>
<li>正因为有了 SAI，所以才能建立一个操作系统（通过统一 API 与各交换机各组件通信）。有了 SAI 之后，适配 ASIC 的工作就由芯片厂商完成。</li>
<li>SAI 本身没有完全开源，不过其却为 SONiC 提供了统一的 API，通过该统一的 API 可以向下对接不同的 ASIC（Application Specific Integrated Circuit，集成电路）。</li>
</ul>
<h1 id="3-功能-amp-特性"><a href="#3-功能-amp-特性" class="headerlink" title="3. 功能&amp;特性"></a>3. 功能&amp;特性</h1><ul>
<li>实现了数据<strong>控制面</strong>与<strong>转发面</strong>的分离</li>
<li>可以直接管理交换机状态</li>
<li>能够更快的调试、修复并测试软件</li>
<li>通过 <strong>改变软件策略和拓扑</strong> 实现 <strong>新的网络架构</strong>，让网络实践更为灵活</li>
<li>SONiC 的网络应用都是基于容器构建的，可以非常方便的在生产环境实现 <strong>不停机部署或升级</strong> 应用</li>
</ul>
<h1 id="4-独特优势"><a href="#4-独特优势" class="headerlink" title="4. 独特优势"></a>4. 独特优势</h1><ul>
<li>提供了将传统交换机 OS 拆分成多个容器化组件的解决方案</li>
<li>进而也定义了<strong>控制面的容器化架构</strong>，囊括了诸多组件和编程端口</li>
</ul>
<h1 id="5-SONiC-系统架构"><a href="#5-SONiC-系统架构" class="headerlink" title="5. SONiC 系统架构"></a>5. SONiC 系统架构</h1><p>SONiC 采用模块化体系结构，将每个模块放在独立的 <strong>Docker 容器</strong>中。其在保持组件之间的<strong>高内聚性</strong>的同时<strong>减少</strong>组件之间的<strong>耦合</strong>。<br>其主要组件包括：DHCP-Relay、Pmon、Snmp、LLDP、BGP、Teamd、Database、Swss、Syncd。其系统架构如下图所示。</p>
<img data-src="../../../../uploads/SONICArchitecture.png" class="full-image" />

<h1 id="6-SONiC-中各容器功能简介"><a href="#6-SONiC-中各容器功能简介" class="headerlink" title="6. SONiC 中各容器功能简介"></a>6. SONiC 中各容器功能简介</h1><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th></th>
        <th align="center"><b>容器名</b></th>
        <th align="center"><b>功能</b></th>
    </tr>
    <tr>
        <td align="center">1</td>
        <td align="center">Teamd</td>
        <td>负责实现链路聚合组 (Link Aggregation Group，LAG) 功能</td>
    </tr>
    <tr>
        <td align="center">2</td>
        <td align="center">Pmon</td>
        <td>负责监听“传感器”状态，在紧急状态时告警</td>
    </tr>
    <tr>
        <td align="center">3</td>
        <td align="center">Snmp</td>
        <td>负责实现简单网络管理协议（Simple Network Management Protocol，SNMP）功能，以支持远程管理网络</td>
    </tr>
    <tr>
        <td align="center">4</td>
        <td align="center">DHCP-Relay</td>
        <td>负责实现 DHCP 中继代理功能</td>
    </tr>
    <tr>
        <td align="center">5</td>
        <td align="center">LLDP</td>
        <td>负责实现链路层发现协议（Link Layer Discovery Protocol，LLDP）功能</td>
    </tr>
    <tr>
        <td align="center">6</td>
        <td align="center">BGP</td>
        <td>负责实现边界网关协议（Border Gateway Protocol，BGP）功能</td>
    </tr>
    <tr>
        <td align="center">7</td>
        <td align="center">Database</td>
        <td>承载 Redis 数据库引擎，以供 SONiC 应用程序访问数据</td>
    </tr>
    <tr>
        <td align="center">8</td>
        <td align="center">Swss</td>
        <td>负责交换状态服务（SWitch State Service，SWSS）功能，提供与网络应用程序和网络交换硬件<br>进行通信的数据库接口，以及提供呈现状态的服务。</td>
    </tr>
    <tr>
        <td align="center">9</td>
        <td align="center">Syncd</td>
        <td>提供支持交换机的<b>网络状态</b>与<b>实际硬件/ASIC 同步</b>的机制，包括端口的初始化、配置和 ASIC 电流状态的收集等。</td>
    </tr>
</table>

<h2 id="6-1-Teamd-container"><a href="#6-1-Teamd-container" class="headerlink" title="6.1. Teamd container"></a>6.1. Teamd container</h2><p>在 SONiC 设备中运行链路聚合功能 (LAG)。</p>
<ul>
<li><p><strong>teamd</strong>：负责基于 Linux 的 LAG 协议的开源实现。</p>
</li>
<li><p><strong>teamsyncd</strong>：进程支撑“teamd”与南部子系统之间相互作用。</p>
</li>
</ul>
<h2 id="6-2-Pmon-container"><a href="#6-2-Pmon-container" class="headerlink" title="6.2. Pmon container"></a>6.2. Pmon container</h2><p>这是一个<strong>守护进程</strong>，负责监听“传感器”状态，包括定期记录硬件组件的传感器读数，并在高危情景下发出告警信号。</p>
<ul>
<li><strong>fancontrol</strong>: 对风扇进行控制</li>
<li><strong>sensord</strong>：负责监听各传感器的状态</li>
</ul>
<h2 id="6-3-Snmp-container"><a href="#6-3-Snmp-container" class="headerlink" title="6.3. Snmp container"></a>6.3. Snmp container</h2><p>主要负责实现简单网络管理协议（Simple Network Management Protocol，SNMP），以远程管理网络。这个容器中有两个相关的进程，snmpd 和 snmp-agent (sonic_ax_impl)。</p>
<ul>
<li><strong>snmpd</strong>：负责处理来自外部网络的 <strong>snmp 轮询</strong>。</li>
<li><strong>snmp-agent</strong>：是 SONiC 对可扩展代理协议 (Agent Extensibility，AgentX) 的实现。这个子代理向主代理 (snmpd) 提供 Redis 引擎 SONiC 数据库中汇聚后的信息。</li>
</ul>
<h2 id="6-4-Dhcp-relay-container"><a href="#6-4-Dhcp-relay-container" class="headerlink" title="6.4. Dhcp-relay container"></a>6.4. Dhcp-relay container</h2><p>负责实现 DHCP 中继代理功能。DHCP 中继代理可实现在不同子网和物理网段之间处理和转发 DHCP 信息的功能。</p>
<ul>
<li><strong>dhcprelay</strong>：实现 DHCP 中继代理功能</li>
</ul>
<h2 id="6-5-LLDP-container"><a href="#6-5-LLDP-container" class="headerlink" title="6.5. LLDP container"></a>6.5. LLDP container</h2><p>负责实现链路层发现协议（Link Layer Discovery Protocol，LLDP）功能。该容器提供 hosts lldp 链路层发现协议功能，其主要包含三个相关进程：</p>
<ul>
<li><strong>lldp</strong>：具有链路层发现功能的实际 LLDP 守护进程。负责与外部对等点建立 LLDP 连接，以接收或发布系统功能</li>
<li><strong>lldp_syncd</strong>：负责<strong>上传</strong> LLDP 发现的结果到集中式系统消息组件 (Redis-engine)。以便于其他组件（如：snmp）消费此 LLDP 状态信息。</li>
<li><strong>lldpmgrd</strong>：负责为 LLDP 守护进程提供<strong>增量配置</strong>功能。该容器通过订阅 Redis-engine 中的 STATE_DB 表来实现这一功能。</li>
</ul>
<h2 id="6-6-BGP-container"><a href="#6-6-BGP-container" class="headerlink" title="6.6. BGP container"></a>6.6. BGP container</h2><p>负责实现边界网关协议（Border Gateway Protocol，BGP）功能。BGP 协议是一种实现自治系统（Autonomous System，AS）之间的路由可达，并<strong>选择最佳路由</strong>的距离矢量路由协议。运行支持的路由堆栈的 Quagga（路由软件工具）或 FRR（IP 快速重路由技术，Fast ReRoute）。尽管该容器是以 BGP 命名的，但实际上，这些路由协议栈还可以运行各种其他协议，如：OSPF、ISIS、LDP 等。容器主要包含三个进程：</p>
<ul>
<li><strong>bgpd</strong>：负责<strong>边界网关协议</strong>功能的实现。通过 TCP&#x2F;UDP 套接字接收来自外部各方的路由状态，并通过 zebra&#x2F;fpmsyncd 端口下放到转发平面。</li>
<li><strong>zebra</strong>：充当传统的 IP <strong>路由管理器</strong>，负责跨不同协议提供内核路由表更新、端口查找和路由重分发服务。Zebra 还负责将计算出的转发信息库（Forwarding Information Base，FIB）推送到<strong>内核</strong>（通过进程间通信接口 Netlink）和（转发过程中所涉及的）<strong>南向组件</strong>（通过转发平面管理器 Forwarding Plane Manager，FPM 端口）。</li>
<li><strong>fpmsyncd</strong>：小型<strong>守护进程</strong>，负责收集 Zebra 生成的 FIB 状态，并将其内容转储到 Redis 引擎中的应用表 (APPL_DB)。</li>
</ul>
<h2 id="6-7-Database-container"><a href="#6-7-Database-container" class="headerlink" title="6.7. Database container"></a>6.7. Database container</h2><p>承载 Redis 数据库引擎，此引擎中保存的数据库可供 SONiC 应用程序<b>通过由 Redis-daemon 公开的 UNIX 套接字接口</b>访问。SONIC 中包含五个主要的数据库 DB：</p>
<ol>
<li><font color="red">APPL_DB</font>： 存储所有应用程序容器<b>生成的状态</b>，包括：路由、下一跳、邻居等。这是与 SONiC 其他子系统交互的应用程序南方入口点。</li>
<li><b><font color="red">CONFIG_DB</font></b>： 存储由 SONiC 应用程序创建的 <b>配置状态</b> ，如：端口配置、VLAN 等。</li>
<li><font color="red">STATE_DB</font>： STATE_DB 存储了<b>跨模块依赖所必需的所有状态</b>，以用于解决 SONiC 不同子系统之间的 <b>依赖关系</b>。如：LAG 端口通道（由 teamd 子模块定义的）可引用系统中可能存在&#x2F;不存在的物理端口。另一个例子是 VLAN 的定义（通过 vlanmgrd 组件） ，它可以引用在系统中存在不确定的端口成员。</li>
<li><b><font color="red">ASIC_DB</font></b>： 存储驱动特殊应用集成电路（Application Specific　Integrated Circuit，ASIC）的<b>配置和操作所需的状态</b>。这里的状态以 ASIC 友好的格式保存，以便于 Syncd 和 ASIC SDK 之间的交互。</li>
<li><font color="red">COUNTERS_DB</font>： 存储系统中每个端口相关联的<b>计数器&#x2F;统计</b>信息。该信息可用于响应 CLI 的本地请求（查询统计信息）或用于为远程遥测提供信息。</li>
</ol>
<p>SONiC 各<strong>容器</strong>与<strong>各 Redis 表</strong>间数据流交互关系如下图所示（详细交互流程可参见：<a href="https://github.com/Azure/SONiC/wiki/Architecture">SONiC Architecture</a>）：</p>
<img data-src="../../../../uploads/DataflowBetweenSONICContainerAndRedisTable.png" class="full-image" />

<h2 id="6-8-Swss-container"><a href="#6-8-Swss-container" class="headerlink" title="6.8. Swss container"></a>6.8. Swss container</h2><p>负责交换状态服务（SWitch State Service，SWSS）功能，提供与网络应用程序和网络交换硬件进行通信的数据库接口，以及提供呈现状态的服务。该容器通过一组工具使得 SONiC 所有模块之间能够有效的通信，Swss 容器主要负责：提供了促进所有不同模块之间的<strong>通信</strong>的机制、承载了负责与 SONiC 应用层北向相互作用的进程、提供了允许 SONiC 应用程序和 SONiC 集中消息基础结构 (Redis-engine) 之间连接的方法。该容器主要包含三个<strong>状态生成</strong>进程和三个<strong>状态分发</strong>进程。</p>
<p>三个<strong>状态生成进程</strong>：</p>
<ul>
<li><strong>portsyncd</strong>：侦听与端口相关的网络链接事件。在启动过程中，portsyncd 通过解析系统的硬件配置文件获取物理端口信息。<strong>portsyncd</strong> 最终将所有收集到的状态推送到 APPL_DB 中，如：端口速度、通道和 MTU 等属性。</li>
<li><strong>Intfsyncd</strong>：侦听与端口相关的网络链接事件，并将收集的状态 <strong>推送到 APPL_DB</strong> 中。如与端口关联的属性：新增&#x2F;更改的 IP 地址。</li>
<li><strong>Neighsyncd</strong>：监听（由于 ARP 处理而被新发现的邻居触发的）与邻居相关的网络链接事件，如：MAC 地址和邻居的 Address-family 等属性的处理。这种状态最终将被用于构建 L2 时，重写所需的数据平面中的邻接表，并且所有收集到的状态最终都将被传输到 APPL_DB。</li>
</ul>
<p>三个<strong>状态分发进程</strong>：</p>
<ul>
<li><strong>Orchagent</strong>：作为 Swss 容器中最关键的组成部分，Orchagent 进程负责逻辑提取由 *syncd 守护进程输入的相关状态（APPL_DB）、相应地处理和发送这些信息、并最终将其推送到其南向端口（ASIC_DB）。由此可知，Orchagent 既作为消费者（消费来自 APPL_DB 的状态），又作为生产者（将状态写入 ASIC_DB）。</li>
<li><strong>IntfMgrd</strong>：响应来自 APPL_DB、CONFIG_DB 和 STATE_DB 的状态，以在 Linux 内核中配置<strong>端口</strong>。（此步骤只有在所监听的所有数据库中没有冲突或不一致的状态时进行）</li>
<li><strong>VlanMgrd</strong>：响应来自 APPL_DB、CONFIG_DB 和 STATE_DB 的状态，以在 Linux 内核中配置** vlan-interfaces**。（只有在的依赖状态&#x2F;条件全部满足时，才尝试执行此步骤）</li>
</ul>
<h2 id="6-9-Syncd-container"><a href="#6-9-Syncd-container" class="headerlink" title="6.9. Syncd container"></a>6.9. Syncd container</h2><p>提供一种允许交换机的<strong>网络状态</strong>与交换机的<strong>实际硬件</strong>&#x2F;ASIC <strong>同步</strong>的机制，包括端口的初始化、配置和 ASIC 电流状态的收集等。其主要包含三个主要逻辑组件：</p>
<ul>
<li><strong>Syncd</strong>：负责执行上面提到的同步逻辑的进程。在编译时与硬件供应商提供的 ASIC SDK 库进行同步链接，并通过调用 SDK 提供的端口将状态写入 ASIC。Syncd 既通过订阅 ASIC_DB 以接收来自 SWss 的状态，又作为发布者来上传硬件的状态。</li>
<li><strong>SAI API</strong>：交换机抽象端口定义的 API，提供一种独立于供应商的控制&#x2F;转发接口，即交换 ASIC、NPU 或软件交换机的统一调用接口。</li>
<li><strong>ASIC SDK</strong>：硬件供应商预计将提供一个用于驱动其 ASIC 的、支持系统架构演进（System Architecture Evolution，SAE）的 SDK。此 SDK 通常以动态链接库的形式提供，负责驱动其执行的驱动进程。</li>
</ul>
<h1 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h1><ul>
<li><a href="https://github.com/azure/sonic/wiki">SONiC 社区 WiKi</a></li>
<li><a href="https://github.com/Azure/SONiC/blob/master/doc/SONiC-User-Manual.md">SONiC 用户手册</a></li>
<li><a href="https://github.com/Azure/sonic-utilities/blob/master/doc/Command-Reference.md">SONiC 命令行参考</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SONiC</tag>
      </tags>
  </entry>
  <entry>
    <title>七次省视自己的灵魂--卡里·纪伯伦</title>
    <url>/2017/03/21/Save-your-soul-seven-times/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/Save-your-soul-seven-times.jpg" class="full-image" />

<p>发现自己的缺点并直视才是真的勇士。我曾七次鄙视自己的灵魂：</p>
<a id="more"></a>

<blockquote class="blockquote-center">
<p><strong>第一次</strong>，当它本可进取时，却故作谦卑<br><strong>第二次</strong>，当它在空虚时，用爱欲来填充<br><strong>第三次</strong>，在困难和容易之间，它选择了容易<br><strong>第四次</strong>，它犯了错，却借由别人也会犯错来宽慰自己<br><strong>第五次</strong>，它自由软弱，却把它认为是生命的坚韧<br><strong>第六次</strong>，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副<br><strong>第七次</strong>，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾</p>
<div align = right>--卡里·纪伯伦</div>
</blockquote>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>人生观触动</tag>
      </tags>
  </entry>
  <entry>
    <title>成长规划</title>
    <url>/2019/11/04/SelfgrowthPlanning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/SelfgrowthPlanning.jpg" class="full-image" />

<p>总结 Bilibili Up主 zettaranc 不断践行并获取成功的四点方法论：年轻人如何赚到自己的第一桶金，乍一看虽会觉得老生常谈，但粗略考虑却也是符合无数名人的成功和发展的大体趋势，而且zettaranc结合自身诸多“小目标”的成功实践也颇具说服力。践行强于妄想，不断培养自我成长的“内驱力”，记录以自勉👊</p>
<a id="more"></a>

<blockquote class="blockquote-center">
<p>心中醒，口中说，纸上作，不从身上习过，皆无用也。<br>– by 颜元</p>

</blockquote>

<h1 id="1-找到你最想干的事"><a href="#1-找到你最想干的事" class="headerlink" title="1. 找到你最想干的事"></a>1. 找到你最想干的事</h1><ul>
<li>不要企图用理想让这个世界上有谁理解你，你只有用做到后的事实让大家认可你！</li>
<li>越年轻，失败的成本越低，所以趁还年轻勇于尝试</li>
<li>一个人老后不会伤心曾经做过什么，因为已成既定事实，而是懊悔没有做过什么</li>
</ul>
<h1 id="2-找到擅长的领域，成长为专家"><a href="#2-找到擅长的领域，成长为专家" class="headerlink" title="2. 找到擅长的领域，成长为专家"></a>2. 找到擅长的领域，成长为专家</h1><ul>
<li>比别人思考更多的专业问题，学习更多的专业知识，投入更多的时间精力。因为必须至少成为某个领域额的专家，你才有资格在这个领域混口饭吃。</li>
</ul>
<h1 id="3-主动尝试，主动出击"><a href="#3-主动尝试，主动出击" class="headerlink" title="3. 主动尝试，主动出击"></a>3. 主动尝试，主动出击</h1><ul>
<li>这个世界人太多了，想要赚取“超额收益”比你想象中更难，总有人比你离机会更近，总有人比你想进入的领域钻研的时间更长，你只有巩固第一二项，不断的投入更多的时间于精力，才可能有更大概率获取期待的“超额收益”，否则仍难突破大众平庸。</li>
</ul>
<h1 id="4-想象力的正向循环激励"><a href="#4-想象力的正向循环激励" class="headerlink" title="4. 想象力的正向循环激励"></a>4. 想象力的正向循环激励</h1><ul>
<li>在前三项实践过程中，总会有各种挑战阻碍你，总会有各种诱惑纷扰你，总会有各种质疑诋毁你，让成功的憧憬成为你的正向循环自驱力。</li>
<li>注意区别幻想与想象力，前者是没有事实根据的，是虚无的，后者是建立在一步步阶段小目标实现后对未来几步的远瞻和预估。</li>
</ul>
<h1 id="5-zettaranc分享方法论的视频"><a href="#5-zettaranc分享方法论的视频" class="headerlink" title="5. zettaranc分享方法论的视频"></a>5. zettaranc分享方法论的视频</h1><iframe src="//player.bilibili.com/player.html?aid=61773370&cid=107417443&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>自驱</tag>
      </tags>
  </entry>
  <entry>
    <title>对于阶级固化下人生追求的思考</title>
    <url>/2017/11/12/Social-stratification-and-personal-life-goals/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/Social-stratification-and-personal-life-goals.jpg" class="full-image" />

<h1 id="1-《北京的无奈》引发的思考"><a href="#1-《北京的无奈》引发的思考" class="headerlink" title="1. 《北京的无奈》引发的思考"></a>1. 《北京的无奈》引发的思考</h1><p>《北京的无奈：海淀区拼娃是怎么拼的》——一篇字字扎心却又让你醍醐灌顶的文章。就连被广泛认同公平圣洁的教育，在精英家庭氛围、文化底蕴潜移默化的影响、优质且稀缺教育资源的倾斜等作用下还会公平么？</p>
<a id="more"></a>

<p>在看过余秀兰的文章《底层放弃教育，中产过度焦虑，上层不玩高考》后认识更为深刻，文中概述了诸多原因导致底层人们向上流动受阻，对教育绝望，而中产和上层阶层的家庭对教育的追逐却愈发疯狂。在这个连教育都要拼爹的时代，已无公平可言，但我们却不得不面对这残酷的现实和冰凉的<strong>马太效应</strong>——强者愈强，弱者愈弱，或许成功真的不是一代人的积累。</p>
<h1 id="2-社会即将分层，阶层正在固化，而你，能成为英雄吗？"><a href="#2-社会即将分层，阶层正在固化，而你，能成为英雄吗？" class="headerlink" title="2. 社会即将分层，阶层正在固化，而你，能成为英雄吗？"></a>2. 社会即将分层，阶层正在固化，而你，能成为英雄吗？</h1><p>世界上永远存在这样一类人，<strong>他能够超越自己的家庭、血缘、环境，他能够挣脱时代对他的束缚，让世界另眼相看</strong>，这一类人被称为<strong>英雄</strong>。</p>
<p>那么问题来了：</p>
<blockquote>
<p><strong>社会即将分层，阶层正在固化，而你，能成为英雄吗？</strong></p>
</blockquote>
<p>当前社会并未发展到，某网友看过《北京折叠》后慨叹“<strong>社会正在撕裂，阶层正在固化！这个社会上，绝大多数的人，刚一出生，就已经输了</strong>”那么极端的程度，我<strong>仍然相信机会永远都存在</strong>。与其无奈地吐槽“读书改变命运”在当下如何变味、仇视各种“二代”、万念俱灰地被生活压迫最终向宿命论妥协，不妨沉心静气地思考一下，<strong>在当下阶层逐渐固化的背景下，你除了努力还能拼什么？你有什么理由放弃努力？</strong></p>
<p>逆袭之路漫漫其修远兮，骚年要向屈公“上下求索”看齐，打破马太效应桎梏，<strong>但求精进</strong>！</p>
<h1 id="3-人生目标的思考"><a href="#3-人生目标的思考" class="headerlink" title="3. 人生目标的思考"></a>3. 人生目标的思考</h1><ul>
<li><strong>打破现有家庭环境，文化背景，思想瓶颈的束缚</strong></li>
<li><strong>不断地修正自己的人生最高目标，以使自己能够长期地、持续地获得内心最有意义的感受</strong></li>
<li><strong>追求更精致的生活，更深度的价值观念，更高的生命质量</strong></li>
</ul>
<p>望与君共勉！</p>
<h1 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h1><ul>
<li>《<a href="http://www.360doc.cn/mip/571643947.html">北京的无奈：海淀区拼娃是怎么拼的</a>》</li>
<li>《<a href="http://wemedia.ifeng.com/62150036/wemedia.shtml">余秀兰：底层放弃教育，中产过度焦虑，上层不玩高考</a>》</li>
</ul>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>人生观触动</tag>
      </tags>
  </entry>
  <entry>
    <title>经典排序算法的C++编码实现与性能对比</title>
    <url>/2019/11/17/SortFuncCompare/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/SortFuncComparePicture.png" class="full-image" />

<p>排序作为常用的解决实际问题的计算方法，被广泛应用于生活中的方方面面。而处理实际问题的数据规模常常十分庞大，同一个计算任务选用不同的算法，其执行效率可能相差几百倍，几千倍甚至更高，因此效率常被作入为评判一个算法优劣的重要指标。<br>博主对七种常见的排序算法进行编码实现，和以处理同规模数据所耗时长为指标进行了性能比较（冒泡、选择、插入、希尔、堆、归并和快排）。</p>
<a id="more"></a>

<h1 id="1-测试排序函数运行时间方法"><a href="#1-测试排序函数运行时间方法" class="headerlink" title="1. 测试排序函数运行时间方法"></a>1. 测试排序函数运行时间方法</h1><p>运行排序算法前后打点，取前后两次打点的差值，再除以打点的频率得到函数的运行时长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试排序函数运行时间</span></span><br><span class="line"><span class="comment"> * @param pFunction 排序函数的函数指针</span></span><br><span class="line"><span class="comment"> * @Return 运行时长（秒）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">SortFuncCompare::testRunTime</span><span class="params">(<span class="keyword">void</span> (*pFunction)(ElementType *))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, stop;</span><br><span class="line">    <span class="keyword">double</span> runTime;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    (*pFunction)(m_array);</span><br><span class="line">    stop = <span class="built_in">clock</span>();</span><br><span class="line">    runTime = ((<span class="keyword">double</span>)stop - (<span class="keyword">double</span>)start) / CLOCKS_PER_SEC;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;run time = &quot; &lt;&lt; runTime &lt;&lt; &quot; s&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> runTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-测试函数"><a href="#2-测试函数" class="headerlink" title="2. 测试函数"></a>2. 测试函数</h1><p>定义排序函数的函数指针数组，size为7，逐一将七种static函数地址赋值到函数指针数组，然后循环执行七种函数对相同规模的随机数组的排序操作，便可得到各排序算法在各规模数据下的运行时长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*func[NUM_OF_SORT_FUNC])(ElementType*);<span class="comment">// 定义函数指针数组</span></span><br><span class="line">func[<span class="number">0</span>] = Bubble_Sort;      <span class="comment">// 1.冒泡排序</span></span><br><span class="line">func[<span class="number">1</span>] = Selection_Sort;   <span class="comment">// 2.选择排序</span></span><br><span class="line">func[<span class="number">2</span>] = Insertion_Sort;   <span class="comment">// 3.插入排序</span></span><br><span class="line">func[<span class="number">3</span>] = Shell_Sort;       <span class="comment">// 4.希尔排序</span></span><br><span class="line">func[<span class="number">4</span>] = Heap_Sort;        <span class="comment">// 5.堆排序</span></span><br><span class="line">func[<span class="number">5</span>] = Merge_Sort;       <span class="comment">// 6.归并排序</span></span><br><span class="line">func[<span class="number">6</span>] = Quick_Sort;       <span class="comment">// 7.快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::testFuncRuntime</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> *runTime = <span class="keyword">new</span> <span class="keyword">double</span>[NUM_OF_SORT_FUNC];<span class="comment">// Record the running time</span></span><br><span class="line">    <span class="comment">// Size of random array:10 ～ 100,000</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> size = MIN_NUM_OF_RAND_ARRAY; size &lt;= MAX_NUM_OF_RAND_ARRAY; size *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_SORT_FUNC; ++i) &#123;</span><br><span class="line">            <span class="comment">// Generate a random array</span></span><br><span class="line">            <span class="built_in">refreshArray</span>(size);</span><br><span class="line">            <span class="comment">// Execute and record the running time</span></span><br><span class="line">            *(runTime + i) = <span class="built_in">testRunTime</span>(func[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Output time consuming</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Num of Array = &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;\t: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_OF_SORT_FUNC - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; *(runTime + j) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; *(runTime + NUM_OF_SORT_FUNC - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] runTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-七种经典排序算法的C-编码实现"><a href="#3-七种经典排序算法的C-编码实现" class="headerlink" title="3. 七种经典排序算法的C++编码实现"></a>3. 七种经典排序算法的C++编码实现</h1><h2 id="3-1-冒泡排序"><a href="#3-1-冒泡排序" class="headerlink" title="3.1. 冒泡排序"></a>3.1. 冒泡排序</h2><p>时间复杂度:O(N^2)，空间复杂度:O(1)，原地，稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Bubble_Sort</span><span class="params">(ElementType* pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Bubble Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">bool</span> swapFlag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m_uiSizeOfArray - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        swapFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(pArray + j) COMPARE *(pArray + j + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="built_in">swapTwoNum</span>(pArray + j, pArray + j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!swapFlag)</span><br><span class="line">                    swapFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!swapFlag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-选择排序"><a href="#3-2-选择排序" class="headerlink" title="3.2. 选择排序"></a>3.2. 选择排序</h2><p>时间复杂度:O(N^2)，空间复杂度:O(1)，原地，稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Selection_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Selection Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_uiSizeOfArray - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m_uiSizeOfArray; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(pArray + i) COMPARE *(pArray + j))</span><br><span class="line">                <span class="built_in">swapTwoNum</span>(pArray + i, pArray + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-插入排序"><a href="#3-3-插入排序" class="headerlink" title="3.3. 插入排序"></a>3.3. 插入排序</h2><p>时间复杂度:O(N^2)，空间复杂度:O(1)，原地，稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Insertion_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Insert Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m_uiSizeOfArray; ++i) &#123;</span><br><span class="line">        tmp = *(pArray + i);</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; *(pArray + j - <span class="number">1</span>) COMPARE tmp; --j) &#123;</span><br><span class="line">            *(pArray + j) = *(pArray + j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(pArray + j) = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-希尔排序"><a href="#3-4-希尔排序" class="headerlink" title="3.4. 希尔排序"></a>3.4. 希尔排序</h2><p>时间复杂度:O(N^1.25 ～N^1.5)，空间复杂度:O(1)，原地，非稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Shell_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Shell Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> D = m_uiSizeOfArray / <span class="number">2</span>; D &gt; <span class="number">0</span>; D /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// like Insert sort whose step is D</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = D; i &lt; m_uiSizeOfArray; ++i) &#123;</span><br><span class="line">            tmp = *(pArray + i);</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= D &amp;&amp; *(pArray + j - D) COMPARE tmp; j -= D) &#123;</span><br><span class="line">                *(pArray + j) = *(pArray + j - D);</span><br><span class="line">            &#125;</span><br><span class="line">            *(pArray + j) = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-堆排序"><a href="#3-5-堆排序" class="headerlink" title="3.5. 堆排序"></a>3.5. 堆排序</h2><p>时间复杂度:O(NlogN)，空间复杂度:O(1)，原地，非稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Heap_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Heap Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// build big root heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m_uiSizeOfArray / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">heapDown</span>(pArray, i, m_uiSizeOfArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// choose biggest to end--</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m_uiSizeOfArray - <span class="number">1</span>; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">swapTwoNum</span>(pArray, pArray + j);</span><br><span class="line">        <span class="built_in">heapDown</span>(pArray, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::heapDown</span><span class="params">(ElementType *pArray, <span class="keyword">int</span> fatherIndex, <span class="keyword">int</span> maxIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sonIndex = <span class="number">2</span> * fatherIndex + <span class="number">1</span>;<span class="comment">// default left son</span></span><br><span class="line">    <span class="keyword">if</span> (sonIndex &lt; maxIndex) &#123;</span><br><span class="line">        <span class="comment">// choose the bigger son</span></span><br><span class="line">        <span class="keyword">if</span> (sonIndex + <span class="number">1</span> &lt; maxIndex &amp;&amp; *(pArray + sonIndex + <span class="number">1</span>) COMPARE *(pArray + sonIndex))</span><br><span class="line">            ++sonIndex;</span><br><span class="line">        <span class="comment">// if the bigger son is bigger than its father, then swap</span></span><br><span class="line">        <span class="keyword">if</span> (*(pArray + sonIndex) COMPARE *(pArray + fatherIndex))</span><br><span class="line">            <span class="built_in">swapTwoNum</span>(pArray + sonIndex, pArray + fatherIndex);</span><br><span class="line">        <span class="built_in">heapDown</span>(pArray, sonIndex, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-归并排序"><a href="#3-6-归并排序" class="headerlink" title="3.6. 归并排序"></a>3.6. 归并排序</h2><p>时间复杂度:O(NlogN), 空间复杂度:O(n)，非原地，非稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Merge_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    ElementType* tmpA = <span class="keyword">new</span> ElementType[m_uiSizeOfArray];</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != tmpA) &#123;</span><br><span class="line">        <span class="built_in">mergeSort</span>(pArray, tmpA, <span class="number">0</span>, m_uiSizeOfArray - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">delete</span>[] tmpA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::mergeSort</span><span class="params">(ElementType *pArray, ElementType *tmpA, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">        <span class="keyword">int</span> middleIndex = (leftIndex + rightIndex) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(pArray, tmpA, leftIndex, middleIndex);</span><br><span class="line">        <span class="built_in">mergeSort</span>(pArray, tmpA, middleIndex + <span class="number">1</span>, rightIndex);</span><br><span class="line">        <span class="built_in">merge</span>(pArray, tmpA, leftIndex, middleIndex + <span class="number">1</span>, rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::merge</span><span class="params">(ElementType *pArray, ElementType *tmpA,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> middleIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftSubIndex = leftIndex;</span><br><span class="line">    <span class="keyword">int</span> rightSubIndex = middleIndex;</span><br><span class="line">    <span class="keyword">int</span> tmpIndex = leftIndex;</span><br><span class="line">    <span class="comment">// compare</span></span><br><span class="line">    <span class="keyword">while</span> (leftSubIndex &lt; middleIndex &amp;&amp; rightSubIndex &lt;= rightIndex) &#123;</span><br><span class="line">        *(tmpA + tmpIndex++) = (*(pArray + leftSubIndex) COMPARE *(pArray + rightSubIndex)) ?</span><br><span class="line">                               *(pArray + rightSubIndex++) : *(pArray + leftSubIndex++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy the left rest (if remain)</span></span><br><span class="line">    <span class="keyword">while</span> (leftSubIndex &lt; middleIndex) &#123;</span><br><span class="line">        *(tmpA + tmpIndex++) = *(pArray + leftSubIndex++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy the right rest (if remain)</span></span><br><span class="line">    <span class="keyword">while</span> (rightSubIndex &lt;= rightIndex) &#123;</span><br><span class="line">        *(tmpA + tmpIndex++) = *(pArray + rightSubIndex++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write the result from tmpA to pArray</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = leftIndex; i &lt;= rightIndex; ++i) &#123;</span><br><span class="line">        *(pArray + i) = *(tmpA + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-快速排序"><a href="#3-7-快速排序" class="headerlink" title="3.7. 快速排序"></a>3.7. 快速排序</h2><p>时间复杂度:O(NlogN ~ N^2)，空间复杂度:O(1)，原地，非稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Quick_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Quick Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">quickSort</span>(pArray, <span class="number">0</span>, m_uiSizeOfArray - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_NUM_OF_CUTOFF 32 <span class="comment">// when the length of subarray small than MIN_NUM_OF_CUTOFF, choose the insert sort</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::quickSort</span><span class="params">(ElementType *pArray, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rightIndex - leftIndex &gt; MIN_NUM_OF_CUTOFF) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = leftIndex;</span><br><span class="line">        <span class="keyword">int</span> j = rightIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// choose middle pivot</span></span><br><span class="line">        ElementType middlePivot = <span class="built_in">choosePivot</span>(pArray, leftIndex, rightIndex);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (middlePivot COMPARE *(pArray + ++i)) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span> (*(pArray + --j) COMPARE middlePivot) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="built_in">swapTwoNum</span>(pArray + i, pArray + j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// put the middle pivot into the middle index</span></span><br><span class="line">        <span class="built_in">swapTwoNum</span>(pArray + i, pArray + rightIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(pArray, leftIndex, i - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(pArray, i + <span class="number">1</span>, rightIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Insert sort</span></span><br><span class="line">        ElementType tmp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = leftIndex + <span class="number">1</span>; i &lt;= rightIndex; ++i) &#123;</span><br><span class="line">            tmp = *(pArray + i);</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; leftIndex &amp;&amp; *(pArray + j - <span class="number">1</span>) COMPARE tmp; --j) &#123;</span><br><span class="line">                *(pArray + j) = *(pArray + j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            *(pArray + j) = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">SortFuncCompare::choosePivot</span><span class="params">(ElementType *pArray, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> middleIndex = (leftIndex + rightIndex) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(pArray + leftIndex) COMPARE *(pArray + middleIndex)) &#123;</span><br><span class="line">        <span class="built_in">swapTwoNum</span>(pArray + leftIndex, pArray + middleIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(pArray + leftIndex) COMPARE *(pArray + rightIndex)) &#123;</span><br><span class="line">        <span class="built_in">swapTwoNum</span>(pArray + leftIndex, pArray + rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(pArray + middleIndex) COMPARE *(pArray + rightIndex)) &#123;</span><br><span class="line">        <span class="built_in">swapTwoNum</span>(pArray + middleIndex, pArray + rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swapTwoNum</span>(pArray + middleIndex, pArray + rightIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// return the middle value</span></span><br><span class="line">    <span class="keyword">return</span> *(pArray + rightIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-时耗测试"><a href="#4-时耗测试" class="headerlink" title="4. 时耗测试"></a>4. 时耗测试</h1><p>各排序算法在各个数据规模下排序所耗时长（秒）。</p>
<table>
<thead>
<tr>
<th align="left">数据规模</th>
<th align="left">冒泡</th>
<th align="left">选择</th>
<th align="left">插入</th>
<th align="left">希尔</th>
<th align="left">堆</th>
<th align="left">归并</th>
<th align="left">快排</th>
</tr>
</thead>
<tbody><tr>
<td align="left">十</td>
<td align="left">2e-06</td>
<td align="left">1e-06</td>
<td align="left">1e-06</td>
<td align="left">1e-06</td>
<td align="left">2e-06</td>
<td align="left">1e-06</td>
<td align="left">1e-06</td>
</tr>
<tr>
<td align="left">百</td>
<td align="left">3.3e-05</td>
<td align="left">3.3e-05</td>
<td align="left">8e-06</td>
<td align="left">8e-06</td>
<td align="left">1.1e-05</td>
<td align="left">1e-05</td>
<td align="left">5e-06</td>
</tr>
<tr>
<td align="left">千</td>
<td align="left">0.003153</td>
<td align="left">0.003</td>
<td align="left">0.000627</td>
<td align="left">0.000164</td>
<td align="left">0.00016</td>
<td align="left">0.000118</td>
<td align="left">6.9e-05</td>
</tr>
<tr>
<td align="left">万</td>
<td align="left">0.365065</td>
<td align="left">0.387825</td>
<td align="left">0.060752</td>
<td align="left">0.001938</td>
<td align="left">0.002096</td>
<td align="left">0.001431</td>
<td align="left">0.00089</td>
</tr>
<tr>
<td align="left">十万</td>
<td align="left">38.2601</td>
<td align="left">35.2071</td>
<td align="left">7.63559</td>
<td align="left">0.034236</td>
<td align="left">0.031059</td>
<td align="left">0.019387</td>
<td align="left">0.01238</td>
</tr>
<tr>
<td align="left">百万</td>
<td align="left">9708.16</td>
<td align="left">3736.74</td>
<td align="left">1643.99</td>
<td align="left">0.93</td>
<td align="left">0.98</td>
<td align="left">0.5</td>
<td align="left">0.3</td>
</tr>
</tbody></table>
<h2 id="4-1-分析"><a href="#4-1-分析" class="headerlink" title="4.1. 分析"></a>4.1. 分析</h2><ul>
<li><p>数据规模不超过一百时</p>
<img data-src="../../../../uploads/SortFuncComparePicture_size100.png" class="full-image" />
当数据规模较小时，各排序算法所耗时长区别并不明显，但当数据规模为一百时已有明显区别，最快的排序算法与最满的排序算法效率相差一个数量级。
</li>
<li><p>数据规模为一千时</p>
<img data-src="../../../../uploads/SortFuncComparePicture_size1000.png" class="full-image" />
除了冒泡和选择排序耗时三十几毫秒，其他排序算法耗时均在一毫秒内，此时各排序算法最快与最满效率比值已达为四十多倍
</li>
<li><p>数据规模为十万时</p>
<img data-src="../../../../uploads/SortFuncComparePicture_size100000.png" class="full-image" />
当排序数据规模达到十万时，可以发现排序最快的算法是快排仅12毫秒，效率是最慢的冒泡排序(38秒)的三千多倍，性能差异已十分明显。
</li>
<li><p>数据规模为百万时<br>当排序数据规模达到百万时，可以发现排序最快的算法是快排仅0.3秒，效率是最慢的冒泡排序(9708.16秒，约2.7小时)的三万多倍，性能差异已非常巨大。而且已知快排的平均时间复杂度为O(N*logN)，可进一步推测当数据规模为千万级别时，快排算法在此平台下耗时仅需3秒多，而时间复杂度为O(N^2)的冒泡排序在此平台下预计耗时将达到11天，两种算法的效率显现出天壤之别。</p>
</li>
</ul>
<h2 id="4-2-此次实验收获"><a href="#4-2-此次实验收获" class="headerlink" title="4.2. 此次实验收获"></a>4.2. 此次实验收获</h2><ul>
<li>各种排序算法在数规模小于一百时还没有太大差距，此时选实现较简单的就好</li>
<li>当数据达到一定规模后，不同算法执行效率差异巨大，此时追求算法效率显得十分重要</li>
</ul>
<h1 id="5-附件"><a href="#5-附件" class="headerlink" title="5. 附件"></a>5. 附件</h1><p>本次实验源代码详见博主的个人git仓库:</p>
<ul>
<li><a href="https://github.com/haoleeson/Cpp_Learning/blob/master/SortFuncCompare.h">SortFuncCompare.h</a></li>
<li><a href="https://github.com/haoleeson/Cpp_Learning/blob/master/SortFuncCompare.cpp">SortFuncCompare.cpp</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《千里千寻》中蕴含人生观触动的一段话</title>
    <url>/2017/02/24/Spirited-Away/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/Spirited-Away.jpg" class="full-image" />
<!-- 标签方式引用，要求版本在0.4.5或以上 -->

<blockquote class="blockquote-center">
<p>人生就是一列开往坟墓的列车，<br>路途上会有很多站口，<br>没有一个人可以至始至终陪着你走完，<br>你会看到来来往往、上上下下的人。</p>
<a id="more"></a>

<p>如果幸运，会有人陪你走过一段，<br>当这个人要下车的时候，即使不舍，<br>也该心存感激，然后挥手道别。<br>因为，说不定下一站，<br>会有另外一个人会陪你走得更远。</p>

</blockquote>

<div align = right>----千与千寻</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>人生观触动</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Win10 和 IDEA 的 Spark 开发&amp;测试环境搭建</title>
    <url>/2020/06/25/SparkDevAndTestEnvInWin10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/SparkDevAndTestEnvInWin10.jpg" class="full-image" />

<p>试想一下，将精心编写的Spark业务代码Jar包上传到Spark集群环境，却出现了简单错误或预期之外的结果，势必会破坏一天的心情和积极性，这时一套桌面级的Spark开发&amp;测试环境的优势就展露无遗了。可以在本地开发Spark代码，并测试基础功能，让开发者可以不必担心上传jar包的代码逻辑正确性、代码质量等基础问题。接下来就跟随本文一起搭建一套Win10下的Spark开发&amp;测试环境吧！</p>
<a id="more"></a>

<div class="note success"><p>环境信息<br>Java            1.8.0_251<br>Scala sdk       2.11.12<br>Spark lib       2.4.5<br>IDEA Community  2020.1.2</p>
</div>

<h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="1-1-搭建Java环境"><a href="#1-1-搭建Java环境" class="headerlink" title="1.1. 搭建Java环境"></a>1.1. 搭建Java环境</h2><ul>
<li><a href="https://www.oracle.com/java/technologies/javase-jdk14-downloads.html">Oracle官网</a>下载所需要的JDK(eg.<a href="https://download.oracle.com/otn-pub/java/jdk/14.0.1+7/664493ef4a6946b186ff29eb326336a2/jdk-14.0.1_windows-x64_bin.exe">jdk-14.0.1_windows-x64_bin.exe</a>)</li>
<li>安装JDK</li>
<li>配置环境变量：此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建”JAVA_HOME”变量，其值为上一步JDK安装路径；新建”CLASSPATH”变量，其值为”.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”；最后编辑”Path”变量，追加字段”%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">新建环境变量</span><br><span class="line">JAVA_HOME       C:\Java\jdk1.8.0_251</span><br><span class="line">CLASSPATH       .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</span><br><span class="line">修改Path变量（追加）</span><br><span class="line">Path            %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</span><br></pre></td></tr></table></figure></li>
<li>在PowerShell输入 java -version 判断是否安装成功<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">PS C:\Windows\system32&gt; java -version</span><br><span class="line">java version &quot;1.8.0_251&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_251-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)</span><br><span class="line">PS C:\Windows\system32&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-搭建Scala环境"><a href="#1-2-搭建Scala环境" class="headerlink" title="1.2. 搭建Scala环境"></a>1.2. 搭建Scala环境</h2><p>注：Scala依赖Java 8 JDK (或 Java 11 JDK)以后的版本；目前最新版本为2.13.2，但若需要调试Spark强烈建议下载2.11.x版本，因为Spark主要适配的是2.11.x版本，最新Scala版本可能出现与Spark不兼容问题</p>
<ul>
<li><a href="https://www.scala-lang.org/download/">Scala官网</a>下载Scala可安装程序版<a href="https://downloads.lightbend.com/scala/2.11.12/scala-2.11.12.msi">msi安装包</a>(大小109 MB) 或 <a href="https://downloads.lightbend.com/scala/2.11.12/scala-2.11.12.zip">Zip版本</a>(大小27.8 MB，推荐)。msi版可直接安装，Zip版需解压。</li>
<li>配置环境变量：此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建”SCALA_HOME”变量，其值为上一步Zip版解压路径或msi版安装路径；最后编辑”Path”变量，追加字段”%SCALA_HOME%\bin;”<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">新建环境变量</span><br><span class="line">SCALA_HOME      C:\Scala\scala-2.11.12</span><br><span class="line">修改Path变量（追加）</span><br><span class="line">Path            %SCALA_HOME%\bin;</span><br></pre></td></tr></table></figure></li>
<li>在PowerShell输入 scala 判断是否安装成功<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">PS C:\Windows\system32&gt; scala</span><br><span class="line">Welcome to Scala 2.11.12 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_251).</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta">scala&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-3-搭建Hadoop环境"><a href="#1-3-搭建Hadoop环境" class="headerlink" title="1.3. 搭建Hadoop环境"></a>1.3. 搭建Hadoop环境</h2><p>注：此步未配置将会导致执行scala程序时因缺少Hadoop环境如“winutils.exe”文件而无法执行，抛IOException</p>
<ul>
<li>登录<a href="https://github.com/">GitHub</a>搜索”hadoop win”，下载Spark运行所需的Hadoop win环境（如：<a href="https://github.com/steveloughran/winutils">steveloughran&#x2F;winutils</a>），否则将无法运行Spark工程，报”java.io.IOException: Could not locate executable null\bin\winutils.exe in the Hadoop binaries.”</li>
<li>解压相应Hadoop版本到指定文件夹</li>
<li>需确保bin下有如下两个文件：hadoop.dll、winutils.exe</li>
<li>配置环境变量：此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建”HADOOP_HOME”变量，其值为上一步解压路径；最后编辑”Path”变量，追加字段”%HADOOP_HOME%\bin;”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">新建环境变量</span><br><span class="line">HADOOP_HOME     C:\hadoop-2.7.1</span><br><span class="line">修改Path变量（追加）</span><br><span class="line">Path            %HADOOP_HOME%\bin;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-下载-Spark-的-Jar-依赖包"><a href="#1-4-下载-Spark-的-Jar-依赖包" class="headerlink" title="1.4. 下载 Spark 的 Jar 依赖包"></a>1.4. 下载 Spark 的 Jar 依赖包</h2><p>Idea中Spark工程会用到Spark的jar依赖，故需下载spark的依赖包。</p>
<p>下载<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.5/spark-2.4.5-bin-hadoop2.7.tgz">spark-2.4.5-bin-hadoop2.7.tgz</a>后解压备用</p>
<h2 id="1-5-安装Intellij-IDEA-Community（社区免费版）"><a href="#1-5-安装Intellij-IDEA-Community（社区免费版）" class="headerlink" title="1.5. 安装Intellij IDEA Community（社区免费版）"></a>1.5. 安装Intellij IDEA Community（社区免费版）</h2><p><a href="https://www.jetbrains.com/idea/">官网</a>下载<a href="https://download.jetbrains.8686c.com/idea/ideaIC-2020.1.2.exe">Intellij IDEA Community（社区免费版）</a>，并安装</p>
<h2 id="1-6-IDEA-安装-Scala-插件"><a href="#1-6-IDEA-安装-Scala-插件" class="headerlink" title="1.6. IDEA 安装 Scala 插件"></a>1.6. IDEA 安装 Scala 插件</h2><p>有两种插件安装方式，即在线安装和离线安装，推荐网络不稳定的小伙伴选择后者（注意Scala插件版本应与IDEA版本匹配）</p>
<h3 id="1-6-1-在线安装-Scala-插件（超时、失败）"><a href="#1-6-1-在线安装-Scala-插件（超时、失败）" class="headerlink" title="1.6.1. 在线安装 Scala 插件（超时、失败）"></a>1.6.1. 在线安装 Scala 插件（超时、失败）</h3><p>IDEA -&gt; Settings -&gt; plugins -&gt; search plugins in marketplace(“scala”) -&gt; install -&gt; restart IDEA</p>
<h3 id="1-6-2-离线安装-Scala-插件"><a href="#1-6-2-离线安装-Scala-插件" class="headerlink" title="1.6.2. 离线安装 Scala 插件"></a>1.6.2. 离线安装 Scala 插件</h3><ul>
<li><p>浏览器访问 <a href="https://plugins.jetbrains.com/plugin/1347-scala">IDEA 离线插件库</a>，点击右上角”Get”按钮，并下载支持IDEA版本(2020.1.2)的 <a href="https://plugins.jetbrains.com/files/1347/89709/scala-intellij-bin-2020.1.39.zip?updateId=89709&pluginId=1347&family=INTELLIJ">Scala 插件</a>（支持2020.1 — 2020.1.2）</p>
</li>
<li><p>IDEA -&gt; Settings -&gt; plugins -&gt; 点击小齿轮 -&gt; Install plugin form disk -&gt; select package -&gt; restart IDEA</p>
</li>
</ul>
<div class="note success"><p>准备工作至此结束</p>
</div>

<h1 id="2-创建Scala项目"><a href="#2-创建Scala项目" class="headerlink" title="2. 创建Scala项目"></a>2. 创建Scala项目</h1><ul>
<li>新建Scala工程<br>Run IDEA -&gt; File -&gt; New -&gt; Project -&gt; Scala -&gt; IDEA -&gt; NEXT</li>
<li>填写工程基础信息</li>
</ul>
<p>指定工程的工程名、路径、Java JDK、Scala JDK。设置Scala JDK时点击右侧”Create”按钮会自动识别准备工作中安装的Scala JDK(2.11.12)</p>
<ul>
<li>添加Spark依赖的jar到此工程<br>也可直接将整个jars目录导入到Libraries</li>
</ul>
<p>File –&gt; Project Steuccture –&gt; Libraries –&gt; 点击”+”按钮 –&gt; Java –&gt; 选择准备工作中已解压备用的”spark-2.4.5-bin-hadoop2.7”文件夹里的”jars”目录 –&gt; OK</p>
<ul>
<li>新建一个object</li>
</ul>
<p>左侧工程结构中点击 src -&gt; new -&gt; scala clas -&gt; 输入文件名(“SparkPi.scala”) -&gt; 选择Object</p>
<ul>
<li>编写Spark简易程序：计算圆周率Pi</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.math.random</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spark 简易程序：计算圆周率 Pi</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 原理：随机落在与正方形相切的同心圆内的概率为：S圆 / S正 = Pi / 4</span></span><br><span class="line"><span class="comment"> * 注：根据大数定律，当随机抛点次数达到百万次时，据概率所计算出Pi才具有参考意义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SparkPi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">          .builder</span><br><span class="line">          .appName(<span class="string">&quot;Spark Pi&quot;</span>)</span><br><span class="line">          .getOrCreate()</span><br><span class="line">        <span class="keyword">val</span> slices = <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) args(<span class="number">0</span>).toInt <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> n = math.min(<span class="number">1000000</span>L * slices, <span class="type">Int</span>.<span class="type">MaxValue</span>).toInt <span class="comment">// avoid overflow</span></span><br><span class="line">        <span class="keyword">val</span> count = spark.sparkContext.parallelize(<span class="number">1</span> until n, slices).map &#123; i =&gt;</span><br><span class="line">            <span class="keyword">val</span> x = random * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> y = random * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        &#125;.reduce(_ + _)</span><br><span class="line">        println(<span class="string">&quot;Pi is roughly &quot;</span> + <span class="number">4.0</span> * count / (n - <span class="number">1</span>))</span><br><span class="line">        spark.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置启动参数</li>
</ul>
<p>注：未设置会报”SparkException: A master URL must be set in your configuration”异常</p>
<p>设置vm options：点击菜单栏Run -&gt; Edit Configurations -&gt; VM options -&gt; 填写如下启动参数，让Spark程序以local模式运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dspark.master=local</span><br></pre></td></tr></table></figure>

<ul>
<li>运行Spark程序</li>
</ul>
<p>点击”object SparkPi”旁的绿色小三角即可运行Spark程序（注意设置启动参数）</p>
<h1 id="3-参考博文"><a href="#3-参考博文" class="headerlink" title="3. 参考博文"></a>3. 参考博文</h1><ul>
<li><a href="https://www.cnblogs.com/zlslch/p/5880926.html">IntelliJ IDEA（Community版本）的下载、安装和WordCount的初步使用</a></li>
<li><a href="https://blog.csdn.net/LiangEdward/article/details/106845276">基于windows，IDEA配置hadoop运行环境遇到的问题和解决（null\bin\winutils.exe）</a></li>
<li><a href="https://blog.csdn.net/streamery/article/details/106752423">ERROR SparkContext: Error initializing SparkContext.</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Syslog 模块的故障自检方法及常见已知问题</title>
    <url>/2021/08/24/SyslogSelfDiagnosisAndCommonProblems/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Rsyslog 版本：8.24.0</p>
<h1 id="1-故障自检方法"><a href="#1-故障自检方法" class="headerlink" title="1. 故障自检方法"></a>1. 故障自检方法</h1><h2 id="1-1-无日志输出"><a href="#1-1-无日志输出" class="headerlink" title="1.1. 无日志输出"></a>1.1. 无日志输出</h2><p><strong>现象</strong>：</p>
<p>目标进程的预期日志文件无日志写入， <code>tail -f</code> 未检测到日志写入流</p>
<a id="more"></a>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tail -f /var/log/syslog</span><br></pre></td></tr></table></figure>

<h3 id="1-1-1-可能原因-1：目标进程未启动或异常"><a href="#1-1-1-可能原因-1：目标进程未启动或异常" class="headerlink" title="1.1.1. 可能原因 1：目标进程未启动或异常"></a>1.1.1. 可能原因 1：目标进程未启动或异常</h3><p>自检方法：排查目标进程运行状态，或结合进程自身特性判断</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  检查业务进程是否正常运行（eg. swss 容器中的 fdbmgrd 进程 ）</span></span><br><span class="line">docker exec -it swss ps -ef | grep -v &quot;grep&quot; | grep &quot;fdbmgrd&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-可能原因-2：Rsyslog-未启动"><a href="#1-1-2-可能原因-2：Rsyslog-未启动" class="headerlink" title="1.1.2. 可能原因 2：Rsyslog 未启动"></a>1.1.2. 可能原因 2：Rsyslog 未启动</h3><p><strong>可能原因 2-1</strong>：</p>
<p>系统日志软件 Rsyslog 进程被 Kill</p>
<p>自检方法：检查 Rsyslog 是否运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 检查交换机中 Rsyslog 是否运行</span></span><br><span class="line">ps -ef | grep -v &quot;grep&quot; | grep &quot;rsyslogd&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 检查对应容器（eg. swss）中 Rsyslog 是否运行</span></span><br><span class="line">docker exec -it swss ps -ef | grep rsyslogd</span><br></pre></td></tr></table></figure>

<p><strong>可能原因 2-2</strong>：</p>
<p>Rsyslog 的自身配置文件 <code>/etc/rsyslog.conf</code> 或自定义配置文件夹下 <code>/etc/rsyslog.d/</code> 的配置有错，导致 Rsyslog 启动失败</p>
<p>自检方法：对照正常设备的配置</p>
<h3 id="1-1-3-可能原因-3：无程序打开目标日志文件"><a href="#1-1-3-可能原因-3：无程序打开目标日志文件" class="headerlink" title="1.1.3. 可能原因 3：无程序打开目标日志文件"></a>1.1.3. 可能原因 3：无程序打开目标日志文件</h3><p>自检方法：查看是否有进程打开目标日志文件（eg. <code>/var/log/syslog</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查有无进程“打开了”目标日志文件</span></span><br><span class="line">sudo lsof /var/log/syslog</span><br></pre></td></tr></table></figure>
<p>一般情况如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">rsyslogd 2181 root    8w   REG    8,3 57735831   56 /var/log/syslog</span><br></pre></td></tr></table></figure>

<h3 id="1-1-4-可能原因-4：-日志输出限制级别设定过高"><a href="#1-1-4-可能原因-4：-日志输出限制级别设定过高" class="headerlink" title="1.1.4. 可能原因 4： 日志输出限制级别设定过高"></a>1.1.4. 可能原因 4： 日志输出限制级别设定过高</h3><p>自检方法：通过 swssloglevel 或 logctl 命令检查日志输出限制级别是否过高</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前日志输出限制级别</span></span><br><span class="line">swssloglevel -p | grep fdbmgrd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">logctl -p -c swss#fdbmgrd</span><br></pre></td></tr></table></figure>

<p><strong>应对方法</strong>：</p>
<ul>
<li>更改输出限制级别</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 降低目标进程（eg. fdbmgrd）日志输出限制级别</span></span><br><span class="line">swssloglevel -l INFO -c fdbmgrd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">logctl -l INFO -c swss#fdbmgrd</span><br></pre></td></tr></table></figure>
<p>备注：查看更改日志输出限制级别用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swssloglevel -h</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">logctl -h</span><br></pre></td></tr></table></figure>

<h2 id="1-2-日志文件无法轮转，无限制增长"><a href="#1-2-日志文件无法轮转，无限制增长" class="headerlink" title="1.2. 日志文件无法轮转，无限制增长"></a>1.2. 日志文件无法轮转，无限制增长</h2><p><strong>现象</strong>：</p>
<p>日志文件无限制增长，超过轮转阈值，却未被轮转压缩</p>
<h3 id="1-2-1-可能原因-1：logrotate-配置异常"><a href="#1-2-1-可能原因-1：logrotate-配置异常" class="headerlink" title="1.2.1. 可能原因 1：logrotate 配置异常"></a>1.2.1. 可能原因 1：logrotate 配置异常</h3><p>自检方法：排查 logrotate 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 检查有无安装 logrotate</span></span><br><span class="line">sudo which logrotate</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">ls -l /usr/sbin/logrotate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 检查 logrotate 自身配置（对照正常设备配置）</span></span><br><span class="line">cat /etc/logrotate.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 检查有无对目标日志文件的轮转配置（eg. <span class="string">&quot;daemon.log&quot;</span>）</span></span><br><span class="line">grep -A 5 &quot;daemon.log&quot; /etc/logrotate.d/rsyslog</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">grep -A 5 -Rw &quot;daemon.log&quot; /etc/logrotate.d/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 模拟执行以验证目标文件的轮转配置的正确性（<span class="string">&quot;-d&quot;</span>, 不会真正执行日志轮转）</span></span><br><span class="line">/usr/sbin/logrotate -d /etc/logrotate.d/rsyslog 2&gt;&amp;1 | grep -A 5 &quot;daemon.log&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-可能原因-2：cron-配置异常"><a href="#1-2-2-可能原因-2：cron-配置异常" class="headerlink" title="1.2.2. 可能原因 2：cron 配置异常"></a>1.2.2. 可能原因 2：cron 配置异常</h3><blockquote>
<p>logrotate 日志轮转依赖于被定时任务工具 cron 周期调起</p>
</blockquote>
<p>自检方法：排查 cron 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 检查 cron 配置（对照正常设备配置）</span></span><br><span class="line">cat /etc/crontab</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 检查 cron 周期性调起 logrotate 的配置（对照正常设备配置）</span></span><br><span class="line">cat /etc/cron.d/logrotate</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">cat /etc/cron.daily/logrotate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 检查定时任务 cron 是否启动</span></span><br><span class="line">ps -ef | grep -v &quot;grep&quot; | grep &quot;cron&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 检查有无 cron 成功调起 logrotate 的日志（当前调起周期为十分钟）</span></span><br><span class="line">sudo grep &quot;logrotate&quot; /var/log/cron.log | tail -n 5</span><br></pre></td></tr></table></figure>


<h2 id="1-3-轮转后新文件不记日志"><a href="#1-3-轮转后新文件不记日志" class="headerlink" title="1.3. 轮转后新文件不记日志"></a>1.3. 轮转后新文件不记日志</h2><p><strong>现象</strong>：</p>
<p>日志文件大小为 0，已自检不是“1.1. 无输出日志”的问题</p>
<h3 id="1-3-1-可能原因：Rsyslog-未收到-HUP-信号"><a href="#1-3-1-可能原因：Rsyslog-未收到-HUP-信号" class="headerlink" title="1.3.1. 可能原因：Rsyslog 未收到 HUP 信号"></a>1.3.1. 可能原因：Rsyslog 未收到 HUP 信号</h3><blockquote>
<p>日志轮转工具 logrotate 在轮转 <code>xxx.log</code> 文件后，理应给 Rsyslog 发 HUP 挂起信号，以使 Rsyslog 进程能够重新加载 新的 <code>xxx.log</code> 文件的（文件 inode 号变更）进行记日志。</p>
</blockquote>
<p>Rsyslog 未收到 HUP 信号，其仍根据旧 inode 向不存在的前 <code>xxx.log</code> 写日志。</p>
<p>自检方法：检查该日志文件对应的 lorotate 轮转配置文件（eg.  <code>/etc/logrotate.d/rsyslog</code> ），确保 postrotate 执行块内，存在向 Rsyslog 发送 HUP 信号的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postrotate</span><br><span class="line">    /bin/kill -HUP $(cat /var/run/rsyslogd.pid) 2&gt;/dev/null || true</span><br><span class="line">endscript</span><br></pre></td></tr></table></figure>


<h1 id="2-常见已知问题"><a href="#2-常见已知问题" class="headerlink" title="2. 常见已知问题"></a>2. 常见已知问题</h1><h2 id="2-1-高速刷日志时突然停止输出"><a href="#2-1-高速刷日志时突然停止输出" class="headerlink" title="2.1. 高速刷日志时突然停止输出"></a>2.1. 高速刷日志时突然停止输出</h2><p><strong>现象</strong>：</p>
<p>短时输出大量日志时突然无征兆中断输出，5 分钟后日志又恢复输出，循环往复，导致日志呈现周期性断续输出现象</p>
<p><strong>根因</strong>：</p>
<p>日志吞吐量过高时，会触发容器中 Rsyslog 配置的“熔断”值（2 万条&#x2F;每 5 分钟），此时容器中 Rsyslog 会停止转发日志消息到宿主机 Rsyslog，故宿主机端观检测不到日志输出。不过，进入下一 5 分钟周期计数清零后，日志又恢复输出。</p>
<p>注意：“熔断”期间的输出日志会丢失。</p>
<p>自检方法：查看目标容器（eg. bgp）中的 Rsyslog 配置文件 <code>/etc/rsyslog.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it bgp grep -C 2 &quot;SystemLogRateLimitInterval&quot; /etc/rsyslog.conf</span><br></pre></td></tr></table></figure>

<p>默认配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Set a rate <span class="built_in">limit</span> on messages from the container</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="variable">$SystemLogRateLimitInterval</span> 300</span></span><br><span class="line"><span class="meta">$</span><span class="bash">SystemLogRateLimitBurst 20000</span></span><br></pre></td></tr></table></figure>

<p><strong>应对方法</strong>：</p>
<ul>
<li>更参考1.1.4改日志输出的级别，以降低日志输出速率</li>
<li>临时调高 Rsyslog 配置的“熔断”值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改目标容器（eg. bgp）中 Rsyslog 的“熔断”配置值</span></span><br><span class="line">docker exec -it bgp sed -i &#x27;s/SystemLogRateLimitBurst [0-9]\+/SystemLogRateLimitBurst 30000/g&#x27; /etc/rsyslog.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启目标容器（eg. bgp）中的 Rsyslog 服务以生效配置</span></span><br><span class="line">docker exec -it bgp service rsyslog restart</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Rsyslog-收到-HUP-信号"><a href="#2-2-Rsyslog-收到-HUP-信号" class="headerlink" title="2.2. Rsyslog 收到 HUP 信号"></a>2.2. Rsyslog 收到 HUP 信号</h2><p><strong>现象</strong>：</p>
<p>Rsyslog 收到 HUP 信号并输出下方的 INFO 级别日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-10-16 03:50:01.212971 HOSTNAMR &lt;local7.info&gt; INFO liblogging-stdlog:  [origin software=&quot;rsyslogd&quot; swVersion=&quot;8.24.0&quot; x-pid=&quot;1732&quot; x-info=&quot;http://www.rsyslog.com&quot;] rsyslogd was HUPed</span><br></pre></td></tr></table></figure>

<p><strong>根因</strong>：</p>
<p>符合预期的正常情况。当日志文件发生轮转时，Rsyslog 会收到 logrotate 发送的 HUP 信号，重新加载文件，包括停止往已改名的“准轮转文件”写日志，而是写日志到新建的一个同名文件中。</p>
<h2 id="2-3-Rsyslog-折叠重复日志"><a href="#2-3-Rsyslog-折叠重复日志" class="headerlink" title="2.3. Rsyslog 折叠重复日志"></a>2.3. Rsyslog 折叠重复日志</h2><p><strong>现象</strong>：</p>
<p>Rsyslog 输出下方的折叠日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-10-27 15:57:44.222512 HOSTNAMR &lt;local2.err&gt; ERR swss#orchagent: message repeated 1636 times: [ :- doTask: op: SET, key: vlan23:8.1.1.2]</span><br></pre></td></tr></table></figure>

<p><strong>根因</strong>：</p>
<p>出现 <code>message repeated 1636 times</code> ，是由于容器中的 Rsyslog 开启了“减少重复日志” 开关（默认开启），以避免一千多行重复冗余日志转发的性能消耗，是符合预期的正常情况。</p>
<p>自检方法：查看目标容器（eg. bgp）中的 Rsyslog 配置文件 <code>/etc/rsyslog.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it bgp grep -B 2 &quot;RepeatedMsgReduction&quot; /etc/rsyslog.conf</span><br></pre></td></tr></table></figure>
<p>默认配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Suppress duplicate messages and report <span class="string">&quot;message repeated n times&quot;</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="variable">$RepeatedMsgReduction</span> on</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-Rsyslog-打印-2354-标识"><a href="#2-4-Rsyslog-打印-2354-标识" class="headerlink" title="2.4. Rsyslog 打印 2354 标识"></a>2.4. Rsyslog 打印 2354 标识</h2><p><strong>现象</strong>：</p>
<p>Rsyslog 输出下方日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-09-26 11:20:58.668466 HOSTNAMR &lt;local7.err&gt; ERR liblogging-stdlog: omfwd: error 11 sending via udp: Resource temporarily unavailable [v8.24.0 try http://www.rsyslog.com/e/2354 ]</span><br><span class="line"></span><br><span class="line">2022-02-10 10:16:31.392826 HOSTNAMR &lt;local7.err&gt; ERR liblogging-stdlog: omfwd: error 101 sending via udp: Network is unreachable [v8.24.0 try http://www.rsyslog.com/e/2354 ]</span><br></pre></td></tr></table></figure>

<p>Rsyslog 打<a href="https://www.rsyslog.com/rsyslog-error-2354/">2354 标识日志</a>表明很可能是<strong>系统的 UDP 缓冲区空间不足</strong>。</p>
<p>（注：旧版本（如 8.24）也无法发送接近或大于 64KiB 的日志消息）</p>
<p><strong>根因</strong>：</p>
<p>系统的 UDP 缓冲区空间不足。还需监控系统的 UDP 缓存区占用情况来定位是哪些组件占用较大（可参考：<a href="https://stackoverflow.com/questions/2289830/how-to-monitor-linux-udp-buffer-available-space">监控 UDP buffer 可用空间</a>）</p>
<h2 id="2-5-Rsyslog-打印-2359-标识"><a href="#2-5-Rsyslog-打印-2359-标识" class="headerlink" title="2.5. Rsyslog 打印 2359 标识"></a>2.5. Rsyslog 打印 2359 标识</h2><p><strong>现象</strong>：</p>
<p>Rsyslog 输出下方日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-09-26 10:35:02.802106 HOSTNAMR &lt;local7.info&gt; INFO liblogging-stdlog: action &#x27;action 0&#x27; resumed (module &#x27;builtin:omfwd&#x27;) [v8.24.0 try http://www.rsyslog.com/e/2359 ]</span><br></pre></td></tr></table></figure>
<p><strong>根因</strong>：</p>
<p>Rsyslog 恢复服务的提示日志，<a href="http://www.rsyslog.com/e/2359">2359 标识</a> 表示 之前由于重连到服务器或资源不再紧缺时暂停的操作现已恢复执行，符合预期无需处理。</p>
<h2 id="2-6-Rsyslog-打印-2007-标识"><a href="#2-6-Rsyslog-打印-2007-标识" class="headerlink" title="2.6. Rsyslog 打印 2007 标识"></a>2.6. Rsyslog 打印 2007 标识</h2><p><strong>现象：</strong><br>Rsyslog 输出下方日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-05-06 15:30:34.575869 HOSTNAMR &lt;local7.warning&gt; WARNING liblogging-stdlog: action &#x27;action 0&#x27; suspended, next retry is Fri May  6 15:31:04 2022 [v8.24.0 try http://www.rsyslog.com/e/2007 ]</span><br></pre></td></tr></table></figure>
<p><strong>根因</strong>：<br><a href="https://www.rsyslog.com/rsyslog-error-2007/">2007 标识</a>的常见原因为 Rsyslog 配置中包含向不可达组件写日志的错误配置，如配置了不可达的远程日志服务器，将导致输出大量2007标识的告警信息。</p>
<p><strong>解决方法</strong>：<br>删除&#x2F;注释错误的远程日志服务器配置后重启rsyslog服务。</p>
<h2 id="2-7-无-Redis-自身运行日志"><a href="#2-7-无-Redis-自身运行日志" class="headerlink" title="2.7. 无 Redis 自身运行日志"></a>2.7. 无 Redis 自身运行日志</h2><p><strong>现象</strong>：</p>
<p>未记录 Database 中 Redis 的相关运行日志</p>
<p><strong>根因</strong>：</p>
<p>Database 容器里的 redis 配置中，默认未配置日志输出</p>
<p>自检方法：查看 Redis 配置文件 <code>/etc/redis/redis.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it database grep -B 2 &quot;syslog-enable&quot; /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<p>默认配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">enable</span> logging to the system logger, just <span class="built_in">set</span> <span class="string">&#x27;syslog-enabled&#x27;</span> to yes,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and optionally update the other syslog parameters to suit your needs.</span></span><br><span class="line">syslog-enabled no</span><br></pre></td></tr></table></figure>

<p><strong>应对方法</strong>：</p>
<ul>
<li>修改 Redis 配置文件，添加日志输出配置，并重启 Redis 以生效（不建议线上设备执行此操作）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 备份原配置</span></span><br><span class="line">docker exec -it database cp /etc/redis/redis.conf /etc/redis/redis.conf_bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看备份文件</span></span><br><span class="line">docker exec -it database ls -l /etc/redis/redis.conf_bak</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 添加 Redis 输出日志路径配置</span></span><br><span class="line">docker exec -it database sed -i &#x27;s;logfile \&quot;\&quot;;logfile \&quot;/var/log/redis/redis.log\&quot;;g&#x27; /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 添加 Redis 输出日志 ident 配置</span></span><br><span class="line">docker exec -it database sed -i &#x27;s;# syslog-ident redis;syslog-ident redis;g&#x27; /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 添加 Redis 输出日志 facility 配置</span></span><br><span class="line">docker exec -it database sed -i &#x27;s;# syslog-facility local0;syslog-facility local0;g&#x27; /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 打开 Redis 输出日志开关配置</span></span><br><span class="line">docker exec -it database sed -i &#x27;s;syslog-enabled no;syslog-enabled yes;g&#x27; /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 停启 Database 容器以生效配置</span></span><br><span class="line">docker stop database; docker start database</span><br></pre></td></tr></table></figure>

<ul>
<li>redis-cli 虽然也支持热修改部分日志配置，但不支持热修改开启&#x2F;关闭日志输出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 热修改 Redis 输出日志路径配置</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 CONFIG SET logfile &quot;/var/log/redis/redis.log&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查变更</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 CONFIG GET logfile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 热修改 Redis 输出日志 facility 配置（支持八种 facility 属性：user、local0 ~ local7）</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 CONFIG SET syslog-facility &quot;local0&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查变更</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 CONFIG GET syslog-facility</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 热修改 Redis 输出日志 loglevel 配置（支持四种级别：debug、verbose、notice、warning）</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 CONFIG SET loglevel &quot;warning&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查变更</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 CONFIG GET loglevel</span><br></pre></td></tr></table></figure>

<h2 id="2-8-修改-Rsyslog-配置文件后未生效？"><a href="#2-8-修改-Rsyslog-配置文件后未生效？" class="headerlink" title="2.8. 修改 Rsyslog 配置文件后未生效？"></a>2.8. 修改 Rsyslog 配置文件后未生效？</h2><p>修改 Rsyslog 配置文件后，需要重启服务以生效配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service rsyslog restart</span><br></pre></td></tr></table></figure>

<h2 id="2-9-一条日志能够重定向到多个日志文件么？"><a href="#2-9-一条日志能够重定向到多个日志文件么？" class="headerlink" title="2.9. 一条日志能够重定向到多个日志文件么？"></a>2.9. 一条日志能够重定向到多个日志文件么？</h2><p>可以，在 Rsyslog 配置中（<code>/etc/rsyslog.d/00-HOSTNAMR.conf</code>），若 syslog 消息匹配了多条自定义重定向（引流）规则（且规则执行块内无结束匹配关键字 stop），就能实现输出单条日志到多个文件</p>
<p>多条自定义重定向（引流）单日志到多个文件如下：</p>
<ol>
<li>在配置文件 <code>/etc/rsyslog.d/00-HOSTNAMR.conf</code> 中添加两条自定义重定向（引流）规则</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># test rule1</span></span></span><br><span class="line">if $msg contains &quot;ABC&quot; then &#123;</span><br><span class="line">    /var/log/abc.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># test rule2</span></span></span><br><span class="line">if $msg contains &quot;DEF&quot; then &#123;</span><br><span class="line">    /var/log/def.log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>模拟发送一个 syslog 消息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logger -p local5.info &quot;ABC DEF TEST1&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可发现两个重定向（引流）日志文件都记录了该日志</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-12-29 15:14:18.698602 HOSTNAMR &lt;local.info&gt; INFO admin: ABC DEF TEST1</span><br></pre></td></tr></table></figure>

<h2 id="2-10-Rsyslog-支持修改日志的-facility-么？"><a href="#2-10-Rsyslog-支持修改日志的-facility-么？" class="headerlink" title="2.10. Rsyslog 支持修改日志的 facility 么？"></a>2.10. Rsyslog 支持修改日志的 facility 么？</h2><p>问题补充描述：程序打 local0 的日志，能否让 Rsyslog 在写日志文件时改为 local2 ？</p>
<p>暂不支持，截止官网 8.2112.0 版本，Rsyslog 暂不支持修改日志 facility 的操作；网上也没有成功修改案例。</p>
<p>虽然 Rsyslog 支持的“读已有日志文件并按行转发”功能中支持指定日志 facility，理论上存在“引流 local0 日志 &#x3D;&#x3D;&gt; 指定文件 &#x3D;&#x3D;&gt; 读文件转成 syslog 消息（指定 local2）”这种可能，但这种方式<strong>不具备可行性</strong>：</p>
<ul>
<li>首先是这种“二次转发”的日志会存在<strong>冗余消息前缀</strong>，如</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 原始日志</span></span><br><span class="line">2021-12-29 17:20:51.653444 HOSTNAMR &lt;local0.info&gt; INFO admin: ABC DEF TEST5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 二次转发日志：二次转发的日志前缀（时间戳 2 local2 级别 2 设备属性 2） + 原始日志前缀（时间戳 1 local0 级别 1 设备属性 1）+ 原始消息正文</span></span><br><span class="line">2021-12-29 17:20:52.703466 HOSTNAMR &lt;local2.notice&gt; NOTICE testinput 2021-12-29 17:20:51.653444 HOSTNAMR &lt;local0.info&gt; INFO admin: ABC DEF TEST5</span><br></pre></td></tr></table></figure>
<ul>
<li>其次，这种打日志后再读文件二次转发方式，由于写入文件与读文件二次转发逻辑问题，一条日志很容易陷入被<strong>无限打印循环</strong></li>
</ul>
<h2 id="2-11-获知程序对应的日志路径？"><a href="#2-11-获知程序对应的日志路径？" class="headerlink" title="2.11. 获知程序对应的日志路径？"></a>2.11. 获知程序对应的日志路径？</h2><p>由于 Rsyslog 主要基于程序打日志的 facility、或少量自定义的重定向（引流）规则明确记日志的文件 <code>/etc/rsyslog.d/00-HOSTNAMR.conf</code> ，故暂无进程与日志文件的明确对应关系。不过依然可以参考下方两种方式获知进程的日志文件路径：</p>
<ul>
<li>方法 1：查看梳理的各容器启停日志及各进程输出日志</li>
<li>方法 2：手动检索 <code>/var/log/</code> 目录（检索字段：容器名#进程名）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -Rw &quot;swss#fdbmgrd&quot; /var/log/ | awk &#x27;&#123; print $1 &#125;&#x27; | uniq | sort | uniq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行示例</span></span><br><span class="line">/var/log/auth.log:2022-01-30</span><br><span class="line">/var/log/syslog:2022-01-30</span><br></pre></td></tr></table></figure>

<h2 id="2-12-日志服务器未收到上报日志？"><a href="#2-12-日志服务器未收到上报日志？" class="headerlink" title="2.12. 日志服务器未收到上报日志？"></a>2.12. 日志服务器未收到上报日志？</h2><p>咱们的日志上报是CS架构，下方任一原因都可能导致日志服务器无法收到日志：</p>
<p><strong>设备端：</strong></p>
<ul>
<li>Rsyslog 服务未运行？检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status rsyslog | grep Active</span><br></pre></td></tr></table></figure>
<ul>
<li>设备上是否配置 远程日志服务器IP 检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -A 2 &#x27;remote syslog server&#x27; /etc/rsyslog.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>日志服务器不可达？检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping $(grep -A 1 &#x27;remote syslog server&#x27; /etc/rsyslog.conf  | tail -n +2) </span><br></pre></td></tr></table></figure>
<ul>
<li>防火墙 配置？514 端口未打开？检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -L -n</span><br><span class="line">sudo lsof -i:514</span><br></pre></td></tr></table></figure>
<ul>
<li>设备无异常日志输出？ 检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -E &#x27;NOTICE|WARNING|ERROR&#x27; /var/log/syslog | grep local2 | tail -20</span><br></pre></td></tr></table></figure>

<p><strong>日志服务器端：</strong></p>
<ul>
<li>Rsyslog 服务未运行？检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status rsyslog | grep Active</span><br></pre></td></tr></table></figure>
<ul>
<li>防火墙 配置？514 端口未打开？检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -L -n</span><br><span class="line">sudo lsof -i:514</span><br></pre></td></tr></table></figure>
<ul>
<li>Rsyslog 配置中 $UDPServerAddress 127.0.0.1 被打开了？服务器端需注释，否则只能接收本地日志检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;UDPServerAddress&#x27; /etc/rsyslog.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器端配置了日志全转发？ 检查命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -A 2 &#x27;remote syslog server&#x27; /etc/rsyslog.conf </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>syslog</tag>
      </tags>
  </entry>
  <entry>
    <title>二三层转发</title>
    <url>/2021/09/05/TwoOrThreeLevelForwarding/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2-二层转发"><a href="#2-二层转发" class="headerlink" title="2. 二层转发"></a>2. 二层转发</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1. 简介"></a>2.1. 简介</h2><ul>
<li>一种基于OSI中的<strong>数据链路层（第二层）</strong>的数据帧的存储转发技术，二层交换是依靠<strong>MAC地址和VID号</strong>来确定转发方向的。</li>
<li>二层转发通过维护MAC地址表以及根据目的MAC查表转发，有效的利用了网络带宽，改善了网络性能。</li>
</ul>
<a id="more"></a>

<ul>
<li>二层转发使得二层交换机各端口属于不同的冲突域，不同端口发送和接收的<strong>数据独立</strong>，因此有效地隔离了网络中物理层冲突域，使得通过它互连的主机（或网络）之间不必再担心流量大小对于数据发送冲突的影响。</li>
<li>二层转发通过专用集成电路（Application Specific Integrated Circuit，ASIC）来实现<strong>硬件转发</strong>，其转发性能非常高。</li>
</ul>
<h2 id="2-2-二层转发流程介绍"><a href="#2-2-二层转发流程介绍" class="headerlink" title="2.2. 二层转发流程介绍"></a>2.2. 二层转发流程介绍</h2><h3 id="2-2-1-基础二层转发"><a href="#2-2-1-基础二层转发" class="headerlink" title="2.2.1. 基础二层转发"></a>2.2.1. 基础二层转发</h3><p>二层交换机通过解析和学习以太网帧的<b><font color="red">源MAC地址</font></b>来维护MAC地址与端口的对应关系到<strong>MAC地址表</strong>。转发时，根据<b><font color="blue">目的MAC地址</font></b>检索 <strong>MAC地址表</strong> 来决定向哪个端口转发。</p>
<ul>
<li>二层交换机记录各端口接收到的以太帧的，将其 <b><font color="red">源MAC地址</font></b>与接收的<strong>端口</strong> 的映射关系添加（或覆盖已有，并刷新老化时间）到<strong>MAC地址表</strong>中，作为以后的二层转发依据。</li>
<li>转发时，根据以太帧的<b><font color="blue">目的MAC地址</font></b>检索<strong>MAC地址表</strong>：<ul>
<li>若无法查到表项，则向除接收端口的所有端口转发；</li>
<li>若可查到表项，<ul>
<li>但端口与太网帧的接收端口相同，则丢弃该帧；</li>
<li>反之，则向记录端口转发；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>备注：</strong> 二层交换机虽然能够隔离冲突域，但是它并不能有效的划分广播域，广播报文以及目的MAC查找失败的报文会向所有端口转发。当网络中主机数量增多时，这种情况会消耗大量的网络带宽，并且也会带来安全性相关问题。当然，通过路由器来隔离广播域是一个办法，但是由于路由器的高成本以及转发性能低的特点使得这一方法应用有限。基于这些情况，二层交换中出现了虚拟局域网（Virtual Local Area Network，VLAN）技术。</p>
<h3 id="2-2-2-带VLAN的二层转发"><a href="#2-2-2-带VLAN的二层转发" class="headerlink" title="2.2.2. 带VLAN的二层转发"></a>2.2.2. 带VLAN的二层转发</h3><p>VLAN技术主要根据MAC地址将局域网<strong>从逻辑上</strong>划分为不同网段，从而实现虚拟工作组的一种交换技术。根据MAC地址维护方式的不同，可分为两种方式的二层转发：共享VLAN的MAC地址学习（Shared VLAN Learning，<strong>SVL</strong>）和独立VLAN的MAC地址学习（Independent VLAN Learning，<strong>IVL</strong>）。由于SVL只以<strong>MAC地址作为表项</strong>，学习后存表时不存储VLAN信息，故SVL方式具有 <strong>在不同VLAN中相同MAC地址的多个主机存在通信冲突</strong> 的问题。SVL现已比较少见，这里主要讨论IVL方式的二层转发，其将<strong>MAC地址 + VLAN-ID</strong>作为查找表项（也可理解为——每个VLAN都有自己独立的MAC地址表）。</p>
<ul>
<li>二层交换机记录各个端口接收到以太帧的 <b><font color="red">源MAC地址</font></b> <strong>+ VLAN-ID</strong> 信息，并将其与对应端口的映射关系添加（或覆盖已有）到<strong>MAC地址表中</strong></li>
<li>转发时，根据以太帧的<b><font color="blue">目的MAC地址</font></b> <strong>+ VLAN-ID</strong>检索<strong>MAC地址表</strong>：<ul>
<li>若无表项，则在<strong>VLAN-ID</strong>内广播；</li>
<li>若存在表项，<ul>
<li>且记录端口与接收端口相同，则丢弃该帧；</li>
<li>反之，则将该以太帧转发到表项记录端口；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-MAC地址表的老化"><a href="#2-3-MAC地址表的老化" class="headerlink" title="2.3. MAC地址表的老化"></a>2.3. MAC地址表的老化</h2><p>二层交换机的MAC地址老化和刷新通常直接由硬件ASIC芯片来完成，其老化机制如下：</p>
<ul>
<li>在芯片中储存的每一个动态添加的MAC地址表项都有一个 1 bit 的<strong>老化标志</strong>（1——保留；0——删除），同时芯片有一个<strong>老化定时器</strong>用于控制地址老化；</li>
<li>在学到MAC地址表项时：<ul>
<li>对于新学到的<strong>MAC地址表项</strong>，将其老化标志位置1；</li>
<li>对于学到<strong>MAC地址中已有的表项</strong>（更新），将其老化标志位 置1；</li>
</ul>
</li>
<li>在芯片的老化定时器超时触发时：<ul>
<li>对于老化标志位为1的表项，修改老化标志位为0；</li>
<li>对于老化标志位为0的表项，删除该条表项记录。</li>
</ul>
</li>
</ul>
<p><strong>备注：</strong> 由于新学到表项的时刻随机分布，故对每条表项，其实际老化时间为 1~2 倍的老化定时器周期。</p>
<h1 id="3-三层转发"><a href="#3-三层转发" class="headerlink" title="3. 三层转发"></a>3. 三层转发</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1. 简介"></a>3.1. 简介</h2><ul>
<li>一种基于OSI七层模型中 <strong>第三层网络层</strong> 的数据帧的存储转发技术，三层交换是主要依靠 <strong>IP地址</strong> 来确定转发方向，以实现不同网络间的通信。</li>
</ul>
<h2 id="3-2-三层转发特点"><a href="#3-2-三层转发特点" class="headerlink" title="3.2. 三层转发特点"></a>3.2. 三层转发特点</h2><ul>
<li>IP报文每经过一次三层转发，<b><font color="red" style="">其源&#x2F;目的MAC地址都会变化</font></b>，但是<b><font color="blue" style="">其源&#x2F;目的IP始终不变</font></b>。</li>
<li><strong>一次路由，多次交换</strong>。即首包通过CPU参与转发过程，同时建立交换芯片<strong>硬件表项</strong>，后续包由交换芯片<strong>直接硬件转发</strong></li>
<li>交换芯片的硬件转发并不关心路由的具体下一跳IP，硬件三层表项只包含：目的IP地址&#x2F;网段、目的IP（或下一跳IP）对应的MAC地址、出口VLAN、出端口</li>
</ul>
<h2 id="3-3-路由器与交换机三层转发对比"><a href="#3-3-路由器与交换机三层转发对比" class="headerlink" title="3.3. 路由器与交换机三层转发对比"></a>3.3. 路由器与交换机三层转发对比</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <th align="center"><b>路由器</b></th>
        <th align="center"><b>交换机</b></th>
    </tr>
    <tr>
        <td align="center">成本</td>
        <td align="center">高</td>
        <td align="center">低</td>
    </tr>
    <tr>
        <td align="center">实现方式</td>
        <td align="center">主要依靠CPU计算处理，少部分支持硬件转发</td>
        <td align="center">依靠ASIC硬件芯片集成IP三层转发功能<br>(检查IP报文头、修改存活时间参数、<br>重新计算IP头校验和、IP包的数据链路封装等)</td>
    </tr>
    <tr>
        <td align="center">转发性能</td>
        <td align="center">较弱</td>
        <td align="center">强</td>
    </tr>
    <tr>
        <td align="center">端口数量</td>
        <td align="center">少</td>
        <td align="center">多</td>
    </tr>
</table>

<p>目前三层交换机一般通过VLAN来划分二层网络并实现二层交换（同网段），同时能够实现不同VLAN间的三层IP互访（不同网段）。</p>
<h2 id="3-4-组网一下的三层转发流程详细介绍"><a href="#3-4-组网一下的三层转发流程详细介绍" class="headerlink" title="3.4. 组网一下的三层转发流程详细介绍"></a>3.4. 组网一下的三层转发流程详细介绍</h2><p>组网一如下图所示，源、目的主机都连接在同一台三层交换机上，但它们位于不同的VLAN(网段)。从三层交换机视角来说，源、目的主机都位于其直连网段，基础信息如下：</p>
<p>(<strong>PC_A</strong> , <strong>MAC A</strong>：AA-AA-AA-AA-AA-AA , IP: 1.1.1.2, NetMask: 255.255.255.0, GW: 1.1.1.1)<br>(Ethernet2 1.1.1.1  &lt;-&gt;  <strong>L3_SW</strong>, <strong>MAC_L3_SW</strong>:CC-CC-CC-CC-CC-CC, NetMask: 255.255.255.0, &lt;-&gt;  Ethernet3 2.1.1.1  )<br>(<strong>PC_B</strong> , <strong>MAC B</strong>：BB-BB-BB-BB-BB-BB , IP: 2.1.1.2, NetMask: 255.255.255.0, GW: 2.1.1.1)</p>
<!-- L3_SW的交换芯片的三层MAC地址表内容如下（交换机的VLAN配置时写入）： -->

<!-- <table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">MAC</th>
        <th align="center">VLAN-ID</th>
        <th align="center">Port</th>
    </tr>
    <tr>
        <td align="center">CC-CC-CC-CC-CC-CC</td>
        <td align="center">2</td>
        <td align="center">2</td>
    </tr>
    <tr>
        <td align="center">CC-CC-CC-CC-CC-CC</td>
        <td align="center">3</td>
        <td align="center">3</td>
    </tr>
</table> -->


<p>当 <b><font color="red" style="">PC_A Ping PC_B</font></b> 时，即发起 ICMP 请求时，涉及的三层转发处理流程如下（假设主机均暂未建立任何硬件转发表项）：</p>
<!-- **【1】**  **PC_A进行目标IP网段与自身的异同判断**:  -->
<p><b><font color="#7E3D76" style="">【1】 PC_A判断目标IP网段与自身的异同: </font></b></p>
<p><strong>PC_A</strong>对比报文的目的IP网段与自身网段（发现不在同一网段），需要进行三层转发（即，需通过网关转发报文信息）</p>
<!-- **【2】**  **PC_A查询其ARP缓存表**:  -->
<p><b><font color="#7E3D76" style="">【2】 PC_A查询其ARP缓存表: </font></b></p>
<p><strong>PC_A</strong>检查自己的ARP缓存表，发现网关的MAC地址不在MAC地址表里，此时<strong>PC_A</strong>的ARP缓存表为空：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>IP</th>
        <th>MAC</th>
    </tr>
    <tr>
        <td align="center"> </td>
        <td align="center"> </td>
    </tr>
</table>

<!-- **【3】**  **PC_A广播ARP请求报文**:  -->
<p><b><font color="#7E3D76" style="">【3】 PC_A广播ARP请求报文：</font></b></p>
<p><strong>PC_A</strong>在所处物理广播域内广播ARP请求报文（求取<strong>L3_SW</strong>网关IP(1.1.1.1)的MAC地址？），<strong>PC_A</strong>发送的ARP请求帧内容如下（广播）：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <th colspan="3">Ethernet II Header</th>
        <th colspan="10">ARP Frame</th>
        <th>End</th>
    </tr>
    <tr>
        <td align="center">字段</td>
        <td align="center">DA</td>
        <td align="center">SA</td>
        <td>Type/Length</td>
        <td>HardwareType</td>
        <td>ProtocolType</td>
        <td>HardwareLen</td>
        <td>ProtocolLen</td>
        <td align="center">OP</td>
        <td align="center">SrcAddr</td>
        <td align="center">SrcIP</td>
        <td align="center">DesAddr</td>
        <td align="center">DesIP</td>
        <td>FilledField</td>
        <td>FCR</td>
    </tr>
    <tr>
        <td align="center">字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">6</td>
        <td align="center">4</td>
        <td align="center">6</td>
        <td align="center">4</td>
        <td align="center">18</td>
        <td align="center">4</td>
    </tr>
    <tr>
        <td align="center">填充值(0x)</td>
        <td align="center"><font color="blue">FF-FF-FF-FF-FF-FF</font></td>
        <td align="center"><font color="red">AA-AA-AA-AA-AA-AA</font></td>
        <td align="center"><b>0x0806</b></font></td>
        <td align="center">0x0001</td>
        <td align="center">0x0800</td>
        <td align="center">0x06</td>
        <td align="center">0x04</td>
        <td align="center"><b>0x01</b></td>
        <td align="center"><font color="red">AA-AA-AA-AA-AA-AA</font></td>
        <td align="center"><font color="red">01-01-01-02</font></td>
        <td align="center"><font color="blue">00-00-00-00-00-00</font></td>
        <td align="center"><font color="blue">01-01-01-01</font></td>
        <td align="center">00...00</td>
        <td align="center">/</td>
    </tr>
</table>

<p>注：</p>
<ul>
<li>Ethernet II封装的以太帧头的”Type”字段中，<strong>0x0806</strong>表示其后为<strong>ARP协议</strong></li>
<li>OP为操作码，1表示ARP请求、2表示ARP应答、3表示RARP请求、4表示RARP应答</li>
<li>因物理传输数据帧最短需不低于64Bytes，故上文ARP帧需在填充区段填充18个字节长度的’0’。</li>
</ul>
<!-- **【4】**  **L3_SW接收到ARP请求报文**:  -->
<p><b><font color="#7E3D76" style="">【4】 L3_SW接收到ARP请求报文：</font></b></p>
<p><strong>L3_SW</strong>收到<strong>PC_A</strong>的ARP请求报文，并将<strong>PC_A</strong>的MAC地址学习到自己的MAC地址表和ARP缓存表。<br><strong>L3_SW</strong>的MAC地址表内容如下：</p>
<!-- <b><font color="red" style="">Q：MAC地址表中，转发标志位缺省值为TRUE么 ?</font></b> -->

<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">MAC</th>
        <th align="center">VLAN-ID</th>
        <th align="center">Port</th>
    </tr>
    <!-- <tr>
        <td align="center">CC-CC-CC-CC-CC-CC</td>
        <td align="center">2</td>
        <td align="center">2</td>
    </tr>
    <tr>
        <td align="center">CC-CC-CC-CC-CC-CC</td>
        <td align="center">3</td>
        <td align="center">3</td>
    </tr> -->
    <tr>
        <td align="center"><font color="green">AA-AA-AA-AA-AA-AA</font></td>
        <td align="center"><font color="green">2</font></td>
        <td align="center"><font color="green">2</font></td>
    </tr>
</table>

<p><strong>L3_SW</strong>的ARP缓存表内容如下：</p>
<!-- <b><font color="red" style=""> Q：正确么？</font></b> -->

<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">IP</th>
        <th align="center">MAC</th>
    </tr>
    <tr>
        <td align="center"><font color="green">1.1.1.2</font></td>
        <td align="center"><font color="green">AA-AA-AA-AA-AA-AA</font></td>
    </tr>
</table>

<p>注：为提升检索效率，交换机芯片中，MAC地址表与ARP表融合为一张表。</p>
<!-- **【5】**  **L3_SW单播ARP应答报文**:  -->
<p><b><font color="#7E3D76" style="">【5】 L3_SW单播ARP应答报文：</font></b></p>
<p><strong>L3_SW</strong>发现自己的IP与<strong>PC_A</strong>发出ARP请求包的目的IP一致，向<strong>PC_A</strong>响应ARP应答报文，<strong>L3_SW</strong>向<strong>PC_A</strong>发送的ARP应答帧内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <th colspan="3">Ethernet II Header</th>
        <th colspan="10">ARP Frame</th>
        <th>End</th>
    </tr>
    <tr>
        <td align="center">字段</td>
        <td align="center">DA</td>
        <td align="center">SA</td>
        <td>Type/Length</td>
        <td>HardwareType</td>
        <td>ProtocolType</td>
        <td>HardwareLen</td>
        <td>ProtocolLen</td>
        <td align="center">OP</td>
        <td align="center">SrcAddr</td>
        <td align="center">SrcIP</td>
        <td align="center">DesAddr</td>
        <td align="center">DesIP</td>
        <td>FilledField</td>
        <td>FCR</td>
    </tr>
    <tr>
        <td align="center">字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">6</td>
        <td align="center">4</td>
        <td align="center">6</td>
        <td align="center">4</td>
        <td align="center"><b>18</b></td>
        <td align="center">4</td>
    </tr>
    <tr>
        <td align="center">填充值(0x)</td>
        <td align="center"><font color="blue">AA-AA-AA-AA-AA-AA</font></td>
        <td align="center"><font color="red">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><b>0x0806</b></td>
        <td align="center">0x0001</td>
        <td align="center">0x0800</td>
        <td align="center">0x06</td>
        <td align="center">0x04</td>
        <td align="center"><b>0x02</b></td>
        <td align="center"><font color="red">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><font color="red">01-01-01-01</font></td>
        <td align="center"><font color="blue">AA-AA-AA-AA-AA-AA</font></td>
        <td align="center"><font color="blue">01-01-01-02</font></td>
        <td align="center">00...00</td>
        <td align="center">/</td>
    </tr>
</table>

<p><strong>PC_A</strong>收到<strong>L3_SW</strong>的ARP应答报文后，<strong>PC_A</strong>学习到<strong>L3_SW</strong>的MAC地址并添加到ARP缓存表。<br>此时<strong>PC_A</strong>的ARP缓存表内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>IP</th>
        <th>MAC</th>
    </tr>
    <tr>
        <td align="center"><font color="green">1.1.1.1</font></td>
        <td align="center"><font color="green">CC-CC-CC-CC-CC-CC</font></td>
    </tr>
</table>

<!-- **【6】**  **PC_A组装并发送ICMP请求**:  -->
<p><b><font color="#7E3D76" style="">【6】 PC_A组装并发送ICMP请求：</font></b></p>
<p>接着<strong>PC_A</strong>组装并发出目的IP为<strong>PC_B</strong>IP地址的ICMP请求报文（目的MAC为<strong>L3_SW</strong>的MAC）。<strong>PC_A</strong>向<strong>PC_B</strong>发出的ICMP请求帧内容如下：</p>
<table width="1900" border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <!-- <th colspan="7">Ethernet II Header</th> -->
        <th colspan="3">Ethernet II Header</th>
        <th colspan="12">IP Header</th>
        <th colspan="6">ICMP Frame</th>
        <th>End</th>
    </tr>
    <tr>
        <td align="center">字段</td>
        <td align="center">DA</td>
        <td align="center">SA</td>
        <!-- <td align="center">Type</td>
        <td>UserPriority</td>
        <td>Flag</td>
        <td>VLAN-ID</td> -->
        <td align="center">Type</td>
        <td>Version</td>
        <td>HeaderLen</td>
        <td>Priority</td>
        <td>TotalLen</td>
        <td>Identification</td>
        <td align="center">Flags</td>
        <td align="center">FragmentOffset</td>
        <td align="center">TTL</td>
        <td align="center">Protocol</td>
        <td align="center">Checksum</td>
        <td align="center">SrcIP</td>
        <td align="center">DesIP</td>
        <td align="center">Type</td>
        <td align="center">Code</td>
        <td align="center">Checksum</td>
        <td align="center">Identifier</td>
        <td align="center">SequenceNumber</td>
        <td align="center">OptionalData</td>
        <td align="center">FCR</td>
    </tr>
    <tr>
        <td align="center">字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <!-- <td align="center">2</td>
        <td align="center">3bits</td>
        <td align="center">1bit</td>
        <td align="center">12bits</td> -->
        <td align="center">2</td>
        <td align="center">4bits</td>
        <td align="center">4bits</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">3bits</td>
        <td align="center">13bits</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">/</td>
        <td align="center">4</td>
    </tr>
    <tr>
        <td align="center">填充值(0x)</td>
        <td align="center"><font color="blue">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><font color="red">AA-AA-AA-AA-AA-AA</font></td>
        <!-- <td align="center"><b>0x8100</b></td>
        <td align="center">000B</td>
        <td align="center">0B</td>
        <td align="center"><b>10B</b></td> -->
        <td align="center"><b>0x0800</b></td>
        <td align="center">0100B</td>
        <td align="center">0101B</td>
        <td align="center">0x00</td>
        <td align="center">0x005F</td>
        <td align="center">0x0000</td>
        <td align="center">000B</td>
        <td align="center">0B</td>
        <td align="center">0xFF</td>
        <td align="center"><b>0x01</b></td>
        <td align="center">/</td>
        <td align="center"><font color="red">01-01-01-02</font></td>
        <td align="center"><font color="blue">02-01-01-02</font></td>
        <td align="center"><b>0x08</b></td>
        <td align="center">0</td>
        <td align="center">/</td>
        <td align="center">/</td>
        <td align="center">0x01000001</td>
        <td align="center">0...0</td>
        <td align="center">/</td>
    </tr>
</table>

<p>注：</p>
<ul>
<li>Ethernet II封装的以太帧头的”Type”字段中，<strong>0x0800</strong>表示其后为<strong>IP协议</strong></li>
<li>在IP帧头的”Protocol”字段中，<strong>0x01</strong>表示其后为<strong>ICMP协议</strong></li>
<li>ICMP帧头的”Type”字段中，<strong>0x08</strong>表示请求，<strong>0x00</strong>表示响应。</li>
</ul>
<!-- **【7】**  **L3_SW接收ICMP报文，判断转发方式，查表**:  -->
<p><b><font color="#7E3D76" style="">【7】 L3_SW接收ICMP报文，判断转发方式，查表：</font></b></p>
<p><strong>L3_SW</strong>收到<strong>PC_A</strong>的ICMP请求报文。根据 <strong>目的MAC地址+VLAN</strong> 检索MAC地址表 或 查询 MyStation表是否存在目的MAC：</p>
<ul>
<li>若存在则交换机需对该报文进行三层转发。</li>
<li>但实际不存在，接着根据 <strong>目的IP(2.1.1.2)</strong> 查找交换机芯片三层表项：<ul>
<li>若能查到，则进行硬件三层转发；</li>
<li>但实际未查到，将报文送到CPU处理，CPU根据ICMP请求报文的 <strong>目的IP(2.1.1.2)</strong> 查找其<strong>软件路由表</strong>：<ul>
<li>若未能匹配，不同交换机处理方式不同（丢弃&#x2F;ARP查询到后转发）</li>
<li>匹配了一个直连网段<b><font color="blue">2.1.1.0</font></b>（即PC_B所在的网段），接着继续查找其<strong>软件ARP表</strong>中是否存在 <strong>IP(2.1.1.2)</strong> 的表项：<ul>
<li>若能查到，则更新源&#x2F;目的MAC，并向 <strong>IP(2.1.1.2)</strong> 转发ICMP报文。</li>
<li>但实际未查到，则需先发送ARP请求到 <strong>IP(2.1.1.2)</strong> 的MAC地址，再更新源&#x2F;目的MAC和转发ICMP报文。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br>此时<strong>L3_SW</strong>的交换芯片的MAC地址表内容如下：</p>
<!-- <b><font color="red" style=""> Q：默认添加到交换芯片的表项的转发Flag值？</font></b> -->

<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">MAC</th>
        <th align="center">VLAN-ID</th>
        <th align="center">Port</th>
    </tr>
    <!-- <tr>
        <td align="center"><font color="blue">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><font color="blue">2</font></td>
        <td align="center">2</td>
    </tr>
    <tr>
        <td align="center">CC-CC-CC-CC-CC-CC</td>
        <td align="center">3</td>
        <td align="center">3</td>
    </tr> -->
    <tr>
        <td align="center">AA-AA-AA-AA-AA-AA</td>
        <td align="center">2</td>
        <td align="center">2</td>
    </tr>
</table>


<p><strong>L3_SW</strong>的ARP缓存表内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">IP</th>
        <th align="center">MAC</th>
    </tr>
    <tr>
        <td align="center">1.1.1.2</td>
        <td align="center">AA-AA-AA-AA-AA-AA</td>
    </tr>
</table>

<p><strong>L3_SW</strong>的软件路由表内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>NetworkDestination</th>
        <th>SubnetMask</th>
        <th>Gateway</th>
        <th>Interface</th>
        <th>Metric</th>
    </tr>
    <tr>
        <td align="center">1.1.1.1</td>
        <td align="center">255.255.255.0</td>
        <td align="center">1.1.1.0</td>
        <td align="center">Ethernet 2</td>
        <td align="center">/</td>
    </tr>
    <tr>
        <td align="center">2.1.1.1</td>
        <td align="center">255.255.255.0</td>
        <td align="center"><font color="blue">2.1.1.0</font></td>
        <td align="center">Ethernet 3</td>
        <td align="center">/</td>
    </tr>
</table>

<!-- **【8】**  **L3_SW发送ARP请求**： -->
<p><b><font color="#7E3D76" style="">【8】 L3_SW发送ARP请求：</font></b></p>
<p><strong>L3_SW</strong>向目标网段广播ARP请求报文（求取2.1.1.2的MAC地址），ARP请求帧内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <th colspan="3">Ethernet II Header</th>
        <th colspan="10">ARP Frame</th>
        <th>End</th>
    </tr>
    <tr>
        <td align="center">字段</td>
        <td align="center">DA</td>
        <td align="center">SA</td>
        <td>Type/Length</td>
        <td>HardwareType</td>
        <td>ProtocolType</td>
        <td>HardwareLen</td>
        <td>ProtocolLen</td>
        <td align="center">OP</td>
        <td align="center">SrcAddr</td>
        <td align="center">SrcIP</td>
        <td align="center">DesAddr</td>
        <td align="center">DesIP</td>
        <td>FilledField</td>
        <td>FCR</td>
    </tr>
    <tr>
        <td align="center">字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">6</td>
        <td align="center">4</td>
        <td align="center">6</td>
        <td align="center">4</td>
        <td align="center">18</td>
        <td align="center">4</td>
    </tr>
    <tr>
        <td align="center">填充值(0x)</td>
        <td align="center"><font color="blue">FF-FF-FF-FF-FF-FF</font></td>
        <td align="center"><font color="red">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><b>0x0806</b></td>
        <td align="center">0x0001</td>
        <td align="center">0x0800</td>
        <td align="center">0x06</td>
        <td align="center">0x04</td>
        <td align="center"><b>0x01</b></td>
        <td align="center"><font color="red">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><font color="red">02-01-01-01</font></td>
        <td align="center"><font color="blue">00-00-00-00-00-00</font></td>
        <td align="center"><font color="blue">02-01-01-02</font></td>
        <td align="center">00...00</td>
        <td align="center">/</td>
    </tr>
</table>

<!-- **【9】**  **PC_B接收报文并学习ARP表**:  -->
<p><b><font color="#7E3D76" style="">【9】 PC_B接收报文并学习ARP表：</font></b></p>
<p><strong>PC_B</strong>收到ARP请求报文，更新ARP表。此时<strong>PC_B</strong>的ARP缓存表内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>IP</th>
        <th>MAC</th>
    </tr>
    <tr>
        <td align="center"><font color="green">2.1.1.1</font></td>
        <td align="center"><font color="green">CC-CC-CC-CC-CC-CC</font></td>
    </tr>
</table>

<!-- **【10】**  **PC_B回应ARP应答报文**:  -->
<p><b><font color="#7E3D76" style="">【10】 PC_B回应ARP应答报文：</font></b></p>
<p>PC_B发现目的IP是自己，于是向<strong>L3_SW</strong>发送ARP应答报文，ARP应答帧内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <th colspan="3">Ethernet II Header</th>
        <th colspan="10">ARP Frame</th>
        <th>End</th>
    </tr>
    <tr>
        <td align="center">字段</td>
        <td align="center">DA</td>
        <td align="center">SA</td>
        <td>Type/Length</td>
        <td>HardwareType</td>
        <td>ProtocolType</td>
        <td>HardwareLen</td>
        <td>ProtocolLen</td>
        <td align="center">OP</td>
        <td align="center">SrcAddr</td>
        <td align="center">SrcIP</td>
        <td align="center">DesAddr</td>
        <td align="center">DesIP</td>
        <td>FilledField</td>
        <td>FCR</td>
    </tr>
    <tr>
        <td align="center">字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">6</td>
        <td align="center">4</td>
        <td align="center">6</td>
        <td align="center">4</td>
        <td align="center">18</td>
        <td align="center">4</td>
    </tr>
    <tr>
        <td align="center">填充值(0x)</td>
        <td align="center"><font color="blue">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><font color="red">BB-BB-BB-BB-BB-BB</font></td>
        <td align="center"><b>0x0806</b></td>
        <td align="center">0x0001</td>
        <td align="center">0x0800</td>
        <td align="center">0x06</td>
        <td align="center">0x04</td>
        <td align="center"><b>0x02</b></td>
        <td align="center"><font color="red">BB-BB-BB-BB-BB-BB</font></td>
        <td align="center"><font color="red">02-01-01-02</font></td>
        <td align="center"><font color="blue">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><font color="blue">02-01-01-01</font></td>
        <td align="center">00...00</td>
        <td align="center">/</td>
    </tr>
</table>


<p><strong>L3_SW</strong>收到<strong>PC_B</strong>的ARP应答报文后，<strong>L3_SW</strong>学习到<strong>PC_B</strong>的MAC地址并添加到ARP缓存表（三层表项，注：此后对三层交换机L3_SW来说，L3_SW到PC_A或PC_B的三层表项均已学习到，这样后续PC_A和PC_B之间经过交换机L3_SW互发报文时，可直接通过交换机芯片进行硬件三层转发）。<br>此时<strong>L3_SW</strong>的ARP缓存表内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">IP</th>
        <th align="center">MAC</th>
    </tr>
    <tr>
        <td align="center">1.1.1.2</td>
        <td align="center">AA-AA-AA-AA-AA-AA</td>
    </tr>
    <tr>
        <td align="center"><font color="green">2.1.1.2</font></td>
        <td align="center"><font color="green">BB-BB-BB-BB-BB-BB</font></td>
    </tr>
</table>

<p>此时<strong>L3_SW</strong>的交换芯片的MAC地址表内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">MAC</th>
        <th align="center">VLAN-ID</th>
        <th align="center">Port</th>
    </tr>
    <tr>
        <td align="center">AA-AA-AA-AA-AA-AA</td>
        <td align="center">2</td>
        <td align="center">2</td>
    </tr>
    <tr>
        <td align="center"><font color="blue">BB-BB-BB-BB-BB-BB</font></td>
        <td align="center"><font color="blue">3</font></td>
        <td align="center">3</td>
    </tr>
</table>

<!-- **【11】**    **L3_SW接收ARP应答报文后，修改并转发ICMP请求**:  -->
<p><b><font color="#7E3D76" style="">【11】 L3_SW接收ARP应答报文后，修改并转发ICMP请求：</font></b></p>
<p><strong>L3_SW</strong>修改<strong>PC_A</strong>的ICMP请求包的源&#x2F;目的MAC地址（目的MAC修改为<strong>PC_B的MAC地址</strong>、源MAC修改为<strong>自己的MAC地址</strong>），并转发给PC_B。转发的ICMP请求帧内容如下：</p>
<table width="1900" border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <!-- <th colspan="7">Ethernet II Header</th> -->
        <th colspan="3">Ethernet II Header</th>
        <th colspan="12">IP Header</th>
        <th colspan="6">ICMP Frame</th>
        <th>End</th>
    </tr>
    <tr>
        <td align="center">字段</td>
        <td align="center">DA</td>
        <td align="center">SA</td>
        <!-- <td align="center">Type</td>
        <td>UserPriority</td>
        <td>Flag</td>
        <td>VLAN-ID</td> -->
        <td align="center">Type</td>
        <td>Version</td>
        <td>HeaderLen</td>
        <td>Priority</td>
        <td>TotalLen</td>
        <td>Identification</td>
        <td align="center">Flags</td>
        <td align="center">FragmentOffset</td>
        <td align="center">TTL</td>
        <td align="center">Protocol</td>
        <td align="center">Checksum</td>
        <td align="center">SrcIP</td>
        <td align="center">DesIP</td>
        <td align="center">Type</td>
        <td align="center">Code</td>
        <td align="center">Checksum</td>
        <td align="center">Identifier</td>
        <td align="center">SequenceNumber</td>
        <td align="center">OptionalData</td>
        <td align="center">FCR</td>
    </tr>
    <tr>
        <td align="center">字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <!-- <td align="center">2</td>
        <td align="center">3bits</td>
        <td align="center">1bit</td>
        <td align="center">12bits</td> -->
        <td align="center">2</td>
        <td align="center">4bits</td>
        <td align="center">4bits</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">3bits</td>
        <td align="center">13bits</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">/</td>
        <td align="center">4</td>
    </tr>
    <tr>
        <td align="center">填充值(0x)</td>
        <td align="center"><font color="blue">BB-BB-BB-BB-BB-BB</font></td>
        <td align="center"><font color="red">CC-CC-CC-CC-CC-CC</font></td>
        <!-- <td align="center"><b>0x8100</b></td>
        <td align="center">000B</td>
        <td align="center">0B</td>
        <td align="center"><b>10B</b></td> -->
        <td align="center"><b>0x0800</b></td>
        <td align="center">0100B</td>
        <td align="center">0101B</td>
        <td align="center">0x00</td>
        <td align="center">0x005F</td>
        <td align="center">0x0000</td>
        <td align="center">000B</td>
        <td align="center">0B</td>
        <td align="center">0xFF</td>
        <td align="center"><b>0x01</b></td>
        <td align="center">/</td>
        <td align="center"><font color="red">01-01-01-02</font></td>
        <td align="center"><font color="blue">02-01-01-02</font></td>
        <td align="center"><b>0x08</b></td>
        <td align="center">0</td>
        <td align="center">/</td>
        <td align="center">/</td>
        <td align="center">0x01000001</td>
        <td align="center">0...0</td>
        <td align="center">/</td>
    </tr>
</table>

<!-- **【12】**   **PC_B接收并响应ICMP报文**:  -->
<p><b><font color="#7E3D76" style="">【12】 PC_B接收并响应ICMP报文：</font></b></p>
<p>PC_B收到L3_SW转发的ICMP请求后，向<strong>PC_A</strong>发送应答ICMP报文（目的MAC为<strong>网关MAC地址</strong>）。其中ICMP报文内容如下：</p>
<table width="1900" border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <!-- <th colspan="7">Ethernet II Header</th> -->
        <th colspan="3">Ethernet II Header</th>
        <th colspan="12">IP Header</th>
        <th colspan="6">ICMP Frame</th>
        <th>End</th>
    </tr>
    <tr>
        <td align="center">字段</td>
        <td align="center">DA</td>
        <td align="center">SA</td>
        <!-- <td align="center">Type</td>
        <td>UserPriority</td>
        <td>Flag</td>
        <td>VLAN-ID</td> -->
        <td align="center">Type</td>
        <td>Version</td>
        <td>HeaderLen</td>
        <td>Priority</td>
        <td>TotalLen</td>
        <td>Identification</td>
        <td align="center">Flags</td>
        <td align="center">FragmentOffset</td>
        <td align="center">TTL</td>
        <td align="center">Protocol</td>
        <td align="center">Checksum</td>
        <td align="center">SrcIP</td>
        <td align="center">DesIP</td>
        <td align="center">Type</td>
        <td align="center">Code</td>
        <td align="center">Checksum</td>
        <td align="center">Identifier</td>
        <td align="center">SequenceNumber</td>
        <td align="center">OptionalData</td>
        <td align="center">FCR</td>
    </tr>
    <tr>
        <td align="center">字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <!-- <td align="center">2</td>
        <td align="center">3bits</td>
        <td align="center">1bit</td>
        <td align="center">12bits</td> -->
        <td align="center">2</td>
        <td align="center">4bits</td>
        <td align="center">4bits</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">3bits</td>
        <td align="center">13bits</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">/</td>
        <td align="center">4</td>
    </tr>
    <tr>
        <td align="center">填充值(0x)</td>
        <td align="center"><font color="blue">CC-CC-CC-CC-CC-CC</font></td>
        <td align="center"><font color="red">BB-BB-BB-BB-BB-BB</font></td>
        <!-- <td align="center"><b>0x8100</b></td>
        <td align="center">000B</td>
        <td align="center">0B</td>
        <td align="center"><b>10B</b></td> -->
        <td align="center"><b>0x0800</b></td>
        <td align="center">0100B</td>
        <td align="center">0101B</td>
        <td align="center">0x00</td>
        <td align="center">0x005F</td>
        <td align="center">0x0000</td>
        <td align="center">000B</td>
        <td align="center">0B</td>
        <td align="center">0xFF</td>
        <td align="center"><b>0x01</b></td>
        <td align="center">/</td>
        <td align="center"><font color="red">02-01-01-02</font></td>
        <td align="center"><font color="blue">01-01-01-02</font></td>
        <td align="center"><b>0x00</b></td>
        <td align="center">0</td>
        <td align="center">/</td>
        <td align="center">/</td>
        <td align="center">0x01000001</td>
        <td align="center">0...0</td>
        <td align="center">/</td>
    </tr>
</table>

<!-- **【13】**  **L3_SW硬件转发ICMP应答报文**:  -->
<p><b><font color="#7E3D76" style="">【13】 L3_SW硬件转发ICMP应答报文：</font></b></p>
<p><strong>L3_SW</strong>收到<strong>PC_B</strong>响应<strong>PC_A</strong>的应答报文后，根据 <strong>目的MAC地址+VLAN</strong> 检索MAC地址地址表：</p>
<ul>
<li>能查到，则需对其进行三层转发。然后根据 <strong>目的IP(1.1.1.2)</strong> 查找交换机芯片三层表项：<ul>
<li>能查到，则通过交换机芯片实现<strong>硬件三层转发</strong>该ICMP应答报文（目的MAC修改为PC_A的MAC地址、源MAC修改为自己的MAC地址）。<br></li>
</ul>
</li>
</ul>
<p>此时<strong>L3_SW</strong>的交换芯片的MAC地址表内容如下（交换机的VLAN配置时写入）：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">MAC</th>
        <th align="center">VLAN-ID</th>
        <th align="center">Port</th>
    </tr>
    <tr>
        <td align="center"><font color="blue">AA-AA-AA-AA-AA-AA</font></td>
        <td align="center">2</td>
        <td align="center">2</td>
    </tr>
    <tr>
        <td align="center">BB-BB-BB-BB-BB-BB</td>
        <td align="center">3</td>
        <td align="center">3</td>
    </tr>
</table>

<p><strong>L3_SW</strong>的ARP缓存表内容如下：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center">IP</th>
        <th align="center">MAC</th>
        <!-- <th align="center">VLAN-ID</th>
        <th align="center">Port</th> -->
    </tr>
    <tr>
        <td align="center"><font color="blue">1.1.1.2</font></td>
        <td align="center"><font color="blue">AA-AA-AA-AA-AA-AA</font></td>
        <!-- <td align="center">2</td>
        <td align="center">2</td> -->
    </tr>
    <tr>
        <td align="center">2.1.1.2</td>
        <td align="center">BB-BB-BB-BB-BB-BB</td>
        <!-- <td align="center">3</td>
        <td align="center">3</td> -->
    </tr>
</table>

<p><strong>L3_SW</strong>硬件转发<strong>PC_B</strong>响应<strong>PC_A</strong>的应答报文内容如下：</p>
<table width="1900" border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <!-- <th colspan="7">Ethernet II Header</th> -->
        <th colspan="3">Ethernet II Header</th>
        <th colspan="12">IP Header</th>
        <th colspan="6">ICMP Frame</th>
        <th>End</th>
    </tr>
    <tr>
        <td align="center">字段</td>
        <td align="center">DA</td>
        <td align="center">SA</td>
        <!-- <td align="center">Type</td>
        <td>UserPriority</td>
        <td>Flag</td>
        <td>VLAN-ID</td> -->
        <td align="center">Type</td>
        <td>Version</td>
        <td>HeaderLen</td>
        <td>Priority</td>
        <td>TotalLen</td>
        <td>Identification</td>
        <td align="center">Flags</td>
        <td align="center">FragmentOffset</td>
        <td align="center">TTL</td>
        <td align="center">Protocol</td>
        <td align="center">Checksum</td>
        <td align="center">SrcIP</td>
        <td align="center">DesIP</td>
        <td align="center">Type</td>
        <td align="center">Code</td>
        <td align="center">Checksum</td>
        <td align="center">Identifier</td>
        <td align="center">SequenceNumber</td>
        <td align="center">OptionalData</td>
        <td align="center">FCR</td>
    </tr>
    <tr>
        <td align="center">字段长度(Bytes)</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <!-- <td align="center">2</td>
        <td align="center">3bits</td>
        <td align="center">1bit</td>
        <td align="center">12bits</td> -->
        <td align="center">2</td>
        <td align="center">4bits</td>
        <td align="center">4bits</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">3bits</td>
        <td align="center">13bits</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">6</td>
        <td align="center">6</td>
        <td align="center">1</td>
        <td align="center">1</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">2</td>
        <td align="center">/</td>
        <td align="center">4</td>
    </tr>
    <tr>
        <td align="center">填充值(0x)</td>
        <td align="center"><font color="blue">AA-AA-AA-AA-AA-AA</font></td>
        <td align="center"><font color="red">CC-CC-CC-CC-CC-CC</font></td>
        <!-- <td align="center"><b>0x8100</b></td>
        <td align="center">000B</td>
        <td align="center">0B</td>
        <td align="center"><b>10B</b></td> -->
        <td align="center"><b>0x0800</b></td>
        <td align="center">0100B</td>
        <td align="center">0101B</td>
        <td align="center">0x00</td>
        <td align="center">0x005F</td>
        <td align="center">0x0000</td>
        <td align="center">000B</td>
        <td align="center">0B</td>
        <td align="center">0xFF</td>
        <td align="center"><b>0x01</b></td>
        <td align="center">/</td>
        <td align="center"><font color="red">01-01-01-02</font></td>
        <td align="center"><font color="blue">02-01-01-02</font></td>
        <td align="center"><b>0x00</b></td>
        <td align="center">0</td>
        <td align="center">/</td>
        <td align="center">/</td>
        <td align="center">0x01000001</td>
        <td align="center">0...0</td>
        <td align="center">/</td>
    </tr>
</table>

<p>PC_A成功接收到PC_B发出的ICMP应答报文后整个Ping过程结束。<br>此后PC_A和PC_B之间往返报文都将（经过查MAC地址表，查交换机芯片三层转发表后）由交换芯片<strong>直接完成硬件三层转发</strong>。<br>经过上述流程的分析可知，三层交换机充分利用“<strong>一次路由、多次转换</strong>”的原理实现了转发性能与三层交换复杂业务的完美统一。</p>
<p>注：</p>
<ul>
<li>一次路由：即首包通过CPU参与 <strong>请求&#x2F;转发</strong>，再根据应答 <strong>学习&#x2F;建立</strong> 交换芯片 <strong>硬件表项</strong>的“路由”过程（相对较慢，完成三层交换的必须的表项学习&#x2F;建立流程）</li>
<li>多次交换：后续往返报文都可由交换芯片<strong>直接硬件三层转发</strong>（更快，提升转发性能）</li>
</ul>
<h2 id="3-5-组网二下的三层转发流程介绍"><a href="#3-5-组网二下的三层转发流程介绍" class="headerlink" title="3.5. 组网二下的三层转发流程介绍"></a>3.5. 组网二下的三层转发流程介绍</h2><p>另一种组网示例如下图所示，图中标明了两台主机的MAC、IP、网关以及两台三层交换机的MAC、不同VLAN配置的三层接口IP。且两台交换机分别预配置了静态路由：<br>其中 L3_SW1 静态路由配置为 ip route 2.1.1.0 255.255.255.0 3.1.1.2，L3_SW2 静态路由配置为 ip route 1.1.1.0 255.255.255.0 3.1.1.1。</p>
<p>当 <b><font color="red" style="">PC_A Ping PC_B</font></b> ，即发起 ICMP 请求时，三层转发处理流程如下（假设主机均暂未建立任何硬件转发表项）：</p>
<p>由于组网转发中间许多转发详细流程与具体请求帧分析已在3.5中介绍，这里不再赘述，下面主要介绍此组网示例下三层转发流程：</p>
<p>总结，其与组网一的主要区别在于第7步，组网一的L3_SW交换机在CPU查找软件路由表时<strong>匹配了目的IP的直连网段</strong>（2.1.1.0），然后广播找到直连网段内的PC_B并建立通信；而在本组网二中，L3_SW1交换机在CPU查找软件路由时<b><font color="red" style="">匹配了静态路由表项中某一下一跳网段（2.1.1.0&#x2F;24）</font></b>。组网二多出的流程为，需将ICMP报文转发给下一跳(L3_SW2交换机)，并由L3_SW2交换机重复执行类似的CPU软件路由表查询、建表、转发ICMP请求报文、并最终转发ICMP应答报文回到L3_SW1，其他过程与组网一类似。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><h2 id="4-1-二三层转发对比"><a href="#4-1-二三层转发对比" class="headerlink" title="4.1. 二三层转发对比"></a>4.1. 二三层转发对比</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <th align="center"><b>二层转发</b></th>
        <th align="center"><b>三层转发</b></th>
    </tr>
    <tr>
        <td align="center">转发依据</td>
        <td align="center">MAC地址和VID号</td>
        <td align="center">IP地址</td>
    </tr>
    <tr>
        <td align="center">数据交换范围</td>
        <td align="center">同一网段</td>
        <td align="center">跨网段</td>
    </tr>
    <tr>
        <td align="center">所属OSI网络模型层级</td>
        <td align="center">数据链路层（第二层）</td>
        <td align="center">网络层（第三层）</td>
    </tr>
    <tr>
        <td align="center">是否需要二次封装</td>
        <td align="center">否</td>
        <td align="center">是</td>
    </tr>
</table>

<h2 id="4-2-主机间通信机制及何时二三层转发？"><a href="#4-2-主机间通信机制及何时二三层转发？" class="headerlink" title="4.2. 主机间通信机制及何时二三层转发？"></a>4.2. 主机间通信机制及何时二三层转发？</h2><ul>
<li>当前主机收到以太网数据帧，解析<strong>目的IP</strong></li>
<li>判断目的IP与自己IP是否位于同一网段（和掩码逻辑与）：<ul>
<li>若位于同一网段，则采用<strong>二层转发</strong>。（流程为：当前主机广播ARP请求（获取目的MAC地址），然后填充目的MAC并发送报文。）</li>
<li>若为不同网段，则采用<strong>三层转发</strong>，通过网关转发报文。流程为：当前主机向网关发送ARP请求（获取网关的MAC地址），然后将网关MAC地址作为目的MAC地址并发送报文（注：此时目的IP仍未改动）</li>
</ul>
</li>
</ul>
<p><strong>其他判定方式</strong>：交换芯片中的<strong>MAC地址表</strong>中会记录三层接口MAC+VID表项，且存在<strong>MyStation表</strong>。当报文进来时，用报文的目的MAC检索这两张表，若存在则需<strong>三层转发</strong>。</p>
<h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h1><ul>
<li>《H3C网络之路第六期——交换专题》</li>
<li><a href="https://blog.csdn.net/zqixiao_09/article/details/51170795">ARP 基础知识解析</a></li>
<li><a href="https://blog.csdn.net/qq_38902271/article/details/110213222">ARP请求的详细过程</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>VLAN</title>
    <url>/2021/08/03/VLAN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul>
<li>虚拟局域网（Virtual Local Area Network，VLAN），是将局域网从逻辑上划分为一个个网段，从而实现虚拟工作组的一种交换技术。</li>
<li>每个网段内所有主机间的通讯和广播仅限于该VLAN内，广播帧不会被转发到其他网段，VLAN间不能进行直接通信，从而实现了对广播域的分割和隔离。</li>
</ul>
<a id="more"></a>

<h2 id="1-1-VLAN产生背景"><a href="#1-1-VLAN产生背景" class="headerlink" title="1.1. VLAN产生背景"></a>1.1. VLAN产生背景</h2><ul>
<li>网桥、集线器或交换机构成的整个物理局域网同属于一个广播域，任何一个广播帧或多播帧都将被光波导整个局域网的每一台主机</li>
<li>在网络通讯中，广播信息是普遍存在的，这些广播帧将占用大量网络带宽，导致网络速度和通讯效率下降，增加网络主机处理广播信息的负荷</li>
<li>蠕虫病毒泛滥，为防止网络阻塞和瘫痪，需要进行有效的广播域隔离</li>
</ul>
<h2 id="1-2-VLAN作用"><a href="#1-2-VLAN作用" class="headerlink" title="1.2. VLAN作用"></a>1.2. VLAN作用</h2><ul>
<li><strong>限制广播域</strong>：广播域被限制在一个VLAN内，节省了带宽，提高了网络处理能力。</li>
<li><strong>增强局域网的安全性</strong>：不同VLAN内的报文在传输时是相互隔离的，即一个VLAN内的用户不能和其它VLAN内的用户直接通信。</li>
<li><strong>提高网络的健壮性</strong>：故障被限制在一个VLAN内，本VLAN内的故障不会影响其他VLAN的正常工作。</li>
<li><strong>灵活构建虚拟工作组</strong>：用VLAN可以划分不同的用户到不同的工作组，同一工作组的用户也不必局限于某一固定的物理范围，网络构建和维护更方便灵活。</li>
</ul>
<h1 id="2-静态VLAN与动态VLAN"><a href="#2-静态VLAN与动态VLAN" class="headerlink" title="2. 静态VLAN与动态VLAN"></a>2. 静态VLAN与动态VLAN</h1><h2 id="2-1-静态VLAN"><a href="#2-1-静态VLAN" class="headerlink" title="2.1. 静态VLAN"></a>2.1. 静态VLAN</h2><p>明确指定个端口所属VLAN的设定方法，也称为基于端口的VLAN。</p>
<p>特点：是将交换机按端口进行分组，每组定义一个VLAN，属于同一个VLAN的端口，可来自一台或多台交换机（即可跨多台交换机设置VLAN）。</p>
<h2 id="2-2-动态VLAN"><a href="#2-2-动态VLAN" class="headerlink" title="2.2. 动态VLAN"></a>2.2. 动态VLAN</h2><p>根据每个端口所连的计算机，动态设置端口所属VLAN的设定方法。</p>
<table>
<thead>
<tr>
<th align="left">划分依据</th>
<th align="left">说明</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基于端口</td>
<td align="left">根据以太网交换机的端口来划分</td>
<td align="left">定义VLAN成员时非常简单(只要将所有的端口都指定一下就可以了)</td>
<td align="left">如果VLAN A的用户离开了原来的端口，到了一个新的交换机的某个端口，那么就必须重新定义。</td>
</tr>
<tr>
<td align="left">基于MAC地址</td>
<td align="left">根据端口所连计算机的网卡MAC地址，决定该端口所属的VLAN。<br>eg.MAC地址为”00-0C-6E-E1-1B-36”的计算机被设置为属于VLAN2，则该计算机连接的交换机端口会被自动划归为VLAN2。</td>
<td align="left">当用户物理位置移动时，即从一个交换机换到其他的交换机时，VLAN不用重新配置，可以认为这种根据MAC地址的划分方法是基于用户的VLAN</td>
<td align="left">初始化时，所有的用户都必须进行配置，若用户数量较大则配置量非常大。<br>此外这种划分的方法也导致了交换机执行效率的降低，因为在每一个交换机的端口都可能存在很多个VLAN组的成员，这样就无法限制广播包了。</td>
</tr>
<tr>
<td align="left">基于子网</td>
<td align="left">根据每个主机的网络层地址划分的。虽然这种划分方法是根据网络地址，比如IP地址，但它不是路由，与网络层的路由毫无关系</td>
<td align="left">用户的物理位置改变了，不需要重新配置所属的VLAN。<br>此外无需附加的帧标签来识别VLAN，可减少网络的通信量</td>
<td align="left">效率低，因为检查每一个数据包的网络层地址是需要消耗处理时间的，一般的交换机芯片都可以自动检查网络上数据包的以太网帧头，但要让芯片能检查IP帧头，需要更高的技术，同时更费时</td>
</tr>
<tr>
<td align="left">基于协议</td>
<td align="left">根据报文的协议类型和封装格式进行VLAN的划分。<br>如：IP、IPX、AppleTalk协议族；Ethernet II，802.3，802.3&#x2F;802.2 LLC， 802.3&#x2F;802.2 SNAP等封装格式</td>
<td align="left">一个交换机换到其他的交换机时，VLAN不用重新配置</td>
<td align="left">初始化时，所有的用户都必须进行配置，配置量大、执行效率低、无法限制广播包</td>
</tr>
</tbody></table>
<h2 id="2-3-动静态VLAN对比"><a href="#2-3-动静态VLAN对比" class="headerlink" title="2.3. 动静态VLAN对比"></a>2.3. 动静态VLAN对比</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">静态VLAN</th>
<th align="center">动态VLAN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">划分方式</td>
<td align="center">基于端口</td>
<td align="center">基于MAC地址、子网、用户</td>
</tr>
<tr>
<td align="center">特点</td>
<td align="center">需人为设定，需设定的端口数目较多，工作量大</td>
<td align="center">自动设定，灵活，省事</td>
</tr>
</tbody></table>
<h1 id="3-802-1Q-VLAN帧格式"><a href="#3-802-1Q-VLAN帧格式" class="headerlink" title="3. 802.1Q VLAN帧格式"></a>3. 802.1Q VLAN帧格式</h1><h2 id="3-1-传统以太网帧格式"><a href="#3-1-传统以太网帧格式" class="headerlink" title="3.1. 传统以太网帧格式"></a>3.1. 传统以太网帧格式</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">目的MAC地址</th>
<th align="center">源MAC地址</th>
<th align="center">长度或类型</th>
<th align="center">数据</th>
<th align="center">FCS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">区段大小（bytes））</td>
<td align="center">6</td>
<td align="center">6</td>
<td align="center">2</td>
<td align="center">46~1500</td>
<td align="center">4</td>
</tr>
</tbody></table>
<h2 id="3-2-802-1Q帧格式"><a href="#3-2-802-1Q帧格式" class="headerlink" title="3.2. 802.1Q帧格式"></a>3.2. 802.1Q帧格式</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">目的MAC地址</th>
<th align="center">源MAC地址</th>
<th align="center">802.1Q Tag</th>
<th align="center">长度或类型</th>
<th align="center">数据</th>
<th align="center">FCS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">区段大小（bytes））</td>
<td align="center">6</td>
<td align="center">6</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">46~1500</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>其中802.1Q Tag中又细分了TPID、PRI、CFI和VID4个字段，四个字段说明如下：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">长度（bits）</th>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TPID</td>
<td align="center">16</td>
<td align="left">Tag Protocol ID，表示这个帧是否带标签</td>
<td align="left">如果该值取<strong>0x8100</strong>，则表示这个帧是带Tag的帧，相反表示其是传统不带Tag标签的帧；<br>该帧与传统的以太网帧中该位置的Type&#x2F;Length字段兼容</td>
</tr>
<tr>
<td align="center">PRI</td>
<td align="center">3</td>
<td align="left">Priority，表示帧的优先级</td>
<td align="left">取值范围为0~7，值越大优先级越高，在交换机阻塞时，优先发送优先级较高的帧</td>
</tr>
<tr>
<td align="center">CFI</td>
<td align="center">1</td>
<td align="left">标准格式指示位</td>
<td align="left">-</td>
</tr>
<tr>
<td align="center">VID</td>
<td align="center">12</td>
<td align="left">VLAN Identifier，表示该帧所属的VLAN</td>
<td align="left">VLAN的有效取值范围为1~4094（0和4095为保留取值）</td>
</tr>
</tbody></table>
<h1 id="4-VLAN间的通信"><a href="#4-VLAN间的通信" class="headerlink" title="4. VLAN间的通信"></a>4. VLAN间的通信</h1><p>可使用路由器或三层交换机为VLAN设置路由，在三层交换机中划分VLAN，以支持VLAN间的相互通讯。</p>
<h2 id="4-1-同VLAN内主机的跨域通讯"><a href="#4-1-同VLAN内主机的跨域通讯" class="headerlink" title="4.1. 同VLAN内主机的跨域通讯"></a>4.1. 同VLAN内主机的跨域通讯</h2><ol>
<li>在交换机端口各拿num(VLAN)个端口级联，专门用于对应VLAN的主机跨交换机通讯</li>
<li>让交换机间的互联链路汇集到一条链路上（<strong>汇聚链路</strong>、<strong>主干链路</strong>），该链路的端口被称为汇聚连接端口，该链路允许各VLAN的通讯流过</li>
</ol>
<h2 id="4-2-不同接口类型下的VLAN间通信流程"><a href="#4-2-不同接口类型下的VLAN间通信流程" class="headerlink" title="4.2. 不同接口类型下的VLAN间通信流程"></a>4.2. 不同接口类型下的VLAN间通信流程</h2><p>交换机上的端口分为三种一种是接入层端口<strong>直连</strong>设备的，叫做Access；一种是交换机和交换机之间的端口负责<strong>汇聚</strong>的叫做Trunk，还有一种是Access与Trunk混合的模式，叫做Hybrid。</p>
<table>
<thead>
<tr>
<th align="left">接口类型</th>
<th align="left">不带Tag报文处理</th>
<th align="left">带Tag报文处理</th>
<th align="left">发送帧处理流程</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Access接口</td>
<td align="left">接收该报文，并打上缺省的VLAN ID</td>
<td align="left">当VLAN ID与缺省VLAN ID相同（合法）时，接收该报文；<br>不合法时丢弃该报文</td>
<td align="left">先剥离帧的PVID Tag，然后再发送</td>
</tr>
<tr>
<td align="left">Trunk接口</td>
<td align="left">打上缺省的VLAN ID，当缺省VLAN ID在允许通过的VLAN ID列表里（合法）时，接收该报文；<br>不合法时丢弃该报文</td>
<td align="left">当VLAN ID在接口允许通过的VLAN ID列表里（合法）时，接收该报文；<br>不合法时丢弃该报文</td>
<td align="left">若不是接口允许通过的VLAN ID时，则丢弃该报文。<br>当VLAN ID与缺省VLAN ID相同（合法）时，去掉Tag，发送该报文。<br>不合法时保持原有Tag，发送该报文</td>
</tr>
<tr>
<td align="left">Hybrid接口</td>
<td align="left">打上缺省的VLAN ID，当缺省VLAN ID在允许通过的VLAN ID列表里（合法）时，接收该报文。<br>不合法时丢弃该报文</td>
<td align="left">当VLAN ID在接口允许通过的VLAN ID列表里（合法）时，接收该报文；<br>不合法时丢弃该报文</td>
<td align="left">当VLAN ID是该接口允许通过的VLAN ID时，发送该报文。<br>可以通过命令设置发送时是否携带Tag</td>
</tr>
</tbody></table>
<h2 id="4-3-Tag-x2F-Untag报文的处理原则"><a href="#4-3-Tag-x2F-Untag报文的处理原则" class="headerlink" title="4.3. Tag&#x2F;Untag报文的处理原则"></a>4.3. Tag&#x2F;Untag报文的处理原则</h2><p>背景：在交换机内部，为快速高效的处理，<strong>报文都是带tag转发的</strong>。（交换机上很多会配置多个VLAN，不同VLAN的流量仅能靠tag标签区分）</p>
<h3 id="4-3-1-报文进入switch时"><a href="#4-3-1-报文进入switch时" class="headerlink" title="4.3.1. 报文进入switch时"></a>4.3.1. 报文进入switch时</h3><p>在接收报文时，交换机的主要职责是——根据tag&#x2F;untag属性和端口属性决定<strong>是否允许</strong>该报文进入该端口：</p>
<ul>
<li>报文属性为untag：允许报文进入该端口，并打上PVID的VLAN tag（与端口属性无关）</li>
<li>报文属性为tag，且此交换机端口为Access端口：若端口允许该报文tag标明的VLAN通过，接收并处理报文；若不允许则丢弃报文</li>
<li>报文属性为tag，且此交换机端口为Trunk&#x2F;Hybrid端口：若端口允许该报文tag标明的VLAN通过，接收并处理报文；若不允许则丢弃报文</li>
</ul>
<h3 id="4-3-2-报文出switch时"><a href="#4-3-2-报文出switch时" class="headerlink" title="4.3.2. 报文出switch时"></a>4.3.2. 报文出switch时</h3><p>在转发报文时，主要职责是——根据出端口属性决定是否携带tag转发报文：</p>
<ul>
<li>出端口为Access端口：不带tag转发（将标签剥离）</li>
<li>出端口为Trunk端口：若报文所在的VLAN和PVID相同，则报文不带tag转发；否则带tag转发</li>
<li>出端口为Hybrid端口：根据报文所在的VLAN配置是&#x2F;否为tag，决定是&#x2F;否带tag转发</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>sonic 全量编译及指定容器编译简介</title>
    <url>/2021/09/26/building_sonic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>sonic_version 201911</p>
</blockquote>
<h1 id="1-全量编译-x2F-更换版本步骤回顾"><a href="#1-全量编译-x2F-更换版本步骤回顾" class="headerlink" title="1. 全量编译&#x2F;更换版本步骤回顾"></a>1. 全量编译&#x2F;更换版本步骤回顾</h1><h2 id="1-1-全量编译命令"><a href="#1-1-全量编译命令" class="headerlink" title="1.1. 全量编译命令"></a>1.1. 全量编译命令</h2><blockquote>
<p>编译环境：开发机</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $SONIC_CODE_DIR</span><br><span class="line">rm -rf target/</span><br><span class="line">make configure PLATFORM=broadcom</span><br><span class="line">make target/sonic.bin</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-2-全量更换版本命令"><a href="#1-2-全量更换版本命令" class="headerlink" title="1.2. 全量更换版本命令"></a>1.2. 全量更换版本命令</h2><blockquote>
<p>安装环境：交换机<br>将全量安装包 sonic.bin 上传到交换机后执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sonic_installer install -f /home/admin/sonic.bin</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<h1 id="2-编译及更新单个容器步骤"><a href="#2-编译及更新单个容器步骤" class="headerlink" title="2. 编译及更新单个容器步骤"></a>2. 编译及更新单个容器步骤</h1><h2 id="2-1-以-bgp-为例"><a href="#2-1-以-bgp-为例" class="headerlink" title="2.1. 以 bgp 为例"></a>2.1. 以 bgp 为例</h2><blockquote>
<p>bgp 容器镜像文件： <code>docker-fpm-frr.gz</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在编译机的代码库的 &lt;code&gt;<span class="variable">$SONIC_CODE_DIR</span>&lt;/code&gt; 路径下，删除（待编译容器镜像）旧的镜像包</span></span><br><span class="line">rm target/docker-fpm-frr.gz</span><br><span class="line">rm target/debs/stretch/frr_7.2-sonic-0_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 bgp 容器镜像包（约 8 min）</span></span><br><span class="line">make target/docker-fpm-frr.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传到交换机</span></span><br><span class="line">ls -l $SONIC_CODE_DIR/target/docker-fpm-frr.gz</span><br><span class="line">scp $SONIC_CODE_DIR/target/docker-fpm-frr.gz admin@A.B.C.D:/home/admin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录交换机</span></span><br><span class="line">ssh admin@A.B.C.D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认容器镜像包信息</span></span><br><span class="line">ls -l /home/admin/docker-fpm-frr.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独更新 bgp 容器（无需 reboot 宿主机）</span></span><br><span class="line">sudo sonic_installer upgrade_docker --cleanup_image bgp /home/admin/docker-fpm-frr.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-2-以-lldp-为例"><a href="#2-2-以-lldp-为例" class="headerlink" title="2.2. 以 lldp 为例"></a>2.2. 以 lldp 为例</h2><blockquote>
<p>lldp 容器镜像文件： <code>docker-lldp-sv2.gz</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在编译机的代码库的 &lt;code&gt;<span class="variable">$SONIC_CODE_DIR</span>&lt;/code&gt; 路径下，删除（待编译容器镜像）旧的镜像包</span></span><br><span class="line">rm target/docker-lldp-sv2.gz</span><br><span class="line">rm target/debs/lldpd_1.0.4-1_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 lldp 容器镜像包（约 8 min）</span></span><br><span class="line">make  target/docker-lldp-sv2.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传到交换机</span></span><br><span class="line">ls -l $SONIC_CODE_DIR/target/docker-lldp-sv2.gz</span><br><span class="line">scp $SONIC_CODE_DIR/target/docker-lldp-sv2.gz admin@A.B.C.D:/home/admin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录交换机</span></span><br><span class="line">ssh admin@A.B.C.D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认容器镜像包信息</span></span><br><span class="line">ls -l /home/admin/docker-lldp-sv2.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独更新 lldp 容器（无需 reboot 宿主机）</span></span><br><span class="line">sudo sonic_installer upgrade_docker --cleanup_image lldp /home/admin/docker-lldp-sv2.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-3-以-pmon-为例"><a href="#2-3-以-pmon-为例" class="headerlink" title="2.3. 以 pmon 为例"></a>2.3. 以 pmon 为例</h2><blockquote>
<p>pmon 容器镜像文件： <code>docker-platform-monitor.gz</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在编译机的代码库的 &lt;code&gt;<span class="variable">$SONIC_CODE_DIR</span>&lt;/code&gt; 路径下，删除（待编译容器镜像）旧的镜像包</span></span><br><span class="line">rm target/docker-platform-monitor.gz</span><br><span class="line">rm target/python-debs/python-sonic-hwmgrd_1.0-1_all.deb</span><br><span class="line">rm target/python-debs/python-sonic-syseepromd_1.0-1_all.deb</span><br><span class="line">rm target/python-debs/python-sonic-psud_1.0-1_all.deb</span><br><span class="line">rm target/python-debs/python-sonic-xcvrd_1.0-1_all.deb</span><br><span class="line">rm target/python-debs/python-sonic-ledd_1.1-1_all.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 pmon 容器镜像包（约  min）</span></span><br><span class="line">make target/docker-platform-monitor.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传到交换机</span></span><br><span class="line">ls -l $SONIC_CODE_DIR/target/docker-platform-monitor.gz</span><br><span class="line">scp $SONIC_CODE_DIR/target/docker-platform-monitor.gz admin@A.B.C.D:/home/admin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录交换机</span></span><br><span class="line">ssh admin@A.B.C.D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认容器镜像包信息</span></span><br><span class="line">ls -l /home/admin/docker-platform-monitor.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独更新 pmon 容器（无需 reboot 宿主机）</span></span><br><span class="line">sudo sonic_installer upgrade_docker --cleanup_image pmon /home/admin/docker-platform-monitor.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-4-以-radv-为例"><a href="#2-4-以-radv-为例" class="headerlink" title="2.4. 以 radv 为例"></a>2.4. 以 radv 为例</h2><blockquote>
<p>radv 容器镜像文件： <code>docker-router-advertiser.gz</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在编译机的代码库的 &lt;code&gt;<span class="variable">$SONIC_CODE_DIR</span>&lt;/code&gt; 路径下，删除（待编译容器镜像）旧的镜像包</span></span><br><span class="line">rm target/docker-router-advertiser.gz</span><br><span class="line">rm target/debs/stretch/radvd-dbgsym_2.17-2~bpo9+1_amd64.deb</span><br><span class="line">rm target/debs/stretch/radvd_2.17-2~bpo9+1_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 radv 容器镜像包（约 10 min）</span></span><br><span class="line">make target/docker-router-advertiser.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传到交换机</span></span><br><span class="line">ls -l $SONIC_CODE_DIR/target/docker-router-advertiser.gz</span><br><span class="line">scp $SONIC_CODE_DIR/target/docker-router-advertiser.gz admin@A.B.C.D:/home/admin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录交换机</span></span><br><span class="line">ssh admin@A.B.C.D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认容器镜像包信息</span></span><br><span class="line">ls -l /home/admin/docker-router-advertiser.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独更新 radv 容器（无需 reboot 宿主机）</span></span><br><span class="line">sudo sonic_installer upgrade_docker --cleanup_image radv /home/admin/docker-router-advertiser.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-5-以-swss-为例"><a href="#2-5-以-swss-为例" class="headerlink" title="2.5. 以 swss 为例"></a>2.5. 以 swss 为例</h2><blockquote>
<p>swss 容器镜像文件： <code>docker-orchagent.gz</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在编译机的代码库的 &lt;code&gt;<span class="variable">$SONIC_CODE_DIR</span>&lt;/code&gt; 路径下，删除（待编译容器镜像）旧的镜像包</span></span><br><span class="line">rm target/docker-orchagent.gz</span><br><span class="line">rm target/debs/stretch/swss_1.0.0_amd64.deb</span><br><span class="line">rm target/debs/stretch/libswsscommon_1.0.0_amd64.deb</span><br><span class="line">rm target/debs/stretch/python-swsscommon_1.0.0_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 swss 容器镜像包（约 13 min）</span></span><br><span class="line">make target/docker-orchagent.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传到交换机</span></span><br><span class="line">ls -l $SONIC_CODE_DIR/target/docker-orchagent.gz</span><br><span class="line">scp $SONIC_CODE_DIR/target/docker-orchagent.gz admin@A.B.C.D:/home/admin/</span><br><span class="line"><span class="meta">$</span><span class="bash">$</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录交换机</span></span><br><span class="line">ssh admin@A.B.C.D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认容器镜像包信息</span></span><br><span class="line">ls -l /home/admin/docker-orchagent.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独更新 swss 容器（无需 reboot 宿主机）</span></span><br><span class="line">sudo sonic_installer upgrade_docker --cleanup_image swss /home/admin/docker-orchagent.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-6-以-snmp-为例"><a href="#2-6-以-snmp-为例" class="headerlink" title="2.6. 以 snmp 为例"></a>2.6. 以 snmp 为例</h2><blockquote>
<p>snmp 容器镜像文件： <code>docker-snmp-sv2.gz</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在编译机的代码库的 &lt;code&gt;<span class="variable">$SONIC_CODE_DIR</span>&lt;/code&gt; 路径下，删除（待编译容器镜像）旧的镜像包</span></span><br><span class="line">rm target/docker-snmp-sv2.gz</span><br><span class="line">rm target/debs/stretch/libsnmp30_5.7.3+dfsg-1.5_amd64.deb</span><br><span class="line">rm target/debs/stretch/libsnmp-base_5.7.3+dfsg-1.5_all.deb</span><br><span class="line">rm target/debs/stretch/libsnmp-dev_5.7.3+dfsg-1.5_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 snmp 容器镜像包</span></span><br><span class="line">make target/docker-snmp-sv2.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传到交换机</span></span><br><span class="line">ls -l $SONIC_CODE_DIR/target/docker-snmp-sv2.gz</span><br><span class="line">scp $SONIC_CODE_DIR/target/docker-snmp-sv2.gz admin@A.B.C.D:/home/admin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录交换机</span></span><br><span class="line">ssh admin@A.B.C.D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认容器镜像包信息</span></span><br><span class="line">ls -l /home/admin/docker-snmp-sv2.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独更新 snmp 容器（无需 reboot 宿主机）</span></span><br><span class="line">sudo sonic_installer upgrade_docker --cleanup_image snmp /home/admin/docker-snmp-sv2.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-7-以-teamd-为例"><a href="#2-7-以-teamd-为例" class="headerlink" title="2.7. 以 teamd 为例"></a>2.7. 以 teamd 为例</h2><blockquote>
<p>teamd 容器镜像文件： <code>docker-teamd.gz</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $SONIC_CODE_DIR</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在编译机的代码库的 &lt;code&gt;<span class="variable">$SONIC_CODE_DIR</span>&lt;/code&gt; 路径下，删除（待编译容器镜像）旧的镜像包</span></span><br><span class="line">rm target/docker-teamd.gz</span><br><span class="line">rm target/debs/stretch/libteam5_1.28-1_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 teamd 容器镜像包（约 8 min）</span></span><br><span class="line">make target/docker-teamd.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传到交换机</span></span><br><span class="line">ls -l $SONIC_CODE_DIR/target/docker-teamd.gz</span><br><span class="line">scp $SONIC_CODE_DIR/target/docker-teamd.gz admin@A.B.C.D:/home/admin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录交换机</span></span><br><span class="line">ssh admin@A.B.C.D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认容器镜像包信息</span></span><br><span class="line">ls -l /home/admin/docker-teamd.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独更新 teamd 容器（无需 reboot 宿主机）</span></span><br><span class="line">sudo sonic_installer upgrade_docker --cleanup_image teamd /home/admin/docker-teamd.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-8-以-syncd-为例（sonic-installer-不支持单独更换此容器）"><a href="#2-8-以-syncd-为例（sonic-installer-不支持单独更换此容器）" class="headerlink" title="2.8. 以 syncd 为例（sonic_installer 不支持单独更换此容器）"></a>2.8. <del>以 syncd 为例</del>（sonic_installer 不支持单独更换此容器）</h2><blockquote>
<p>syncd 容器镜像文件： <code>docker-syncd-brcm.gz</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在编译机的代码库的 &lt;code&gt;<span class="variable">$SONIC_CODE_DIR</span>&lt;/code&gt; 路径下，删除（待编译容器镜像）旧的镜像包</span></span><br><span class="line">rm target/docker-syncd-brcm.gz</span><br><span class="line">rm target/debs/stretch/syncd_1.0.0_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 syncd 容器镜像包（约  min）</span></span><br><span class="line">make target/docker-syncd-brcm.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传到交换机</span></span><br><span class="line">ls -l $SONIC_CODE_DIR/target/docker-syncd-brcm.gz</span><br><span class="line">scp $SONIC_CODE_DIR/target/docker-syncd-brcm.gz admin@A.B.C.D:/home/admin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录交换机</span></span><br><span class="line">ssh admin@A.B.C.D</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认容器镜像包信息</span></span><br><span class="line">ls -l /home/admin/docker-syncd-brcm.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独更新 syncd 容器（无需 reboot 宿主机）</span></span><br><span class="line">sudo sonic_installer upgrade_docker --cleanup_image syncd /home/admin/docker-syncd-brcm.gz</span><br></pre></td></tr></table></figure>

<h1 id="3-强制替换同版本镜像方式"><a href="#3-强制替换同版本镜像方式" class="headerlink" title="3. 强制替换同版本镜像方式"></a>3. 强制替换同版本镜像方式</h1><h2 id="3-1-以-syncd-为例"><a href="#3-1-以-syncd-为例" class="headerlink" title="3.1. 以 syncd 为例"></a>3.1. 以 syncd 为例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止旧 syncd 容器</span></span><br><span class="line">docker stop syncd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除旧 syncd 容器</span></span><br><span class="line">sudo docker rm -f syncd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除旧 syncd 镜像</span></span><br><span class="line">sudo docker rmi -f $(docker images | grep syncd  | awk &#x27;&#123; print $3 &#125;&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载新 syncd 镜像包</span></span><br><span class="line">sudo docker load &lt; /home/admin/docker-syncd-brcm.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过服务的方式自动创建新 syncd 容器</span></span><br><span class="line">sudo service syncd restart</span><br></pre></td></tr></table></figure>

<h2 id="3-2-以-swss-为例"><a href="#3-2-以-swss-为例" class="headerlink" title="3.2. 以 swss 为例"></a>3.2. 以 swss 为例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止旧 swss 容器</span></span><br><span class="line">docker stop swss</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除旧 swss 容器</span></span><br><span class="line">sudo docker rm -f swss</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除旧 swss 镜像</span></span><br><span class="line">sudo docker rmi -f $(docker images | grep docker-orchagent  | awk &#x27;&#123; print $3 &#125;&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载新 swss 镜像包</span></span><br><span class="line">sudo docker load &lt; /home/admin/docker-orchagent.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过服务的方式自动创建新 swss 容器</span></span><br><span class="line">sudo service swss restart</span><br></pre></td></tr></table></figure>

<h1 id="4-备注"><a href="#4-备注" class="headerlink" title="4. 备注"></a>4. 备注</h1><ul>
<li>编译时若报 Telemetry 失败可修改 <code>rules/config</code> 中如下配置，以关闭使能Telemetry：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ENABLE_SYSTEM_TELEMETRY = n</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sonic_installer upgrade_docker</code>的 OPTION参数说明如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sonic_installer upgrade_docker --help</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果</span></span><br><span class="line">Usage: sonic_installer upgrade_docker [OPTIONS] &lt;container_name&gt; URL</span><br><span class="line"></span><br><span class="line">  Upgrade docker image from local binary or URL</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -y, --yes</span><br><span class="line">  --cleanup_image  Clean up old docker image</span><br><span class="line">  --skip_check     Skip task check for docker upgrade</span><br><span class="line">  --tag TEXT       Tag for the new docker image</span><br><span class="line">  --warm           Perform warm upgrade</span><br><span class="line">  --help           Show this message and exit.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SONiC</tag>
      </tags>
  </entry>
  <entry>
    <title>抛开怯懦，勇于挑战</title>
    <url>/2017/09/17/challenge-yourself/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/challenge-yourself.jpg" class="full-image" />

<!-- 标签方式引用，要求版本在0.4.5或以上 -->
<blockquote class="blockquote-center">
<p> 你是否擅长去做某件事情，在你没有做之前是不知道的。人对于陌生的事情总是有点害怕和胆怯的。就像我们看到一条陌生的狗，你一般不太敢靠近，而自己家里养的狗就敢随便靠近。我们面对不擅长的陌生领域，就像遇到了一条陌生狗的状态。只要我们勇敢地迎着这条狗走过去，你会发现买际上大部分的狗是不敢咬你的。</p>
<div align = right>----俞敏洪</div>
</blockquote>

<a id="more"></a>

<p>切莫对陌生领域过于胆怯，<strong>勇敢地踏出舒适区，挑战自己</strong>。</p>
<p>望与君共勉！</p>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>自驱</tag>
      </tags>
  </entry>
  <entry>
    <title>函数指针 &amp; 指针函数</title>
    <url>/2018/10/09/functionPointerAndPointerfunction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/pointerFunction.jpg" class="full-image" />

<h1 id="1-指针函数"><a href="#1-指针函数" class="headerlink" title="1. 指针函数"></a>1. 指针函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;<span class="comment">//指针函数</span></span><br></pre></td></tr></table></figure>
<p>指针函数，即返回值为指针地址的函数。实质仍为函数，与普通函数的差异仅在于返回值比较特殊，为一个指针地址（当然需要告知编译器一个特定的类型处理数据类型）。</p>
<a id="more"></a>
<h2 id="1-1-指针函数实例1：-返回值为基本类型"><a href="#1-1-指针函数实例1：-返回值为基本类型" class="headerlink" title="1.1. 指针函数实例1： 返回值为基本类型"></a>1.1. 指针函数实例1： 返回值为基本类型</h2><p>函数实现：大小写互转。将传入字符串内所有小写字母转换为大写字母，所有大写字母转换为小写字母</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Cover</span> <span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Ptr )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p = Ptr;</span><br><span class="line">    <span class="keyword">char</span> ch = *p ;</span><br><span class="line">    <span class="keyword">while</span>( ch != <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span> ) &#123;</span><br><span class="line">            *p -= <span class="number">32</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span> ) &#123;</span><br><span class="line">            *p += <span class="number">32</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">        ch = *(++p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">15</span>] = &#123;<span class="string">&quot;Hello World!&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Previous: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Aftet: &quot;</span> &lt;&lt; <span class="built_in">Cover</span>(str) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-指针函数实例2：返回值为结构体"><a href="#1-2-指针函数实例2：返回值为结构体" class="headerlink" title="1.2. 指针函数实例2：返回值为结构体"></a>1.2. 指针函数实例2：返回值为结构体</h2><p>函数实现：获取并返回注册信息结构体。获取用户信息并返回包含用户名、用户密码的结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserMessage</span> &#123;</span></span><br><span class="line">    string userName;</span><br><span class="line">    string userPassword;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showUser</span> <span class="params">( struct UserMessage* user )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( user == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: register failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success: register success:)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;User: &quot;</span> &lt;&lt; user-&gt;userName &lt;&lt; endl &lt;&lt; <span class="string">&quot;Psw: &quot;</span> &lt;&lt; user-&gt;userPassword &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct UserMessage* <span class="title">Register</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    string str0, str1, str2;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Please input UserName:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; str0;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Please input Password:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; str1;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Please input Password again:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; str2;</span><br><span class="line">    <span class="keyword">if</span> ( str1.<span class="built_in">compare</span>(str2) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">//(string)(user-&gt;userName) = str0; //Doesn&#x27;t work</span></span><br><span class="line">        <span class="comment">//(string)(user-&gt;userPassword) = str1; //Doesn&#x27;t work</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UserMessage</span>* <span class="title">user</span> =</span> <span class="keyword">new</span> UserMessage;</span><br><span class="line">        *user = &#123; str0, str1 &#125;;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UserMessage</span>* <span class="title">Test</span> =</span> <span class="built_in">Register</span>();</span><br><span class="line">    <span class="built_in">showUser</span>(Test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img data-src="../../../../uploads/functionPointer.jpg" class="full-image" />
# 2. 函数指针
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">char</span> ch);<span class="comment">//函数指针</span></span><br></pre></td></tr></table></figure>
函数指针，即指针地址指向一个函数入口地址的指针。实质任为指针。我们可以通过改变这个指针的不同地址调用同型的不同函数。

<h2 id="2-1-函数指针实例1：-通过一个指针调用同型的不同函数"><a href="#2-1-函数指针实例1：-通过一个指针调用同型的不同函数" class="headerlink" title="2.1. 函数指针实例1： 通过一个指针调用同型的不同函数"></a>2.1. 函数指针实例1： 通过一个指针调用同型的不同函数</h2><p>代码实现：通过改变一个指针地址的赋值，以调用同型的不同函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowOnce</span> <span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No.1 &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowTwice</span> <span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No.&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowThrice</span> <span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No.&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*fun)(string);<span class="comment">//函数指针定义</span></span><br><span class="line">    fun = ShowOnce;</span><br><span class="line">    (*fun)(<span class="string">&quot;ShowOnce&quot;</span>);<span class="comment">//通过函数指针调用 函数1</span></span><br><span class="line"></span><br><span class="line">    fun = ShowTwice;</span><br><span class="line">    (*fun)(<span class="string">&quot;ShowTwice&quot;</span>);<span class="comment">//通过函数指针调用 函数2</span></span><br><span class="line"></span><br><span class="line">    fun = ShowThrice;</span><br><span class="line">    (*fun)(<span class="string">&quot;ShowThrice&quot;</span>);<span class="comment">//通过函数指针调用 函数3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-函数指针实例2：-通过一个指针调用同型的不同函数2"><a href="#2-2-函数指针实例2：-通过一个指针调用同型的不同函数2" class="headerlink" title="2.2. 函数指针实例2： 通过一个指针调用同型的不同函数2"></a>2.2. 函数指针实例2： 通过一个指针调用同型的不同函数2</h2><p>代码实现：通过改变一个指针地址的赋值，以调用同型的不同函数，与实例1区别在多个形参，需特别注意函数指针形参类型必须与调用的函数形参类型一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span> <span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;<span class="comment">//加</span></span><br><span class="line">    <span class="keyword">return</span> (num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Subtract</span> <span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;<span class="comment">//减</span></span><br><span class="line">    <span class="keyword">return</span> (num1 - num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Multiply</span> <span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;<span class="comment">//乘</span></span><br><span class="line">    <span class="keyword">return</span> (num1 * num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Divide</span> <span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;<span class="comment">//除</span></span><br><span class="line">    <span class="keyword">return</span> (num1 / num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">double</span></span> (*fun)(<span class="keyword">double</span>, <span class="keyword">double</span>);<span class="comment">//函数指针定义</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Test (*fun)(5,3) :&quot;</span> &lt;&lt; endl &lt;&lt;endl;</span><br><span class="line">    fun = Add;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    fun = Subtract;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Subtract: &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    fun = Multiply;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Multiply: &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    fun = Divide;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Divide: &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-函数指针高级应用：通过函数指针测试不同函数的运行时间（函数指针作为形参）"><a href="#2-3-函数指针高级应用：通过函数指针测试不同函数的运行时间（函数指针作为形参）" class="headerlink" title="2.3. 函数指针高级应用：通过函数指针测试不同函数的运行时间（函数指针作为形参）"></a>2.3. 函数指针高级应用：通过函数指针测试不同函数的运行时间（函数指针作为形参）</h2><p>代码实现：通过形参传入一个函数指针，可在函数体内调用该函数指针形参指向的函数，以测试不同函数的运行时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10   <span class="comment">//多项式最大项数(9阶)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fun_x 1.1 <span class="comment">//多项式x的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXK 1e3  <span class="comment">//被测函数最大重复调用次数</span></span></span><br><span class="line"><span class="keyword">double</span> a[MAXN];   <span class="comment">//多项式系数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFunctionUsingTime</span> <span class="params">(<span class="keyword">double</span> (*fun)(<span class="keyword">void</span>))</span></span>; <span class="comment">// *******函数指针作为形参 *******</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXN; i++) &#123; <span class="comment">//赋值项系数</span></span><br><span class="line">        a[i] = (<span class="keyword">double</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算Function1用时</span></span><br><span class="line">    <span class="built_in">showFunctionUsingTime</span>(Function1);</span><br><span class="line">    <span class="comment">//计算Function2用时</span></span><br><span class="line">    <span class="built_in">showFunctionUsingTime</span>(Function2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function1</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=(MAXN<span class="number">-1</span>); i++) &#123;</span><br><span class="line">        p += (a[i] * <span class="built_in">pow</span>(Fun_x, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function2</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p = a[MAXN<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=(MAXN<span class="number">-1</span>); i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        p = a[i<span class="number">-1</span>] + Fun_x * p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFunctionUsingTime</span> <span class="params">(<span class="keyword">double</span> (*fun)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, stop;</span><br><span class="line">    <span class="keyword">double</span> duration; <span class="comment">//运行时间　变量</span></span><br><span class="line">    <span class="comment">//计算Function1用时</span></span><br><span class="line">    start = <span class="built_in">clock</span>();<span class="comment">//记录时钟此刻打点数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXK ;i++) &#123; <span class="comment">//重复调用多次函数</span></span><br><span class="line">        (*fun)();</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="built_in">clock</span>();<span class="comment">//记录始终此时打点数</span></span><br><span class="line">    duration = ((<span class="keyword">double</span>)(stop - start))/CLOCKS_PER_SEC/MAXK;<span class="comment">//计算实际用时</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Ticks = &quot;</span> &lt;&lt; (<span class="keyword">double</span>)(stop - start) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using time = &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot; s&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC简介</title>
    <url>/2022/01/17/gRPCIntroduction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-RPC-回顾"><a href="#1-RPC-回顾" class="headerlink" title="1. RPC 回顾"></a>1. RPC 回顾</h1><blockquote>
<p>RPC 简介：<a href="https://en.wikipedia.org/wiki/Remote_procedure_call">https://en.wikipedia.org/wiki/Remote_procedure_call</a><br>Remote procedure call, RPC：远程程序调用</p>
</blockquote>
<h2 id="1-1-需求场景"><a href="#1-1-需求场景" class="headerlink" title="1.1. 需求场景"></a>1.1. 需求场景</h2><ul>
<li>分布式计算场景中，一台计算机产生一个“需要在不同网络地址下的计算机中执行的”子程序，希望：<ul>
<li>像调用本地程序一样调用这些需在远程执行的子程序</li>
<li>无需编写远程交互的详细代码</li>
<li>且编码时只需完成简单的“调用方式选择”编码，即选择需调用的一个子程序的方式为：本地调用 or 远程调用</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="1-2-简介"><a href="#1-2-简介" class="headerlink" title="1.2. 简介"></a>1.2. 简介</h2><ul>
<li><p><strong>一种请求响应协议（模式、机制）</strong></p>
<ul>
<li>支持本地计算机远程调用其他计算机中的程序。</li>
<li>基于目标导向编程范式，RPC 通常又表现为<strong>远程方法调用</strong>(remote method invocation, RMI)</li>
</ul>
</li>
<li><p><strong>CS架构</strong>：</p>
<ul>
<li>调用“执行某远程程序”的计算机为客户端（caller is client）</li>
<li>远程真正执行该程序的计算机为服务端（executor is server）</li>
</ul>
</li>
<li><p><strong>调用方式</strong>：</p>
<ul>
<li>基于请求-响应协议的消息传递方式调用</li>
<li>通过进程间通信(inter-process communication, IPC)实现，客户端&#x2F;服务端程序位于不同的地址空间（若在同一物理机，也分别位于不同的虚拟地址空间中）</li>
</ul>
</li>
<li><p><strong>备注</strong>：</p>
<ul>
<li>RPC 模型隐含了（对需远程调用子程序的）“位置暴露”的级别（划分）</li>
<li>相比于本地调用子程序，远程调用子程序的常见特征：响应及时性要求低、与本地主程序依赖程度低</li>
</ul>
</li>
</ul>
<h2 id="1-3-发展历史"><a href="#1-3-发展历史" class="headerlink" title="1.3. 发展历史"></a>1.3. 发展历史</h2><ul>
<li>1960s早期，请求响应模式最早出现在早期的分布式计算中</li>
<li>1970s，“将远程程序调用RPC作为网络操作的模型”的理论被提出<ul>
<li>1978，Per Brinch Hansen提出分布式程序，是基于大量进程间的“外部请求”子程序调用构成的</li>
</ul>
</li>
<li>1980s早期，RPC 才实际应用于实践<ul>
<li>1982，Brian Randell和同事们将 RPC 实际应用于支持多台 UNIX 设备构建分布式系统所需的 Newcastle Connection 程序。</li>
</ul>
</li>
<li>1990s，随着（object-oriented programming，OOP）的普及，多种远程方法调用（RMI）的模型相继出现：<ul>
<li>1991，Common Object Request Broker Architecture，CORBA</li>
<li>Java remote method invocation</li>
</ul>
</li>
<li>2000s，随着因特网的崛起，远程方法调用模型（RMI）也被广泛应用</li>
<li>2015年，谷歌开源了一款精简而强大的 RPC 协议（Google Remote Procedure Call, gRPC）</li>
</ul>
<h1 id="2-gRPC"><a href="#2-gRPC" class="headerlink" title="2. gRPC"></a>2. gRPC</h1><blockquote>
<p>2015年，谷歌开源的一款精简而强大的下一代 RPC 协议（Google Remote Procedure Call, gRPC）。</p>
<ul>
<li>一款性能强大的开源通用 RPC 框架</li>
</ul>
<p>传输方式：<a href="https://http2.github.io/">HTTP&#x2F;2.0</a></p>
<p><a href="https://grpc.io/">gRPC官网</a></p>
<p><a href="https://github.com/grpc/grpc/tree/master/doc">grpc官方github文档</a></p>
</blockquote>
<h2 id="2-1-gRPC-诞生原因（解决什么问题）"><a href="#2-1-gRPC-诞生原因（解决什么问题）" class="headerlink" title="2.1. gRPC 诞生原因（解决什么问题）"></a>2.1. gRPC 诞生原因（解决什么问题）</h2><p>提升数据交换性能：</p>
<ul>
<li>提升网络传输速率和带宽</li>
<li>提升编解码效率</li>
<li>精简传输数据</li>
</ul>
<p>主流的数据交换格式有两种（可扩展标记语言）：XML、JSON</p>
<h3 id="2-1-1-XML优缺点"><a href="#2-1-1-XML优缺点" class="headerlink" title="2.1.1. XML优缺点"></a>2.1.1. XML优缺点</h3><ul>
<li>优势：<ul>
<li>格式统一：使用DTD(document type definition)文档类型定义来组织数据，格式统一，跨平台和语言，已成为业界公认的标准</li>
<li>与其他系统进行远程交互较容易，数据共享较方便。</li>
</ul>
</li>
<li>缺点：<ul>
<li>XML 文件庞大，格式复杂，传输占用带宽较高</li>
<li>XML解析代码冗长且复杂、不易维护</li>
<li>不同客户端浏览器之间解析XML的方式不一致，需要重复编写很多适配代码；</li>
<li>解析 XML 耗费较多资源及时间</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-JSON-优缺点"><a href="#2-1-2-JSON-优缺点" class="headerlink" title="2.1.2. JSON 优缺点"></a>2.1.2. JSON 优缺点</h3><ul>
<li>优势：<ul>
<li>格式简单：数据格式比较简单，易于读写，格式中空格换行能被压缩</li>
<li>易解析：</li>
<li>易于维护：</li>
</ul>
</li>
<li>缺点：<ul>
<li>描述性不及 XML</li>
<li>普及程度与通用性不及 XML</li>
</ul>
</li>
</ul>
<h2 id="2-2-gRPC-优势"><a href="#2-2-gRPC-优势" class="headerlink" title="2.2. gRPC 优势"></a>2.2. gRPC 优势</h2><ul>
<li>基于 <a href="https://developers.google.com/protocol-buffers">Protobuf</a> 序列化协议的接口定义：<ul>
<li>提升安全性。通过Protobuf来提供严格的接口约束（<a href="https://www.jianshu.com/p/b723053a86a6">Google Protobuf简明教程</a>）</li>
<li>更提升一致性。客户端服务端使用同一份原文件生成接口定义，双方接口完全相同，结构直观精确，便于管理维护</li>
<li>提高传输性能。可以将数据序列化并压缩为二进制编码，大幅减少传输数据量，易于实现更高的吞吐性能</li>
</ul>
</li>
<li>基于 http2.0 传输协议的网络通信：<ul>
<li>支持流式通信。可以非常便捷地支持双向流、流控等</li>
<li>提升通信效率。通过 http2.0可实现异步请求、头部压缩、单 TCP 连接上的多复用请求，从而大幅提升通信效率</li>
<li>支持在浏览器中实现一个 gRPC 客户端</li>
</ul>
</li>
</ul>
<!-- 优点：客户端充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用、和电池寿命。 -->

<!-- ## 4. gRPC 发展情况（发展现状，6年，gRPC-web） -->



<h2 id="2-3-gRPC-如何使用、demo"><a href="#2-3-gRPC-如何使用、demo" class="headerlink" title="2.3. gRPC 如何使用、demo"></a>2.3. gRPC 如何使用、demo</h2><ol>
<li>Define a service in a .proto file.</li>
</ol>
<ul>
<li>定义服务：在 .proto 后缀的文件中定义要建立的服务以及可以远程调用的基本参数和返回类型。</li>
</ul>
<ol start="2">
<li>Generate the gRPC code from the .proto file.</li>
</ol>
<ul>
<li>从 .proto 文件生成 gRPC 代码：gRPC 的编译器 protoc 按照 .proto 文件中定义的服务及数据结构生成目标语言的接口代码</li>
</ul>
<ol start="3">
<li>Implementation of the server in the chosen language.</li>
</ol>
<ul>
<li>以目标语言编码实现服务器端业务功能。</li>
</ul>
<ol start="4">
<li>Creation of the client stub that calls the service.</li>
</ol>
<ul>
<li>创建（目标语言）进行远程调用的 “代理对象”client stub。</li>
</ul>
<h2 id="2-4-安装-grpc-go"><a href="#2-4-安装-grpc-go" class="headerlink" title="2.4. 安装 grpc-go"></a>2.4. 安装 grpc-go</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置env proxy</span></span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 gRPC-go 方式1（go 一键安装）</span></span><br><span class="line">go install google.golang.org/grpc@latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 gRPC-go 方式2 (go get)</span></span><br><span class="line">go get -u google.golang.org/grpc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 gRPC-go 方式3（GitHub）</span></span><br><span class="line">git clone https://github.com/grpc/grpc-go.git ./google.golang.org/grpc; cd google.golang.org/grpc; go install; cd ../../</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 Protobuf</span></span><br><span class="line">brew install protobuf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证命令</span></span><br><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 go net 包</span></span><br><span class="line">git clone https://github.com/golang/net.git ./google.golang.org/x/net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 go genproto 包</span></span><br><span class="line">git clone https://github.com/google/go-genproto.git ./google.golang.org/genproto</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 go text 包</span></span><br><span class="line">git clone https://github.com/golang/text.git ./google.golang.org/x/text</span><br></pre></td></tr></table></figure>

<h2 id="2-5-安装-Python-gRPC-插件"><a href="#2-5-安装-Python-gRPC-插件" class="headerlink" title="2.5. 安装 Python gRPC 插件"></a>2.5. 安装 Python gRPC 插件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m pip install grpcio</span><br><span class="line">pip3 install grpcio-tools</span><br></pre></td></tr></table></figure>


<h2 id="2-6-利用-grpc-go-中提供的-helloworld-example-实验"><a href="#2-6-利用-grpc-go-中提供的-helloworld-example-实验" class="headerlink" title="2.6. 利用 grpc-go 中提供的 helloworld example 实验"></a>2.6. 利用 grpc-go 中提供的 helloworld example 实验</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 server 端</span></span><br><span class="line">cd google.golang.org/grpc</span><br><span class="line">go get google.golang.org/grpc/examples/helloworld/helloworld</span><br><span class="line">go run examples/helloworld/greeter_server/main.go</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后启动 client 端</span></span><br><span class="line">examples/helloworld/greeter_client/main.go</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果（服务端）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go run examples/helloworld/greeter_server/main.go</span></span><br><span class="line"></span><br><span class="line">2021/12/24 20:09:20 server listening at 127.0.0.1:50051</span><br><span class="line">2021/12/24 20:10:37 Received: world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果（客户端）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go run examples/helloworld/greeter_client/main.go</span></span><br><span class="line">2021/12/24 20:10:37 Greeting: Hello world</span><br></pre></td></tr></table></figure>

<h2 id="2-7-Quick-start-记录"><a href="#2-7-Quick-start-记录" class="headerlink" title="2.7. Quick start 记录"></a>2.7. Quick start 记录</h2><blockquote>
<p><a href="https://grpc.io/docs/languages/go/quickstart/">官网 Quick Start 教程</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 protocol compiler</span></span><br><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26</span><br><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新 PATH 以能够发现上述安装插件后的</span></span><br><span class="line">export PATH=&quot;$PATH:$(go env GOPATH)/bin&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 gRPC 示例代码</span></span><br><span class="line">git clone -b v1.41.0 https://github.com/grpc/grpc-go</span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳转到 helloworld 实例路径</span></span><br><span class="line">cd grpc-go/examples/helloworld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行示例，启动服务端</span></span><br><span class="line">go run greeter_server/main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在另一窗口启动客户端</span></span><br><span class="line">go run greeter_client/main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">done</span>. 完成一次 简单的 基于 gRPC 的远程程序调用</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-备注"><a href="#2-8-备注" class="headerlink" title="2.8. 备注"></a>2.8. 备注</h2><ul>
<li>gRPC 服务压测工具：<ul>
<li><a href="https://github.com/bojand/ghz">ghz</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/huanggang982/article/details/77944174">Protobuf 的 proto2 与 proto3 的区别</a></li>
<li>gRPC 在 SONIC 中的应用（sonic-sairedis、sonic-mgmt-framework、sonic-telemetry、sonic-frr）</li>
</ul>
<h1 id="3-参考文档"><a href="#3-参考文档" class="headerlink" title="3. 参考文档"></a>3. 参考文档</h1><ul>
<li><a href="https://grpc.io/">gRPC官网</a></li>
<li><a href="https://github.com/grpc/grpc/tree/master/doc">grpc官方github文档</a></li>
<li><a href="https://www.jianshu.com/p/b723053a86a6">Google Protobuf简明教程</a></li>
<li><a href="https://www.modb.pro/db/78814">了解grpc</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>git撤销已push到远端仓库的提交</title>
    <url>/2019/10/26/gitRevert/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/gitRevert.jpg" class="full-image" />

<p>随着互联网时代的来临，代码项目多采用git仓库管理多人协同编码的方式。人非圣贤孰能无过，难免有时自己刚push到远端仓库的代码存在瑕疵需要修改，此时不必惊慌，我们可以利用git的强制覆盖远端仓库来实现撤销提交的目的。适用前提：待撤销的提交记录后暂无他人提交记录。</p>
<p>关键词: git、回退commit</p>
<a id="more"></a>
<blockquote class="blockquote-center">
<p>人谁无过？过而能改，善莫大焉<br>– 左丘明《晋灵公不君》</p>

</blockquote>
<p>记录以便查询，回退commit步骤如下。</p>
<h2 id="Step1-在本地其他路径重新克隆一份代码"><a href="#Step1-在本地其他路径重新克隆一份代码" class="headerlink" title="Step1. 在本地其他路径重新克隆一份代码"></a>Step1. 在本地其他路径重新克隆一份代码</h2><p>接下来的操作均在新克隆的路径执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远端代码仓库路径</span><br></pre></td></tr></table></figure>

<h2 id="Step2-切换到要撤销提交的分支"><a href="#Step2-切换到要撤销提交的分支" class="headerlink" title="Step2. 切换到要撤销提交的分支"></a>Step2. 切换到要撤销提交的分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b 自定义本地分支名 origin/对应远端分支名</span><br></pre></td></tr></table></figure>
<p>查看当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<h2 id="Step3-获取前一次的提交commit-id"><a href="#Step3-获取前一次的提交commit-id" class="headerlink" title="Step3. 获取前一次的提交commit id"></a>Step3. 获取前一次的提交commit id</h2><p>默认连续显示最近几次提交记录和对应的commit id，输入q退出。这步操作是为了获取待撤销提交的上一次正常提交的commit id。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="Step4-强制回退到上一次提交节点"><a href="#Step4-强制回退到上一次提交节点" class="headerlink" title="Step4. 强制回退到上一次提交节点"></a>Step4. 强制回退到上一次提交节点</h2><p>强制回退本地仓库代码到远端仓库上一次正常提交到的记录节点【注意：此时所有代码修改均会被删除，这也是为什么第一步选择在其他路径重新克隆代码和执行回退操作】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 【待撤销提交的前一次提交的commit id】</span><br></pre></td></tr></table></figure>

<h2 id="Step5-再次查询分支的提交记录"><a href="#Step5-再次查询分支的提交记录" class="headerlink" title="Step5. 再次查询分支的提交记录"></a>Step5. 再次查询分支的提交记录</h2><p>检验本地此路径仓库的提交记录是否不含待撤销的提交，输入q退出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="Step6-强制覆盖远端仓库"><a href="#Step6-强制覆盖远端仓库" class="headerlink" title="Step6. 强制覆盖远端仓库"></a>Step6. 强制覆盖远端仓库</h2><p>强制用不含待撤销记录的本地仓库完全覆盖远端仓库。【注意：此操作后远端仓库会与本地仓库完全一致，请确保在待撤销记录之后暂无他人提交代码】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin HEAD --force</span><br></pre></td></tr></table></figure>
<p>至此，git撤销已push到远端仓库的提交已完成，接下来跳转到工作仓库pull最新代码完善瑕疵吧！enjoy it :)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>高效软件推荐</title>
    <url>/2018/09/26/highValueApplicationSoftware/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/highValueApplicationSoftware.jpg" class="full-image" />

<h1 id="1-浏览器"><a href="#1-浏览器" class="headerlink" title="1. 浏览器"></a>1. <strong>浏览器</strong></h1><h2 id="1-1-chrome-x2F-Microsoft-Edge"><a href="#1-1-chrome-x2F-Microsoft-Edge" class="headerlink" title="1.1. chrome&#x2F;Microsoft Edge"></a>1.1. chrome&#x2F;Microsoft Edge</h2><p>第三方搜集的Google官方离线包，Google Chrome下载地址：<a href="https://api.shuax.com/tools/getchrome">https://api.shuax.com/tools/getchrome</a></p>
<a id="more"></a>

<p><strong>必备插件</strong>：</p>
<ul>
<li>Adblock Plus 屏蔽广告</li>
<li>SearchPreview 网页预览</li>
<li>Multi-highlight 网页关键字高亮</li>
<li>IDM Integration Module 使chrome支持IDM</li>
<li>Video Speed Controller 网页视频倍速播放</li>
<li>Cool Clock 网页时钟</li>
<li><strong>Proxy SwitchyOmega 智能选择梯子类似：PAC</strong><ul>
<li>Proxy SwitchyOmega插件官网：<a href="https://www.switchyomega.com/">https://www.switchyomega.com/</a></li>
<li>在chrome:&#x2F;&#x2F;extensions&#x2F; 中添加crx插件，注意先勾选Developer mode</li>
<li><strong>配合Shadowsockers使用，设置Proxy SwitchyOmega</strong></li>
<li><strong>VPN提供商服务器</strong>&lt;&#x3D;&#x3D;443端口通讯&#x3D;&#x3D;&gt;<strong>本地VPN软件</strong>&lt;&#x3D;&#x3D;1080端口通讯&#x3D;&#x3D;&gt;<strong>Proxy SwitchyOmega插件</strong>&lt;&#x3D;&#x3D;其他未知通讯&#x3D;&#x3D;&gt;<strong>chrome浏览器</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy:</span><br><span class="line">	SOCKS5--&gt;127.0.0.1--&gt;1080  #即Proxy SwitchyOmega插件监听本地1080端口</span><br><span class="line">auto switch:</span><br><span class="line">	Rule list rules--&gt;proxy</span><br><span class="line">	Default--&gt;Direct</span><br><span class="line">	Rule List Config--&gt;AutoProxy</span><br><span class="line">	Rule List URL--&gt;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gfwlist&#x2F;gfwlist&#x2F;master&#x2F;gfwlist.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>常用Google链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Google：https:&#x2F;&#x2F;www.google.com&#x2F;ncr</span><br><span class="line">- Google学术搜索：https:&#x2F;&#x2F;scholar.google.com&#x2F;</span><br><span class="line">- Google翻译：http:&#x2F;&#x2F;translate.google.cn&#x2F;</span><br><span class="line">- GooGle香港：https:&#x2F;&#x2F;www.google.com.hk&#x2F;ncr </span><br><span class="line">- chrome同步状态Sync: chrome:&#x2F;&#x2F;sync-internals&#x2F;</span><br></pre></td></tr></table></figure>

<h1 id="2-云盘"><a href="#2-云盘" class="headerlink" title="2. 云盘"></a>2. 云盘</h1><ul>
<li>坚果云。文件容器：用于[重要且常用、不重要却常用]文件及时分享，使用。</li>
<li>oneDrive。文件仓库：用于[重要但不常用]文件长期存放。</li>
<li>百度云</li>
<li>Dropbox</li>
</ul>
<h1 id="3-云笔记"><a href="#3-云笔记" class="headerlink" title="3. 云笔记"></a>3. 云笔记</h1><ul>
<li>有道云笔记</li>
<li>EveryNote</li>
<li>oneNote</li>
</ul>
<h1 id="4-输入法"><a href="#4-输入法" class="headerlink" title="4. 输入法"></a>4. 输入法</h1><ul>
<li>Win：<strong>手心输入法</strong> #无广告无弹窗</li>
<li>Linux：<strong>ibus-pinyin</strong> #无广告无弹窗</li>
</ul>
<h1 id="5-梯子"><a href="#5-梯子" class="headerlink" title="5. 梯子"></a>5. 梯子</h1><h2 id="5-1-ShadowsocksR"><a href="#5-1-ShadowsocksR" class="headerlink" title="5.1. ShadowsocksR"></a>5.1. ShadowsocksR</h2><ul>
<li><a href="https://lolico.moe/tutorial/shadowsocksr.html">ShadowsocksR介绍</a></li>
<li>ss免费账号分享：<ul>
<li><a href="https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7">分享链接1</a></li>
<li><a href="https://gitlab.com/Alvin9999/free/wikis/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7">分享链接2</a></li>
<li><a href="https://github.com/gfw-breaker/ssr-accounts">分享链接3</a></li>
</ul>
</li>
</ul>
<h2 id="5-2-v2rayN"><a href="#5-2-v2rayN" class="headerlink" title="5.2. v2rayN"></a>5.2. v2rayN</h2><ul>
<li><a href="https://www.v2ray.com/">V2Ray官网</a></li>
<li><a href="https://v2raypro.top/"><strong>V2RayPro官网</strong></a>，<a href="https://myv2.us/">附链</a></li>
<li><a href="https://dl.v2raypro.us/">V2RayPro<strong>多平台客户端</strong>及说明</a></li>
</ul>
<h2 id="5-3-手动更改hosts文件"><a href="#5-3-手动更改hosts文件" class="headerlink" title="5.3. 手动更改hosts文件"></a>5.3. 手动更改hosts文件</h2><h3 id="5-3-1-查询hosts"><a href="#5-3-1-查询hosts" class="headerlink" title="5.3.1. 查询hosts"></a>5.3.1. 查询hosts</h3><p>推荐<a href="https://laod.cn/">老D博客</a>，长期更新hosts</p>
<h3 id="5-3-2-管理员修改hosts文件，hosts所在文件夹："><a href="#5-3-2-管理员修改hosts文件，hosts所在文件夹：" class="headerlink" title="5.3.2. 管理员修改hosts文件，hosts所在文件夹："></a>5.3.2. 管理员修改hosts文件，hosts所在文件夹：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows 系统hosts位于 C:\Windows\System32\drivers\etc\hosts</span><br><span class="line">Android（安卓）系统hosts位于 &#x2F;etc&#x2F;hosts</span><br><span class="line">Mac（苹果电脑）系统hosts位于 &#x2F;etc&#x2F;hosts</span><br><span class="line">iPhone（iOS）系统hosts位于 &#x2F;etc&#x2F;hosts</span><br><span class="line">Linux系统hosts位于 &#x2F;etc&#x2F;hosts</span><br><span class="line">绝大多数Unix系统都是在 &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>

<h3 id="5-3-3-使修改后的hosts生效"><a href="#5-3-3-使修改后的hosts生效" class="headerlink" title="5.3.3. 使修改后的hosts生效"></a>5.3.3. 使修改后的hosts生效</h3><p><strong>Windows</strong></p>
<p>开始 -&gt; 运行 -&gt; 输入cmd -&gt; 在CMD窗口输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig &#x2F;flushdns</span><br></pre></td></tr></table></figure>
<p><strong>Linux</strong></p>
<p>终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rcnscd restart</span><br></pre></td></tr></table></figure>
<p>对于systemd发行版，请使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager</span><br></pre></td></tr></table></figure>
<p><strong>Mac OS X</strong></p>
<p>终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>
<p><strong>Android</strong></p>
<p>开启飞行模式 -&gt; 关闭飞行模式</p>
<p><strong>通用方法</strong></p>
<p>拔网线(断网) -&gt; 插网线(重新连接网络)</p>
<p>如不行请清空浏览器缓存</p>
<h1 id="6-生产工具"><a href="#6-生产工具" class="headerlink" title="6. 生产工具"></a>6. 生产工具</h1><h2 id="6-1-代码编辑器"><a href="#6-1-代码编辑器" class="headerlink" title="6.1. 代码编辑器"></a>6.1. 代码编辑器</h2><ul>
<li>VIM</li>
<li>Notepad++</li>
</ul>
<h2 id="6-2-集成IDE开发环境"><a href="#6-2-集成IDE开发环境" class="headerlink" title="6.2. 集成IDE开发环境"></a>6.2. 集成IDE开发环境</h2><ul>
<li>CLion：C++集成IDE开发工具</li>
<li>CodeBlocks：C++集成IDE开发工具</li>
<li>IDEA：Java集成IDE开发工具</li>
<li>PyCharm：Python集成IDE开发工具</li>
</ul>
<h2 id="6-3-Markdown编辑器"><a href="#6-3-Markdown编辑器" class="headerlink" title="6.3. Markdown编辑器"></a>6.3. Markdown编辑器</h2><ul>
<li>Typora</li>
<li>VScode</li>
</ul>
<h2 id="6-4-思维导图"><a href="#6-4-思维导图" class="headerlink" title="6.4. 思维导图"></a>6.4. 思维导图</h2><ul>
<li>ManagerPortable</li>
<li>Mindmaster</li>
</ul>
<h2 id="6-5-辅助工具"><a href="#6-5-辅助工具" class="headerlink" title="6.5. 辅助工具"></a>6.5. 辅助工具</h2><ul>
<li>辅助计算工具：Matlab</li>
<li>数学公式编辑器：MathType</li>
</ul>
<h2 id="6-6-文献管理工具"><a href="#6-6-文献管理工具" class="headerlink" title="6.6. 文献管理工具"></a>6.6. 文献管理工具</h2><ul>
<li>EndNote</li>
</ul>
<h1 id="7-下载工具"><a href="#7-下载工具" class="headerlink" title="7. 下载工具"></a>7. 下载工具</h1><ul>
<li>IDM，IDM 6.25.11汉化破解版</li>
<li>迅雷，迅雷 精简版最后一版1.0.35.366</li>
<li>PanDownload，第三方提供百度云管家替代下载工具，PanDownload_v1.5.2</li>
</ul>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro系统安装.rpm或.deb软件</title>
    <url>/2018/09/30/howToConvert.rpmPackagesIntoArchPackages/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/howToConvert.rpmPackagesIntoArchPackages.jpg" class="full-image" />

<p>尽管AUR被称为这个星球上最大的软件资源库，但不可避免的，我们有时会遇到在AUR库中没有待装软件，而待装软件官网只提供.rpm或.deb软件包的情况。本文将介绍如何利用.rpm或.deb软件包资源创建一个Arch软件包，然后在Manjaro系统下安装这些软件。</p>
<a id="more"></a>

<h1 id="1-通过-deb包安装-推荐"><a href="#1-通过-deb包安装-推荐" class="headerlink" title="1. 通过.deb包安装(推荐)"></a>1. 通过.deb包安装(推荐)</h1><h2 id="1-1-deb包安装流程简述："><a href="#1-1-deb包安装流程简述：" class="headerlink" title="1.1. .deb包安装流程简述："></a>1.1. .deb包安装流程简述：</h2><ul>
<li>用一个叫“Debtap”的软件将.deb软件包转换成Arch软件包</li>
<li>用我们熟悉的<code>pacman</code>命令安装上一步创建的Arch软件包</li>
</ul>
<h2 id="1-2-准备工作："><a href="#1-2-准备工作：" class="headerlink" title="1.2. 准备工作："></a>1.2. 准备工作：</h2><ul>
<li>确保系统已安装<code>debtap</code>，可通过以下命令查询</li>
</ul>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">debtap -v #查询debtap安装的版本号</span><br></pre></td></tr></table></figure>
<p>若没安装也可通过（<code>pacaur</code>、<code>packer</code>、<code>yaourt</code>）三种方式下载debtap源码文件然后安装debtap，以下是通过<code>yaourt</code>安装debtap的示例。<code>yaourt -S debtap</code>命令会下载debtap源码文件压缩包及<code>PKGBUILD</code>配置文件，我们只需要在下载完成后编译并安装debtap即可:</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S yaourt #安装yaourt</span><br><span class="line">yaourt -S debtap</span><br><span class="line"></span><br><span class="line">#不用更改下载配置文件，一路No</span><br><span class="line">Edit PKGBUILD ? [Y&#x2F;n] --&gt; N</span><br><span class="line">Edit debtap.install ? --&gt; N</span><br><span class="line">Continue building debtap ? [Y&#x2F;n] --&gt; Y</span><br><span class="line"></span><br><span class="line">#安装过程中访问&#x2F;var目录会询问一次管理员密码</span><br><span class="line">Continue installing debtap ? [Y&#x2F;n] --&gt; Y</span><br><span class="line">Proceed with installation? [Y&#x2F;n] --&gt; Y</span><br><span class="line">debtap -v #查询debtap安装的版本号</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确保系统已安装<code>bash</code>, <code>binutils</code>, <code>pkgfile</code>和<code>fakeroot</code><br>一般情况均已安装。安装Debtap和所有上述依赖项后，运行以下命令来创建&#x2F;更新pkgfile和debtap数据库（至少执行一次）。</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo debtap -u</span><br><span class="line"># 等待。。。创建&#x2F;更新pkgfile和debtap数据库。当看到下列信息时，表明debtap已安装完毕。</span><br><span class="line">&#x3D;&#x3D;&gt; Generating base group packages list...</span><br><span class="line">&#x3D;&#x3D;&gt; All steps successfully completed!</span><br></pre></td></tr></table></figure>
</li>
<li><p>去待安装软件官网下载与你系统相匹配的(64位或32位)<code>.deb</code>软件包，推荐下载到<code>~/Downloads</code>目录</p>
</li>
</ul>
<h2 id="1-3-实际操作及代码"><a href="#1-3-实际操作及代码" class="headerlink" title="1.3. 实际操作及代码"></a>1.3. 实际操作及代码</h2><ol>
<li><p>跳转到.deb软件包的下载目录：<br>如果准备工作中<code>.deb软件包</code>下载到<code>~/Downloads</code>目录的话</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Downloads</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>debtap</code>命令转换.deb软件包为arch软件包</p>
<figure class="highlight plain"><figcaption><span>执行命令目录：你下载的.deb文件目录 eg:~/Download</span></figcaption><table><tr><td class="code"><pre><span class="line">debtap EasyConnect_x64.deb</span><br><span class="line"></span><br><span class="line"># 如果您不想在程序包转换期间回答任何问题，可使用-q标志绕过所有问题</span><br><span class="line">debtap -q EasyConnect_x64.deb(建议)</span><br><span class="line"></span><br><span class="line"># 或使用-Q标志绕过所有问题（不建议使用）</span><br><span class="line">debtap -Q EasyConnect_x64.deb</span><br></pre></td></tr></table></figure>
<p>系统将要求您输入软件包维护者和许可证的名称。 只需输入它们并按ENTER键即可开始转换过程。软件包转换需要几秒钟到几分钟，具体取决于您的CPU速度。期间可以喝杯咖啡休息一下</p>
<figure class="highlight plain"><figcaption><span>若标志绕过所有问题，则不需要以下操作</span></figcaption><table><tr><td class="code"><pre><span class="line">:: Enter Packager name: --&gt; EasyConnect</span><br><span class="line">:: Enter package license: --&gt; 填&#39;GPL&#39;或&#39;unknow&#39;</span><br><span class="line">:: If you want to edit: --&gt; Enter(跳过编辑)</span><br></pre></td></tr></table></figure>
<p>转换完成后会在当前目录生成一个Arch软件包：<code>packagename.pkg.tar.xz</code>形式的文件(eg:<code>easyconnect-7.6.3.0.86415-1-x86_64.pkg.tar.xz</code>)</p>
</li>
<li><p>用熟悉的<code>pacman</code>命令安装刚创建的Arch软件包</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：刚刚转换Arch包的文件目录</span></figcaption><table><tr><td class="code"><pre><span class="line">#安装刚创建的Arch软件包</span><br><span class="line">sudo pacman -U easyconnect-7.6.3.0.86415-1-x86_64.pkg.tar.xz</span><br></pre></td></tr></table></figure>
<p>恭喜，至此已顺利安装软件。</p>
</li>
<li><p>若安装失败或想卸载该软件，执行以下命令即可</p>
</li>
</ol>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -R easyconnect</span><br></pre></td></tr></table></figure>

<h1 id="2-通过-rpm软件包安装"><a href="#2-通过-rpm软件包安装" class="headerlink" title="2. 通过.rpm软件包安装"></a>2. 通过.rpm软件包安装</h1><h2 id="2-1-rpm安装流程简述："><a href="#2-1-rpm安装流程简述：" class="headerlink" title="2.1. .rpm安装流程简述："></a>2.1. .rpm安装流程简述：</h2><ul>
<li>新建一个文件夹作为软件安装目录，并将待安装软件<code>.rpm</code>软件包移动到该文件夹内</li>
<li>在安装文件夹内创建并配置<code>PKGBUILD</code>文件</li>
<li>在待装软件文件夹内运行<code>makepkg</code>，然后创建Arch软件包</li>
<li>用我们熟悉的<code>pacman</code>命令安装上一步创建的Arch软件包</li>
</ul>
<h2 id="2-2-准备工作："><a href="#2-2-准备工作：" class="headerlink" title="2.2. 准备工作："></a>2.2. 准备工作：</h2><ul>
<li>确保系统已安装<code>rpmextract</code><figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S rpmextract #安装rpmextract</span><br></pre></td></tr></table></figure></li>
<li>去待安装软件官网下载与你系统相匹配的(64位或32位)<code>.rpm</code>软件包</li>
</ul>
<h2 id="2-3-实际操作及代码："><a href="#2-3-实际操作及代码：" class="headerlink" title="2.3. 实际操作及代码："></a>2.3. 实际操作及代码：</h2><ol>
<li><p>新建一个软件的安装文件夹，并将待安装软件<code>.rpm</code>包移动到该文件夹内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir package #新建待安装软件文件夹，取名尽量具有可读性</span><br><span class="line">cd package #跳转到该文件夹</span><br><span class="line">#将待安装软件.rpm包复制到该文件夹内</span><br></pre></td></tr></table></figure>
</li>
<li><p>在待装软件文件夹内创建并配置<code>PKGBUILD</code>文件<br>这个<code>PKGBUILD</code>文件包含有关我们将要创建的包的所有配置信息，而Manjaro系统自带原生的<code>PKGBUILD</code>文件模板，所以直接复制到本目录再配置一下便可，可参考：<a href="https://jlk.fjfi.cvut.cz/arch/manpages/man/PKGBUILD.5">官方PKGBUILD文件配置说明</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;pacman&#x2F;PKGBUILD.proto PKGBUILD #复制系统自带的原生PKGBUILD文件模板到待安装软件目录</span><br><span class="line">gedit PKGBUILD #配置PKGBUILD文件</span><br></pre></td></tr></table></figure>
<p>我的<code>PKGBUILD</code>文件最终配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkgname&#x3D;google-musicmanager-beta</span><br><span class="line">pkgver&#x3D;current</span><br><span class="line">pkgrel&#x3D;1</span><br><span class="line">pkgdesc&#x3D;&quot;Add a simple disprection.&quot;</span><br><span class="line">arch&#x3D;(&#39;x86_64&#39;)</span><br><span class="line">url&#x3D;&quot;https:&#x2F;&#x2F;music.google.com&#x2F;&quot;</span><br><span class="line">license&#x3D;(&#39;unknown&#39;)</span><br><span class="line">depends&#x3D;(&#39;libidn&#39;)</span><br><span class="line">makedepends&#x3D;(&#39;rpmextract&#39;)</span><br><span class="line">options&#x3D;(&#39;emptydirs&#39;)</span><br><span class="line">source&#x3D;(&quot;http:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;direct&#x2F;google-musicmanager-beta_current_x86_64.rpm&quot;)</span><br><span class="line">md5sums&#x3D;(&#39;6c05f087f9cd77563b7d001584e3b2d8&#39;)</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">cd &quot;$pkgdir&quot;</span><br><span class="line">rpmextract.sh ..&#x2F;google-musicmanager-beta_current_x86_64.rpm</span><br><span class="line">&#125;</span><br><span class="line">package() &#123;</span><br><span class="line">cd $srcdir</span><br><span class="line">rsync -ruDq $srcdir $pkgdir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PKGBUILD</code>文件中代码说明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序名称（强制格式：小写，无空格等）</span><br><span class="line">版本（默认“current”吧）</span><br><span class="line">内部版本号，对于包的每次更改都应增加1</span><br><span class="line">简短描述（少于约80个字符）</span><br><span class="line">架构（i686，x86_64，两者任意一种，或都支持）</span><br><span class="line">包的官方网站的URL（可选）</span><br><span class="line">许可证（GPL，BSD，unknown等）</span><br><span class="line">程序可能具有的任何依赖项（若多个以空格分隔，而不是逗号）</span><br><span class="line">只需要构建但不运行程序的依赖关系(&#39;rpmextract optipng&#39;或&#39;rpmextract&#39;)</span><br><span class="line">任意选项（在这种情况下，提取后有一些空目录，我发现不必要，所以我使用了emptydirs选项）</span><br><span class="line">源文件列表（如果是URL，则会在安装时下载这些.rpm文件，但也可以直接将.rpm软件包放在与PKGBUILD文件相同的文件夹中）</span><br><span class="line">文件的md5sums列表（您可以通过在包含文件的文件夹中运行“makepkg -g”来获取这些文件的md5sums）。</span><br><span class="line">最后是构建脚本进行提取</span><br></pre></td></tr></table></figure>
</li>
<li><p>在待装软件文件夹内运行<code>makepkg</code>创建Arch软件包<br>首先，在待装软件文件夹内运行<code>makepkg -g</code>。其次，待下载PKGBUILD文件中指定文件并返回一行<code>md5sum</code>，并复制<code>md5sum</code>到PKGBUILD文件中 。再次，再根据提示安装依赖项。最后，用<code>makepkg</code>创建最终的Arch软件包(即：<code>pkgname.pkg.tar.xz</code>文件)</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：待装软件文件夹内</span></figcaption><table><tr><td class="code"><pre><span class="line">makepkg -g #该命令将下载PKGBUILD文件中指定文件并返回一md5sum行</span><br><span class="line">gedit PKGBUILD #再次编辑PKGBUILD文件，将返回的md5sums行复制到md5sums&#x3D;(&#39;&#39;)中</span><br><span class="line">makepkg #创建Arch包，可能会提示存在尚未安装的依赖项，按提示安装所需依赖项</span><br></pre></td></tr></table></figure>
</li>
<li><p>用熟悉的<code>pacman</code>命令安装刚创建的Arch软件包</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：刚刚转换Arch包的文件目录</span></figcaption><table><tr><td class="code"><pre><span class="line">pacman -U pkgname.pkg.tar.xz</span><br></pre></td></tr></table></figure>
<p>恭喜，至此已顺利安装软件。</p>
</li>
<li><p><strong>若安装失败或想卸载该软件</strong>，执行以下命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -R pkgname #其中pkgname为PKGBUILD文件中配置的软件名</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="3-Linux每日一练"><a href="#3-Linux每日一练" class="headerlink" title="3. Linux每日一练"></a>3. Linux每日一练</h1><p>在Linux系统中搜索文件命令<code>find</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo find &#x2F; -name *example*.*</span><br><span class="line"></span><br><span class="line">#其中</span><br><span class="line">&#39;&#x2F;&#39;表示搜索路径为&#x2F;根目录，也可自定</span><br><span class="line">&#39;-name&#39;表示搜索条件为名称</span><br><span class="line">&#39;\*&#39; 表不确定内容，可搜索文件或文件夹</span><br></pre></td></tr></table></figure>

<h1 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h1><ul>
<li><a href="http://nemrod.se/guides/install-rpm-packages-on-arch-linux/">Install RPM packages on Arch Linux</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Creating_packages">Creating packages</a></li>
<li><a href="https://wiki.archlinux.org/index.php/PKGBUILD">PKGBUILD</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安装SONiC</title>
    <url>/2021/09/28/install_sonic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="1-1-制作-SONiC-安装U盘"><a href="#1-1-制作-SONiC-安装U盘" class="headerlink" title="1.1. 制作 SONiC 安装U盘"></a>1.1. 制作 SONiC 安装U盘</h2><h3 id="1-1-1-依赖材料"><a href="#1-1-1-依赖材料" class="headerlink" title="1.1.1. 依赖材料"></a>1.1.1. 依赖材料</h3><ol>
<li>一台带 USB 接口的白盒交换机（已安装 SONiC 系统）</li>
<li>一个空U盘 （容量高于2G）</li>
<li>两个<font color="red" style="">安装文件</font>：sonic.bin 和 sonic-recovery.bin</li>
</ol>
<ul>
<li>sonic.bin，全量安装 SONiC 系统的二进制文件（六百多MB）</li>
<li>sonic-recovery.bin，构建&#x2F;恢复 SONiC-OS 系统基础环境的二进制文件（约三百MB）</li>
</ul>
<a id="more"></a>

<p>其中，sonic.bin 和 sonic-recovery.bin 的编译方式如下：</p>
<blockquote>
<p>备注：</p>
<ul>
<li>编译 SONiC 版本需确保当前登录用户已加入 <b><font color="#7E3D76" style="">docker</font></b> 组</li>
<li>查询当前 <b><font color="#7E3D76" style="">docker</font></b> 组用户列表的命令为： <code>sudo cat /etc/group | grep docker</code> </li>
<li>若当前登录用户不在 <b><font color="#7E3D76" style="">docker</font></b> 组用户列表中，则需添加到 <b><font color="#7E3D76" style="">docker</font></b> 组用户列表，命令为：  <code>sudo usermod -aG docker $&#123;当前用户名&#125; </code></li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 进入 SONiC 源码目录</span></span><br><span class="line">cd $SONIC_CODE_DIR</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 设置芯片厂商（eg. broadcom）</span></span><br><span class="line">make configure PLATFORM=broadcom</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 执行 make 编译 sonic.bin （编译用时约 1小时）</span></span><br><span class="line">make target/sonic.bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 执行 make 编译 sonic-recovery.bin （编译用时约 10分钟）</span></span><br><span class="line">make target/sonic-recovery.bin</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-制作安装U盘"><a href="#1-1-2-制作安装U盘" class="headerlink" title="1.1.2. 制作安装U盘"></a>1.1.2. 制作安装U盘</h3><ol>
<li>上传两个<font color="red" style="">安装文件</font>到（用于制作安装U盘的）SONiC白盒交换机的 &#x2F;host&#x2F; 目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拷贝安装文件到交换机（eg. 通过 scp 命令传输）</span></span><br><span class="line">scp sonic.bin admin@A.B.C.D:/home/admin</span><br><span class="line">scp sonic-recovery.bin admin@A.B.C.D:/home/admin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝安装文件到交换机的 /host/ 目录</span></span><br><span class="line">cp /home/admin/sonic.bin /host/</span><br><span class="line">cp /home/admin/sonic-recovery.bin /host/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步</span></span><br><span class="line">sync</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在（用于制作安装U盘的）白盒交换机上，安装 SONiC-OS recovery 基础镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 /host/ 目录</span></span><br><span class="line">cd /host/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 SONiC-OS recovery 基础镜像</span></span><br><span class="line">./sonic-recovery.bin -L SONiC-OS –g</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启设备，进入上一步新安装的SONIC-OS recovery 基础镜像系统<br>（依据当前时间，在GRUB中选择进入上一步安装的系统版本）</li>
<li>插入U盘，查看U盘盘符<br>（根据U盘容量判别，eg. 32G）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例U盘盘符名：/dev/sdb</span></span><br><span class="line">Disk /dev/sdb: 28.8 GiB, 30943995904 bytes, 60437492 sectors</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例U盘分区名：/dev/sdb1~n</span></span><br><span class="line">Device      Start       End         Sectors     Size        Type</span><br><span class="line">/dev/sdb3   526370      60434458    59910000    28.6G       filesystem</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>制作安装U盘<br>（上一步获知的U盘盘符名： <code>/dev/sdb</code> ）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sonic-recovery.bin -u -n /dev/sdb</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>同时将两个安装文件拷贝到U盘<br>（上一步获知的U盘分区名：&#x2F;dev&#x2F;sdb3）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂载U盘</span></span><br><span class="line">mount /dev/sdb3 /mnt/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝安装文件到 U 盘</span></span><br><span class="line">cp /host/sonic.bin /mnt/</span><br><span class="line">cp /host/sonic-recovery.bin /mnt/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步</span></span><br><span class="line">sync</span><br></pre></td></tr></table></figure>

<h2 id="1-2-安装-x2F-配置-minicom-串口工具"><a href="#1-2-安装-x2F-配置-minicom-串口工具" class="headerlink" title="1.2. 安装&#x2F;配置 minicom 串口工具"></a>1.2. 安装&#x2F;配置 minicom 串口工具</h2><p>minicom 对比 screen 优势：</p>
<ul>
<li>screen 方式连接串口设备： <code>screen /dev/tty.usbserial-110 115200</code><ul>
<li>优势：系统自带，随用随取。</li>
<li>短板：用完要关闭需要先按Ctrl+A，再按Ctrl+K来杀掉进程；可能遇到在关闭后&#x2F;dev路径没有Serial文件而无法使用的情况。</li>
</ul>
</li>
<li>minicom 串口工具连接串口设备： <code>minicom -c on</code> <ul>
<li>优势：使用便捷，仅需一次配置，后续自动调用连接配置；稳定性好；支持热插拔；功能丰富。</li>
</ul>
</li>
</ul>
<h3 id="1-2-1-安装-minicom-串口工具"><a href="#1-2-1-安装-minicom-串口工具" class="headerlink" title="1.2.1. 安装 minicom 串口工具"></a>1.2.1. 安装 minicom 串口工具</h3><ul>
<li>执行 <code>brew install minicom</code> 命令安装 minicom （依赖工具 <a href="https://brew.sh/">HomeBrew</a>）</li>
</ul>
<h3 id="1-2-2-配置-minicom-串口工具"><a href="#1-2-2-配置-minicom-串口工具" class="headerlink" title="1.2.2. 配置 minicom 串口工具"></a>1.2.2. 配置 minicom 串口工具</h3><ol>
<li><b><font color="#7E3D76" style="">查询串口设备ID</font></b><br>（需在串口线连接 <strong>交换机</strong> 与 <strong>Mac笔记本</strong>后执行下方命令才能看到）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /dev/tty.usb*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果示例</span></span><br><span class="line">/dev/tty.usbserial-110</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><b><font color="#7E3D76" style="">进入 minicom 配置界面</font></b></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minicom -s</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><b><font color="#7E3D76" style="">进入串口配置项</font></b><br>上下方向键移动光标，选择“Serial port setup”，Enter 确认</li>
<li><b><font color="#7E3D76" style="">更改串口设备 ID</font></b><br>按 A 进入“Serial Device”配置，删除默认值 &#x2F;dev&#x2F;modem，更改为第 1 步查询得到的设备 ID（eg. <code>/dev/tty.usbserial-110</code> ），Enter 确认更改</li>
<li><b><font color="#7E3D76" style="">更改波特率</font></b><br>按 E 进入“Bps&#x2F;Par&#x2F;Bits”配置，选择适当波特率（如，按 E 切换波特率为 115200），Enter 确认更改</li>
<li><b><font color="#7E3D76" style="">关闭硬件流控</font></b><br>按 F 切换“Hardware Flow Control”开关值，切换为“NO”<br>示例配置如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------------------------------+</span><br><span class="line">| A -    Serial Device      : /dev/tty.usbserial-110                    |</span><br><span class="line">| B - Lockfile Location     : /opt/homebrew/Cellar/minicom/2.8/var      |</span><br><span class="line">| C -   Callin Program      :                                           |</span><br><span class="line">| D -  Callout Program      :                                           |</span><br><span class="line">| E -    Bps/Par/Bits       : 115200 8N1                                |</span><br><span class="line">| F - Hardware Flow Control : No                                        |</span><br><span class="line">| G - Software Flow Control : No                                        |</span><br><span class="line">| H -     RS485 Enable      : No                                        |</span><br><span class="line">| I -   RS485 Rts On Send   : No                                        |</span><br><span class="line">| J -  RS485 Rts After Send : No                                        |</span><br><span class="line">| K -  RS485 Rx During Tx   : No                                        |</span><br><span class="line">| L -  RS485 Terminate Bus  : No                                        |</span><br><span class="line">| M - RS485 Delay Rts Before: 0                                         |</span><br><span class="line">| N - RS485 Delay Rts After : 0                                         |</span><br><span class="line">|                                                                       |</span><br><span class="line">|    Change which setting?                                              |</span><br><span class="line">+-----------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><b><font color="#7E3D76" style="">保存配置</font></b><br>按 Enter 或 Esc 退回到“configuration”主界面，选择“Save setup as dfl”保存为默认配置，最后选择“Exit from Minicom”退出</li>
</ol>
<h3 id="1-2-3-通过-minicom-串口工具登录交换机"><a href="#1-2-3-通过-minicom-串口工具登录交换机" class="headerlink" title="1.2.3. 通过 minicom 串口工具登录交换机"></a>1.2.3. 通过 minicom 串口工具登录交换机</h3><ol>
<li>用串口线连接 <strong>交换机</strong> 与 <strong>Mac笔记本</strong></li>
<li>通过串口工具访问<strong>交换机</strong>（终端执行命令为： <code>minicom -c on</code> ）</li>
</ol>
<p>备注： ESC + Z 可调出 minicom 工具的命令菜单</p>
<h1 id="2-安装-SONiC"><a href="#2-安装-SONiC" class="headerlink" title="2. 安装 SONiC"></a>2. 安装 SONiC</h1><h2 id="2-1-通过-U-盘安装-SONiC-系统"><a href="#2-1-通过-U-盘安装-SONiC-系统" class="headerlink" title="2.1. 通过 U 盘安装 SONiC 系统"></a>2.1. 通过 U 盘安装 SONiC 系统</h2><p><b><font color="#7E3D76" style="">1. 从U盘启动</font></b><br></p>
<ul>
<li>交换机插入安装U盘</li>
<li>重启（BIOS 默认优先从U盘启动）</li>
<li>输入U盘中 SONiC 系统的用户&#x2F;密码: admin&#x2F;admin</li>
<li>进入 &#x2F;host&#x2F; 目录，确认存在两个<font color="red" style="">安装文件</font> ：sonic.bin 和 sonic-recovery.bin</li>
</ul>
<p><b><font color="#7E3D76" style="">2. （交换机）硬盘分区并准备SONiC-OS基础环境</font></b><br></p>
<blockquote>
<p>通过 sonic-recovery.bin 对（交换机）硬盘进行分区并准备 SONiC-OS 基础环境</p>
</blockquote>
<ul>
<li>(1). 通过 <code>blkid</code> 命令查看交换机分区信息及了解硬盘类型（sda 或 nvme）</li>
<li>(2a). 若执行blkid命令显示的信息中，硬盘类型为 <b><font color="red" style="">sda</font></b> ，则执行以下命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sonic-recovery.bin -n /dev/sda</span><br></pre></td></tr></table></figure>
<ul>
<li>(2b). 若执行blkid命令显示的信息中，硬盘类型为 <b><font color="red" style="">nvme</font></b> ，则执行以下命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sonic-recovery.bin -n /dev/nvme0n1</span><br></pre></td></tr></table></figure>
<ul>
<li>(3). 再次通过 <code>blkid</code> 命令查看硬盘分区信息，确认硬盘分区信息囊括下方所有 <strong>LABEL</strong> <br>（GRUB、SONiC-OS、Recovery、Diag、Reserved、Log）</li>
</ul>
<p><b><font color="#7E3D76" style="">3. 安装 SONiC 系统</font></b></p>
<p>执行下方命令安装 SONiC 系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sonic.bin</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">4. 拔掉U盘，重启</font></b></p>
<h2 id="2-2-通过-ONIE-重装-SONiC"><a href="#2-2-通过-ONIE-重装-SONiC" class="headerlink" title="2.2. 通过 ONIE 重装 SONiC"></a>2.2. 通过 ONIE 重装 SONiC</h2><p><b><font color="#7E3D76" style="">1. 卸载旧 SONiC</font></b><br></p>
<ul>
<li>串口访问设备（切COM-E），手动重启；</li>
<li>在 GRUB 菜单选择 ONIE: Uninstall OS，等待其卸载旧 SONiC 系统后自动重启；</li>
<li>在重启后的 GRUB 菜单选择 ONIE: Rescue；</li>
<li>在提示 “please press enter to activate this console” 后，按回车进入 ONIE 系统</li>
</ul>
<p><b><font color="#7E3D76" style="">2. 手动配置 ONIE 系统的管理 IP</font></b><br></p>
<blockquote>
<p>配置同网段IP</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 1.2.3.4 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">3. 拷贝 SONiC 安装镜像到 ONIE 系统的 &#x2F;tmp 路径</font></b><br></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp admin@4.5.6.7:/home/admin/sonic.bin /tmp/</span><br></pre></td></tr></table></figure>


<p><b><font color="#7E3D76" style="">4. 通过 onie-nos-install 安装 SONiC 镜像</font></b><br></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">onie-nos-install /tmp/sonic.bin</span><br></pre></td></tr></table></figure>

<h2 id="2-3-通过-sonic-installer-更新-SONiC"><a href="#2-3-通过-sonic-installer-更新-SONiC" class="headerlink" title="2.3. 通过 sonic_installer 更新 SONiC"></a>2.3. 通过 sonic_installer 更新 SONiC</h2><p>若设备已安装旧版 SONiC，可直接通过 sonic_installer 指令更新版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sonic_installer install -f /home/admin/new-sonic.bin</span><br></pre></td></tr></table></figure>

<h1 id="3-配置交换机IP及管理网路由"><a href="#3-配置交换机IP及管理网路由" class="headerlink" title="3. 配置交换机IP及管理网路由"></a>3. 配置交换机IP及管理网路由</h1><blockquote>
<p>备注：</p>
<ul>
<li>建议串口访问下执行下述操作，ssh 访问可能会因重新分配 IP 导致断连</li>
<li><b><font color="red" style="">重启后 IP 配置丢失根因</font></b>：ZTP 服务启动后若发现同时缺失配置文件 <code>/etc/sonic/config_db.json</code> 和 旧配置文件夹 <code>/etc/sonic/old_config/</code> ，将自动获取IP，强制覆盖已配置的静态 IP。<br>故在新设备配置IP，需先开启 ZTP 服务并执行 config save 生成配置文件，然后配置静态管理 IP，以防止重启后 ZTP 检测到无配置文件而去自动获取IP导致IP配置丢失。</li>
<li>若发现设备缺失配置文件 <code>/etc/sonic/config_db.json</code> ，执行下方 3(a) 步即可配置IP并生成配置文件。</li>
<li>若发现设备管理 IP 丢失（ <code>/etc/network/interfaces</code>文件被删 ），执行下方 3(b) 步即可配置静态 IP（此文件为生成文件，不推荐手动配置）。</li>
</ul>
</blockquote>
<p>（SONiC 支持通过 cli 配置，可作为接线后临时测试的配置参考）</p>
<ol>
<li><b><font color="#7E3D76" style="">查看设备状态信息</font></b></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看此设备有无“用户配置”文件</span></span><br><span class="line">ls -l /etc/sonic/config_db.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前设备 IP</span></span><br><span class="line">ip addr | grep &#x27;scope global eth0&#x27; | awk &#x27;&#123; print $2 &#125;&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询 ZTP 服务启/停状态</span></span><br><span class="line">systemctl list-units --all --type=service | grep ztp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 ZTP 服务详细状态信息</span></span><br><span class="line">sudo service ztp status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看生成的配置文件中是否包含管理IP字段</span></span><br><span class="line">sed -n &quot;$(grep -n &#x27;MGMT_INTERFACE&#x27; /etc/sonic/config_db.json | tail -1 | cut -d : -f 1), +5p&quot; /etc/sonic/config_db.json</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><b><font color="#7E3D76" style="">打开“零配置部署”功能（Zero Touch Provisioning，ZTP）</font></b></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若 ztp 服务未开启，需执行下方命令开启 ZTP 服务</span></span><br><span class="line">sudo systemctl start ztp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 备注：</span></span><br><span class="line">sudo update-rc.d -f ztp remove      # 禁止 ZTP 服务开启自启  </span><br><span class="line">sudo update-rc.d ztp enable 2 3 4 5 # 开启 ZTP 服务开机自启</span><br></pre></td></tr></table></figure>
<ul>
<li>若设备缺失配置文件<code>/etc/sonic/config_db.json</code>且启动时 ztp 服务已开启，执行 <code>ip addr | grep eth0</code> 将能看到已自动获取的 IP（eg.10.0.0.2）</li>
<li>若此时无 IP，执行下方 3(a) 步即可配置IP并生成配置文件。</li>
</ul>
<ol start="3">
<li><b><font color="#7E3D76" style="">配置IP</font></b><br>（如配置交换机的 静态IP为：10.0.0.2&#x2F;24、网关为：10.0.0.0）<br><br><font color="black" style="">a. 方式一：通过调用cli命令配置IP（推荐）</font></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cli</span><br><span class="line"><span class="meta">sonic&gt;</span><span class="bash"> configure terminal</span></span><br><span class="line"><span class="meta">sonic(config)#</span><span class="bash"> interface-config</span></span><br><span class="line">sonic(interface config)# management</span><br><span class="line">sonic(interface mgmt)# ipv4-family</span><br><span class="line">sonic(interface mgmt v4)# address 10.0.0.2/24</span><br></pre></td></tr></table></figure>
<p>或调 cli 命令行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 调命令配置静态IP和网关（静态IP为：10.0.0.2/24、网关为：10.0.0.0）</span></span><br><span class="line">sudo config interface eth0 ip add 10.0.0.2/24</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加到管理网路由（目的IP为：10.0.0.0/8、下一跳为网关：10.0.0.0）</span></span><br><span class="line">sudo config route mgmt add 10.0.0.0/8 10.0.0.0 eth0</span><br></pre></td></tr></table></figure>
<p>生成配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo config save</span><br></pre></td></tr></table></figure>
<p>查看生成的配置文件中是否包含管理IP字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &quot;$(grep -n &#x27;MGMT_INTERFACE&#x27; /etc/sonic/config_db.json | tail -1 | cut -d : -f 1), +5p&quot; /etc/sonic/config_db.json</span><br></pre></td></tr></table></figure>
<p><br><font color="black" style="">b. 方式二：通过直接修改网卡配置文件（临时，重启后失效）</font><br>通过 <code>sudo vi /etc/network/interfaces</code> 修改网卡配置文件，示例配置内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="meta">#</span><span class="bash"> The management network interface</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">    address 10.0.0.2</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    # management network policy routing rules</span><br><span class="line">    # management port up rules</span><br><span class="line">    up ip -4 route add 10.0.0.0/24 dev eth0 table default</span><br><span class="line">    up ip -4 rule add from 10.0.0.2/32 table default</span><br><span class="line">    # management port down rules</span><br><span class="line">    down ip -4 route delete 10.0.0.0/24 dev eth0 table default</span><br><span class="line">    down ip -4 rule delete from 10.0.0.2/32 table default</span><br><span class="line">source /etc/network/interfaces.d/*</span><br></pre></td></tr></table></figure>
<p>生效配置<br>（以下方式均可）</p>
<ul>
<li>a.重启网络：<code>sudo /etc/init.d/networking restart</code> 或 <code>sudo service networking restart</code><br><font color="black" style=""></li>
<li>b.重启网卡（eg. eth0）： <code>sudo ifdown eth0</code> 或 <code>sudo ifup eth0</code></li>
</ul>
<h1 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h1><ul>
<li><a href="https://blog.csdn.net/dirksmaller/article/details/105063379">Mac笔记本 Pro 工具之 minicom安装与串口配置</a></li>
<li><a href="https://www.cnblogs.com/xig112635/p/14838651.html">linux route命令详解</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SONiC</tag>
      </tags>
  </entry>
  <entry>
    <title>日志规范</title>
    <url>/2021/08/26/logSpecification/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-日志分类"><a href="#1-日志分类" class="headerlink" title="1. 日志分类"></a>1. 日志分类</h1><blockquote>
<p><strong>日志</strong>：用来准确、恰当、适量地记录用户操作、系统运行状态等，是一个系统的重要组成部分</p>
</blockquote>
<p>日志从功能划分，可分为<strong>诊断日志</strong>、<strong>统计日志</strong>、<strong>审计日志</strong>：</p>
<a id="more"></a>

<ul>
<li><strong>诊断日志</strong><ul>
<li>请求的入口和出口</li>
<li>外部服务调用及返回</li>
<li>资源消耗操作: 打开文件等</li>
<li>容错行为，譬如云硬盘的副本修复操作</li>
<li>程序异常，譬如数据库无法连接</li>
<li>后台操作，清理程序</li>
<li>启动、关闭、配置加载</li>
<li>抛出异常时，不记录日志</li>
</ul>
</li>
<li><strong>统计日志</strong><ul>
<li>用户访问统计</li>
<li>计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</li>
</ul>
</li>
<li><strong>审计日志</strong><ul>
<li>管理操作</li>
</ul>
</li>
</ul>
<h1 id="2-日志规范重要性"><a href="#2-日志规范重要性" class="headerlink" title="2. 日志规范重要性"></a>2. 日志规范重要性</h1><blockquote>
<p>只有在程序出问题以后才会知道打一个好的日志有多么重要</p>
</blockquote>
<p><strong>低效日志</strong>将导致开发&#x2F;测试&#x2F;运维人员：</p>
<ul>
<li>对系统的运行状态一知半解，甚至一无所知</li>
<li>系统出现问题无法定位，或需耗费大量时间和精力</li>
<li>无法发现系统瓶颈，不知优化从何做起</li>
<li>无法基于日志对系统运行过程中的错误和潜在风险进行监控和报警</li>
<li>对挖掘用户行为和提升产品价值毫无帮助</li>
</ul>
<p><strong>优质日志</strong>将帮助开发&#x2F;测试&#x2F;运维人员：</p>
<ul>
<li>准确知晓线上系统的运行状态</li>
<li>快速定位线上问题，高效排障</li>
<li>发现系统瓶颈</li>
<li>预警系统潜在风险</li>
<li>挖掘产品最大价值</li>
</ul>
<h1 id="3-日志规范总则"><a href="#3-日志规范总则" class="headerlink" title="3. 日志规范总则"></a>3. 日志规范总则</h1><ul>
<li><p>减少日志中无用信息，防止淹没重要信息</p>
</li>
<li><p>要尽可能使日志信息准确全面，以便快速精确定位问题</p>
</li>
<li><p>要统一日志格式规范，以方便后续排障和分析</p>
</li>
<li><p>要不断优化完善日志，以提升问题定位效率</p>
</li>
<li><p>要明确不同功能日志的用途，使日志内容符合对应功能日志的要求</p>
</li>
<li><p>开发过程中记录日志应思考：</p>
<ul>
<li>该行日志真的有人看么？</li>
<li>该条日志能够传递什么信息？</li>
<li>这条日志能对排障带来什么帮助？</li>
</ul>
</li>
</ul>
<h1 id="4-日志规范"><a href="#4-日志规范" class="headerlink" title="4. 日志规范"></a>4. 日志规范</h1><h2 id="4-1-日志级别的选择规约"><a href="#4-1-日志级别的选择规约" class="headerlink" title="4.1. 日志级别的选择规约"></a>4.1. 日志级别的选择规约</h2><blockquote>
<p>如何针对不同场景，选择恰当的日志级别？</p>
</blockquote>
<ul>
<li><strong>Emergency</strong>：<ul>
<li>发生导致系统不可用的事故时</li>
<li>一个进程的生命周期里最多记录一次 Emergency 级别日志（慎用）</li>
</ul>
</li>
<li><strong>Alert</strong>：<ul>
<li>发生核心功能不可用的紧急事件时</li>
<li>紧急程度仅次于 Emergency，此时系统虽仍可用，但已严重影响了功能的完整性与可用性</li>
<li>必须马上处理</li>
</ul>
</li>
<li><strong>Critical</strong>：<ul>
<li>发生程序组件不可用的危急事件时</li>
<li>需要马上处理</li>
</ul>
</li>
<li><strong>Error</strong>：<ul>
<li>程序运行中出现错误，但不影响整个系统的逻辑运行时</li>
<li>一般不需要立即修复，但必须及时记录并做检测</li>
</ul>
</li>
<li><strong>Warning</strong>：<ul>
<li>发生若不及时处理可能引发&#x2F;导致程序出错的征兆事件时</li>
<li>虽暂时未发生程序错误，但也需要提醒并及时查看和处理</li>
</ul>
</li>
<li><strong>Notice</strong>：<ul>
<li>发生不影响程序功能，但需要引起注意的事件时</li>
</ul>
</li>
<li><strong>Informational</strong>：<ul>
<li>记录系统正常运行的一般信息，侧重对正常运行的主要流程的记录</li>
<li>辅助更高级别错误日志的定位分析，譬如排除掉Error错误前已打Info日志的正常流程，缩小排障范围</li>
</ul>
</li>
<li><strong>Debug</strong>：<ul>
<li>帮助开发&#x2F;测试&#x2F;运维人员，对系统进行诊断的更丰富和细致的信息</li>
</ul>
</li>
</ul>
<p>日志级别选择流程：</p>
<p><img data-src="/../../../../uploads/logLevelChoose.png" alt="CloudComputing-20190617100822880"></p>
<h2 id="4-2-日志格式规约"><a href="#4-2-日志格式规约" class="headerlink" title="4.2. 日志格式规约"></a>4.2. 日志格式规约</h2><blockquote>
<p>如何利用正确的日志格式规范所输出的日志内容？</p>
</blockquote>
<h3 id="4-2-1-日志格式总体要求"><a href="#4-2-1-日志格式总体要求" class="headerlink" title="4.2.1. 日志格式总体要求"></a>4.2.1. 日志格式总体要求</h3><ul>
<li><strong>统一字段命名</strong>：对于不同请求中的同一含义的字段，只能有一个名字</li>
<li><strong>统一字段风格</strong>：譬如字段一律使用 xxx_yyy 的下划线命名风格</li>
<li><strong>统一字段顺序</strong>：譬如统一使用 请求ID&#x2F;服务名&#x2F;请求参数&#x2F;响应数据&#x2F;响应时间 作为日志字段顺序</li>
</ul>
<h3 id="4-2-2-格式规则"><a href="#4-2-2-格式规则" class="headerlink" title="4.2.2. 格式规则"></a>4.2.2. 格式规则</h3><ul>
<li>避免字符串拼接，使用‘{‘和’}’作为消息正文中参数的占位符</li>
<li>避免重复记录，同样的日志内容理论上只需要记录一次，否则会造成磁盘空间浪费，过多冗余日志也会对查找问题产生干扰</li>
<li>日志一定要有显示Level呈现，一眼就知道日志属性</li>
<li>重要日志信息脱敏，如用’*’号代替</li>
</ul>
<h3 id="4-2-3-日志格式"><a href="#4-2-3-日志格式" class="headerlink" title="4.2.3. 日志格式"></a>4.2.3. 日志格式</h3><p>即日志的字段结构，包含哪些字段，字段顺序等</p>
<p><br><b><font color="#7E3D76" style="">示例日志格式</font></b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-08-31 20:35:01.713966 host &lt;local2.notice&gt; NOTICE client[38] zread_hello(): client 29 says hello and bids fair.</span><br></pre></td></tr></table></figure>

<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center"><b>日志结构中各字段</b></th>
        <th align="center"><b>对应日志内容</b></th>
    </tr>
    <tr>
        <td><b><font color="green" style="">日志时间</font></b></td>
        <td>2021-08-31 20:35:01.713966</td>
    </tr>
    <tr>
        <td><b><font color="green" style="">主机名</font></b></td>
        <td>host</td>
    </tr>
    <tr>
        <td><b><font color="green" style="">日志属性&lt;模块类别.日志级别&gt;</font></b></td>
        <td>&lt;local2.notice&gt;</td>
    </tr>
    <tr>
        <td><b><font color="green" style="">日志级别</font></b></td>
        <td>NOTICE</td>
    </tr>
    <tr>
        <td><b><font color="green" style="">所属进程/线程</font></b></td>
        <td>client[38]</td>
    </tr>
    <tr>
        <td><b><font color="green" style="">类名/方法名</font></b></td>
        <td>zread_hello():</td>
    </tr>
    <tr>
        <td><b><font color="green" style="">日志正文</font></b></td>
        <td>client 29 says hello and bids fair.</td>
    </tr>
</table>


<h2 id="4-3-日志内容规约"><a href="#4-3-日志内容规约" class="headerlink" title="4.3. 日志内容规约"></a>4.3. 日志内容规约</h2><blockquote>
<p>什么场景下打日志，日志输出什么内容？</p>
</blockquote>
<h3 id="4-3-1-推荐记录的日志内容"><a href="#4-3-1-推荐记录的日志内容" class="headerlink" title="4.3.1. 推荐记录的日志内容"></a>4.3.1. 推荐记录的日志内容</h3><p><b><font color="#7E3D76" style="">1. 系统启动或初始化时，重要的系统初始化参数、配置加载【Info】</font></b></p>
<p><b><font color="#7E3D76" style="">2. 系统运行过程中的重要信息</font></b></p>
<ul>
<li>所有<strong>错误信息</strong>：<ul>
<li>程序崩溃事故【Emergency】</li>
<li>核心功能不可用紧急事件【Alert】</li>
<li>程序组件不可用危急事件【Critical】</li>
<li>程序运行错误【Error】</li>
</ul>
</li>
<li>所有<strong>警告信息</strong>【Warning】：<ul>
<li>暂未但不及时处理可能将会导致错误的事件</li>
<li>流程中正常的请求出错</li>
</ul>
</li>
<li>关键<strong>流程信息</strong>【Info】：<ul>
<li>主要模块间的请求与响应</li>
<li>重要事件的发生与结束</li>
<li>重要状态变化</li>
<li>持久化数据时修改前后的记录变化</li>
<li>长期执行任务的执行进度</li>
</ul>
</li>
<li>后台<strong>定期执行任务</strong>【Info】：<ul>
<li>定期缓存更新任务的启停时间</li>
</ul>
</li>
<li>异常处理逻辑【Notice】：<ul>
<li>请求资源首次未成功后，后续尝试再次请求的行为记录</li>
</ul>
</li>
</ul>
<p><b><font color="#7E3D76" style="">3. 有助于排障运维的信息【Debug】</font></b></p>
<ul>
<li>重要事件函数的启停，返回值信息等</li>
<li>核心变量的变化</li>
<li>内存数据结构的状态</li>
</ul>
<h3 id="4-3-2-避免记录的日志内容"><a href="#4-3-2-避免记录的日志内容" class="headerlink" title="4.3.2. 避免记录的日志内容"></a>4.3.2. 避免记录的日志内容</h3><ul>
<li>文件内容或者一大段消息的内容</li>
<li>良性“错误”，有时候尽管出现了错误，然而错误处理的流程可以正确解决这种情况</li>
<li>预期会发生且能够被正常处理的异常，否则将打印出一堆无用的堆栈信息</li>
<li>开发者为方便调试临时加入的非必要状态信息</li>
<li>输出机密信息</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels">When to use the different log levels</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1553096">日志记录规范总结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27363484">最佳日志实践（v2.0）</a></li>
<li><a href="https://juejin.cn/post/6844903584904003592">SeasLog 之企业级日志行为规范发布</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>syslog</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的博文编写调试发布流程简介</title>
    <url>/2018/08/29/post-debugging-steps/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/post-debugging-steps.png" class="full-image" />

<h1 id="1-博客文章编写＆调试＆发布"><a href="#1-博客文章编写＆调试＆发布" class="headerlink" title="1. 博客文章编写＆调试＆发布"></a>1. 博客文章编写＆调试＆发布</h1><h2 id="1-1-进入Hexo根目录"><a href="#1-1-进入Hexo根目录" class="headerlink" title="1.1. 进入Hexo根目录"></a>1.1. 进入Hexo根目录</h2><ol>
<li>输入密码,进入root用户模式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo su</span><br></pre></td></tr></table></figure></li>
<li>进入Hexo站点根目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;haoleeson&#x2F;haoleeson.github.io</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
</ol>
<h2 id="1-2-写文章"><a href="#1-2-写文章" class="headerlink" title="1.2. 写文章"></a>1.2. 写文章</h2><ol>
<li>进入发布文件夹<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;haoleeson&#x2F;haoleeson.github.io&#x2F;source&#x2F;_posts</span><br></pre></td></tr></table></figure></li>
<li>新建md文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch example.md</span><br></pre></td></tr></table></figure></li>
<li>编辑example.md文件，编写文章(用Markdown大肆发挥吧，可参考<a href="https://eisenhao.cn/2018/08/31/write-a-md-file/">Markdown文章语法</a>)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim example.md</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-3-本地调试"><a href="#1-3-本地调试" class="headerlink" title="1.3. 本地调试"></a>1.3. 本地调试</h2><ol>
<li>开启测试<figure class="highlight c"><figcaption><span>命令执行目录：~/你的博客站点根目录</span></figcaption><table><tr><td class="code"><pre><span class="line">$ sudo hexo s</span><br></pre></td></tr></table></figure></li>
<li>在浏览器中输入: <a href="http://localhost:4000/">http://localhost:4000/</a>以查看效果.</li>
</ol>
<h2 id="1-4-发布"><a href="#1-4-发布" class="headerlink" title="1.4. 发布"></a>1.4. 发布</h2><ol>
<li>测试没问题后，我们就生成静态网页文件发布至我们的Github pages 中。<figure class="highlight c"><figcaption><span>命令执行目录：~/你的博客站点根目录</span></figcaption><table><tr><td class="code"><pre><span class="line">$ cd /home/haoleeson/haoleeson.github.io</span><br><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
<li>可能会要求输入github账号密码</li>
<li>如果上传失败显示如下信息,可能是由于我们没有配置root环境中的GitHub账号global，按照提示配置一下GitHub的global账号即可.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="2-主题配置"><a href="#2-主题配置" class="headerlink" title="2. 主题配置"></a>2. 主题配置</h1><ol>
<li>主题配置文件在主题文件夹中,我们可以更改config.yml文件进行配置.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;haoleeson&#x2F;haoleeson.github.io&#x2F;themes&#x2F;next&#x2F;_config.yml</span><br></pre></td></tr></table></figure></li>
<li>用文本编辑器打开编辑主题配置文件,点击查看<a href="http://theme-next.iissnan.com/getting-started.html#theme-settings">设置详细介绍.</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim &#x2F;home&#x2F;haoleeson&#x2F;haoleeson.github.io&#x2F;themes&#x2F;next&#x2F;_config.yml</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="3-Linux-技巧每日一练"><a href="#3-Linux-技巧每日一练" class="headerlink" title="3. Linux 技巧每日一练"></a>3. Linux 技巧每日一练</h1><p>用管理员运行文档管理器. sudo nautilus 会打开root版的文档管理器，可在终端键入ctrl+c就会关闭这个文档管理器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo nautilus</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是真正的富人思维？</title>
    <url>/2017/01/07/rich-thinking-by-mba/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/rich-thinking-by-mba.jpg" class="full-image" />

<div class="note success"><p>全文摘自MBA中国网：<br><a href="http://www.mbachina.com/html/zhaopin/201701/101719.html">http://www.mbachina.com/html/zhaopin/201701/101719.html</a></p>
</div>

<h1 id="1-你渴望成为的那种有钱人，不是靠技能获取一份高工资的人"><a href="#1-你渴望成为的那种有钱人，不是靠技能获取一份高工资的人" class="headerlink" title="1. 你渴望成为的那种有钱人，不是靠技能获取一份高工资的人"></a>1. 你渴望成为的那种有钱人，不是靠技能获取一份高工资的人</h1><p>严格来说，即使在中国，凭借高超的技术领取高薪，最终取得财务自由也不是不可能的，只是难度极大，而且异常辛苦。没有过人的先天的条件和顶级的后天培养，大多数人所能习得的技能，都不是不可替代到让老板心甘情愿为你付一份远远超过市场平均水平的薪水的。只要你对中国绝大多数企业的收入获得方式稍加理解，就能明白技术骨干的收入是很难超过掌握客户的销售总监和组建团队和客户对接的项目主管的。</p>
<a id="more"></a>

<p>美国的一个著名的喜剧明星Chris Rock在一场脱口秀中讲过一个段子：黑人在美国最多也就rich，但不可能wealthy。奥尼尔年薪两千万美金，那只能叫rich;在奥尼尔工资支票上签字的那些白人老头们，才能算wealthy。事实上，我们身边最常见的有钱人都是后者，他们不是技能过人的人，而是整合资源的人，简称老板，也是这篇文章想探讨的重点。</p>
<p>值得一提的是，在现代的商业环境下，并非传统企业那种100%的公司拥有者才叫老板。项目投资人，企业的合伙人，装修队的工头，夜总会的妈咪，安排一队小弟在三里屯收二手iPhone自己坐在旁边抽烟的人… 但凡直接发起并促成商业活动的人，在我看来都是老板。</p>
<p>你真正渴望成为的那种有钱人，不是超凡技能的人，而是寻找资源并整合资源的人。这就是学校和父母从来不曾告诉你的秘密，当然了他们之所以不告诉你，很可能是因为自己也没这么想过。</p>
<h1 id="2-自我保护心理注定了穷人的宿命"><a href="#2-自我保护心理注定了穷人的宿命" class="headerlink" title="2. 自我保护心理注定了穷人的宿命"></a>2. 自我保护心理注定了穷人的宿命</h1><p>不信?可以看看你身边多少人热衷于分享 “盖茨的的书不会告诉你他母亲是IBM董事”，“还原聚美优品陈欧履历造假真相”，百度知道甚至有好几个问题都在研究“马化腾究竟是是不是富二代”。</p>
<p>我们的内心深处有一种与生俱来的强烈的自我保护机制，它会不停地暗示你，只有自己的想法和选择才是最好的最合理的。但凡当大脑扫描到有什么人和事会令自己的显得是如此的无知而无能的信息，这种保护机制就会迅速启动，收集一切线索去证明他们都是因为一些<em>客观因素而侥幸成功</em>，自己要是有同样的客观条件，只会比他们更好。</p>
<p>在<a href="http://wiki.mbalib.com/wiki/%E9%A6%96%E9%A1%B5">MBA智库百科</a>中，自我保护是指个体维护心理平衡的一种自发性行为，即是通过压抑、补偿、文饰和升华的手段改变对心理紧张的主观感受，掩饰不能接受的内在冲动和虚拟现实环境的危险，用以<em>减少痛苦</em>以及对痛苦的<em>意识</em>，达到心理平衡的行为反应。<small>(自欺欺人)</small></p>
<p>而且，万一这些成功人士是自己身边非常熟悉的人，内心的保护机制会更加强大。就像上学的时候，我们热衷于讨论学习好的人都是书呆子没出息，漂亮姑娘只喜欢开跑车的渣男一样;长大之后则变成了，同事升职了是因为会拍领导马屁，同学创业成功了因为家里给了巨额的启动资金。穷人的头脑(<em>穷人思维</em>)是如此的敏捷，如果上述原因都找不到，还有最后一招杀手锏。</p>
<p>是的，正是这种与生俱来的自我保护心理，维护了社会稳定，减少了自杀率，也让<small>极少</small>的一部分克服了这种心理的人，成为了有钱人。</p>
<blockquote>
<p>总结下来就是，穷人相信人和人之间的差距是<em>客观条件所决定的</em>，而富人相信这种差距的决定性因素是主观能动性。</p>
</blockquote>
<p><em>穷人的思维习惯</em>是：<em>他们做到了，是因为他们富二代&#x2F;有关系&#x2F;运气好，我没有这些，所以我做不到</em>（<em>将一切原因归咎于客观条件，掩饰自生的问题）。如果我有这些条件，我也可以做到</em>。富人的思维习惯是：他们做到了，我为什么没做到，我怎么才能做到?（正视自身薄弱点，充分发挥主观能动性，并积极地通过理性分析和寻找各种方式弥补差距）</p>
<p>可怜的穷人们，不打破这种自我保护的心里，是很难摆脱一事无成的宿命的。可惜，他们中的大多数一生都<del><em>沉浸在自我安慰中，从怀才不遇到壮志未酬，最终感慨平平淡淡才是真。</em></del></p>
<h1 id="3-有钱人的思维是整合资源，而不是拥有现成的资源"><a href="#3-有钱人的思维是整合资源，而不是拥有现成的资源" class="headerlink" title="3. 有钱人的思维是整合资源，而不是拥有现成的资源"></a>3. 有钱人的思维是整合资源，而不是拥有现成的资源</h1><p>如果这篇文章你只能看一段，那就是这一段，没准它就能改变个别人的人生轨迹。</p>
<p>其实很多穷人也不是甘心于一辈子领薪水的啊，他们只是在等机会，他们<small>永远在等机会</small>。</p>
<p>“我在美国留学的时候，惊人地发现原来每个留学生和他们的父母心里其实也都有一条走上人生巅峰的道路嘛。本科认真学习，积极参加课外活动，拓展社交网络，最终成绩优异简历丰富，找到一个大公司工作几年积累工作经验，继续名校MBA深造，出任跨国公司高级管理人员，最终调回国内担任中国区经理，甚至<del>时机成熟了</del>，凭借多年工作积累的经验和人脉，跳出来单飞最终创业成功。”</p>
<p>听起来如此酣畅淋漓的人生攻略，其实是最经典的穷人思维，穷人总以为有钱人的每一步都是<em>按部就班顺水推舟得来的，所以要等着一切时机都成熟了，一切资源都获取了，才能开始行动</em>。</p>
<p>他们无法理解的是，世界上还有另外一小撮人，和他们拥有类似的客观条件，但却把他们觉得遥不可及的事情做起来了。这一小撮人，没有本金，找朋友借钱找投资人投资甚至找银行贷款；没有技术，自己去现学或者找到懂技术的人帮自己来做；没有关系，找人介绍请人吃饭送礼屡败屡战；没有客户，一个一个冷拨电话登门拜访甚至办公室门口堵着。上面这种人，就是传说中的老板。（正视自身薄弱点，充分发挥主观能动性，并积极地通过理性分析和寻找各种方式弥补差距 。整合资源，而不是拥有现成的资源）</p>
<p>按照穷人的万事俱备才能行动的思维，聚美优品的创业过程应该是这样：</p>
<p>陈欧同学大学时期学习的是快消品营销，斯坦福MBA毕业后进入丝芙兰美国总部担任销售高管，工作五年之后跳槽到天猫国际任化妆品频道总监，在天猫又干了几年之后，掌握了大量供货商资源，打造了一个优秀的电商运营团队，在化妆品行业侵染了20多年后，终于在2026年成立了聚美优品。然后…</p>
<p>聚美优品的实际创业过程这里就不细表了，微博上已经写的太多了，可无论陈老板的之前经历作假也好，波士堂上装逼也罢，还是他家里多有钱真格基金给他提供了多少关系，他又如何运气好赶上了垂直化电商爆发的前夜，仅仅是他决定去做化妆品电商这一件事，勇气和魄力就远远超越了多少客观条件跟他相仿甚至更好的人。</p>
<p>其实，当你真正开始做一个整合资源的老板的时候就会发现，你之前自以为拥有的资源和人脉远没有你想的那么好用，任何一个商业活动从无到有，都必然要经历那些团队不整没有客户的阶段，滴滴打车两年前还在在北京机场T3一个一个拽着出租车司机下载App;以雷军在互联网圈二十多年的人脉，创立小米的时候光一个个登门挖人就挖了近一年，相比之下，你觉得自己能有的那些资源又能有多管用呢?切记，老板的实质是寻找资源然后整合资源的人，并不是拥有现成资源的人。</p>
<p>更进一步说，一切商业机会都包含了大量的未知因素，而鉴于人类对于一个未知事物的群体接受度的判断力是极其有限的，一个优秀的老板擅长的是边做根据形势快速调整自己的商业活动，而不是事先把一切事情都预料好了。你能想象亚马逊的创始人当年在网上卖书的时候，已经计划好了公司的业务要包括电子阅读器，电商，流媒体，云计算，无人机吗?</p>
<p>为什么穷人等待的机会永远不会到来?等你把一切都看的清清楚楚的时候，市场早已经被那些趁着一切并不明朗就冲进去的人瓜分干净了。真正的好机会，永远都存在与未知中。同样的道理并非只存在于商业世界，每个人生活中最好的机会，几乎都出现在那些你没有完全准备好的时候。</p>
<p>还记得刚去美国的时候，我听说高中的数学课代表去新东方做了托福老师，班里的同学谈起这件事，语气中大多充满了怀疑和嘲讽，因为大家都清楚他高中的时候学习好是因为数理化成绩优异，英语水平根本不行。他们想的一点没错，后来我才得知，这哥们当时连托福都没考过，但就是一咬牙硬着头皮上去应聘还成功了，结果最初过得心惊胆战，做梦都怕被学生从讲台上赶下来，于是每天疯狂的做题备课恶补英语，好不容易坚持了下来。</p>
<p>而两年之后，嘲讽他的人还是当年的样子，他已经成了新东方的托福名师，公开课出现在新东方官网上，学生遍布北美。后来我默默地在家里看了他的讲课视频，比起我当年崇拜的那些新东方名师毫不逊色。我忽然想起了罗永浩当年写给俞敏洪的求职信，试想如果罗老师当年认为要把英语练到王强老师一样才能敢去新东方应聘，现在可能也只是一个吉林延边的文艺老愤青罢。</p>
<p>你看，真正把事情做起来的人，考虑的问题的过程其实是这样的，这件事我一定要做，缺什么东西我去想办法去争取。而什么做不起来的人，永远在等待时机成熟。</p>
<p>只有在实践中摔打过才知道，牛逼的商业理论可以让企业从1发展到10000，可以让创业者在经营的路上少走很多弯路，可以帮其他成型的企业的做商业咨询分析，但是对于一个渴望无中生有开展一段成功的商业活动的人而言，寻找资源并整合资源的能力才是从0到1的根本，它和任何具体的知识都没有关系，而是源于突破舒适区的决心，不屈不挠解决问题的耐心，愿赌服输的魄力。简而言之，它是一股不安于现状，相信主观能动性可以超越客观条件的，比性欲还强烈的内心驱动力。</p>
<p>无论是工作还是生活，成功的人必然是有勇有谋，但勇又大于谋。相比之下，勤奋专注聪明简直只能算雕虫小技，唯有勇气才是一个人出类拔萃的核心竞争力。</p>
<h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h1><p>如果你的抽象思维能力实在有限，必须得看十分具体的例子去理解究竟什么才是寻找资源并整合资源，强烈推荐你上网看两个故事，一个是星巴克老板舒尔茨当年在西雅图开第一家咖啡店的始末，另一个是杨洁导演拍摄86版西游记的过程。</p>
<p>以上，就是我在读了这么多年书，看了那么多案例，和自己在残酷的实践中，能给出的关于“不是富二代，不是官二代，很想成功，是不是就会成功了”的最好答案。至于你觉得它是醍醐灌顶还是勾兑鸡汤，看你的了。</p>
<div class="note success"><p>全文摘自MBA中国网：<br><a href="http://www.mbachina.com/html/zhaopin/201701/101719.html">http://www.mbachina.com/html/zhaopin/201701/101719.html</a></p>
</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>深度好文</tag>
      </tags>
  </entry>
  <entry>
    <title>sonic201911 丢失 swss.rec 历史日志问题及修复</title>
    <url>/2021/11/22/sonic201911_lost_swss_rec_history_log_problem_and_fix/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>sonic版本：201911</p>
<p>发现问题： swss.rec 无轮转文件</p>
<a id="more"></a>

<h1 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h1><h2 id="2-1-问题定位"><a href="#2-1-问题定位" class="headerlink" title="2.1. 问题定位"></a>2.1. 问题定位</h2><p><code>/var/log/swss/swss.rec</code> 文件存在被其他未知程序误删或覆盖的操作</p>
<h2 id="2-2-问题可能性分析"><a href="#2-2-问题可能性分析" class="headerlink" title="2.2. 问题可能性分析"></a>2.2. 问题可能性分析</h2><ul>
<li>怀疑被其他未知程序或脚本误删或覆盖。<br>通过 <code>lsof /var/log/swss/swss.rec</code> 命令观测读写 <code>swss.rec</code> 文件的进程，仅发现 orchagent 及 轮转时 logrotated 进程，而同路径 <code>sairedis.rec</code> 正常，且测试<code>swss.rec</code>轮转正常，排除。</li>
<li>怀疑为 Docker 同步问题。<br>&#x2F;var&#x2F;log&#x2F;swss&#x2F; 路径为 swss 容器（rw形式）挂载宿主机同路径文件夹，怀疑可能同步问题导致，但同路径 <code>sairedis.rec</code> 正常，排除。</li>
<li>怀疑 orchagent 进程未正常关闭、重启可能导致正在打开的 <code>swss.rec</code> 内容丢失。<br>但相似模式的 <code>sairedis.rec</code> 无此问题，排除。</li>
<li>怀疑 orchagent 进程对 <code>swss.rec</code> 读写业务流程中与 <code>sairedis.rec</code> 存在差异的地方导致的此问题。<br>分析源码 swss.rec 读写流涉及函数，发现 main.cpp 中必打的日志丢失。<img data-src="../../../../uploads/Analyze_the_source_code_swss_rec.png" class="full-image" /></li>
<li>怀疑 “pgrep -x orchagent | xargs &#x2F;bin&#x2F;kill -HUP 2&gt;&#x2F;dev&#x2F;null || true” 触发 Orch::logfileReopen() 后，文件打开方式为默认，可能会覆盖之前内容。<br>swss.rec 与 sairedis.rec 重载参数对比：<img data-src="../../../../uploads/Comparison_of_swss_rec_and_sairedis_rec.png" class="full-image" /></li>
</ul>
<h3 id="2-2-1-测试-logfileReopen-函数调用前后-swss-rec-文件变化"><a href="#2-2-1-测试-logfileReopen-函数调用前后-swss-rec-文件变化" class="headerlink" title="2.2.1. 测试 logfileReopen() 函数调用前后 swss.rec 文件变化"></a>2.2.1. 测试 logfileReopen() 函数调用前后 swss.rec 文件变化</h3><img data-src="../../../../uploads/Test_logfileReopen_the_swss.rec.png" class="full-image" />

<p>分析：给 orchagent 发送 HUP 信号，触发重载 <code>swss.rec</code> 文件后，后续写入的新内容将覆盖历史日志，造成日志丢失。</p>
<h3 id="2-2-2-测试重载流程中的关键函数-open-是否携带参数造成的差异"><a href="#2-2-2-测试重载流程中的关键函数-open-是否携带参数造成的差异" class="headerlink" title="2.2.2. 测试重载流程中的关键函数 open() 是否携带参数造成的差异"></a>2.2.2. 测试重载流程中的关键函数 open() 是否携带参数造成的差异</h3><p>这也是 <code>swss.rec</code> 与 <code>sairedis.rec</code> 两个文件重载中的主要差异点。<br><img data-src="../../../../uploads/Test_the_open_file_func_with_no_parameters_and_with_parameters.png" class="full-image" /></p>
<p>由测试结果可知：</p>
<ul>
<li>默认无参 open() 打开文件将覆盖旧内容，造成历史日志丢失。</li>
<li>而带 out 及 app 参数的 open() 打开文件将采用追加形式写入新内容，历史内容会被保留。<ul>
<li>ofstream::out，Open for output.  Default for @c ofstream and fstream.</li>
<li>ofstream::app，eek to end before each write.</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-根因总结"><a href="#2-2-3-根因总结" class="headerlink" title="2.2.3. 根因总结"></a>2.2.3. 根因总结</h3><p>上述分析可知根因为： <code>swss.rec</code> 的重载函数中 open() 未携带 out 及 app 参数，导致后续内容覆盖了历史日志，造成日志丢失。</p>
<h2 id="2-3-问题影响"><a href="#2-3-问题影响" class="headerlink" title="2.3. 问题影响"></a>2.3. 问题影响</h2><ul>
<li><strong>问题后果</strong>：造成 <code>swss.rec</code> 日志记录丢失，影响排障定位。</li>
<li><strong>触发条件</strong>：orchagent 在未达到轮转阈值前，就被误发送 HUP 信号问题“概率”引发），进而导致 orchagent 采用“覆盖”open()的形式打开 <code>swss.rec</code>，进而导致该文件的历史日志丢失。</li>
</ul>
<h1 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h1><p>在 <code>swss.rec</code> 的重载函数中调 open()处增加 out 及 app 参数，使其以追加形式写入后续日志，以保留历史日志。改动如下：<br>src&#x2F;sonic-swss&#x2F;orchagent&#x2F;orch.cpp 的重载函数Orch::logfileReopen()，在调用 open()函数处增加 out 及 app 参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gRecordOfs.open(gRecordFile, std::ofstream::out | std::ofstream::app);</span><br></pre></td></tr></table></figure>

<p>修复后换包自问题已修复， <code>swss.rec</code> 历史日志不再丢失。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SONiC</tag>
      </tags>
  </entry>
  <entry>
    <title>sonic各类告警日志梳理</title>
    <url>/2022/02/14/sonicLogs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-硬件类"><a href="#1-硬件类" class="headerlink" title="1. 硬件类"></a>1. 硬件类</h1><blockquote>
<p>本地日志：&#x2F;var&#x2F;log&#x2F;syslog</p>
</blockquote>
<h2 id="1-1-电源"><a href="#1-1-电源" class="headerlink" title="1.1. 电源"></a>1.1. 电源</h2><ul>
<li><p>插入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化时默认打印</span></span><br><span class="line">2022-02-14 17:56:02.609340 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :pluggable_dev_log:- Psu2 is plugged in. vendor: ARTESYN, serial number: L214VZ006005P</span><br></pre></td></tr></table></figure>
</li>
<li><p>拔出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂无操作日志，日志代码如下：</span></span><br><span class="line">logger.log_warning(device + &#x27; is pulled out. &#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 预估拔出电源日志</span></span><br><span class="line">2022-02-14 17:56:02.609340 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :pluggable_dev_log:- Psu2 is pulled out.</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 异常也可能为四种异常（<span class="string">&#x27;no power&#x27;</span>, <span class="string">&#x27;thermal error&#x27;</span>, <span class="string">&#x27;fan error&#x27;</span>, <span class="string">&#x27;vol error&#x27;</span>）的任意组合，共 15 种情况：</span></span><br><span class="line">2022-02-14 17:56:02.614955 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :dev_alarm_log:- Psu2 is alarm: no power</span><br><span class="line">2021-12-22 03:42:27.825952 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :dev_alarm_log:- Psu1 is alarm: from normal to no power, vol error</span><br></pre></td></tr></table></figure></li>
</ul>
<a id="more"></a>

<ul>
<li>正常<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化时也会打印</span></span><br><span class="line">2022-02-14 17:56:02.596387 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :dev_alarm_log:- Psu1 is normal</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-风扇"><a href="#1-2-风扇" class="headerlink" title="1.2. 风扇"></a>1.2. 风扇</h2><ul>
<li><p>插入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化时默认打印</span></span><br><span class="line">2022-02-14 10:25:37.481551 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :pluggable_dev_log:- Fan2 is plugged in. vendor: Inventec, serial number: 945301818370UZ</span><br></pre></td></tr></table></figure>
</li>
<li><p>拔出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂无操作日志，日志代码如下：</span></span><br><span class="line">logger.log_warning(device + &#x27; is pulled out. &#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 预估拔出风扇日志</span></span><br><span class="line">2022-02-14 10:25:37.481551 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :pluggable_dev_log:- Fan2 is pulled out.</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂无操作日志，日志代码如下：</span></span><br><span class="line">logger.log_warning(&#x27;%s is alarm&#x27; % device)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 预估风扇异常日志</span></span><br><span class="line">2022-02-14 17:56:15.038878 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :dev_alarm_log:- Fan6 is alarm</span><br></pre></td></tr></table></figure>
</li>
<li><p>正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化时正常默认打印</span></span><br><span class="line">2022-02-14 17:56:15.038878 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :dev_alarm_log:- Fan6 is normal</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-3-CPU"><a href="#1-3-CPU" class="headerlink" title="1.3. CPU"></a>1.3. CPU</h2><blockquote>
<p>本地日志：&#x2F;var&#x2F;log&#x2F;monit.log</p>
</blockquote>
<ul>
<li><p>monit 检测到用户态 CPU 使用率过高告警</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-17 16:05:47.705193 HOSTNAME &lt;local2.err&gt; ERR monit[652]: &#x27;HOSTNAME.TEST&#x27; cpu user usage of 93.1% matches resource limit [cpu user usage&gt;90.0%]</span><br></pre></td></tr></table></figure>
</li>
<li><p>monit 检测到内核态 CPU 使用率过高告警</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-17 16:16:06.390901 HOSTNAME &lt;local2.err&gt; ERR monit[615]: &#x27;HOSTNAME.TEST&#x27; cpu system usage of 99.8% matches resource limit [cpu system usage&gt;90.0%]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-4-内存"><a href="#1-4-内存" class="headerlink" title="1.4. 内存"></a>1.4. 内存</h2><blockquote>
<p>本地日志：&#x2F;var&#x2F;log&#x2F;monit.log</p>
</blockquote>
<ul>
<li>monit 检测到内存使用率过高告警<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-17 16:46:05.407053 HOSTNAME &lt;local2.err&gt; ERR monit[641]: &#x27;HOSTNAME.TEST&#x27; mem usage of 85.9% matches resource limit [mem usage&gt;80.0%]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-5-硬盘"><a href="#1-5-硬盘" class="headerlink" title="1.5. 硬盘"></a>1.5. 硬盘</h2><blockquote>
<p>本地日志：&#x2F;var&#x2F;log&#x2F;monit.log</p>
</blockquote>
<ul>
<li>monit 检测到总磁盘使用率过高告警<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-17 16:52:06.521099 HOSTNAME &lt;local2.err&gt; ERR monit[641]: &#x27;root-overlay&#x27; space usage 91.3% matches resource limit [space usage&gt;90.0%]</span><br></pre></td></tr></table></figure></li>
</ul>
<!-- 

磁盘不可写异常（ XorPlus 设备）
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Jan 1 11:44:33 100.122.166.72 HOSTNAME : [RTRMGR xorp_rtrmgr]Failed to save file /pica/config/pica_startup.boot: File /pica/config/pica_startup.boot.tmp exists, and can not be overwritten.#012Read-only file system</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!-- ## 2.5. 槽位号 slot【hwmgrd 未支持】 -->

<h2 id="1-6-光模块"><a href="#1-6-光模块" class="headerlink" title="1.6. 光模块"></a>1.6. 光模块</h2><ul>
<li><p>插入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化时默认打印</span></span><br><span class="line">2022-02-14 17:56:26.450923 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :pluggable_dev_log:- Sff12 is plugged in. vendor: FINISAR, serial number: PZ611NQ</span><br></pre></td></tr></table></figure>
</li>
<li><p>拔出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-12-14 16:10:18.780321 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :pluggable_dev_log:- Sff1 is pulled out.</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-7-线卡"><a href="#1-7-线卡" class="headerlink" title="1.7. 线卡"></a>1.7. 线卡</h2><ul>
<li><p>插入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化时默认打印</span></span><br><span class="line">2017-02-05 05:25:10.419415 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :pluggable_dev_log:- Linecard4 is plugged in. vendor: H3C, serial number: 210231AF1D020600001B</span><br></pre></td></tr></table></figure>
</li>
<li><p>拔出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂无操作日志，日志代码如下：</span></span><br><span class="line">logger.log_warning(device + &#x27; is pulled out. &#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 预估拔出板卡日志</span></span><br><span class="line">2017-02-05 05:25:10.419415 HOSTNAME &lt;local2.warning&gt; WARNING pmon#hwmgrd: :pluggable_dev_log:- Linecard4 is pulled out.</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-8-温度"><a href="#1-8-温度" class="headerlink" title="1.8. 温度"></a>1.8. 温度</h2><ul>
<li>高温告警<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-02 23:48:48.859650 HOSTNAME &lt;local2.warning&gt; WARNING pmon#drv: :dev_alarm_log:- Thermal alarm: hotspot11 : 93.00 Centigrade</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-端口类"><a href="#2-端口类" class="headerlink" title="2. 端口类"></a>2. 端口类</h1><blockquote>
<p>本地日志：&#x2F;var&#x2F;log&#x2F;syslog</p>
</blockquote>
<h2 id="2-1-硬件端口"><a href="#2-1-硬件端口" class="headerlink" title="2.1. 硬件端口"></a>2.1. 硬件端口</h2><ul>
<li><p>端口 UP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-14 10:32:54.573793 HOSTNAME &lt;local2.warning&gt; WARNING swss#orchagent: :- updatePortOperStatus: OperStatus of Port Ethernet38 (alias: he-1/1/38) changed from down to up</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口 DOWN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-14 12:40:34.319598 HOSTNAME &lt;local2.warning&gt; WARNING swss#orchagent: :- updatePortOperStatus: OperStatus of Port Ethernet37 (alias: he-1/1/37) changed from up to down</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-三层接口"><a href="#2-2-三层接口" class="headerlink" title="2.2. 三层接口"></a>2.2. 三层接口</h2><ul>
<li><p>三层接口 UP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-14 10:32:54.583867 HOSTNAME &lt;local2.warning&gt; WARNING swss#orchagent: :- setHostVlanAdminState: OperStatus of L3Interface Vlan38 changed to up</span><br></pre></td></tr></table></figure>
</li>
<li><p>三层接口 DOWN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-14 12:40:34.344832 HOSTNAME &lt;local2.warning&gt; WARNING swss#orchagent: :- setHostVlanAdminState: OperStatus of L3Interface Vlan40 changed to down</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-协议类异常"><a href="#3-协议类异常" class="headerlink" title="3. 协议类异常"></a>3. 协议类异常</h1><h2 id="3-1-BGP"><a href="#3-1-BGP" class="headerlink" title="3.1. BGP"></a>3.1. BGP</h2><blockquote>
<p>模块代码： <code>src/HOSTNAME-frr/frr/bgpd/</code> </p>
</blockquote>
<ul>
<li>异常<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂未找到异常日志，日志代码如下：</span></span><br><span class="line">zlog_err(&quot;BGPd daemon failed: %s&quot;, strerror(errno));</span><br><span class="line">zlog_err(&quot;getsockopt of SO_SNDBUF failed %s\n&quot;, safe_strerror(errno));</span><br><span class="line">zlog_err(&quot;couldn&#x27;t create af structure for peer %s&quot;, peer-&gt;host);</span><br><span class="line">zlog_err (&quot;bgp_connect_success peer&#x27;s fd is negative value %d&quot;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-1-1-BGP-容器停启日志"><a href="#3-1-1-BGP-容器停启日志" class="headerlink" title="3.1.1. BGP 容器停启日志"></a>3.1.1. BGP 容器停启日志</h3><blockquote>
<p>本地日志：&#x2F;var&#x2F;log&#x2F;daemon.log</p>
</blockquote>
<ul>
<li><p>BGP 容器启动日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-01-25 11:11:51.100344 HOSTNAME &lt;daemon.info&gt; INFO systemd[1]: Started BGP container.</span><br></pre></td></tr></table></figure>
</li>
<li><p>BGP 容器停止日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2021-12-24 11:20:50.749969 HOSTNAME &lt;daemon.info&gt; INFO systemd[1]: Stopping BGP container...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-1-2-BGP-容器中关键子进程退出日志"><a href="#3-1-2-BGP-容器中关键子进程退出日志" class="headerlink" title="3.1.2. BGP 容器中关键子进程退出日志"></a>3.1.2. BGP 容器中关键子进程退出日志</h3><blockquote>
<p>此 local0 日志为监控工具 supervisor 产生（ <code>/var/log/syslog</code> ），不会上传日志服务器</p>
</blockquote>
<ul>
<li><p>zebra 退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-14 15:53:36.202696 HOSTNAME &lt;local0.info&gt; INFO bgp#supervisord 2022-02-14 15:53:31,385 INFO exited: zebra (terminated by SIGKILL; not expected)</span><br></pre></td></tr></table></figure>
</li>
<li><p>staticd 退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-14 15:58:56.443911 HOSTNAME &lt;local0.info&gt; INFO bgp#supervisord 2022-02-14 15:58:55,433 INFO exited: staticd (terminated by SIGKILL; not expected)</span><br></pre></td></tr></table></figure>
</li>
<li><p>bgpd 退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-14 16:01:46.588714 HOSTNAME &lt;local0.info&gt; INFO bgp#supervisord 2022-02-14 16:01:44,320 INFO exited: bgpd (terminated by SIGKILL; not expected)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-1-3-BGP-建立-x2F-断开邻居事件日志"><a href="#3-1-3-BGP-建立-x2F-断开邻居事件日志" class="headerlink" title="3.1.3. BGP 建立&#x2F;断开邻居事件日志"></a>3.1.3. BGP 建立&#x2F;断开邻居事件日志</h3><blockquote>
<p>本地日志：&#x2F;var&#x2F;log&#x2F;quagga&#x2F;bgpd.log</p>
</blockquote>
<img data-src="../../../../uploads/BGP_state.png" class="full-image" />

<ul>
<li><p>邻居建立</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-11 15:43:20.630737 HOSTNAME &lt;local2.notice&gt; NOTICE bgp#bgpd[45]: 10.166.0.66 went from Idle to Connect</span><br><span class="line">2022-02-11 15:43:20.631348 HOSTNAME &lt;local2.notice&gt; NOTICE bgp#bgpd[45]: 10.166.0.66 went from Connect to OpenSent</span><br><span class="line">2022-02-11 15:43:20.631844 HOSTNAME &lt;local2.notice&gt; NOTICE bgp#bgpd[45]: 10.166.0.66 went from OpenSent to OpenConfirm</span><br><span class="line">2022-02-11 15:43:20.633960 HOSTNAME &lt;local2.notice&gt; NOTICE bgp#bgpd[45]: 10.166.0.66 went from OpenConfirm to Established</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻居断开</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-13 00:19:45.015599 HOSTNAME &lt;local2.notice&gt; NOTICE bgp#bgpd[45]: 10.166.0.66 went from Established to Clearing</span><br><span class="line">2022-02-13 00:19:45.128939 HOSTNAME &lt;local2.notice&gt; NOTICE bgp#bgpd[45]: 10.166.0.66 went from Clearing to Idle</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-2-OSPF【未支持】"><a href="#3-2-OSPF【未支持】" class="headerlink" title="3.2. OSPF【未支持】"></a>3.2. OSPF【未支持】</h2><blockquote>
<p>模块代码： <code>src/HOSTNAME-frr/frr/ospfd</code>、 <code>src/HOSTNAME-frr/frr/ospf6d</code> </p>
</blockquote>
<ul>
<li>异常<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 未启用，异常代码</span></span><br><span class="line">printf(&quot;Connecting to OSPF daemon on %s failed!\n&quot;, args[1]);</span><br><span class="line">vty_out (vty, &quot;   OSPF not enabled on this interface%s&quot;, VNL);</span><br><span class="line">flog_err(EC_OSPF_INIT_FAIL, &quot;OSPF instance init failed: %s&quot;, strerror(errno));</span><br><span class="line">flog_err(EC_LIB_SOCKET, &quot;%s: ospf_sock_init is unable to open a socket&quot;, __func__);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3-ISIS【未支持】"><a href="#3-3-ISIS【未支持】" class="headerlink" title="3.3. ISIS【未支持】"></a>3.3. ISIS【未支持】</h2><blockquote>
<p>模块代码： <code>src/HOSTNAME-frr/frr/isisd</code> </p>
</blockquote>
<ul>
<li>异常<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 未启用，异常代码</span></span><br><span class="line">flog_err(EC_ISIS_CONFIG, &quot;Could not bring up %s because of invalid config.&quot;, circuit-&gt;interface-&gt;name);</span><br><span class="line">flog_err(EC_ISIS_CONFIG, &quot;Clearing config for %s. Please re-examine it.&quot;, circuit-&gt;interface-&gt;name);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-MAC-类"><a href="#4-MAC-类" class="headerlink" title="4. MAC 类"></a>4. MAC 类</h1><blockquote>
<p>这类异常发生在芯片层级，不会输出告警日志</p>
</blockquote>
<p>但可通过监听 BCM 系列线程异常状态（<code>bcmL2X</code>、<code>bcmCNTR</code>、<code>bcmLINK</code>、<code>bcmDPC</code>、<code>bcmINTR</code>、<code>bcmTX</code>、<code>bcmXGS3AsyncTX</code>、<code>bcmRX</code>、<code>bcmL2age</code>），推测设备大概率发生了 MAC 类异常</p>
<p>各 BCM 线程异常退出&#x2F;重启日志如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-02-16 01:27:59.712742 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmCNTR&#x27; status failed (9) -- Thread bcmCNTR has exited abnormally. It is being restarted now.</span><br><span class="line">2022-02-16 01:27:59.715515 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmDPC&#x27; status failed (9) -- Thread bcmDPC has exited abnormally.</span><br><span class="line">2022-02-16 01:27:59.716774 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmINTR&#x27; status failed (9) -- Thread bcmINTR has exited abnormally.</span><br><span class="line">2022-02-16 01:27:59.711377 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmL2&#x27; status failed (9) -- Thread bcmL2X has exited abnormally. It is being restarted now.</span><br><span class="line">2022-02-16 01:27:59.736919 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmL2age&#x27; status failed (9) -- Thread bcmL2age has exited abnormally.</span><br><span class="line">2022-02-16 01:27:59.714208 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmLINK&#x27; status failed (9) -- Thread bcmLINK has exited abnormally. It is being restarted now.</span><br><span class="line">2022-02-16 01:27:59.726623 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmRX&#x27; status failed (9) -- Thread bcmRX has exited abnormally.</span><br><span class="line">2022-02-16 01:27:59.722205 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmTX&#x27; status failed (9) -- Thread bcmTX has exited abnormally.</span><br><span class="line">2022-02-16 01:27:59.723675 HOSTNAME &lt;local2.err&gt; ERR monit[661]: &#x27;bcmXGS3AsyncTX&#x27; status failed (9) -- Thread bcmXGS3AsyncTX has exited abnormally.</span><br></pre></td></tr></table></figure>

<h1 id="5-系统类"><a href="#5-系统类" class="headerlink" title="5. 系统类"></a>5. 系统类</h1><h2 id="5-1-各容器启-x2F-停状态日志查询"><a href="#5-1-各容器启-x2F-停状态日志查询" class="headerlink" title="5.1. 各容器启&#x2F;停状态日志查询"></a>5.1. 各容器启&#x2F;停状态日志查询</h2><p><b><font color="red" style="">各容器启&#x2F;停日志查看命令：</font></b><br></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;$&#123;container_name&#125; container&quot; /var/log/daemon.log</span><br></pre></td></tr></table></figure>

<h3 id="5-1-1-snmp-容器"><a href="#5-1-1-snmp-容器" class="headerlink" title="5.1.1. snmp 容器"></a>5.1.1. snmp 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;snmp container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># snmp 容器启动日志</span></span></span><br><span class="line">2022-01-18 15:25:48.218932 sonic &lt;daemon.info&gt; INFO systemd[1]: Started SNMP container.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># snmp 容器停止日志</span></span></span><br><span class="line">2022-01-18 15:25:19.641467 sonic &lt;daemon.info&gt; INFO systemd[1]: Stopped SNMP container.</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-lldp-容器"><a href="#5-1-2-lldp-容器" class="headerlink" title="5.1.2. lldp 容器"></a>5.1.2. lldp 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;lldp container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># lldp 容器启动日志</span></span></span><br><span class="line">2022-01-04 21:51:00.082042 sonic &lt;daemon.info&gt; INFO systemd[1]: Started LLDP container.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># lldp 容器停止日志</span></span></span><br><span class="line">2022-01-04 21:50:29.080276 sonic &lt;daemon.info&gt; INFO systemd[1]: Stopped LLDP container.</span><br></pre></td></tr></table></figure>

<h3 id="5-1-3-teamd-容器"><a href="#5-1-3-teamd-容器" class="headerlink" title="5.1.3. teamd 容器"></a>5.1.3. teamd 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;teamd container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># teamd 容器启动日志</span></span></span><br><span class="line">2022-01-13 14:40:41.912032 sonic &lt;daemon.info&gt; INFO systemd[1]: Started TEAMD container.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># teamd 容器停止日志</span></span></span><br><span class="line">2022-01-18 15:25:05.472610 sonic &lt;daemon.info&gt; INFO systemd[1]: Stopped TEAMD container.</span><br></pre></td></tr></table></figure>

<h3 id="5-1-4-bgp-容器"><a href="#5-1-4-bgp-容器" class="headerlink" title="5.1.4. bgp 容器"></a>5.1.4. bgp 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;bgp container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># bgp 容器启动日志</span></span></span><br><span class="line">2021-12-31 10:41:22.266584 sonic &lt;daemon.info&gt; INFO systemd[1]: Started BGP container.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># bgp 容器停止日志</span></span></span><br><span class="line">2022-01-04 21:50:43.337088 sonic &lt;daemon.info&gt; INFO systemd[1]: Stopped BGP container.</span><br></pre></td></tr></table></figure>

<h3 id="5-1-5-database-容器"><a href="#5-1-5-database-容器" class="headerlink" title="5.1.5. database 容器"></a>5.1.5. database 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;database container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># database 容器启动日志</span></span></span><br><span class="line">2022-01-20 18:11:58.655729 sonic &lt;daemon.info&gt; INFO systemd[1]: Started Database container.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># database 容器停止日志</span></span></span><br><span class="line">2021-12-23 18:07:52.612817 sonic &lt;daemon.info&gt; INFO systemd[1]: Stopped Database container.</span><br></pre></td></tr></table></figure>

<h3 id="5-1-6-radv-容器"><a href="#5-1-6-radv-容器" class="headerlink" title="5.1.6. radv 容器"></a>5.1.6. radv 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;radv container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># syncd 容器启动日志</span></span></span><br><span class="line">2022-01-11 17:14:24.665014 sonic &lt;daemon.info&gt; INFO radv.sh[2148]: Starting existing radv container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#（无容器退出日志，暂监听radv容器里的 supervisor-proc-exit-script 停止日志代替）</span></span></span><br><span class="line">sudo grep -a &quot;radv&quot; /var/log/syslog | grep &quot;supervisor-proc-exit-script&quot; | grep stop | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># radv 容器停止日志</span></span></span><br><span class="line">2022-01-11 11:54:36.009347 sonic &lt;local0.info&gt; INFO radv#supervisord 2022-01-11 11:53:52,755 INFO stopped: supervisor-proc-exit-script (terminated by SIGTERM)</span><br></pre></td></tr></table></figure>

<h3 id="5-1-7-dhcp-relay-容器"><a href="#5-1-7-dhcp-relay-容器" class="headerlink" title="5.1.7. dhcp_relay 容器"></a>5.1.7. dhcp_relay 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;dhcp_relay container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># dhcp_relay 容器启动日志（或启动一个已有容器）</span></span></span><br><span class="line">2022-01-20 18:12:07.952541 sonic &lt;daemon.info&gt; INFO dhcp_relay.sh[3429]: Starting existing dhcp_relay container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># （无容器退出日志，暂监听dhcp_relay容器里的 supervisor-proc-exit-listener 停止日志代替）</span></span></span><br><span class="line">sudo grep -a &quot;dhcp_relay&quot; /var/log/syslog | grep &quot;supervisor-proc-exit-listener&quot; | grep stop | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># dhcp_relay 容器停止日志</span></span></span><br><span class="line">2022-01-11 11:54:38.304276 sonic &lt;local0.info&gt; INFO dhcp_relay#supervisord 2022-01-11 11:53:54,128 INFO stopped: supervisor-proc-exit-listener (terminated by SIGTERM)</span><br></pre></td></tr></table></figure>

<h3 id="5-1-8-syncd-容器"><a href="#5-1-8-syncd-容器" class="headerlink" title="5.1.8. syncd 容器"></a>5.1.8. syncd 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;syncd container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># syncd 容器启动日志（创建一个新容器）</span></span></span><br><span class="line">2021-12-22 22:49:20.897248 sonic &lt;daemon.info&gt; INFO syncd.sh[25671]: Creating new syncd container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># syncd 容器启动日志（或启动一个已有容器）</span></span></span><br><span class="line">2022-01-20 18:12:06.333407 sonic &lt;daemon.info&gt; INFO syncd.sh[2920]: Starting existing syncd container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 无容器退出日志，暂监听syncd容器里的 supervisor-proc-exit-listener 停止日志代替）</span></span></span><br><span class="line">sudo grep -a &quot;syncd&quot; /var/log/syslog | grep &quot;supervisor-proc-exit-listener&quot; | grep stop | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># syncd 容器停止日志</span></span></span><br><span class="line">2022-01-11 11:54:32.373488 sonic &lt;local0.info&gt; INFO syncd#supervisord 2022-01-11 11:53:48,949 INFO stopped: supervisor-proc-exit-listener (terminated by SIGTERM)</span><br></pre></td></tr></table></figure>

<h3 id="5-1-9-swss-容器"><a href="#5-1-9-swss-容器" class="headerlink" title="5.1.9. swss 容器"></a>5.1.9. swss 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;swss container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># swss 容器启动日志（创建一个新容器）</span></span></span><br><span class="line">2022-01-11 17:13:16.747983 sonic &lt;daemon.info&gt; INFO swss.sh[28958]: Creating new swss container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># swss 容器启动日志（或启动一个已有容器）</span></span></span><br><span class="line">2022-01-20 18:12:03.332602 sonic &lt;daemon.info&gt; INFO swss.sh[1950]: Starting existing swss container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># （无容器退出日志，暂监听swss容器里的 supervisor-proc-exit-listener 停止日志代替）</span></span></span><br><span class="line">sudo grep -a &quot;swss&quot; /var/log/syslog | grep &quot;supervisor-proc-exit-listener&quot; | grep stop | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># swss 容器停止日志</span></span></span><br><span class="line">2022-01-11 11:54:30.919836 sonic &lt;local0.info&gt; INFO swss#supervisord 2022-01-11 11:53:36,769 INFO stopped: supervisor-proc-exit-listener (terminated by SIGTERM)</span><br></pre></td></tr></table></figure>

<h3 id="5-1-10-pmon-容器"><a href="#5-1-10-pmon-容器" class="headerlink" title="5.1.10. pmon 容器"></a>5.1.10. pmon 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;pmon container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># pmon 容器启动日志（创建一个新容器）</span></span></span><br><span class="line">2021-12-22 22:51:57.133310 sonic &lt;daemon.info&gt; INFO pmon.sh[2522]: Creating new pmon container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># pmon 容器启动日志（或启动一个已有容器）</span></span></span><br><span class="line">2022-01-20 18:12:01.562897 sonic &lt;daemon.info&gt; INFO pmon.sh[1944]: Starting existing pmon container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># （无标志，暂监听pmon容器里的 hwmgrd 停止日志代替）</span></span></span><br><span class="line">sudo grep -a &quot;pmon&quot; /var/log/syslog | grep &quot;hwmgrd&quot; | grep stop | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># pmon 容器停止日志</span></span></span><br><span class="line">2021-08-18 13:57:35.807813 &lt;local0.info&gt; sonic INFO pmon#supervisord 2021-08-18 05:57:19,661 INFO stopped: hwmgrd (terminated by SIGKILL)</span><br></pre></td></tr></table></figure>

<h3 id="5-1-11-mgmt-framework-容器"><a href="#5-1-11-mgmt-framework-容器" class="headerlink" title="5.1.11. mgmt-framework 容器"></a>5.1.11. mgmt-framework 容器</h3><p>（暂未开启）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;mgmt-framework container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># mgmt-framework 容器启动日志（创建一个新容器）</span></span></span><br><span class="line">2021-07-15 16:13:55.808772 sonic &lt;daemon.info&gt; INFO mgmt-framework.sh[2766]: Creating new mgmt-framework container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># mgmt-framework 容器启动日志（或启动一个已有容器）</span></span></span><br><span class="line">2021-07-20 16:21:08.207138 sonic &lt;daemon.info&gt; INFO mgmt-framework.sh[2812]: Starting existing mgmt-framework container with HWSKU BT2575</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># （无容器退出日志，暂监听mgmt-framework容器里的 rsyslogd 停止日志代替）</span></span></span><br><span class="line">sudo grep -a &quot;mgmt-framework&quot; /var/log/syslog | grep &quot;rsyslogd&quot; | grep stop | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># mgmt-framework 容器停止日志</span></span></span><br><span class="line">2021-08-11 20:04:12.517360 sonic &lt;local0.info&gt; INFO mgmt-framework#supervisord 2021-08-11 12:02:59,842 INFO stopped: rsyslogd (exit status 0)</span><br></pre></td></tr></table></figure>

<h3 id="5-1-12-sflow-容器"><a href="#5-1-12-sflow-容器" class="headerlink" title="5.1.12. sflow 容器"></a>5.1.12. sflow 容器</h3><p>（暂未开启）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;sflow container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># sflow 容器启动日志</span></span></span><br><span class="line">2021-08-17 22:14:23.550052 sonic &lt;daemon.info&gt; INFO systemd[1]: Started sFlow container.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># sflow 容器停止日志</span></span></span><br><span class="line">2021-08-17 22:14:22.418637 sonic &lt;daemon.info&gt; INFO systemd[1]: Stopped sFlow container.</span><br></pre></td></tr></table></figure>

<h3 id="5-1-13-telemetry-容器"><a href="#5-1-13-telemetry-容器" class="headerlink" title="5.1.13. telemetry 容器"></a>5.1.13. telemetry 容器</h3><p>（暂未开启）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -i &quot;telemetry container&quot; /var/log/daemon.log | tail -n 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># telemetry 容器启动日志</span></span></span><br><span class="line">2021-08-18 19:57:56.832442 sonic &lt;daemon.info&gt; INFO systemd[1]: Started Telemetry container.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># telemetry 容器停止日志</span></span></span><br><span class="line">2021-08-18 19:57:55.668585 sonic &lt;daemon.info&gt; INFO systemd[1]: Stopped Telemetry container.</span><br></pre></td></tr></table></figure>

<h2 id="5-2-各容器内各进程对应日志文件路径"><a href="#5-2-各容器内各进程对应日志文件路径" class="headerlink" title="5.2. 各容器内各进程对应日志文件路径"></a>5.2. 各容器内各进程对应日志文件路径</h2><p><br><b><font color="#7E3D76" style="">各容器进程对应日志文件路径表如下：</font></b></p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th>容器</th>
        <th>日志文件</th>
        <th>写日志的进程</th>
    </tr>
    <tr>
        <td align="center"  rowspan="3" >snmp</td>
        <td>/var/log/daemon.log</td>
        <td>snmp#snmp-subagent 进程运行日志<font color="red" style="">&lt;daemon.err/info/warning&gt;</font><br>snmp#snmpd进程 进程运行日志<font color="red" style="">&lt;daemon.warning&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>snmp#supervisord 守护进程日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>snmp#supervisord 守护进程日志<font color="red" style="">&lt;local0.info&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="4" >telemetry</td>
        <td>/var/log/daemon.log</td>
        <td>守护进程日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/telemetry.log</td>
        <td>telemetry 运行日志<font color="red" style="">&lt;user.info&gt;</font>,<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>telemetry#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>sonic systemd 日志<font color="red" style="">&lt;local0.info&gt;</font>,<font color="red" style="">&lt;local7.info&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="5" >lldp</td>
        <td>/var/log/daemon.log</td>
        <td>lldp#lldpd 进程运行日志<font color="red" style="">&lt;daemon.warning/info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>lldp#lldpmgrd 进程运行日志<font color="red" style="">&lt;user.err/warning/info/debug&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>lldp#supervisord 日志<font color="red" style="">&lt;local0.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/messages</td>
        <td>start_module lldp 日志<font color="red" style="">&lt;local0.info/warning&gt;</font>,<font color="red" style="">&lt;local2.warning&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/running.log</td>
        <td>AUTOPROVISION pica_autoprovision 日志<font color="red" style="">&lt;local0.info/warning&gt;</font>,<font color="red" style="">&lt;local2.warning&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="3" >sflow</td>
        <td>/var/log/daemon.log</td>
        <td>sflow 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>sflow#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>sflow#sflowmgrd 进程运行日志<font color="red" style="">&lt;local2.notice&gt;</font><br>sflow#supervisord 进程运行日志<font color="red" style="">&lt;local0.info&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="3" >radv</td>
        <td>/var/log/daemon.log</td>
        <td>radv 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>radv#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>radv#supervisord 进程运行日志<font color="red" style="">&lt;local0.info&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="3" >dhcp_relay</td>
        <td>/var/log/daemon.log</td>
        <td>dhcp_relay 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>dhcp_relay#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>dhcp_relay#supervisord 进程运行日志<font color="red" style="">&lt;local0.info&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="3" >syncd</td>
        <td>/var/log/daemon.log</td>
        <td>syncd 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>syncd#syncd 进程运行日志<font color="red" style="">&lt;user.info/debug&gt;</font><br>syncd#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font><br>syncd#dsserve 进程运行日志<font color="red" style="">&lt;user.notice&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>syncd#syncd 进程运行日志<font color="red" style="">&lt;local2.err/warning/debug/notice&gt;</font><br>syncd#supervisord 进程运行日志<font color="red" style="">&lt;local0.info&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="4" >teamd</td>
        <td>/var/log/daemon.log</td>
        <td>teamd 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/teamd.log</td>
        <td>teamd#teamd_PortChannel* 进程运行日志<font color="red" style="">&lt;daemon.debug&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>teamd#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>teamd#supervisord 进程运行日志<font color="red" style="">&lt;local0.info&gt;</font><br>teamd#teamsyncd/teammgrd 进程运行日志<font color="red" style="">&lt;local2.err/notice&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="3" >mgmt-framework</td>
        <td>/var/log/daemon.log</td>
        <td>mgmt-framework 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>mgmt-framework#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>mgmt-framework#supervisord 进程运行日志<font color="red" style="">&lt;local0.info&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="3" >swss</td>
        <td>/var/log/daemon.log</td>
        <td>swss 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>swss#intmgrd/restore_neighbor/supervisor-proc-exit-listener 进程运行日志<font color="red" style="">&lt;user.err/info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>swss#orchagent/portsyncd/neighsyncd/vrfmgrd/vxlanmgrd/switchmgrd/<br>fdbmgrd/cfgmgrd/intmgrd/transmgrd 进程运行日志<font color="red" style="">&lt;local0/local2.err/warning/notice&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="3" >pmon</td>
        <td>/var/log/daemon.log</td>
        <td>pmon 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>pmon#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>pmon#supervisord 进程运行日志<font color="red" style="">&lt;local0.info&gt;</font><br>pmon#hwmgrd 进程运行日志<font color="red" style="">&lt;local2.err/info&gt;</font></td>
    </tr>
    <tr>
        <td align="center"  rowspan="7" >bgp</td>
        <td>/var/log/daemon.log</td>
        <td>bgp 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/quagga/bgpd.log</td>
        <td>bgp#bgpd 进程运行日志<font color="red" style="">&lt;local2.err/warning/info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/quagga/zebra.log</td>
        <td>bgp#zebra 进程运行日志<font color="red" style="">&lt;local2.err/warning/notice&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td>bgp#bgpcfgd 进程运行日志<font color="red" style="">&lt;user.info&gt;</font><br>bgp#supervisord 进程运行日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/messages</td>
        <td>BGP xorp_bgp 运行日志<font color="red" style="">&lt;local2.err/warning&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/running.log</td>
        <td>RTRMGR xorp_rtrmgr 启动日志<font color="red" style="">&lt;local0.info&gt;</font><br>BGP xorp_bgp 运行日志<font color="red" style="">&lt;local2.err/info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>bgp#fpmsyncd/monitorlinkd/staticd 进程运行日志<font color="red" style="">&lt;local2.err/warning/notice&gt;</font>,<font color="red" style="">&lt;local7.info&gt;</font><br>bgp#supervisord 守护进程日志<font color="red" style="">&lt;local0.info&gt;</font> </td>
    </tr>
    <tr>
        <td align="center"  rowspan="5" >database</td>
        <td>/var/log/daemon.log</td>
        <td>database 容器运行日志<font color="red" style="">&lt;daemon.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/user.log</td>
        <td> database 容器运行日志<font color="red" style="">&lt;user.notice&gt;</font><br>database#supervisord 守护进程日志<font color="red" style="">&lt;user.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/syslog</td>
        <td>database#supervisord 进程运行日志<font color="red" style="">&lt;local0.info&gt;</font></td>
    </tr>
    <tr>
        <td>/var/log/messages</td>
        <td>WARMBOOT_FINALIZER 等待日志</td>
    </tr>
    <tr>
        <td>/var/log/running.log</td>
        <td>WARMBOOT_FINALIZER 等待日志</td>
    </tr>
</table>

<h3 id="5-2-1-snmp-容器"><a href="#5-2-1-snmp-容器" class="headerlink" title="5.2.1. snmp 容器"></a>5.2.1. snmp 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （snmp#snmp-subagent 进程运行日志&lt;daemon.err&#x2F;info&#x2F;warning&gt;；snmp#snmpd进程 进程运行日志&lt;daemon.warning&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （snmp#supervisord守护进程日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （snmp#supervisord守护进程日志&lt;local0.info&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】snmp#snmpd进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【2】snmp#snmp-subagent 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【3】snmp#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-2-telemetry-容器"><a href="#5-2-2-telemetry-容器" class="headerlink" title="5.2.2. telemetry 容器"></a>5.2.2. telemetry 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （守护进程日志&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;telemetry.log  （telemetry 运行日志&lt;user.info&gt;,&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （telemetry#supervisord 进程运行日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （sonic systemd日志&lt;local0.info&gt;,&lt;local7.info&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】telemetry#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;telemetry.log</li>
</ul>
<h3 id="5-2-3-lldp-容器"><a href="#5-2-3-lldp-容器" class="headerlink" title="5.2.3. lldp 容器"></a>5.2.3. lldp 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log         （lldp#lldpd 进程运行日志&lt;daemon.warning&#x2F;info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;user.log           （lldp#lldpmgrd 进程运行日志&lt;user.err&#x2F;warning&#x2F;info&#x2F;debug&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog             （lldp#supervisord 日志&lt;local0.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;messages           （start_module lldp日志&lt;local0.info&#x2F;warning&gt;,&lt;local2.warning&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;running.log        （AUTOPROVISION pica_autoprovision日志&lt;local0.info&#x2F;warning&gt;,&lt;local2.warning&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】lldp#lldpmgrd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【2】lldp#lldpd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【3】lldp#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-4-sflow-容器"><a href="#5-2-4-sflow-容器" class="headerlink" title="5.2.4. sflow 容器"></a>5.2.4. sflow 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log         （sflow容器运行日志&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;user.log           （sflow#supervisord 进程运行日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog             （sflow#sflowmgrd 进程运行日志&lt;local2.notice&gt;；sflow#supervisord 进程运行日志&lt;local0.info&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】sflow#sflowmgrd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<p><b><font color="#7E3D76" style="">【2】sflow#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-5-radv-容器"><a href="#5-2-5-radv-容器" class="headerlink" title="5.2.5. radv 容器"></a>5.2.5. radv 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （radv#supervisord运行日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （radv#supervisord运行日志&lt;local0.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （radv容器运行日志&lt;daemon.info&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】radv#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-6-dhcp-relay-容器"><a href="#5-2-6-dhcp-relay-容器" class="headerlink" title="5.2.6. dhcp_relay 容器"></a>5.2.6. dhcp_relay 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （dhcp_relay#supervisord 进程运行日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （dhcp_relay容器运行日志&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （dhcp_relay#supervisord 进程运行日志&lt;local0.info&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】dhcp_relay#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-7-syncd-容器"><a href="#5-2-7-syncd-容器" class="headerlink" title="5.2.7. syncd 容器"></a>5.2.7. syncd 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （syncd#syncd 进程运行日志&lt;user.info&#x2F;debug&gt;；syncd#supervisord 进程运行日志&lt;user.info&gt;；syncd#dsserve 进程运行日志&lt;user.notice&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （syncd容器运行日志&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （syncd#syncd 进程运行日志&lt;local2.*&gt;；syncd#supervisord 进程运行日志&lt;local0.info&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】syncd#syncd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<p><b><font color="#7E3D76" style="">【2】syncd#dsserve 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【3】syncd#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-8-teamd-容器"><a href="#5-2-8-teamd-容器" class="headerlink" title="5.2.8. teamd 容器"></a>5.2.8. teamd 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;teamd.log      （teamd#teamd_PortChannel* 进程运行日志&lt;daemon.debug&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （teamd#supervisord 进程运行日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （teamd 容器运行日志&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （teamd#supervisord 进程运行日志&lt;local0.info&gt;；teamd#teamsyncd&#x2F;teammgrd进程运行日志&lt;local2.err&#x2F;notice&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】teamd#teamd_PortChannel* 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;teamd.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【2】teamd#teamsyncd&#x2F;teammgrd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<p><b><font color="#7E3D76" style="">【3】teamd#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-9-mgmt-framework-容器"><a href="#5-2-9-mgmt-framework-容器" class="headerlink" title="5.2.9. mgmt-framework 容器"></a>5.2.9. mgmt-framework 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （mgmt-framework#supervisord 进程运行日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （mgmt-framework 容器运行日志，&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （mgmt-framework#supervisord 进程运行日志&lt;local0.info&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】mgmt-framework#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-10-swss-容器"><a href="#5-2-10-swss-容器" class="headerlink" title="5.2.10. swss 容器"></a>5.2.10. swss 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log           （swss#intmgrd&#x2F;restore_neighbor&#x2F;supervisor-proc-exit-listener 进程运行日志&lt;user.*&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log         （swss 容器运行日志&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog             （swss#orchagent&#x2F;portsyncd&#x2F;neighsyncd&#x2F;vrfmgrd&#x2F;vxlanmgrd&#x2F;switchmgrd&#x2F;fdbmgrd&#x2F;cfgmgrd&#x2F;intmgrd&#x2F;transmgrd 进程运行日志&lt;local0&#x2F;local2.err&#x2F;warning&#x2F;notice&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】swss#intmgrd&#x2F;restore_neighbor&#x2F;supervisor-proc-exit-listener 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【2】swss#orchagent&#x2F;portsyncd&#x2F;neighsyncd&#x2F;vrfmgrd&#x2F;vxlanmgrd&#x2F;switchmgrd&#x2F;fdbmgrd&#x2F;cfgmgrd&#x2F;intmgrd&#x2F;transmgrd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<p><b><font color="#7E3D76" style="">【3】swss#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-11-pmon-容器"><a href="#5-2-11-pmon-容器" class="headerlink" title="5.2.11. pmon 容器"></a>5.2.11. pmon 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （pmon#supervisord 进程运行日志，&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （pmon容器运行日志，&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （pmon#supervisord 进程运行日志，&lt;local0.info&gt;；pmon#hwmgrd 进程运行日志&lt;local2.info&#x2F;err&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】pmon#hwmgrd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<p><b><font color="#7E3D76" style="">【2】pmon#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
</ul>
<h3 id="5-2-12-bgp-容器"><a href="#5-2-12-bgp-容器" class="headerlink" title="5.2.12. bgp 容器"></a>5.2.12. bgp 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;quagga&#x2F;bgpd.log        （bgp#bgpd 进程运行日志&lt;local2.err&#x2F;info&#x2F;warning&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;quagga&#x2F;zebra.log       （bgp#zebra 进程运行日志&lt;local2.err&#x2F;warning&#x2F;notice&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;user.log               （bgp#bgpcfgd 进程运行日志&lt;user.info&gt;；bgp#supervisord 进程运行日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log             （bgp 容器运行日志&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;messages               （BGP xorp_bgp 运行日志&lt;local2.err&#x2F;warning&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;running.log            （RTRMGR xorp_rtrmgr 启动日志&lt;local0.info&gt;；BGP xorp_bgp 运行日志&lt;local2.err&#x2F;info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog                 （bgp#fpmsyncd&#x2F;liblogging-stdlog&#x2F;monitorlinkd&#x2F;staticd 进程运行日志&lt;local2.err&#x2F;warning&#x2F;notice&gt;,&lt;local7.info&gt;；bgp#supervisord守护进程日志&lt;local0.info&gt; ）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】bgp#bgpd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;quagga&#x2F;bgpd.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【2】bgp#zebra 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;quagga&#x2F;zebra.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【3】bgp#bgpcfgd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
</ul>
<p><b><font color="#7E3D76" style="">【4】bgp#fpmsyncd&#x2F;liblogging-stdlog&#x2F;monitorlinkd&#x2F;staticd 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<p><b><font color="#7E3D76" style="">【5】bgp#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h3 id="5-2-13-database-容器"><a href="#5-2-13-database-容器" class="headerlink" title="5.2.13. database 容器"></a>5.2.13. database 容器</h3><p>日志文件：</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log       （ database 容器运行日志&lt;user.notice&gt;；database#supervisord守护进程日志&lt;user.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log     （database容器运行日志，&lt;daemon.info&gt;）</li>
<li>&#x2F;var&#x2F;log&#x2F;messages       （WARMBOOT_FINALIZER 等待日志）</li>
<li>&#x2F;var&#x2F;log&#x2F;running.log    （WARMBOOT_FINALIZER 等待日志）</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog         （database#supervisord 进程运行日志，&lt;local0.info&gt;）</li>
</ul>
<p><b><font color="#7E3D76" style="">【1】database#supervisord 进程</font></b></p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;user.log</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog</li>
</ul>
<h2 id="5-3-系统-Crash"><a href="#5-3-系统-Crash" class="headerlink" title="5.3. 系统 Crash"></a>5.3. 系统 Crash</h2><p>思考点：譬如内核异常，不会直接输出日志</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SONiC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis loglevel_db 中残留2至n个下划线前缀的冗余表项问题</title>
    <url>/2021/12/17/sonic_underscore_prefixes_remaining_in_Redis_loglevel_db/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>Redis loglevel_db 中残留2~n个下划线前缀的冗余表项问题</p>
<p>在 Redis 因忙或服务异常未及时处理带下划线前缀的临时表项时，重启 swss 容器将导致 loglevel_db 出现 2 ~ n 个下划线前缀的冗余表项，且在 Redis 恢复后也不会被删除，将一直残留在 loglevel_db 中。</p>
<h1 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h1><h2 id="2-1-定位"><a href="#2-1-定位" class="headerlink" title="2.1. 定位"></a>2.1. 定位</h2><p>在 Redis 因忙或服务异常未及时处理带下划线前缀的临时表项时，重启 swss 容器将导致 loglevel_db 出现“临时表项的临时表项”，即产生双下划线前缀的临时表项。进而，在第二次重启时将产生三下划线前缀的临时表项，且这2~n 个下划线前缀的表项在 redis 恢复后也不会被删除，将一直残留并累积在loglevel_db中。</p>
<p>（1）第一次出现临时表被当做正常表项的监控记录如下图：</p>
<img data-src="../../../../uploads/The_first_time_a_temporary_table_appears_as_a_monitoring_record_of_a_normal_table_item.png" class="full-image" />


<a id="more"></a>


<p>由上图中</p>
<ul>
<li><code>_vxlanmgrd_KEY_SET</code> ，</li>
<li>由<code>TableName_KeySet::getKeySetName()</code> ，初始化时 <code>m_key(tableName + "_KEY_SET")</code> ，方法得到（<strong>tableName</strong> + “_KEY_SET”）</li>
<li>及  <code>__vxlanmgrd:_vxlanmgrd</code> ，<ul>
<li>由<code>TableBase::getKeyName(key)</code>  ，初始化时 <code>m_tableName(tableName)</code> ，方法得到（<strong>m_tableName</strong> + m_tableSeparator + key）</li>
</ul>
</li>
</ul>
<p>可知是 key 多了 n 个下划线，且 TableBase 及 TableName_KeySet 创建实例时入参 <strong>tableName</strong> 就已经多了 n 个下划线。进而可推知在</p>
<ul>
<li><code>ProducerStateTable : TableBase(tableName), TableName_KeySet(tableName)...</code> </li>
<li>或 <code>ConsumerStateTable : ConsumerStateTable(tableName), TableName_KeySet(tableName)</code><br>创建实例时，其 入参 <strong>tableName</strong> 就已包含  n 个下划线</li>
</ul>
<p>（2）第一次异常监测： <code>ProducerStateTable::set()</code> 的入参key已多出冗余下划线前缀：</p>
<img data-src="../../../../uploads/redis_loglevel_db_abnormal_first_monitoring.png" class="full-image" />

<p>（3）第二次异常监测测： <code>ProducerStateTable::set()</code> 的入参 key 已多出冗余”__”前缀：</p>
<img data-src="../../../../uploads/redis_loglevel_db_abnormal_second_monitoring.png" class="full-image" />

<h2 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2. 分析"></a>2.2. 分析</h2><p>由上图明确问题出在 <code>ProducerStateTable::set()</code>，而调用其的函数有：</p>
<ul>
<li><code>src/sonic-swss-common/common/logger.cpp</code>  中的  <code>Logger::linkToDbWithOutput()</code> 。</li>
<li>其仅上层被 <code>Logger::linkToDb()</code> 调用，再仅被 <code>Logger::linkToDbNative()</code> 调用，再仅被各进程 main() 中指定 key（几乎不可能引入下划线前缀）</li>
<li><code>src/sonic-swss-common/common/loglevel.cpp</code> 中的 <code>setLoglevel()</code> 。</li>
<li>而调用其的地方没考虑到做过滤带下划线前缀临时表项的操作</li>
</ul>
<img data-src="../../../../uploads/redis_loglevel_db_The_code_calls_setLoglevel.png" class="full-image" />

<h2 id="2-3-根因"><a href="#2-3-根因" class="headerlink" title="2.3. 根因"></a>2.3. 根因</h2><p>swssloglevel 未过滤 loglevel_db 中的临时表项。swss 启动时会调 <code>swssloglevel -l WARN -a</code>，由于 swssloglevel 程序的 <code>setLoglevel()</code> 未过滤带下划线前缀的临时表项，导致其也被当做正常表项处理。最终导致会增量创建“临时表项的临时表项”问题，重启 n 次则创建 n 个。</p>
<h1 id="3-问题影响"><a href="#3-问题影响" class="headerlink" title="3. 问题影响"></a>3. 问题影响</h1><ul>
<li>在 Redis loglevel_db 中存在下划线前缀的临时表项时，调用 swssloglevel 必出 core</li>
</ul>
<img data-src="../../../../uploads/redis_loglevel_db_analysis_log_level.png" class="full-image" />

<ul>
<li>冗余表项虽不影响 swss 正常运行，但多出的异常表项会占用内存资源，且会对定位排障造成一定干扰。</li>
</ul>
<h1 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h1><ul>
<li>在调取由 <code>redisClient.hget()</code> 获得的值前加判空，防止出 core</li>
<li>在设置表项时初始值时添加判断，若 传入 key 是临时 key（已带 _ 前缀），则从流程中跳过以防止迭代创建无意义的 临时key的临时 key</li>
<li>在 swssloglevel 遍历获取表项时，过滤掉带下划线前缀的临时表项</li>
</ul>
<p>按上述方案解决后问题解决</p>
<ul>
<li>自测运行三天无下划线前缀的冗余表项生成</li>
<li>手动构造带下划线前缀的冗余表项后，调 swssloglevel -p 不再出 core</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SONiC</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机基础简介</title>
    <url>/2021/08/09/switch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-交换机概述"><a href="#1-交换机概述" class="headerlink" title="1. 交换机概述"></a>1. 交换机概述</h1><ul>
<li><strong>基本概念</strong>：英文名为 switch，也称为交换式集线器，是一种基于<strong>MAC地址识别</strong>，能完成<strong>封装转发数据包</strong>功能的网络设备。</li>
<li><strong>功能</strong>：可以学习<strong>MAC地址</strong>，并把其存放在内部<strong>MAC地址对照表</strong>中，通过在数据帧的始发者和目标接受者之间建立临时的交换路径，是数据帧直接由源地址到达目的地址。</li>
</ul>
<a id="more"></a>

<h1 id="2-switch-简介"><a href="#2-switch-简介" class="headerlink" title="2. switch 简介"></a>2. switch 简介</h1><h2 id="2-1-工作特点"><a href="#2-1-工作特点" class="headerlink" title="2.1. 工作特点"></a>2.1. 工作特点</h2><ul>
<li>拥有一条很高带宽的<strong>背板总线</strong>和<strong>内部交换矩阵</strong></li>
<li>所有端口都挂接在这条背板总线上</li>
<li>控制电路收到数据包后，处理端口会查找内存中的<strong>MAC地址对照表</strong>。若能够查询到<strong>目的MAC地址</strong>，则查询该<strong>目的MAC地址</strong>的网卡挂接在哪个<strong>端口</strong>上，然后通过内部交换矩阵迅速将数据包传送到<strong>目的端口</strong>；若表中不存在<strong>目的MAC地址</strong>，则广播到所有端口，接收端口回应后交换机会”学习”新地址，并把它添加到内部<strong>MAC地址对照表</strong>中。</li>
</ul>
<h2 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2. 特性"></a>2.2. 特性</h2><ul>
<li>支持并行通信，提升了信息吞吐量</li>
<li>（大局域网）用户分组，每个端口连接一台设备或一个工作组，有效解决拥挤</li>
<li>虚拟局域网 VLAN，给交换机使用和管理提供更大灵活性</li>
<li>端口密度可以与集线器相媲美</li>
</ul>
<h2 id="2-3-三个主要功能"><a href="#2-3-三个主要功能" class="headerlink" title="2.3. 三个主要功能"></a>2.3. 三个主要功能</h2><ol>
<li><strong>学习</strong><br>以太网交换机了解每一端口相连设备的<strong>MAC地址</strong>，并将地址相应的端口映射信息缓存到<strong>MAC地址对照表</strong>中</li>
<li><strong>转发&#x2F;过滤</strong><br>当一个数据帧的目的地址在<strong>MAC地址</strong>表中时，将它转发到连接目的地址端口。若<strong>MAC地址</strong>表中不存在时，广播<strong>MAC地址</strong>到所有端口，并在接收端口回应后”学习”新地址与端口的映射，并缓存到<strong>MAC地址对照表</strong>中</li>
<li><strong>消除回路</strong><br>当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后备路径。</li>
</ol>
<h1 id="3-switch-交换模式"><a href="#3-switch-交换模式" class="headerlink" title="3. switch 交换模式"></a>3. switch 交换模式</h1><h2 id="3-1-存储转发（Store-and-Forward）"><a href="#3-1-存储转发（Store-and-Forward）" class="headerlink" title="3.1. 存储转发（Store and Forward）"></a>3.1. 存储转发（Store and Forward）</h2><ul>
<li>流程：交换机接收到数据包后，首先将数据包<strong>存储到缓冲器</strong>中，进行** CRC 循环冗余校验<strong>。若存在 CRC 错误，则将该包丢弃；若无 CRC 错误，且数据包完整，则将其转发到</strong>目的MAC地址**对应端口。</li>
<li>优点：不会转发残缺数据包（可减少不必要的数据转发）</li>
<li>缺点：转发速率比直接转发方式慢</li>
<li>适用场景：普通链路质量或质量较为恶劣的网络环境</li>
<li>特点：延迟与帧大小有关</li>
</ul>
<h2 id="3-2-直通交换（Cut-Through）"><a href="#3-2-直通交换（Cut-Through）" class="headerlink" title="3.2. 直通交换（Cut-Through）"></a>3.2. 直通交换（Cut-Through）</h2><ul>
<li>流程：交换机只读出数据帧的前 6 个字节（目的<strong>MAC地址</strong>），将其转发到对应端口</li>
<li>优点：转发速率快、减少延时、提升整体吞吐率</li>
<li>缺点：无法消除流经整个交换机网络的垃圾通信包</li>
<li>适用场景：网络链路质量好、错误数据包较少的网络环境</li>
<li>特点：延迟与帧大小无关</li>
</ul>
<h2 id="3-3-碎片丢弃（Fragment-free）"><a href="#3-3-碎片丢弃（Fragment-free）" class="headerlink" title="3.3. 碎片丢弃（Fragment free）"></a>3.3. 碎片丢弃（Fragment free）</h2><ul>
<li>流程：检查数据包长度，若小于 64 个字节（假包），丢弃该包；若大于等于 64 个字节，则读出数据帧的前 6 个字节（目的<strong>MAC地址</strong>），将其转发到对应端口</li>
<li>优点：兼具了数据包校验和传输速率</li>
<li>适用场景：一般通讯链路</li>
</ul>
<h1 id="4-switch-与网桥-x2F-集线器对比"><a href="#4-switch-与网桥-x2F-集线器对比" class="headerlink" title="4. switch 与网桥&#x2F;集线器对比"></a>4. switch 与网桥&#x2F;集线器对比</h1><table>
<thead>
<tr>
<th align="center">设备</th>
<th align="center">ISO 网络模型层</th>
<th align="center">传输信息</th>
</tr>
</thead>
<tbody><tr>
<td align="center">路由器&#x2F;三层交换机</td>
<td align="center">网络层</td>
<td align="center">包（Packet）</td>
</tr>
<tr>
<td align="center">交换机&#x2F;网桥</td>
<td align="center">数据链路层</td>
<td align="center">帧（Frame）</td>
</tr>
<tr>
<td align="center">集线器&#x2F;中继器</td>
<td align="center">物理层</td>
<td align="center">比特（bit）</td>
</tr>
</tbody></table>
<h2 id="4-1-vs-网桥"><a href="#4-1-vs-网桥" class="headerlink" title="4.1. vs 网桥"></a>4.1. vs 网桥</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">网桥</th>
<th align="center">交换机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">交换实现方式</td>
<td align="center">计算机运行桥接协议（软件）实现</td>
<td align="center">专用集成电路（硬件）实现</td>
</tr>
<tr>
<td align="center">转发速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
<tr>
<td align="center">延迟</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">端口数</td>
<td align="center">少</td>
<td align="center">多</td>
</tr>
<tr>
<td align="center">支持功能</td>
<td align="center">转发&#x2F;过滤</td>
<td align="center">转发&#x2F;过滤、网络管理协议、虚拟局域网的划分等诸多管理功能</td>
</tr>
</tbody></table>
<h2 id="4-2-vs-集线器"><a href="#4-2-vs-集线器" class="headerlink" title="4.2. vs 集线器"></a>4.2. vs 集线器</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="left">集线器</th>
<th align="left">交换机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">工作层级</td>
<td align="left">物理层</td>
<td align="left">数据链路层，或网络层、传输层、甚至更高层</td>
</tr>
<tr>
<td align="center">数据传输方式</td>
<td align="left">广播方式（所有端口处在一个冲突域）</td>
<td align="left">数据传输只发生在源端口与目的端口之间，交换机的每个端口处在不同的冲突域</td>
</tr>
<tr>
<td align="center">带宽占用方式</td>
<td align="left">所有端口共享集线器的总带宽</td>
<td align="left">每个端口具有独立带宽</td>
</tr>
<tr>
<td align="center">传输模式</td>
<td align="left">半双工</td>
<td align="left">全双工</td>
</tr>
</tbody></table>
<h1 id="5-switch-的分类"><a href="#5-switch-的分类" class="headerlink" title="5. switch 的分类"></a>5. switch 的分类</h1><h2 id="5-1-按应用区域划分"><a href="#5-1-按应用区域划分" class="headerlink" title="5.1. 按应用区域划分"></a>5.1. 按应用区域划分</h2><ul>
<li>广域网交换机：主要应用与电信领域，提供通信基础平台</li>
<li>局域网交换机：应用于局域网络，用于连接终端设备，如 PC 机及网络打印机等</li>
</ul>
<h2 id="5-2-按网络拓扑结构划分"><a href="#5-2-按网络拓扑结构划分" class="headerlink" title="5.2. 按网络拓扑结构划分"></a>5.2. 按网络拓扑结构划分</h2><h3 id="5-2-1-核心层交换机"><a href="#5-2-1-核心层交换机" class="headerlink" title="5.2.1. 核心层交换机"></a>5.2.1. 核心层交换机</h3><p><strong>简介：</strong></p>
<ul>
<li>是整个网络的中心交换机，具有最高的交换性能，用于连接和汇聚各汇聚层交换机的流量</li>
<li>一般采用 3 层交换机 (eg. Cisco4000, 4500, 6500…)，具有很高的交换背板带宽和较多的高速以太网端口或光纤端口</li>
<li>一般采用机箱式模块化涉及，机箱中可承载管理模块、光端口模块、高速电口模块、电源等</li>
</ul>
<h3 id="5-2-2-汇聚层交换机"><a href="#5-2-2-汇聚层交换机" class="headerlink" title="5.2.2. 汇聚层交换机"></a>5.2.2. 汇聚层交换机</h3><p><strong>简介：</strong></p>
<ul>
<li>用于汇聚接入层交换机的流量，并上联至核心层交换机</li>
<li>一般采用 3 层交换机 (eg.Cisco3550, 华为 Quidway S3526E)，这类交换机一般具有一定数量的高速端口，以提供具有较高的接入能力和带宽</li>
<li>可以是机箱式模块化交换机，也可以是固定配置的交换机，一般会包含光端口、高速电口等端口</li>
</ul>
<h3 id="5-2-3-接入层交换机"><a href="#5-2-3-接入层交换机" class="headerlink" title="5.2.3. 接入层交换机"></a>5.2.3. 接入层交换机</h3><p><strong>简介：</strong></p>
<ul>
<li>通常将网络中直接面向用户连接或访问网络的部分称为接入层，一般是固定配置的交换机</li>
<li>端口密度较大，具有较高的接入能力。以 10&#x2F;100M 端口为主，以固定端口或扩展槽方式提供 100Mbps 的上联端口</li>
</ul>
<h2 id="5-3-按架构特点划分"><a href="#5-3-按架构特点划分" class="headerlink" title="5.3. 按架构特点划分"></a>5.3. 按架构特点划分</h2><ul>
<li>机架式</li>
<li>带扩展槽固定配置式</li>
<li>不带扩展槽固定配置式</li>
</ul>
<h2 id="5-4-按位于-OSI-七层网络模型的层级划分"><a href="#5-4-按位于-OSI-七层网络模型的层级划分" class="headerlink" title="5.4. 按位于 OSI 七层网络模型的层级划分"></a>5.4. 按位于 OSI 七层网络模型的层级划分</h2><ul>
<li>数据链路层（第二层）：基于<strong>MAC地址</strong>的工作的第二层交换机最为普遍，用于网络接入层与汇聚层</li>
<li>网络层（第三层）：基于 IP 地址和协议进行交换的第三层交换机应用与网络的核心层，也少量应用于汇聚层。（部分第三层交换机也同时具有第四层交换功能）</li>
<li>传输层（第四层）：可以根据数据帧的协议端口信息进行目标端口判断。</li>
<li>应用层（第七层）：应用型交换机，主要用于互联网数据中心。</li>
</ul>
<h2 id="5-5-按交换机的可管理性划分"><a href="#5-5-按交换机的可管理性划分" class="headerlink" title="5.5. 按交换机的可管理性划分"></a>5.5. 按交换机的可管理性划分</h2><ul>
<li>可管理型交换机：可管理型交换机便于网络监控、流量分析，但成本也相对较高；大中型网络在汇聚层应该选择可管理型交换机；核心层交换机则全部是可管理型交换机。</li>
<li>不可管理型交换机：在接入层视应用需要而定</li>
</ul>
<h2 id="5-6-按可否堆叠划分"><a href="#5-6-按可否堆叠划分" class="headerlink" title="5.6. 按可否堆叠划分"></a>5.6. 按可否堆叠划分</h2><ul>
<li>可堆叠交换机</li>
<li>不可堆叠交换机</li>
</ul>
<h2 id="5-7-按应用角度划分"><a href="#5-7-按应用角度划分" class="headerlink" title="5.7. 按应用角度划分"></a>5.7. 按应用角度划分</h2><ul>
<li>电话交换机（PBX）：主要应用于电信领域，提供语音通讯</li>
<li>数据交换机（Switch）：应用于计算机网络</li>
</ul>
<h1 id="6-switch-主要性能指标"><a href="#6-switch-主要性能指标" class="headerlink" title="6. switch 主要性能指标"></a>6. switch 主要性能指标</h1><h2 id="6-1-背板带宽与端口速率"><a href="#6-1-背板带宽与端口速率" class="headerlink" title="6.1. 背板带宽与端口速率"></a>6.1. 背板带宽与端口速率</h2><p>背板带宽和端口速率是衡量交换机的交换能力的主要参数。</p>
<h3 id="6-1-1-背板带宽"><a href="#6-1-1-背板带宽" class="headerlink" title="6.1.1. 背板带宽"></a>6.1.1. 背板带宽</h3><p>通过交换机所有通信的最大值</p>
<h3 id="6-1-2-交换机的端口速率"><a href="#6-1-2-交换机的端口速率" class="headerlink" title="6.1.2. 交换机的端口速率"></a>6.1.2. 交换机的端口速率</h3><p>每秒通过的比特数</p>
<p>eg. 10Mbps, 100Mbps, 1000Mbps, 10000Mbps</p>
<h2 id="6-2-模块化与固定配置"><a href="#6-2-模块化与固定配置" class="headerlink" title="6.2. 模块化与固定配置"></a>6.2. 模块化与固定配置</h2><h3 id="6-2-1-模块化交换机"><a href="#6-2-1-模块化交换机" class="headerlink" title="6.2.1. 模块化交换机"></a>6.2.1. 模块化交换机</h3><p>具有很强的可扩展性，可在机箱内提供一系列扩展模块，以将具有不同协议、不同拓扑结构的网络连接起来。</p>
<p>eg. 千兆位以太网模块、FDDI 模块、ATM 模块、快速以太网模块、令牌环模块等</p>
<p>但它的价格一般很昂贵，一般用作为骨干交换机</p>
<h3 id="6-2-2-固定配置交换机"><a href="#6-2-2-固定配置交换机" class="headerlink" title="6.2.2. 固定配置交换机"></a>6.2.2. 固定配置交换机</h3><p>一般具有固定端口配置的交换机。</p>
<p>eg.Cisco 公司的 Catalyst I900&#x2F;2900 交换机，Bay 公司的 BayStack350&#x2F;450 交换机等。</p>
<p>价格较低，但可扩充性不如模块化交换机。</p>
<h2 id="6-3-专用芯片与通用芯片"><a href="#6-3-专用芯片与通用芯片" class="headerlink" title="6.3. 专用芯片与通用芯片"></a>6.3. 专用芯片与通用芯片</h2><ul>
<li>x86：通用计算机芯片</li>
<li>ASIC：专用集成电路（Application-Specific-Integrated Circuit）</li>
<li>NP：专用网络处理器</li>
</ul>
<h2 id="6-4-单-x2F-多MAC地址类型"><a href="#6-4-单-x2F-多MAC地址类型" class="headerlink" title="6.4. 单&#x2F;多MAC地址类型"></a>6.4. 单&#x2F;多MAC地址类型</h2><ul>
<li>单MAC交换机：每个端口只有一个MAC地址；单MAC交换机主要用于连接最终用户、网络共享资源或非桥接路由器，它们不能用于连接集线器或含有多个网络设备的网段；</li>
<li>多MAC交换机：每个端口捆绑有多个MAC硬件地址；多MAC交换机的每个端口可以看作是一个集线器，而多MAC交换机可以看作是集线器的集线器。</li>
</ul>
<h1 id="7-交换机的接口与连接方式"><a href="#7-交换机的接口与连接方式" class="headerlink" title="7. 交换机的接口与连接方式"></a>7. 交换机的接口与连接方式</h1><h2 id="7-1-交换机的接口类型"><a href="#7-1-交换机的接口类型" class="headerlink" title="7.1. 交换机的接口类型"></a>7.1. 交换机的接口类型</h2><p>交换机的接口是随着网络类型的变化和传输介质的发展而产生的不同的接口规格，主要有：</p>
<h3 id="7-1-1-双绞线-RJ-45-接口"><a href="#7-1-1-双绞线-RJ-45-接口" class="headerlink" title="7.1.1. 双绞线 RJ-45 接口"></a>7.1.1. 双绞线 RJ-45 接口</h3><p>数量最多、应用最广的一种接口类型，它属于以太接口类型。它不仅在最基本的 10Base-T 以太网网络中使用，还在目前主流的 100Base-TX 快速以太网和 1000Base-TX 千兆以太网中使用。</p>
<h3 id="7-1-2-光纤接口"><a href="#7-1-2-光纤接口" class="headerlink" title="7.1.2. 光纤接口"></a>7.1.2. 光纤接口</h3><p>目前光纤传输介质发展相当迅速，各种光纤接口也层出不穷，分别应用于 100Base-FX、1000Base-FX 等网络中。</p>
<h3 id="7-1-3-AUI-接口与-BNC"><a href="#7-1-3-AUI-接口与-BNC" class="headerlink" title="7.1.3. AUI 接口与 BNC"></a>7.1.3. AUI 接口与 BNC</h3><ul>
<li>AUI 接口：这是专门用于连接粗同轴电缆的，目前这种网络在局域网中已不多见。</li>
<li>BNC 接口：这是专门用于连接细同轴电缆的接口，目前提供这种接口的交换机比较少见。</li>
</ul>
<h3 id="7-1-4-Console-接口"><a href="#7-1-4-Console-接口" class="headerlink" title="7.1.4. Console 接口"></a>7.1.4. Console 接口</h3><p>用于配置交换机而是用的接口。</p>
<p>不同交换机的 Console 接口有所不同，有些与 Cisco 路由器一样采用 RJ-45 类型 Console 接口，而有的则采用串口作为 Console 接口</p>
<h3 id="7-1-5-FDDI-接口"><a href="#7-1-5-FDDI-接口" class="headerlink" title="7.1.5. FDDI 接口"></a>7.1.5. FDDI 接口</h3><p>光纤分布式数据接口，在早期的 100Mbps 时代的一种 FDDI 网络类型接口。其传输介质为光纤，目前已较少见。</p>
<h2 id="7-2-交换机的连接方式"><a href="#7-2-交换机的连接方式" class="headerlink" title="7.2. 交换机的连接方式"></a>7.2. 交换机的连接方式</h2><h3 id="7-2-1-级联"><a href="#7-2-1-级联" class="headerlink" title="7.2.1. 级联"></a>7.2.1. 级联</h3><p>最常见的连接方式，即使用网线将两个交换机连接起来。有使用光纤介质连接和双绞线介质连接两种情况：</p>
<ul>
<li>光纤介质连接：直接连接的两个交换机端口要保证一致的光纤规格、端口速率，发送信号光纤端口与接收信号光纤端口相连。</li>
<li>双绞线介质连接：普通端口之间相连——使用交叉双绞线；一台交换机使用 Uplink 端口相连——使用直通双绞线</li>
</ul>
<h3 id="7-2-2-冗余"><a href="#7-2-2-冗余" class="headerlink" title="7.2.2. 冗余"></a>7.2.2. 冗余</h3><p>两种工作方式连接：</p>
<ul>
<li>Spanning Tree 冗余连接：工作方式是 StandBy，一条链路在工作，其余链路处于待机（StandBy）状态，效率没有提高，可靠性提高。</li>
<li>PortTrunking 连接：多条冗余连接链路实现负载分担；交换机之间联结带宽成倍提高，可靠性已得到增强</li>
</ul>
<h3 id="7-2-3-堆叠"><a href="#7-2-3-堆叠" class="headerlink" title="7.2.3. 堆叠"></a>7.2.3. 堆叠</h3><p>多台交换机的堆叠是靠一个提供背板总线带宽的多口堆叠<strong>母模块</strong>与单口的堆叠<strong>子模块</strong>相连实现的，并插入不同的交换机实现交换机的堆叠。</p>
<p>备注：只有支持堆叠的交换机之间才可以进行堆叠。</p>
<p><strong>交换机堆叠连接方法</strong> ：</p>
<p>堆叠中所有的交换机在拓扑结构上可视为一个整体的交换机来管理。</p>
<p>堆叠优势：增加用户端口、更高的用户带宽、便于统一管理整个堆叠交换机拓扑网络。</p>
<p>常用堆叠方式：</p>
<ul>
<li>菊花型：堆叠口首尾相连，是一种类似于普通的交换机之间级联连接，通过相对高速的端口串接和软件支持，最终实现构建一个多交换机的层叠结构。</li>
<li>星型：星型堆叠即一个主交换机以及多个与该主交换机相连的多台交换机构成的星型网络拓扑的堆叠方式。</li>
</ul>
<h3 id="7-2-4-级联和堆叠的对比"><a href="#7-2-4-级联和堆叠的对比" class="headerlink" title="7.2.4. 级联和堆叠的对比"></a>7.2.4. 级联和堆叠的对比</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">级联</th>
<th align="center">堆叠</th>
</tr>
</thead>
<tbody><tr>
<td align="center">连接方式</td>
<td align="center">两台交换机通过两个 Port 互联</td>
<td align="center">交换机通过专门的背板堆叠模块相连</td>
</tr>
<tr>
<td align="center">通用行</td>
<td align="center">可通过光纤或双绞线在任何网络设备厂家的交换机之间进行连接</td>
<td align="center">只能在支持堆叠的交换机设备之间堆叠连接</td>
</tr>
<tr>
<td align="center">连接距离</td>
<td align="center">较远（一百~几百米）</td>
<td align="center">几米以内</td>
</tr>
<tr>
<td align="center">能否增加总带宽</td>
<td align="center">否</td>
<td align="center">能</td>
</tr>
</tbody></table>
<h1 id="8-多层交换"><a href="#8-多层交换" class="headerlink" title="8. 多层交换"></a>8. 多层交换</h1><h2 id="8-1-三层交换"><a href="#8-1-三层交换" class="headerlink" title="8.1. 三层交换"></a>8.1. 三层交换</h2><ul>
<li><p>概念：是相对于传统交换概念而提出的（传统交换技术是在 OSI 网络标准模型中的<strong>第二层</strong>数据链路层进行操作的），而三层交换技术是在网络模型中的<strong>第三层</strong>网络层实现了数据包的<strong>高速转发</strong>。简单来说，三层交换技术就是：二层交换技术 + 三层转发技术。</p>
</li>
<li><p>原理：三层交换机的路由记忆功能是由<strong>路由缓存</strong>来实现的，其实质上是将二层交换机与路由器结合起来的网络设备，它既可以完成数据交换功能，又可以完成数据路由功能。</p>
</li>
<li><p>优点：解决了局域网中网段划分后，网段间子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。</p>
</li>
</ul>
<h2 id="8-2-多层交换"><a href="#8-2-多层交换" class="headerlink" title="8.2. 多层交换"></a>8.2. 多层交换</h2><ul>
<li>概念：凡事超越传统工作的第二层数据链路层的交换统称为——多层交换</li>
<li>第四层交换：在第四层传输层的交换。其作用为在端到端性能和服务质量要求方面，实现对所有联网设备的负载进行细致的均衡，以保证客户机与服务器之间数据平滑地流动。</li>
<li>第七层交换：在第七层应用层的交换。其作用为在高可用和负载均衡方面，可利用由应用返回给最终用户的第七层信息，为用户提供便捷的确认站点内容的响应性和正确性。</li>
</ul>
<h1 id="9-交换机端口分类"><a href="#9-交换机端口分类" class="headerlink" title="9. 交换机端口分类"></a>9. 交换机端口分类</h1><p>交换机上的端口分为三种一种是接入层端口<strong>直连</strong>设备的，叫做 Access；一种是交换机和交换机之间的端口负责<strong>汇聚</strong>的叫做 Trunk，还有一种是 Access 与 Trunk 混合的模式，叫做 Hybrid。</p>
<h2 id="9-1-不同接口类型下的-VLAN-间通信流程"><a href="#9-1-不同接口类型下的-VLAN-间通信流程" class="headerlink" title="9.1. 不同接口类型下的 VLAN 间通信流程"></a>9.1. 不同接口类型下的 VLAN 间通信流程</h2><table>
<thead>
<tr>
<th align="left">接口类型</th>
<th align="left">不带 Tag 报文处理</th>
<th align="left">带 Tag 报文处理</th>
<th align="left">发送帧处理流程</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Access 接口</td>
<td align="left">接收该报文，并打上缺省的 VLAN ID</td>
<td align="left">当 VLAN ID 与缺省 VLAN ID 相同（合法）时，接收该报文；不合法时丢弃该报文</td>
<td align="left">先剥离帧的 PVID Tag，然后再发送</td>
</tr>
<tr>
<td align="left">Trunk 接口</td>
<td align="left">打上缺省的 VLAN ID，当缺省 VLAN ID 在允许通过的 VLAN ID 列表里（合法）时，接收该报文；不合法时丢弃该报文</td>
<td align="left">当 VLAN ID 在接口允许通过的 VLAN ID 列表里（合法）时，接收该报文；不合法时丢弃该报文</td>
<td align="left">若不是接口允许通过的 VLAN ID 时，则丢弃该报文。当 VLAN ID 与缺省 VLAN ID 相同（合法）时，去掉 Tag，发送该报文。不合法时保持原有 Tag，发送该报文</td>
</tr>
<tr>
<td align="left">Hybrid 接口</td>
<td align="left">打上缺省的 VLAN ID，当缺省 VLAN ID 在允许通过的 VLAN ID 列表里（合法）时，接收该报文。不合法时丢弃该报文</td>
<td align="left">当 VLAN ID 在接口允许通过的 VLAN ID 列表里（合法）时，接收该报文；不合法时丢弃该报文</td>
<td align="left">当 VLAN ID 是该接口允许通过的 VLAN ID 时，发送该报文。可以通过命令设置发送时是否携带 Tag</td>
</tr>
</tbody></table>
<h1 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10. 参考资料"></a>10. 参考资料</h1><ul>
<li><p><a href="https://mp.weixin.qq.com/s?search_click_id=10063577871016826066-1626490825247-452760&sub=&__biz=MzAxNzU3NjcxOA==&mid=2650725002&idx=2&sn=d61b005f733aa534fa792a08e3ea2a8e&chksm=83e91cebb49e95fda30e9a74010c844442f79ec14a691ab9afcad55505febf5e47fa4ac51a87&scene=3&subscene=10000&clicktime=1626490825&enterid=1626490825&ascene=0&devicetype=android-29&version=28000737&nettype=WIFI&abtest_cookie=AAACAA==&lang=zh_CN&exportkey=ASpa0Hemse+iZ8QTZ0NEw7M=&pass_ticket=W5SLqGGBIm6sTtDFh9/FpeQO0DfiWKzR42+bP/KFJwyuesaB3YXa6pM7zC40EJ79&wx_header=1">详解交换机基础知识</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMzgxMjIxNg==&mid=2651358625&idx=1&sn=12226bab937470888bfe27e486328f4e&chksm=8060cd36b717442070afd915aa475a1a89075845908e0c742f0c1cd0713e0f9206c05ffafaf0&mpshare=1&scene=24&srcid=0716mJAaYWtKhmTkI61NyNLv&sharer_sharetime=1626369740847&sharer_shareid=ae3ffc0e2d3538e9d0d75e04ccae9d3a&ascene=14&devicetype=android-29&version=28000737&nettype=WIFI&abtest_cookie=AAACAA==&lang=zh_CN&exportkey=AZ5D1ZkwVmG4oEzUQS6UnKo=&pass_ticket=W5SLqGGBIm6sTtDFh9/FpeQO0DfiWKzR42+bP/KFJwyuesaB3YXa6pM7zC40EJ79&wx_header=1">交换机中常见的相关术语</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>恋爱观</title>
    <url>/2018/04/24/talkAboutLoveCiteByAnonymousSenior/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/talkAboutLoveCiteByAnonymousSenior.jpg" class="full-image" />


<div class="note success"><p><a href="http://rs.xidian.edu.cn/forum.php?mod=viewthread&tid=935336">全文转自西电睿思学姐(内网)</a>分享了如何树立正确的爱情观（约束而又不失个性，理性与感性并存），观点很正，值得学习，遂与大家分享。</p>
</div>

<a id="more"></a>


			<script>
				console.error("Error: [hexo-tag-aplayer] Specified asset file not found (../../../../uploads/loveYou.jpg)");
			</script>

<h1 id="1-恋爱观"><a href="#1-恋爱观" class="headerlink" title="1. 恋爱观"></a>1. 恋爱观</h1><p>我们要树立正确的恋爱观，在有热情的同时也要保持清醒理智。之前听陈果的一个分享很有意思，记录了笔记，拿出来和大家分享。<br>总共分为两个部分：</p>
<p><strong>第一部分是关于爱情的三个问题：</strong></p>
<ul>
<li>爱与被爱</li>
<li>爱的对象与能力</li>
<li>激情与爱情、性与爱；</li>
</ul>
<p><strong>第二部分是很喜欢的四句话：</strong></p>
<ul>
<li>每一个不曾起舞的日子都是对生命的辜负；</li>
<li>我自风情万种与世无争；</li>
<li>把有意思的事变得有意义，有意义的事变得有意思；</li>
<li>告诉他们我度过了幸福的一生。</li>
</ul>
<h2 id="1-1-关于爱情的三个问题"><a href="#1-1-关于爱情的三个问题" class="headerlink" title="1.1. 关于爱情的三个问题"></a>1.1. 关于爱情的三个问题</h2><blockquote class="blockquote-center">
<p><strong>爱与被爱</strong></p>

</blockquote>
<p>很多时候我们想要的是享受被爱的感觉，考虑的更多的是如何让自己爱的对象更爱自己或者让大家爱自己。但其实对于这个问题来说，我们首先要学会怎样去爱别人。比如爱自己的对象要考虑到怎样去爱他，他需要怎样的感情。如何为他提供更好的服务（爱和鼓励），在他失意的时候以自己对他的了解，给他给予支持和关怀。</p>
<p>但事实是，我们很少为别人提供服务，但需要别人为我们提供爱这种服务。对于男性来说，他们更多的是在意社会的评判，取得成就、更强、更有钱；对于女性来说，可能想要美丽、漂亮的仪容仪表。而对于男性和女性共同来说，就是需要优雅的谈吐、谦虚、诚实这些良好的品质。我们都在用优秀的要素来武装自己，来证明自己是一个优秀的人。</p>
<p>很多时候我们需要用别人的“我爱你”，来打消自己内心的疑惑，因为我们内心没有安全感。但很多东西如果需要被证实，那就说明自己本来就没有。在两个人相处的过程中应该相互信任，让信任播种出信任的种子。但很多人就是守护不住自己的感情，不知道两个人很好的爱情是需要细水长流的，是需要慢慢熬的。</p>
<p>很多时候给予比得到更让我们感到快乐。我们能够给予说明自己内心很富有，把自己身上的活力给别人。之前看到一个说穷人没有给予的乐趣。（这里所说的穷人是不愿意给予的人，而不是经济意义上的穷人。）</p>
<blockquote class="blockquote-center">
<p><strong>爱的对象和爱的能力的问题</strong></p>

</blockquote>
<p>首先我们要承认：爱是一种能力。如果说爱是一个对象的话，当这个对象出现的时候就会发现空间的转移，我们就会爱上这个对象。但是事实上，爱跟画画是一样的。我们画画首先需要打磨自己画画的技巧，而不是去寻找一个自己想画的对象。我们认为爱情是对象的问题，对爱情有热度。事实上，我们必须要有能力、有信心让爱情有持久度。所以需要去培养自己爱的能力，经营、去维护甚至去修复一段感情。在爱中，免有人会犯错，们需要做一个很好的聆听者，不是那个喋喋不休的人。</p>
<p>之前看过一段话说：时间能带走一切东西。所有人们可以留下来的东西，时间通通都可以带走。比如美丽的容颜。</p>
<p>有一种人，他们会频繁的更换爱的对象。他们是爱无能的人，他们没有爱的能力，他们没有办法沉淀下来来维护爱、欣赏爱。爱对它们来说只是一种好奇心。他们无法欣赏那些看似平常看似平淡无奇却长长久久的美，不能感受到两个人相互依赖相互依偎的美。这个也像一个体能不太好的人想去尝试各种体育项目，换了这个换那个，总觉得是体育项目的问题，但真实的原因是她自己的体质不够好，要先培养自己足够的体能。</p>
<p>也有可能是因为这些人外部展现出来的出色和自己内心世界的空洞两者相互矛盾，他们无法正视自己是一个无趣的人，也担心别人走入他们的心里的时候会发现他们自己是一个无趣的人。在他们的内心不是繁华的宫殿，而是荒草不生的荒凉的空地。</p>
<blockquote class="blockquote-center">
<p><strong>激情与爱情（性与爱）</strong></p>

</blockquote>
<p>激情点燃了爱的火炬，爱情要让火炬一直燃烧，要保持爱的持久度。两个人的相处是由最开始的拘束，到最终的自然确立关系。这个是激情的部分，也是两个人 fall in love。但这个过程不是爱情的终点，而是爱情的起点。我们要把激情维护成温情，两个人相互陪伴，being in Love。要去学着经营和维护自己爱的对象，保护自己爱的人。帮助他成长的同时也让自己成长，让彼此成为更好的人。</p>
<h2 id="1-2-四句喜欢的话："><a href="#1-2-四句喜欢的话：" class="headerlink" title="1.2. 四句喜欢的话："></a>1.2. 四句喜欢的话：</h2><blockquote class="blockquote-center">
<p><strong>每一个不曾起舞的日子都是对生命的辜负。（用心对待此时此刻，不负此生。）</strong></p>

</blockquote>

<p>过去是完成了的现在，未来是当下的延伸。人生的过去和未来都是由现在决定的。那些永远不来的才是未来，而真真切切的就是现在。那些没有来的未来就是由当下决定的，未来是由当下延伸出去的。我们用心的对待此时此刻，就用心的对待了由此时此刻完成的过去和由此时此刻所延伸的未来。</p>
<p>关于幸福这个话题，很多人都觉得等到明天或者等到未来的某一天我们要追寻幸福。我们总把幸福不断的延伸，觉得达到什么目标之后我们才有资格去幸福、实现梦想。但总有一个明天会让我们推卸梦想。所以我们要从现在开始好好的去生活，好好对待自己的梦想，好好的对待自己想做的事情。</p>
<p>著名的诗人海子写过《面朝大海春暖花开》这首诗，但其实他还有另外一首诗《从明天开始做一个幸福的人》。但从明天开始这句话的潜台词就是：今天不幸福。不要从明天开始才去做一个幸福的人，而要从此时此刻开始。在自己能力的范围内创造属于自己的幸福。如果你有50万，你就创造50万的幸福；如果你只有50块，就创造50块的幸福。按自己的生活节奏过自己认为幸福的生活。</p>
<p>我们人生有很多阶段，在学生的时候我们要演好学生的生活；以后在公司要演好公司职员的生活。在人生的每个港口我们都要安家落户落户，做最真实的自己。很多时候我们并没有那么富裕，但我们可以用贫穷的物质过好丰富的精神生活。很多时候我们会很忙，但是忙也就是一件事接着一件事，去把他们做好就好了。我们很忙的时候，也不会有时间来抱怨。如果自己时间很闲的话，我们可以做一些没有效率的事情，比如抄书什么的。你要记住你不是一个人，你是有小伙伴的，你就是自己最好的小伙伴。一个人很自由，我们要享受独处。</p>
<p>要看重每一个当下，把握好此时此刻，不要等到明天才想着开始做一个幸福的或者真诚的人。要全身全心地投入每一个过程，尽人事，做最真实的自己。有时候目标导向性太强、效率优先，反而让我们很不舒服。尽力而为、顺其自然，有志者事未必竟成，但我们要全心全意的去做。</p>
<blockquote class="blockquote-center">
<p><strong>我自风情万种与世无争</strong></p>

</blockquote>

<p>在不干扰别人、不给别人带来麻烦、不影响别人的情况下，我们真的不必太去在意别人的想法。（但这也是有条件的，我们不能做不道德的事情。）</p>
<p>有这样一个问题:让别人喜欢自己和自己喜欢自己哪个更重要。说实话这两个都很重要，但如果非要选一个最重要的，那只能选让自己喜欢自己这个更重要。因为不管你活成什么样，活的多优秀、多完美、甚至是多糟糕，总有人喜欢你，总有人不喜欢你。当你做真实的自己的时候，还是有人喜欢你，有人不喜欢你。但你会更喜欢你。喜欢你的人多了一个最重要的人，你喜欢你自己。当一个人真的喜欢自己的时候，他会由内而外的散发出自信。</p>
<p>这里区分一下自信和他信。很多时候很多人将自己的自信建立于别人对自己的信任之上，很在意别人的眼光，但其实这是不必要的。因为你们信，所以我才信我。这是典型的他信。而真正的自信是自己知道自己的重量，不会因为别人夸自己而觉得自己很厉害，也不会因为别人贬低自己而看轻自己。不管别人怎么说自己，我自己知道我自己是怎样的人。很多时候别人喜欢你，并不是因为你这个人优不优秀，也许是因为他们可以从你身上得到好处吧。</p>
<p>当一个人由内而外散发出自由和自信的气息的时候有很多别称，有一个称呼叫魅力、从容、风情。这是一种来自真正喜欢自己的人的自信。一个人喜欢自己的时候是自信自由而优雅的。</p>
<p>很多时候我们会很喜欢优雅这个词，但香奈儿的slogan告诉我们言行自如便是一种优雅。举手投足之间表露的自信，由内而外散发的自由和优雅。</p>
<p>一个人发自内心有自由、自信，会散发出一种感染力。正能量不是告诉别人“加油你是最棒的”。正能量是将自己活成了一个光源、一个小太阳。不需要跟别人说什么，当他们接近我们的时候，不管我自己愿不愿意，他们都被我温暖，我们都照亮了他们的内心。一个负能量满满的人，不管他说什么都会大打折扣，他们也给不了别人有用的建议。让自己活出自信、自由，真正喜欢自己，会散发出一种正能量，这才叫感染力。你的存在本身就是一种光明与优雅。</p>
<p>如何找到好友？大家都知道“物以类聚，人以群分”。只有同等能量的人才能相互识别、相互结识、相互珍惜、相互欣赏，彼此成为知己。我们想要怎么样的朋友，首先我们要将自己变成那样的人。只有成为那样的人之后，才会引来那样的人。自信而自由的喜欢自己，才会吸引到那样的人。做一个闪闪发光的真诚的人。</p>
<p>一个很爱自己的人一定也是一个热爱生活的人，一个人对自己很满意的时候也会对世界很满意，因为这是这个世界将他变成让他满意的自己。所有的厌世都是自厌，因为他们不喜欢这样的自己。</p>
<blockquote class="blockquote-center">
<p><strong>把有意义的事变得有意思，让有意思的事儿变得有意义。</strong></p>

</blockquote>

<p>我们要将无趣而有意义的事情变得好玩，将有意思的事把它变得更有意义。</p>
<blockquote class="blockquote-center">
<p><strong>告诉他们我度过了幸福的一生。</strong></p>

</blockquote>

<p>我自己要幸福，要帮助他人，让他们变得更加幸福。自己好好活着，要帮别人好好活着。</p>
<h2 id="1-3-很喜欢的一句话："><a href="#1-3-很喜欢的一句话：" class="headerlink" title="1.3. 很喜欢的一句话："></a>1.3. 很喜欢的一句话：</h2><blockquote class="blockquote-center">
<p><strong>希望我遇到的每一个人，经历的每一件事，都因为我而变得更加美好。</strong></p>

</blockquote>

<div class="note success"><p><a href="http://rs.xidian.edu.cn/forum.php?mod=viewthread&tid=935336">全文转自西电睿思学姐(内网)</a></p>
</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>爱情观</tag>
      </tags>
  </entry>
  <entry>
    <title>syslog协议与Rsyslog系统日志软件简介</title>
    <url>/2021/08/07/syslogProtocolAndRsyslog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/syslogProtocol.png"  style="zoom:75%;" />

<a id="more"></a>

<h1 id="1-syslog系统日志协议"><a href="#1-syslog系统日志协议" class="headerlink" title="1. syslog系统日志协议"></a>1. syslog系统日志协议</h1><h2 id="1-1-syslog协议简介"><a href="#1-1-syslog协议简介" class="headerlink" title="1.1. syslog协议简介"></a>1.1. syslog协议简介</h2><ul>
<li>Unix&#x2F;Linux系统中的<strong>绝大部分日志</strong>都是通过一种叫做<strong>syslog</strong>的机制<strong>产生和维护</strong>的。</li>
<li><strong>syslog协议</strong>是一个<b><font color="red" style="">转发系统日志信息的标准</font></b>，它是在美国加州大学伯克利软件分布研究中心BSD的 TCP&#x2F;IP 系统实施中开发的，目前已成为一种工业标准协议。</li>
<li>syslog协议可根据与日志消息的生产关系分为客户端和服务器端。其中<strong>客户端</strong>是产生日志消息的一方；<strong>服务器端</strong>负责接收客户端发送来的日志消息，并进行保存到特定的日志文件中或其他方式的处理。</li>
<li><strong>syslog记录着系统中的任何事件</strong>，任何希望生成日志的程序都可以向 syslog 发送信息。</li>
</ul>
<h2 id="1-2-syslog协议的日志信息结构"><a href="#1-2-syslog协议的日志信息结构" class="headerlink" title="1.2. syslog协议的日志信息结构"></a>1.2. syslog协议的日志信息结构</h2><p>标准syslog协议的日志信息结构主要由PRI（priority，优先级）、HEADER、MSG三部分组成。下方为某syslog消息示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;147&gt;Oct 9 22:33:20 hlfedora auditd[1787]: The audit daemon is exiting.</span><br></pre></td></tr></table></figure>

<table width="700" border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <td colspan="5" align="center"><b><font color="red" style="">&lt;147&gt;</font></b><b><font color="blue" style="">Oct 9 22:33:20 hlfedora</font></b> <b><font color="green" style="">auditd[1787]: The audit daemon is exiting.</font></b></td>
    </tr>
    <tr>
        <td align="center"><b><font color="red" style="">&lt;147&gt;</font></b></td>
        <td colspan="2" align="center"><b><font color="blue" style="">Oct 9 22:33:20 hlfedora</font></b></td>
        <td colspan="2" align="center"><b><font color="green" style="">auditd[1787]: The audit daemon is exiting.</font></b></td>
    </tr>
    <tr>
        <th align="center"><b><font color="red" style="">PRI</font></b></th>
        <th colspan="2" align="center"><b><font color="blue" style="">HEADER</font></b></th>
        <th colspan="2" align="center"><b><font color="green" style="">MSG</font></b></th>
    </tr>
    <tr>
        <th align="center"><b>&lt;Facility * 8 + Severity&gt;</th>
        <th align="center"><b>时间</th>
        <th align="center"><b>主机名（或IP）</th>
        <th align="center"><b>TAG（可选）</th>
        <th align="center"><b>Content</th>
    </tr>
    <tr>
        <td align="center">&lt;18(local2) * 8 + 3(Error)&gt;</td>
        <td align="center">Oct 9 22:33:20</td>
        <td align="center">hlfedora</td>
        <td align="center">auditd[1787]:</td>
        <td align="center"> The audit daemon is exiting.</td>
    </tr>
</table>

<p>其中“&lt;147&gt;”是PRI部分，“Oct 9 22:33:20 hlfedora”是HEADER部分，“auditd[1787]: The audit daemon is exiting.”是MSG部分。</p>
<h3 id="1-2-1-PRI部分"><a href="#1-2-1-PRI部分" class="headerlink" title="1.2.1. PRI部分"></a>1.2.1. PRI部分</h3><p>PRI（priority，优先级）部分由尖括号包含的一个数字构成，这个数字包含了程序模块（Facility）、严重性（Severity），这个数字是由 Facility 乘以 8 再加上 Severity 得来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">priNum = Facility * 8 + Severity</span><br></pre></td></tr></table></figure>

<p><b><font color="red" style="">协议定义了24个日志 程序模块（Facility）：</font></b></p>
<table>
<thead>
<tr>
<th align="center">Numerical Code</th>
<th align="left">Facility</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="left">kernel messages</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">user-level messages</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">mail system</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">system daemons</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">security&#x2F;authorization messages (note 1)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">messages generated internally by syslogd</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">line printer subsystem</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">network news subsystem</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">UUCP subsystem</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">clock daemon (note 2)</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">security&#x2F;authorization messages (note 1)</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">FTP daemon</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">NTP subsystem</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">log audit (note 1)</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">log alert (note 1)</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">clock daemon (note 2)</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left">local use 0  (local0)</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left">local use 1  (local1)</td>
</tr>
<tr>
<td align="center"><strong>18</strong></td>
<td align="left"><strong>local use 2  (local2)</strong></td>
</tr>
<tr>
<td align="center">19</td>
<td align="left">local use 3  (local3)</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left">local use 4  (local4)</td>
</tr>
<tr>
<td align="center">21</td>
<td align="left">local use 5  (local5)</td>
</tr>
<tr>
<td align="center">22</td>
<td align="left">local use 6  (local6)</td>
</tr>
<tr>
<td align="center">23</td>
<td align="left">local use 7  (local7)</td>
</tr>
</tbody></table>
<blockquote>
<p>Note 1 - Various operating systems have been found to utilize<br>Facilities 4, 10, 13 and 14 for security&#x2F;authorization,audit, and alert messages which seem to be similar.<br>Note 2 - Various operating systems have been found to utilize<br>both Facilities 9 and 15 for clock (cron&#x2F;at) messages.</p>
</blockquote>
<p><b><font color="red" style="">协议定义了8个日志级别——严重性（Severity）：</font></b></p>
<table>
<thead>
<tr>
<th align="center">Numerical Code</th>
<th align="left">Severity</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="left">Emergency: system is unusable</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">Alert: action must be taken immediately</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">Critical: critical conditions</td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="left"><strong>Error: error conditions</strong></td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">Warning: warning conditions</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">Notice: normal but significant condition</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">Informational: informational messages</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">Debug: debug-level messages</td>
</tr>
</tbody></table>
<p>对上述PRI值为147的日志消息示例，syslog协议在：</p>
<ul>
<li><p><strong>填充PRI字段时</strong>，根据要传入日志消息的程序模块（Facility）和严重性（Severity）参数计算消息的PRI值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">18(local2) * 8 + 3(Error) = 147</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解析时PRI字段时</strong>，取 PRI值(<b><font color="green" style="">10010</font></b><b><font color="red" style="">011</font></b>B, 147) 的：</p>
<ul>
<li>低位3位(<b><font color="red" style="">011</font></b>B, 3)即可得到Severity的值(<b><font color="red" style="">Error</font></b>)；</li>
<li>取PRI值的高5位（右移3位后）(<b><font color="green" style="">10010</font></b>B, 18)即可得到Facility的值(<b><font color="green" style="">local2</font></b>)。</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-HEADER部分"><a href="#1-2-2-HEADER部分" class="headerlink" title="1.2.2. HEADER部分"></a>1.2.2. HEADER部分</h3><p>HEADER部分包括两个字段，<strong>时间</strong>和<strong>主机名（或IP）</strong>。其格式如下：</p>
<table  border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <td colspan="2" align="center">Oct 9 22:33:20 hlfedora</td>
    </tr>
    <tr>
        <th align="center">时间</th>
        <th align="center">主机名（或IP）</th>
    </tr>
    <tr>
        <td align="center">Oct 9 22:33:20</td>
        <td align="center">hlfedora</td>
    </tr>
</table>

<p>格式必须是“Mmm dd hh:mm:ss”，不包括年份。“日”的数字如果是1～9，前面会补一个空格（也就是月份后面有两个空格），而“小时”、“分”、“秒”则在前面补“0”。<br>月份取值包括：Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec</p>
<p>备注：</p>
<ul>
<li>长期以来，没有一个标准来规范syslog的格式，导致syslog的<strong>格式是非常随意</strong>；</li>
<li>某些不标准的syslog格式中包含了年份，若未做<strong>容错处理</strong>将会导致解析出错；</li>
<li>大部分syslog都包含PRI和MSG部分，而HEADER可能没有，这个时候MSG部分紧跟在PRI后面，中间没有空格。</li>
</ul>
<h3 id="1-2-3-MSG部分"><a href="#1-2-3-MSG部分" class="headerlink" title="1.2.3. MSG部分"></a>1.2.3. MSG部分</h3><p>MSG由TAG部分（可选）和Content部分构成。其格式如下：</p>
<table  border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <td colspan="2" align="center">auditd[1787]: The audit daemon is exiting.</td>
    </tr>
    <tr>
        <th align="center">TAG（可选）</th>
        <th align="center">Content</th>
    </tr>
    <tr>
        <td align="center">auditd[1787]</td>
        <td align="center"> The audit daemon is exiting.</td>
    </tr>
</table>

<p>其中，TAG域的值是产生日志消息的<strong>程序或进程</strong>的名称，TAG后面用一个冒号隔开Content部分，这部分的内容是应用程序自定义的日志正文。</p>
<h2 id="1-3-各日志文件的默认意义说明"><a href="#1-3-各日志文件的默认意义说明" class="headerlink" title="1.3. 各日志文件的默认意义说明"></a>1.3. 各日志文件的默认意义说明</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center"><b>文件</b></th>
        <th align="center"><b>说明</b></th>
    </tr>
    <tr>
        <td><b>/var/log/messages</b></td>
        <td>系统主日志文件，记录常见的系统和服务错误信息</td>
    </tr>
    <tr>
        <td><b>/var/log/syslog</b></td>
        <td>只记录警告信息，常常是系统出问题的信息，使用lastlog查看</td>
    </tr>
    <tr>
        <td>/var/log/boot.log</td>
        <td>记录系统在引导过程中发生的事件，即开机自检中显示信息</td>
    </tr>
    <tr>
        <td>/var/log/lastlog</td>
        <td>记录最后一次用户成功登陆的时间、登陆IP等信息</td>
    </tr>
    <tr>
        <td>/var/log/secure</td>
        <td>系统认证/安全日志。记录用户和工作组变坏情况、用户登陆认证情况</td>
    </tr>
    <tr>
        <td>/var/log/maillog</td>
        <td>邮件postfix相关日志</td>
    </tr>
    <tr>
        <td>/var/log/btmp</td>
        <td>记录Linux登陆失败的用户、时间以及远程IP地址</td>
    </tr>
    <tr>
        <td>/var/log/cron</td>
        <td>记录计划任务crond服务执行情况</td>
    </tr>
    <tr>
        <td>/var/log/dmesg</td>
        <td>记录系统启动相关日志</td>
    </tr>
</table>

<h1 id="2-Rsyslog系统日志软件简介"><a href="#2-Rsyslog系统日志软件简介" class="headerlink" title="2. Rsyslog系统日志软件简介"></a>2. Rsyslog系统日志软件简介</h1><h2 id="2-1-系统日志软件简介"><a href="#2-1-系统日志软件简介" class="headerlink" title="2.1. 系统日志软件简介"></a>2.1. 系统日志软件简介</h2><ul>
<li>系统日志软件可根据当条日志消息的<strong>PRI属性值</strong>，即对应syslog协议中的<strong>程序模块（Facility）</strong>和<strong>严重性级别（Severity）</strong>，对当条日志消息按配置文件中<strong>指定的方式进行处理</strong>，如：保存到不同的文件中、发送到远程服务器或数据库等。</li>
<li><b><font color="red" style="">Syslog</font></b> 是早期大部分Linux发行版的内置<strong>日志记录程序</strong>，现已逐渐被 <b><font color="red" style="">Rsyslog</font></b> 取代（<strong>优势</strong>：性能和安全性更高，日志处理规模可达每秒百万条），Red Hat Enterprise Linux 6 之后的系统默认使用了Rsyslog。</li>
<li>系统日志软件转发日志消息时，绝大多数情况下使用UDP协议转发syslog消息，少数情况使用TCP协议（RFC3195协议）转发syslog消息</li>
</ul>
<h2 id="2-2-常用的系统日志软件（Syslog、Syslog-ng-与-Rsyslog）对比"><a href="#2-2-常用的系统日志软件（Syslog、Syslog-ng-与-Rsyslog）对比" class="headerlink" title="2.2. 常用的系统日志软件（Syslog、Syslog-ng 与 Rsyslog）对比"></a>2.2. 常用的系统日志软件（Syslog、Syslog-ng 与 Rsyslog）对比</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <th align="center"><b><a href="//en.wikipedia.org/wiki/Syslog">Syslog</a></b></th>
        <th align="center"><b><a href="//www.syslog-ng.com/products/open-source-log-management">Syslog-ng</a></b></th>
        <th align="center"><b><a href="//www.rsyslog.com">Rsyslog</a></b></th>
    </tr>
    <tr>
        <td align="center">诞生时间</td>
        <td align="center">1980</td>
        <td align="center">1998</td>
        <td align="center">2004</td>
    </tr>
    <tr>
        <td align="center">守护进程</td>
        <td align="center">syslogd<br>klogd</td>
        <td align="center">journald</td>
        <td align="center">rsyslogd</td>
    </tr>
    <tr>
        <td align="center">配置文件</td>
        <td align="center">/etc/syslog.conf</td>
        <td align="center">/etc/syslog.conf</td>
        <td align="center">/etc/rsyslog.conf</td>
    </tr>
    <tr>
        <td align="center">主要特性</td>
        <td>* 支持单机模式<br>* 支持C/S架构<br>* 支持UDP/TCP协议</td>
        <td>* 支持SSL/TLS协议<br>* 支持输出日志到数据库，如：MySQL、<br>Oracle、PostgreSQL和SQLite.<br>* 支持标准的Syslog协议<br>* 支持Filter、Parse以及Rewrite<br>* 支持更多的平台和更高的负载能力</td>
        <td>* 多线程<br>* 支持TCP, SSL, TLS, RELP<br>* 支持输出日志到各种数据库，如：MySQL，PostgreSQL，<br>MongoDB，ElasticSearch等<br>* 可通过可靠事件记录协议（Reliable Event Logging Protocol<br>，RELP） + TCP实现数据的可靠传输<br>* 可对输出格式进行精细控制<br>具有强大的消息过滤能力<br>具有高精度时间戳、队列操作（内存，磁盘以及混合模式等）<br>支持数据的加密和压缩传输等</td>
    </tr>
</table>

<p>常用系统日志软件中，应用最广泛同时性能最强大的是<strong>Rsyslog</strong>（官网标语：The rocket-fast system for log processing）。</p>
<h2 id="2-3-Rsyslog工作流"><a href="#2-3-Rsyslog工作流" class="headerlink" title="2.3. Rsyslog工作流"></a>2.3. Rsyslog工作流</h2><p>支持多线程的Rsyslog工作流示意图（多种输入输出方式并行处理）：</p>
<img data-src="../../../../uploads/RsyslogWorkFlow.png" class="full-image" alt="Rsyslog工作流" />

<p>对单个日志消息，日志message先进入主队列再过滤到分支队列，最后在各个processor线程中输出内容，输出到指定的输出方式中（如：写文件、发送远程主机、存数据库等）。</p>
<img data-src="../../../../uploads/RsyslogMsgDeal.jpg" class="full-image" alt="Rsyslog消息处理流程" />

<h2 id="2-4-Rsyslog日志消息流向"><a href="#2-4-Rsyslog日志消息流向" class="headerlink" title="2.4. Rsyslog日志消息流向"></a>2.4. Rsyslog日志消息流向</h2><p>下面从 rsyslogd 进程的输入和输出两个方面概述的日志信息流向。</p>
<img data-src="../../../../uploads/RsyslogFeaturesImagemap.png" class="full-image" alt="Rsyslog msg流向" />

<p><strong>输入</strong>：</p>
<ol>
<li>接收Linux内核进程发送到&#x2F;dev&#x2F;klog（特殊的设备，读取内核发出的消息）的日志消息</li>
<li>接收用户进程（通过进程间通信）发送到&#x2F;dev&#x2F;log（UNIX域数据包套接字）的日志消息</li>
<li>接收UDP协议（TCP&#x2F;IP网络通信）发送到514端口的日志消息</li>
<li>监听写入文件的日志消息</li>
</ol>
<p><strong>输出</strong>：</p>
<ol>
<li>写入本地指定文件</li>
<li>发送给远程主机（eg. 远程ELK实时日志分析平台）</li>
<li>输出日志到数据库</li>
</ol>
<h1 id="3-参考文档"><a href="#3-参考文档" class="headerlink" title="3. 参考文档"></a>3. 参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/skyofbitbit/p/3674664.html">linux syslog详解</a></li>
<li><a href="https://www.rsyslog.com/">Rsyslog官网</a></li>
<li><a href="https://www.cnblogs.com/taosiyu/p/12930410.html">rsyslog详解实战和避坑</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>syslog</tag>
      </tags>
  </entry>
  <entry>
    <title>win10优化精选</title>
    <url>/2017/03/02/win10Optimization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/win10Optimization.jpg" class="full-image" />

<h1 id="1-Win-R-常用命令"><a href="#1-Win-R-常用命令" class="headerlink" title="1. Win + R 常用命令"></a>1. Win + R 常用命令</h1><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">msconfig</td>
<td align="left">系统配置 (启动方式：安全模式，有无GUI引导等)</td>
</tr>
<tr>
<td align="left">gpedit.msc</td>
<td align="left">本地组策略编辑器</td>
</tr>
<tr>
<td align="left">services.msc</td>
<td align="left">服务</td>
</tr>
<tr>
<td align="left">netplwiz</td>
<td align="left">用户账户</td>
</tr>
<tr>
<td align="left">msinfo32</td>
<td align="left">查看系统是否UEFI启动</td>
</tr>
<tr>
<td align="left">slmgr.vbs -dlv</td>
<td align="left">查询操作系统版本、部分产品密钥、许可证等</td>
</tr>
<tr>
<td align="left">slmgr.vbs -xpr</td>
<td align="left">命令可以查询Win10是否永久激活</td>
</tr>
<tr>
<td align="left">winver</td>
<td align="left">查询系统内核版本，以及注册用户信息</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="2-win10组策略关闭自动更新、Windows-Defender"><a href="#2-win10组策略关闭自动更新、Windows-Defender" class="headerlink" title="2. win10组策略关闭自动更新、Windows Defender"></a>2. win10组策略关闭自动更新、Windows Defender</h1><ul>
<li>组策略关闭自动更新</li>
</ul>
<p>按Win键+R键调出运行，输入<code>gpedit.msc</code>点击“确定”，调出“本地组策略编辑器”。按顺序依次展开”计算机配置”，”管理模板” ，”windows组件” ，”windows更新 “。在右面找到“配置自动更新”，并双击。 禁用</p>
<ul>
<li>关闭Windows Defender</li>
</ul>
<p>找到计算机配置、管理模板、Windows组件、Windows Defender”选项“”双击打开“关闭 Windows Defender”后启用关掉“本地组策略编辑器”，重启电脑。</p>
<h1 id="3-离线安装-Net3-5"><a href="#3-离线安装-Net3-5" class="headerlink" title="3. 离线安装.Net3.5"></a>3. 离线安装.Net3.5</h1><ul>
<li>按键盘上的windows+x组合键，在弹出的系统菜单中选择“命令提示符（管理员）”这一项：</li>
<li>然后输入以下命令: (注意盘符要根据安装U盘实际盘符作出更改)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:NetFX3 &#x2F;Source:F:\sources\sxs #其中“d:\sources\sxs”为SXS文件夹路径：</span><br></pre></td></tr></table></figure>
命令无误后安回车，稍等即可开始离线安装了</li>
<li>当进程到100%时还需要稍等一会，显示“操作成功完成”后表示.net framework3.5离线安装完成：</li>
<li>到控制面板中的“启用或关闭Windows功能”中看看，.net framework3.5程序已经打勾，一些程序可正常安装了，也不会再弹出.net framework3.5安装提示：</li>
</ul>
<h1 id="4-免密登陆win10"><a href="#4-免密登陆win10" class="headerlink" title="4. 免密登陆win10"></a>4. 免密登陆win10</h1><ul>
<li>Win + R 打开运行程序，在空白框输入netplwiz,然后点击确定按钮</li>
<li>进入账户页面，选择一个账户，将下图所示的要使用计算机，用户必须输入用户名和密码复选框的勾去掉！</li>
<li>点击右下角“应用”弹出密码账户界面，输入密码，点击“确定”完成修改，下次将自动以此账户直接登录，免输密码！</li>
</ul>
<h1 id="5-Windows10必做的优化"><a href="#5-Windows10必做的优化" class="headerlink" title="5. Windows10必做的优化"></a>5. Windows10必做的优化</h1><ul>
<li>右键点击“此电脑”，选择“管理”，进入“计算机管理”窗口，在左侧的菜单选择“服务”，</li>
<li>手动禁用下列服务：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HomeGroup Listener</span><br><span class="line">HomeGroup Provider</span><br><span class="line">IPHelper （如果您的网络运营商不分配IPV6地址，可以将其关闭。）</span><br><span class="line">WindowsSearch （会在后台偷偷查户口。）</span><br><span class="line">Windows Update 禁用更新</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6-卸载无用应用"><a href="#6-卸载无用应用" class="headerlink" title="6. 卸载无用应用"></a>6. 卸载无用应用</h1><ul>
<li>打开开始菜单里的“设置”应用，依次进入“系统”→“应用和功能”，可以卸掉一些您用不到的系统自带应用。</li>
</ul>
<h1 id="7-关闭优化驱动器"><a href="#7-关闭优化驱动器" class="headerlink" title="7. 关闭优化驱动器"></a>7. 关闭优化驱动器</h1><ul>
<li>双击“此电脑”打开，右键点击任意磁盘，选择“属性”。</li>
<li>在上方的标签选择“工具”，然后点击“优化”。</li>
<li>在下方“已计划的优化”处点“更改设置”，然后取消计划。</li>
<li>win10的“优化驱动器”即win7时代的磁盘碎片整理，每两三个月做一次即可，每周计划运行实属对资源的浪费。【固态硬盘不需要】</li>
</ul>
<h1 id="8-禁用系统保护"><a href="#8-禁用系统保护" class="headerlink" title="8. 禁用系统保护"></a>8. 禁用系统保护</h1><ul>
<li>右键点击“此电脑”，选择“属性”，再在“系统”窗口的左侧选择“系统保护”。</li>
<li>在下方配置系统保护功能，选择禁用。（如果有开启的话）</li>
<li>“系统保护”即XP时代的“系统还原”。现在一键GHOST或各品牌厂商的一键恢复软件的功能完爆它几条街，它也就没什么用了，关掉吧，还能节省一些磁盘空间。</li>
</ul>
<h1 id="9-关闭IPV6"><a href="#9-关闭IPV6" class="headerlink" title="9. 关闭IPV6"></a>9. 关闭IPV6</h1><p>如果您的网络运营商不分配IPV6地址，可以将其关闭。</p>
<ul>
<li>右键点击“此电脑”，选择“管理”，进入“计算机管理”窗口。在左侧的菜单选择“服务”，并在右侧找到“IPHelper”。右键点击它，选择“属性”，并在新打开的窗口中把启动类型改为“禁用”。方法基本同第一部分。</li>
<li>网络共享中心&gt;网络连接&gt;以太网&gt;属性&gt;取消ipv6。</li>
</ul>
<h1 id="10-关闭家庭组"><a href="#10-关闭家庭组" class="headerlink" title="10. 关闭家庭组"></a>10. 关闭家庭组</h1><p>因为这功能会导致硬盘和CPU处于高负荷状态</p>
<ul>
<li>关闭方法：控制面板&gt;家庭组&gt;离开。</li>
</ul>
<h1 id="11-防火墙"><a href="#11-防火墙" class="headerlink" title="11. 防火墙"></a>11. 防火墙</h1><p>可在控制面板里面的防火墙的“高级设置”里面的“属性”把“域配置文件”、“专用配置文件”、“公用配置文件”的状态改成关闭，这样就可以在不禁用防火墙服务的情况下关闭防火墙。但windows firewall　(windows防火墙服务)千万不能停用。</p>
<h1 id="12-设置好Superfetch服务-Windows-Search"><a href="#12-设置好Superfetch服务-Windows-Search" class="headerlink" title="12. 设置好Superfetch服务 Windows Search"></a>12. 设置好Superfetch服务 Windows Search</h1><p>服务Superfetch启动类型改成延迟启动或禁用，可以避免Win10对硬盘的频繁访问。关于Superfetch和Search，SSD用户要关</p>
<h1 id="13-开启HybridBoot"><a href="#13-开启HybridBoot" class="headerlink" title="13. 开启HybridBoot"></a>13. 开启HybridBoot</h1><ul>
<li>Win10启动飞快</li>
</ul>
<p>控制面板&gt;电源选项&gt;选择电源按钮的功能，更改当前不可用的设置&gt;关机设置&gt;勾上启用快速启动。</p>
<ul>
<li>关闭休眠</li>
</ul>
<p>Win+R输入powercfg -h on，关闭休眠：powercfg -h off（关闭后C盘会空出几G的空间）</p>
<h1 id="14-关闭性能特效"><a href="#14-关闭性能特效" class="headerlink" title="14. 关闭性能特效"></a>14. 关闭性能特效</h1><p>配置不太好的机器可以适当关闭显示效果以提高系统相应速度</p>
<ul>
<li>系统属性&gt;高级&gt;性能&gt;设置&gt;关闭淡出淡入效果。打开文件夹，小软件很快的</li>
</ul>
<h1 id="15-关闭讨厌的第三方软件服务项"><a href="#15-关闭讨厌的第三方软件服务项" class="headerlink" title="15. 关闭讨厌的第三方软件服务项"></a>15. 关闭讨厌的第三方软件服务项</h1><ul>
<li>Win+ R输入“msconfig”→确定。打开系统配置→勾选隐藏所有的Microsoft服务去掉不需要运行的服务</li>
<li>引导 – 勾上无GUI引导，确定。</li>
</ul>
<h1 id="16-Win10加速关机速度"><a href="#16-Win10加速关机速度" class="headerlink" title="16. Win10加速关机速度"></a>16. Win10加速关机速度</h1><ul>
<li>Win+R键。输入 gpedit.msc</li>
<li>计算机管理中选择，模块管理 - 系统 -关机选项</li>
<li>“启用” 关闭会阻止或取消关机的应用程序的自动终止功能</li>
</ul>
<h1 id="17-关闭计划任务里的隐藏的自启动程序"><a href="#17-关闭计划任务里的隐藏的自启动程序" class="headerlink" title="17. 关闭计划任务里的隐藏的自启动程序"></a>17. 关闭计划任务里的隐藏的自启动程序</h1><ul>
<li>控制面板→所有控制面板项→管理工具→任务计划程序→任务计划程序库→右侧任务列表→禁用不需要的任务</li>
</ul>
<h1 id="18-关闭windows安全中心服务"><a href="#18-关闭windows安全中心服务" class="headerlink" title="18. 关闭windows安全中心服务"></a>18. 关闭windows安全中心服务</h1><ul>
<li>Win+R键 输入services.msc回车——找到SecurityCenter ，设置禁用。</li>
</ul>
<h1 id="19-关闭onedrive，自动上传文件"><a href="#19-关闭onedrive，自动上传文件" class="headerlink" title="19. 关闭onedrive，自动上传文件"></a>19. 关闭onedrive，自动上传文件</h1><ul>
<li>Win+R键输入 <code>gpedit.msc</code></li>
</ul>
<p>在计算机配置 管理模板 windows组件里，有三个选项关闭</p>
<h1 id="20-取消默认网速20-限制，让网速在快一点儿"><a href="#20-取消默认网速20-限制，让网速在快一点儿" class="headerlink" title="20. 取消默认网速20%限制，让网速在快一点儿"></a>20. 取消默认网速20%限制，让网速在快一点儿</h1><ul>
<li>单击“开始”菜单，然后单击“运行”，在出现的“运行”对话框的“打开”文本框中输入<code>gpedit.msc</code>命令，点击“确定”，启动组策略管理器</li>
<li>展开“计算机配置”，而后再展开其下的“管理模板”子项目，展开“网络”，单击选中“Qos数据包调度程序”项目</li>
<li>双击“限制可保留带宽”，将该项目设置为“已启动”，并将“带宽限制”设置为“0”就可以了</li>
<li>单击“确定”按钮使设置生效</li>
</ul>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：从理解需求到强大执行</title>
    <url>/2021/09/26/workplace_note_10_understanding_requirements_and_strong_execution/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-如何清晰的理解需求"><a href="#1-如何清晰的理解需求" class="headerlink" title="1. 如何清晰的理解需求"></a>1. 如何清晰的理解需求</h1><h2 id="1-1-理解需求的重要性"><a href="#1-1-理解需求的重要性" class="headerlink" title="1.1. 理解需求的重要性"></a>1.1. 理解需求的重要性</h2><p>需求产生的：原因、背景</p>
<p>并不是每次都有补救的机会</p>
<ul>
<li>清楚的理解需求，事半功倍</li>
<li>错误的理解需求，满盘皆输</li>
</ul>
<a id="more"></a>

<h2 id="1-2-清晰的了解需求"><a href="#1-2-清晰的了解需求" class="headerlink" title="1.2. 清晰的了解需求"></a>1.2. 清晰的了解需求</h2><p><strong>我</strong>需要在什么<strong>时间</strong>，产出什么<strong>结果</strong></p>
<ul>
<li><strong>要求</strong><ul>
<li><strong>一次性产出</strong>&amp;<strong>阶段性产出</strong></li>
<li>最终结果&amp;阶段性结果</li>
</ul>
</li>
<li>每个阶段的<strong>时间节点</strong><ul>
<li>期望（计划） 完成时间</li>
<li>完成时间底线</li>
</ul>
</li>
<li>每个阶段<strong>需要产出结果</strong><ul>
<li>期望结果</li>
<li>底线结果</li>
</ul>
</li>
</ul>
<h2 id="1-3-完整、深入的理解需求"><a href="#1-3-完整、深入的理解需求" class="headerlink" title="1.3. 完整、深入的理解需求"></a>1.3. 完整、深入的理解需求</h2><p>从背景、要求、全局、注意事项、细节等方面真正理解需求。</p>
<ul>
<li><strong>背景</strong>：谁，用来做什么的，用在什么场合 —— （会议的主题、规模、主办者、受众、演讲者）</li>
<li><strong>全局</strong>：<ul>
<li>在这个事情的基础上的整体需求是什么 —— （整个大会对于公司、部门的意义，后续还有没有其他大会）</li>
<li>我的产出结果在整体中的作用 —— （大会上公司整体想突出什么、事业群想突出什么、部门想突出什么，如何与整体战略形成契合）</li>
</ul>
</li>
<li><strong>要求和注意事项</strong><ul>
<li>显性 —— （PPT 格式、模板、需要提到什么）</li>
<li><strong>隐性</strong> —— （内容、发言者职级对等、有没有什么敏感信息不能提）</li>
</ul>
</li>
<li><strong>查漏补缺</strong>：<strong>换位主动思考</strong>，深入挖掘需求 —— （如果我是演讲者，我会怎么讲，如何能讲的很顺，如何与前后内容）</li>
</ul>
<h1 id="2-制定方案很重要"><a href="#2-制定方案很重要" class="headerlink" title="2. 制定方案很重要"></a>2. 制定方案很重要</h1><p>如何制定执行方案：</p>
<ul>
<li><b><font color="red" style="">定</font></b> 角色 &amp; 职责</li>
<li><b><font color="red" style="">发</font></b> 任务安排</li>
<li><b><font color="red" style="">出</font></b> 执行方案</li>
<li><b><font color="red" style="">做</font></b> 风险预判和紧急预案</li>
</ul>
<h2 id="2-1-定角色和职责"><a href="#2-1-定角色和职责" class="headerlink" title="2.1. 定角色和职责"></a>2.1. 定角色和职责</h2><p><strong>谁来做？</strong></p>
<ul>
<li>我<ul>
<li>我是什么角色？ —— （负责人、主导者、组织者、支持者、配合者、牵线者？）</li>
<li>我都需要做什么？ —— 为结果负责？攒局？支持？</li>
</ul>
</li>
<li>其他人<ul>
<li>找对人，为什么是他？ —— （能做主，能为结果负责）</li>
<li>他在这个事情中是什么角色 —— （负责人、主导者、组织者、支持者、配合者、牵线者？）</li>
<li>你需要他为你做什么？他为什么要为你做事？ —— （善用换位思考，整体利益和例行制度。eg. 业务发展需求、共同利益、项目曝光、合作促进、助力 KPI）</li>
</ul>
</li>
</ul>
<p>“定角色”示例：</p>
<ol>
<li>受众分析，按需取材<br>（纯专业观众适合 RD 讲解，一般行业观众或媒体适合 PM 讲）</li>
<li>PM、RD 一起产出一版讲解脚本及 Q&amp;A，如果有关键时间都需在场，非关键时间可轮班讲解，如果有公众参观日，可培训运营或展台工作人员后，代为讲解，PM&amp;RD 远程支持问题解答。</li>
</ol>
<h2 id="2-2-发任务安排"><a href="#2-2-发任务安排" class="headerlink" title="2.2. 发任务安排"></a>2.2. 发任务安排</h2><p>精准、有效的下发任务，是高效推动的</p>
<ul>
<li>沟通有技巧<ul>
<li>先跟<strong>关键角色</strong>做单独沟通</li>
<li>在会上对齐，最大公约数</li>
<li>沉默角色，要在会上主动询问确认。</li>
</ul>
</li>
<li>会上有结论<ul>
<li>能当场拍板的绝不拖延</li>
<li>不能当场拍板的给出决策时间</li>
<li>不在场的，当场打电话对齐</li>
<li>定不了的，给出决策时间及负责人</li>
</ul>
</li>
<li>结论落字面<ul>
<li>会后尽快邮件同步会议结论，写清楚各个事项负责人及预期结果</li>
<li>并提醒看邮件，有异议及时回复，如无异议，则就是确认</li>
</ul>
</li>
</ul>
<p><strong>开会防止</strong>：会而不议、议而不决、决而不行、行而无果</p>
<h2 id="2-3-出执行方案"><a href="#2-3-出执行方案" class="headerlink" title="2.3. 出执行方案"></a>2.3. 出执行方案</h2><p><b><font color="#7E3D76" style="">（1）谁做（谁对结果负责）</font></b></p>
<ul>
<li>我<ul>
<li>我是什么角色？ —— 项目负责人</li>
<li>我都需要做什么？ —— 为全局结果负责</li>
</ul>
</li>
<li>其他人<ul>
<li>找对人，为什么是他？ —— 市场、PR、RD、QA…</li>
<li>他在这个事情中是什么角色 —— 搭建&amp;发布会、传播、调试&amp;讲解、嘉宾邀请、展车提供</li>
<li>你需要他为你做什么？他为什么要为你做事？ —— 业务发展需求、共同利益、项目曝光、合作促进、助力 KPI…</li>
</ul>
</li>
</ul>
<p><b><font color="#7E3D76" style="">（2）怎么做</font></b></p>
<p><strong>分工清晰</strong>：工作边界清晰，宁可重叠，绝不疏漏</p>
<p><b><font color="#7E3D76" style="">（3）做成什么样（需求沟通对齐，标准清晰详细）</font></b></p>
<p>工作内容沟通、项目启动会及分工纪要、项目推进日报</p>
<ul>
<li>高效沟通<ul>
<li>高效沟通方式（<strong>当面</strong> &gt; 电话 &gt; 打字 &gt; 邮件）</li>
<li><strong>赫拉别恩法则：</strong> 在人际沟通中，他人获取你表达内容的途径，只有7%来自于你说的内容，38%来自于你说话的语调，55%来自外型与肢体语言</li>
</ul>
</li>
<li>结论落实到字面（巧用<strong>会议纪要</strong>）<ul>
<li>不要把你负责的事情，寄托于被人的记忆力</li>
<li>口说无凭</li>
</ul>
</li>
<li>最好能提供示例（讲再多也没有<strong>例子</strong>好使）<ul>
<li>信息在传递过程中会有很大一部分丢失</li>
<li>最高效的传递方式就是给示例，让对方替换内容</li>
</ul>
</li>
</ul>
<p><b><font color="#7E3D76" style="">（4）什么时间完成（保持高效、保证安全）</font></b></p>
<ul>
<li><strong>保持高效</strong>：并行优先<ul>
<li>理清每个环节之间的时间关系（各环节完成时间）</li>
<li>能并行的就觉不要串行</li>
</ul>
</li>
<li><strong>保证安全</strong>：（留出缓冲时间，做风险预判和应急预案）<ul>
<li>eg.以开幕时间倒推，留出3天安全时间，能提前完成绝不拖延</li>
</ul>
</li>
</ul>
<p><b><font color="#7E3D76" style="">（5）找出风险，做好最坏的打算</font></b></p>
<ul>
<li>有哪些可能出现的风险点？ —— 某个互动环节风险，有可能活动整体无法按计划时间上线</li>
<li>不能如期完成怎么办？ —— 延期多久可以开发完？活动是否有延期空间？</li>
<li>达不到预期标准怎么办？ —— 降低标准：是否可以接受去掉此互动环节或简化环节？替代方案：是否可以用其他互动方式替代？</li>
</ul>
<p><b><font color="#7E3D76" style="">（6）做好应急预案</font></b></p>
<ul>
<li>提前策划好备用方案 —— 确定启动应急预案条件及启动应急预案所需时间，找出关键时间节点，确保快速响应。备用设备提前就位，保障人员随时待命，发现问题立即介入。</li>
</ul>
<h2 id="2-4-方案推进"><a href="#2-4-方案推进" class="headerlink" title="2.4. 方案推进"></a>2.4. 方案推进</h2><p>项目推动神器 —— <b><font color="red" style="">项目推进日报</font></b></p>
<p>再复杂的项目，只要做好完备的执行方案，都可以有条不紊地完成落地。</p>
<h1 id="3-推进执行有技巧"><a href="#3-推进执行有技巧" class="headerlink" title="3. 推进执行有技巧"></a>3. 推进执行有技巧</h1><p>推进执行五个宝藏：</p>
<ul>
<li>以身作则，把握关键</li>
<li>严守标准，同舟共济</li>
<li>小步快跑，善于借力</li>
<li>全局思维，信息拉齐</li>
<li>风险预警，重点跟进</li>
</ul>
<h3 id="3-0-1-以身作则，把握关键"><a href="#3-0-1-以身作则，把握关键" class="headerlink" title="3.0.1. 以身作则，把握关键"></a>3.0.1. 以身作则，把握关键</h3><p>（善用会邀、日程、闹钟）</p>
<ul>
<li>说到做到，与上游、下游形成互信</li>
<li>做事抓重点<ul>
<li>把握关键事件环节</li>
<li>把握关键时间节点</li>
<li>把握关键负责人</li>
<li>预估下游环节操作时间，打出合适的时间余量，反算催促时间</li>
<li>严控输出时间和结果（注重细节、质量）</li>
</ul>
</li>
</ul>
<h3 id="3-0-2-严守标准，同舟共济"><a href="#3-0-2-严守标准，同舟共济" class="headerlink" title="3.0.2. 严守标准，同舟共济"></a>3.0.2. 严守标准，同舟共济</h3><p>（同理心：换位思考）</p>
<ul>
<li>严守标准，只接收达标结果。</li>
<li>注意情绪控制和话术，对事不对人。</li>
<li>帮助（或辅导），陪伴共同完成。<b><font color="red" style="">（可以帮助，但不要轻易代替）</font></b></li>
</ul>
<h3 id="3-0-3-小步快跑，善于借力"><a href="#3-0-3-小步快跑，善于借力" class="headerlink" title="3.0.3. 小步快跑，善于借力"></a>3.0.3. 小步快跑，善于借力</h3><ul>
<li>小步快跑<ul>
<li>不要等一切都就绪再开始，先把能做的做完</li>
<li>留充足的时间，专心应对“难啃的骨头”</li>
</ul>
</li>
<li>善于借力<ul>
<li>决定自己做之前，先看看有没有现成的</li>
<li>推不动时，找找有没有人有共同需求</li>
</ul>
</li>
</ul>
<h3 id="3-0-4-全局思维，信息拉齐"><a href="#3-0-4-全局思维，信息拉齐" class="headerlink" title="3.0.4. 全局思维，信息拉齐"></a>3.0.4. 全局思维，信息拉齐</h3><ul>
<li>及时同步<ul>
<li>及时将最新的<strong>进展</strong>、<strong>变化</strong>信息同步到所有人</li>
</ul>
</li>
<li>主动了解<ul>
<li>主动了解全局的<strong>进展及变化</strong>信息</li>
</ul>
</li>
</ul>
<h3 id="3-0-5-风险预警，重点跟进"><a href="#3-0-5-风险预警，重点跟进" class="headerlink" title="3.0.5. 风险预警，重点跟进"></a>3.0.5. 风险预警，重点跟进</h3><ul>
<li>主动寻找风险，及时预警</li>
<li>风险项重点跟进，避免进一步恶化</li>
</ul>
<h1 id="4-复盘"><a href="#4-复盘" class="headerlink" title="4. 复盘"></a>4. 复盘</h1><h2 id="4-1-为什么要复盘"><a href="#4-1-为什么要复盘" class="headerlink" title="4.1. 为什么要复盘"></a>4.1. 为什么要复盘</h2><ul>
<li>为了不再犯同样的错误</li>
<li>为了传承<b><font color="red" style="">经验</font></b>和提升<b><font color="red" style="">能力</font></b></li>
<li>为了总结<b><font color="red" style="">规律</font></b>以应对未来</li>
<li>为了<b><font color="red" style="">快速</font></b>迭代和化繁为简</li>
<li>为了把失败转化为财富，把成功转化为<b><font color="red" style="">能力</font></b></li>
</ul>
<h2 id="4-2-如何放大推动力的效果"><a href="#4-2-如何放大推动力的效果" class="headerlink" title="4.2. 如何放大推动力的效果"></a>4.2. 如何放大推动力的效果</h2><ul>
<li>通过经验积累、总结、复盘，建立一套强大的<b><font color="red" style="">标准化流程和机制</font></b>，通过<b><font color="red" style="">把握关键节点</font></b>，让事情<b><font color="red" style="">自己运转</font></b>起来。</li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：想清楚说明白</title>
    <url>/2021/08/03/workplace_note_1_think_perfectly_and_state_clearly/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-想清楚"><a href="#1-想清楚" class="headerlink" title="1. 想清楚"></a>1. 想清楚</h1><p><strong>核心策略：</strong></p>
<ul>
<li>对人：确定目标（eg.营收）</li>
<li>对事：有分类、有排序、有对应、有结论</li>
</ul>
<a id="more"></a>

<p><strong>梳理顺序：</strong></p>
<p>有结论、有对应（结构）、有分类、有排序（主次）</p>
<p>eg. 某件事故影响，对外…、对内…、复盘…，给出解决方案，前后因果关联等。</p>
<p><strong>分清事情轻重、主次（有排序）。</strong> 讲述多个点时，考虑主次。如：</p>
<ul>
<li>结构顺序</li>
<li>重要性顺序</li>
<li>时间顺序</li>
</ul>
<p><strong>备注：</strong></p>
<ol>
<li>做&#x2F;讲什么取决于对方想听什么</li>
<li>结论要与目标一致</li>
</ol>
<h1 id="2-说明白"><a href="#2-说明白" class="headerlink" title="2. 说明白"></a>2. 说明白</h1><p><strong>核心策略：</strong></p>
<ul>
<li>对人：引兴趣（<strong>SCQA原则</strong>）</li>
<li>对事：三步骤（<strong>总分总</strong>）</li>
</ul>
<h2 id="2-1-引起听众兴趣的四要素——SCQA"><a href="#2-1-引起听众兴趣的四要素——SCQA" class="headerlink" title="2.1. 引起听众兴趣的四要素——SCQA"></a>2.1. 引起听众兴趣的四要素——SCQA</h2><ul>
<li>S（现状）</li>
<li>C（冲突）</li>
<li>Q（疑问）</li>
<li>A（回答）</li>
</ul>
<p>eg. 经典广告案例</p>
<ul>
<li>（S：现状）得了灰指甲 </li>
<li>（C：冲突）一个传染俩</li>
<li>（Q：疑问）问我怎么办 </li>
<li>（A：回答）赶快用亮甲</li>
</ul>
<h2 id="2-2-讲述大纲"><a href="#2-2-讲述大纲" class="headerlink" title="2.2. 讲述大纲"></a>2.2. 讲述大纲</h2><ol>
<li>总——宣告结论，阐述支持分论点</li>
<li>分——分论点1…m，支撑的素材1…n</li>
<li>总——总结分论点，重申结论</li>
</ol>
<h1 id="3-经典案例Demo"><a href="#3-经典案例Demo" class="headerlink" title="3. 经典案例Demo"></a>3. 经典案例Demo</h1><h2 id="3-1-述职PPT大纲demo"><a href="#3-1-述职PPT大纲demo" class="headerlink" title="3.1. 述职PPT大纲demo"></a>3.1. 述职PPT大纲demo</h2><ul>
<li>个人简介</li>
<li>重点工作大纲（注意要有逻辑顺序，为什么是这个顺序展开</li>
<li>重点工作1、2、3<ul>
<li>工作背景介绍（让评审理解工作价值）</li>
<li>工作亮点展开大纲（让评审理解后续讲述逻辑）</li>
<li>工作两点1、2、3<ul>
<li>背景&#x2F;问题&#x2F;难点与挑战等</li>
<li>方案&#x2F;实现亮点&#x2F;个人贡献等</li>
<li>量化指标&#x2F;落地效果&#x2F;变化等</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>备注：</p>
<ol>
<li>整体述职内容逻辑线：<strong>先总后分，重点有亮点工作先讲</strong>；</li>
<li>语言精炼，实事求是，多用<strong>数字3原则</strong>（重点工作尽量浓缩3个以内；如果亮点太多，尽量提炼聚合）；</li>
<li>每项工作亮点必须具备<strong>背景-技术方案-效果</strong>三要素；</li>
</ol>
<h2 id="3-2-邮件组织大纲demo"><a href="#3-2-邮件组织大纲demo" class="headerlink" title="3.2. 邮件组织大纲demo"></a>3.2. 邮件组织大纲demo</h2><ol>
<li>有结论，结论先行。eg. 将需要传递的中心思想写在邮件标题</li>
<li>有对应，以上统下。eg. 正文与标题一致</li>
<li>有分类，归类分组。eg. 内容较多时进行分类</li>
<li>有排序，排序逻辑。eg. 内容较多时先说什么后说什么；抄送的list超过3人，考虑顺序</li>
</ol>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：精力管理的七个锦囊妙计</title>
    <url>/2021/08/10/workplace_note_2_seven_Tips_for_Energy_Management/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-真相"><a href="#1-真相" class="headerlink" title="1. 真相"></a>1. 真相</h1><h2 id="1-1-真相一——没时间-x3D-不重要"><a href="#1-1-真相一——没时间-x3D-不重要" class="headerlink" title="1.1. 真相一——没时间 &#x3D; 不重要"></a>1.1. 真相一——没时间 &#x3D; 不重要</h2><p>所有你没有着手去做的事情，只是因为对你还不够重要，或者你根本不知道什么对你才是重要的。</p>
<a id="more"></a>

<h2 id="1-2-真相二——时间是足够的"><a href="#1-2-真相二——时间是足够的" class="headerlink" title="1.2. 真相二——时间是足够的"></a>1.2. 真相二——时间是足够的</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">168 - 56 - 60 = 52</span><br></pre></td></tr></table></figure>
<p>解读：（一周时长）24h * 7 - （睡眠时间）8h * 7 - （工作）12h * 5 &#x3D; （每周可自由安排时间）52小时</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10000 / 52 / 52 = 3.7</span><br></pre></td></tr></table></figure>
<p>解读：（一万小时定律）10000 &#x2F; （一年周数）52 &#x2F; （每周可自由安排时间）52 &#x3D; （成为某领域专家所需年限）3.7<br>如果你知道自己想要什么，又愿意投入时间，你有机会在4~7年里成为这个领域的专家</p>
<h2 id="1-3-真相三——时间-精力-x3D-效能"><a href="#1-3-真相三——时间-精力-x3D-效能" class="headerlink" title="1.3. 真相三——时间 * 精力 &#x3D; 效能"></a>1.3. 真相三——时间 * 精力 &#x3D; 效能</h2><p>自己的工作效能与你投入的时长和工作期间的精力系数正相关</p>
<h1 id="2-锦囊一——明确要做的事"><a href="#2-锦囊一——明确要做的事" class="headerlink" title="2. 锦囊一——明确要做的事"></a>2. 锦囊一——明确要做的事</h1><h2 id="2-1-方法——每天把要做的事情列下来"><a href="#2-1-方法——每天把要做的事情列下来" class="headerlink" title="2.1. 方法——每天把要做的事情列下来"></a>2.1. 方法——每天把要做的事情列下来</h2><p><strong>重要性四象限（是否重要、是否紧急），及其应对策略</strong></p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <td><b>Q1象限：重要且紧急</b><br>及时处理应对</td>
        <td><b>Q2象限：重要不紧急</b><br>大石头优先保障</td>
    </tr>
    <tr>
        <td><b>Q3象限：不重要但紧急</b><br>尽量减少干扰</td>
        <td><b>Q4象限：不重要不紧急</b><br>尽量减少</td>
    </tr>
</table>

<p><strong>依据重要性四象限划分要做的事，每天把要做的事情列下来。</strong></p>
<p>好处：</p>
<ul>
<li>就在手边，随时提醒自己</li>
<li>仪式感强</li>
<li>成就感强</li>
<li>对外抗干扰</li>
</ul>
<h1 id="3-锦囊二——运用大石头周计划表管理时间"><a href="#3-锦囊二——运用大石头周计划表管理时间" class="headerlink" title="3. 锦囊二——运用大石头周计划表管理时间"></a>3. 锦囊二——运用大石头周计划表管理时间</h1><h2 id="3-1-方法——运用大石头周计划表管理时间"><a href="#3-1-方法——运用大石头周计划表管理时间" class="headerlink" title="3.1. 方法——运用大石头周计划表管理时间"></a>3.1. 方法——运用大石头周计划表管理时间</h2><p>待做事项拆分建议：</p>
<ol>
<li>工作（4象限）</li>
<li>生活（4象限）</li>
<li>投资未来的自己（成为理想中自己所需做的事）</li>
</ol>
<p>计划表实施步骤：</p>
<ol>
<li>结合四象限对自己的计划做出排序</li>
<li>给自己下周的计划为大石头先留出时间</li>
<li>然后填充其他事情（eg. 恢复能量、调整情绪）</li>
</ol>
<h1 id="4-锦囊三——懂得-Say-No"><a href="#4-锦囊三——懂得-Say-No" class="headerlink" title="4. 锦囊三——懂得 Say No"></a>4. 锦囊三——懂得 Say No</h1><p>有时候计划很完美，但总被打扰，影响计划实施。如何解决？</p>
<h2 id="4-1-方法——减少干扰"><a href="#4-1-方法——减少干扰" class="headerlink" title="4.1. 方法——减少干扰"></a>4.1. 方法——减少干扰</h2><ul>
<li>设置免打扰时段，对不必要的干扰 <b><font color="red" style="">Say No</font></b></li>
<li>空间上远离易干扰物品，避免被诱惑</li>
<li>明确自己的角色、职责范围</li>
</ul>
<h1 id="5-锦囊四——吃好睡好运动好"><a href="#5-锦囊四——吃好睡好运动好" class="headerlink" title="5. 锦囊四——吃好睡好运动好"></a>5. 锦囊四——吃好睡好运动好</h1><p><strong>保持精力的三个纬度（精力管理）：</strong></p>
<ul>
<li>体能</li>
<li>思维</li>
<li>情感</li>
</ul>
<h2 id="5-1-方法——规律睡眠-健康饮食-运动锻炼"><a href="#5-1-方法——规律睡眠-健康饮食-运动锻炼" class="headerlink" title="5.1. 方法——规律睡眠 + 健康饮食 + 运动锻炼"></a>5.1. 方法——规律睡眠 + 健康饮食 + 运动锻炼</h2><ul>
<li><strong>规律睡眠</strong>：尊重生物钟、适当午休</li>
<li><strong>健康饮食</strong>：少吃多餐、及时补充能量</li>
<li><strong>运动锻炼</strong>：适当的有氧运动</li>
</ul>
<h1 id="6-锦囊五——与情绪做朋友（接纳情绪）"><a href="#6-锦囊五——与情绪做朋友（接纳情绪）" class="headerlink" title="6. 锦囊五——与情绪做朋友（接纳情绪）"></a>6. 锦囊五——与情绪做朋友（接纳情绪）</h1><h2 id="6-1-前提——正确认识情绪、接纳情绪"><a href="#6-1-前提——正确认识情绪、接纳情绪" class="headerlink" title="6.1. 前提——正确认识情绪、接纳情绪"></a>6.1. 前提——正确认识情绪、接纳情绪</h2><p>正确认识情绪：</p>
<ul>
<li>情绪是真实的</li>
<li>情绪是有周期的</li>
<li>每一种情绪都是合理的</li>
</ul>
<p>理解情绪的产生机制：</p>
<p>威胁性刺激 –&gt; 丘脑 –&gt; 杏仁核 –&gt; 脑干 –&gt; 身体应激反应（eg.恐惧反应：心跳加快、内脏收缩、身体出汗）</p>
<p>Tips：<strong>情绪是被强化了的经验</strong>：困扰我们的并非事情本身，而是我们对它的解读</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center"><b>大脑分层</b></th>
        <th align="center"><b>起源</b></th>
        <th align="center"><b>特点</b></th>
    </tr>
    <tr>
        <td align="center">理智脑</td>
        <td>始于250万年前，衍生文明</td>
        <td>~~绝对~~(相对)理性</td>
    </tr>
    <tr>
        <td align="center">情绪脑</td>
        <td>始于2亿年前的哺乳动物</td>
        <td>被强化了的经验支配，容易受情感驱动<br>（易怒、易被爱感化）</td>
    </tr>
    <tr>
        <td align="center">爬行脑</td>
        <td>始于3.6亿年前的爬行动物</td>
        <td>受原始生理行为准则驱动，不可控（eg. 呼吸、心跳）</td>
    </tr>
</table>

<h2 id="6-2-方法1——学会处理负面情绪"><a href="#6-2-方法1——学会处理负面情绪" class="headerlink" title="6.2. 方法1——学会处理负面情绪"></a>6.2. 方法1——学会处理负面情绪</h2><ul>
<li>尝试腹式呼吸（感受和调节情绪），暂缓发作，等待大脑皮层协调工作</li>
<li>尝试培养一个口号（eg. “不生气、不生气、1234567”）</li>
<li>尝试训练思维模式（【看到 –&gt; 反应】 &#x3D;&#x3D;&#x3D;转换为&#x3D;&#x3D;&#x3D;》 【看到 –&gt; 喊出口号 –&gt; 思考后果 –&gt; 反思初心 –&gt; 做出反应】）</li>
</ul>
<h2 id="6-3-方法2——探索管理自己情绪的方法"><a href="#6-3-方法2——探索管理自己情绪的方法" class="headerlink" title="6.3. 方法2——探索管理自己情绪的方法"></a>6.3. 方法2——探索管理自己情绪的方法</h2><p>观察自己的能量走向，练习并写出清单。记录哪些是自己积攒能量的事情，哪些是消耗能量的事情？</p>
<p>eg.<br><strong>积攒能量</strong>：睡觉、听音乐、健身<br><strong>消耗能量</strong>：工作、学习、胡思乱想</p>
<h1 id="7-锦囊六——管理自己的思维"><a href="#7-锦囊六——管理自己的思维" class="headerlink" title="7. 锦囊六——管理自己的思维"></a>7. 锦囊六——管理自己的思维</h1><h2 id="7-1-方法1——寻找自己的注意力专区"><a href="#7-1-方法1——寻找自己的注意力专区" class="headerlink" title="7.1. 方法1——寻找自己的注意力专区"></a>7.1. 方法1——寻找自己的注意力专区</h2><p>可能的影响因素：刺激程度、时段、空间氛围</p>
<p>寻找自己的注意力专区：</p>
<ul>
<li>什么时候你的注意力最集中？</li>
<li>注意力涣散时，你会怎样帮助自己恢复到注意力集中的状态？</li>
</ul>
<h2 id="7-2-方法2——减少精力内耗"><a href="#7-2-方法2——减少精力内耗" class="headerlink" title="7.2. 方法2——减少精力内耗"></a>7.2. 方法2——减少精力内耗</h2><p>几种常见的非理性思维（会内耗自己）：</p>
<ul>
<li><del><strong>完美主义</strong>：我必须做好每件事，绝对不能犯错</del></li>
<li><del><strong>灾难性想象</strong>：刚才他提醒我有个小失误，恐怕之后再也不会信任我了</del></li>
<li><del><strong>对他人认可和喜爱的过分追求</strong>：每个人都必须喜欢我，并且认可我</del></li>
<li><del><strong>对挫折的不确定性的低容忍度</strong>：晋升失败了，就代表我整个人都很失败，无法忍受</del></li>
<li><del><strong>对他人和世界的绝对化要求</strong>：我提出的需求别人必须马上满足、马上响应</del></li>
<li>……</li>
</ul>
<h1 id="8-锦囊七——遵循价值观活着"><a href="#8-锦囊七——遵循价值观活着" class="headerlink" title="8. 锦囊七——遵循价值观活着"></a>8. 锦囊七——遵循价值观活着</h1><h2 id="8-1-方法1——将每天的工作-x2F-生活方式调整为你想要样子"><a href="#8-1-方法1——将每天的工作-x2F-生活方式调整为你想要样子" class="headerlink" title="8.1. 方法1——将每天的工作&#x2F;生活方式调整为你想要样子"></a>8.1. 方法1——将每天的工作&#x2F;生活方式调整为你想要样子</h2><p>Tips：<b><font color="red" style="">你怎么过今天一天，你的一生大致也会这样度过</font></b></p>
<ul>
<li>立刻&#x2F;现在&#x2F;马上就采取<strong>你想要具备的品质</strong>的方式 工作和生活</li>
<li>时间是一种选择（选择投入时间做某事）、时间是生命的投入（做任何事都相当于倾注了自己的时间&#x2F;精力&#x2F;生命的投射）、时间是自己的朋友（正视正在做的事（相对愉快地去面对））</li>
</ul>
<h2 id="8-2-方法2——正视工作与生活的关系"><a href="#8-2-方法2——正视工作与生活的关系" class="headerlink" title="8.2. 方法2——正视工作与生活的关系"></a>8.2. 方法2——正视工作与生活的关系</h2><p>工作与生活紧密联系，从观念上正视工作的意义。工作&#x2F;产品的成功 &amp; 个人成功</p>
<ul>
<li>你做的工作&#x2F;产品会影响到很多人的生活，你的工作成果就变成了一道光，照亮他人的同时也活出了自己（成就自己）</li>
</ul>
<h2 id="8-3-方法3——不断探索你的价值观"><a href="#8-3-方法3——不断探索你的价值观" class="headerlink" title="8.3. 方法3——不断探索你的价值观"></a>8.3. 方法3——不断探索你的价值观</h2><ul>
<li>如果现在来到了人生尽头，你希望自己被他人记住的是什么？你的墓志铭上留下什么？</li>
<li>你最敬重或喜欢的人是谁？你最钦佩和喜欢他身上的三种特质是什么？</li>
<li>你能做到的最好的自己会具备哪些品质？</li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：高效会议三部曲</title>
    <url>/2021/08/17/workplace_note_3_efficient_meeting_trilogy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-高效会议三部曲——for-组织者"><a href="#1-高效会议三部曲——for-组织者" class="headerlink" title="1. 高效会议三部曲——for 组织者"></a>1. 高效会议三部曲——for 组织者</h1><h2 id="1-1-会前筹备"><a href="#1-1-会前筹备" class="headerlink" title="1.1. 会前筹备"></a>1.1. 会前筹备</h2><h3 id="1-1-1-明确会议目标及议题"><a href="#1-1-1-明确会议目标及议题" class="headerlink" title="1.1.1. 明确会议目标及议题"></a>1.1.1. 明确会议目标及议题</h3><ul>
<li>期望通过会议获得什么样的结论，用于改变当前的什么问题</li>
<li>能够传达会议目标的议题设定</li>
</ul>
<a id="more"></a>

<h3 id="1-1-2-明确参会人"><a href="#1-1-2-明确参会人" class="headerlink" title="1.1.2. 明确参会人"></a>1.1.2. 明确参会人</h3><ul>
<li>期望的会议结论，是需要那些人决策并达成共识的</li>
<li>哪些人必须，哪些人可选（可以请关键负责人指定参会人）</li>
</ul>
<h3 id="1-1-3-明确会议时间"><a href="#1-1-3-明确会议时间" class="headerlink" title="1.1.3. 明确会议时间"></a>1.1.3. 明确会议时间</h3><ul>
<li>优先考虑高阶与会者的时间来安排会议，因为TA们的会议更多、时间更难协调</li>
<li>确定会议整体时长，可以请关键负责人明确对应环节所需时长，总原则宜短不宜长</li>
</ul>
<h3 id="1-1-4-明确会议地点"><a href="#1-1-4-明确会议地点" class="headerlink" title="1.1.4. 明确会议地点"></a>1.1.4. 明确会议地点</h3><ul>
<li>抢会议室是门技术活儿，宜早不宜迟</li>
<li>会议室地址写得详细些，方便人找</li>
</ul>
<h3 id="1-1-5-明确会议议程"><a href="#1-1-5-明确会议议程" class="headerlink" title="1.1.5. 明确会议议程"></a>1.1.5. 明确会议议程</h3><ul>
<li>主议题拆解的分议题</li>
<li>每个分议题的负责人</li>
<li>每个分议题的时长</li>
<li>预留讨论&#x2F;提问时间</li>
</ul>
<h3 id="1-1-6-提前发会议材料"><a href="#1-1-6-提前发会议材料" class="headerlink" title="1.1.6. 提前发会议材料"></a>1.1.6. 提前发会议材料</h3><ul>
<li>内容是关键</li>
<li>形式不限</li>
<li>注意分享范围</li>
</ul>
<h3 id="1-1-7-会前对齐"><a href="#1-1-7-会前对齐" class="headerlink" title="1.1.7. 会前对齐"></a>1.1.7. 会前对齐</h3><ul>
<li>跨团队沟通会必选项</li>
<li>对齐的可以是问题</li>
</ul>
<h3 id="1-1-8-发出会邀"><a href="#1-1-8-发出会邀" class="headerlink" title="1.1.8. 发出会邀"></a>1.1.8. 发出会邀</h3><p>关于会邀：</p>
<ol>
<li>会议主题、参会人、时间、地点（非必须，后续可更新）<br>确认后即可发起会邀book大家时间</li>
<li>如有会议&#x2F;项目如流群，发出会邀后，在群里再周知大家关注</li>
<li>关键参会人，单独再通知确认，通知时可以附上会邀截图</li>
<li>若会邀发出后还需再添加新参会人，更新会邀时，选择只发送给更新人选（避免干扰其他人）</li>
</ol>
<h2 id="1-2-会中管理"><a href="#1-2-会中管理" class="headerlink" title="1.2. 会中管理"></a>1.2. 会中管理</h2><p>常见低质量会议特征：</p>
<ul>
<li>跑题</li>
<li>超时</li>
<li>无结论</li>
</ul>
<p><b><font color="#7E3D76" style="">需要一个会议主持人</font>来：</b></p>
<ul>
<li>控主题</li>
<li>把时间</li>
<li>促结论</li>
</ul>
<h3 id="1-2-1-控主题"><a href="#1-2-1-控主题" class="headerlink" title="1.2.1. 控主题"></a>1.2.1. 控主题</h3><ul>
<li><b><font color="#7E3D76" style="">申明会议主题</font></b>。开场时跟与会人明确本次会议的主题<br>eg.咱们本次会议的主题是…</li>
<li><b><font color="#7E3D76" style="">拉回会议主题（若需要）</font></b>。有人跑题时，礼貌但严格地拉回到会议主题。<br>eg.我理解你现在说的问题与咱们本次会议主题无关，如果需要，可以另外组织讨论，先回到今天的主题…</li>
<li><b><font color="#7E3D76" style="">过程总结引导</font></b>：<ul>
<li>分议题结束后小结，引导进入下个分议题；<br>eg. 针对XX问题，刚刚的结论是YY，大家理解一致的话，咱们进人下个议题…</li>
<li>理解不一致时，澄清与引导；<br>eg. 针对XX问题，大家理解是一致的么…</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-把时间"><a href="#1-2-2-把时间" class="headerlink" title="1.2.2. 把时间"></a>1.2.2. 把时间</h3><ul>
<li>申明会议时间安排</li>
<li>控制各环节时间，礼貌提醒</li>
<li>时间提醒工具推荐（zClock Lite）</li>
</ul>
<h3 id="1-2-3-促结论"><a href="#1-2-3-促结论" class="headerlink" title="1.2.3. 促结论"></a>1.2.3. 促结论</h3><ul>
<li>记录发言人表达要点，及时总结询问</li>
<li>保持中立态度，强调共同利益</li>
<li>回忆结论决策工具</li>
</ul>
<p><b><font color="red" style="">会议结论类别：</font></b></p>
<ul>
<li><b><font color="#7E3D76" style="">权威决策</font></b>。决策人具有决策权和否决权，可单方面作出决定。</li>
<li><b><font color="#7E3D76" style="">共识决策</font></b>。会议主持人引导参会各方对讨论的议题达成共识，原则是最大化共同收益。</li>
<li><b><font color="#7E3D76" style="">另行再议</font></b>。经过深入思考筹备的会议，依然有可能没想到关键问题，导致会议无法达成结论。没关系，再另行组会讨论便是。</li>
</ul>
<h2 id="1-3-会后跟进"><a href="#1-3-会后跟进" class="headerlink" title="1.3. 会后跟进"></a>1.3. 会后跟进</h2><p>要点：</p>
<ul>
<li>准确、言简意赅的会议纪要</li>
<li>明确TODO及跟进&#x2F;反馈时间，责任到人</li>
<li>下次例会前跟进TODO完成情况</li>
</ul>
<p><b><font color="#7E3D76" style="">会议记录人需具备能力：</font></b></p>
<ul>
<li>有足够的业务基础</li>
<li>优秀的理解能力</li>
<li>敏捷的思维能力</li>
<li>良好的总结能力</li>
<li>优秀的沟通能力</li>
</ul>
<p><b><font color="#7E3D76" style="">会议记录人怎么找：</font></b></p>
<ul>
<li>找关键负责人指定</li>
<li>会议主持人兼职</li>
</ul>
<h3 id="1-3-1-会议纪要"><a href="#1-3-1-会议纪要" class="headerlink" title="1.3.1. 会议纪要"></a>1.3.1. 会议纪要</h3><p>会议纪要结构：</p>
<table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <td align="center">会议主题</td>
        <td align="center"></td>
    </tr>
    <tr>
        <td align="center">会议时间、地点</td>
        <td align="center"></td>
    </tr>
    <tr>
        <td align="center">参会人</td>
        <td align="center"></td>
    </tr>
    <tr>
        <td align="center">讨论议题</td>
        <td align="center"></td>
    </tr>
    <tr>
        <td align="center">关键结论</td>
        <td align="center"></td>
    </tr>
    <tr>
        <td align="center">TODO</td>
        <td align="center"></td>
    </tr>
</table>

<h3 id="1-3-2-责任到人"><a href="#1-3-2-责任到人" class="headerlink" title="1.3.2. 责任到人"></a>1.3.2. 责任到人</h3><h3 id="1-3-3-追踪待办"><a href="#1-3-3-追踪待办" class="headerlink" title="1.3.3. 追踪待办"></a>1.3.3. 追踪待办</h3><h1 id="2-高效会议三部曲——for-参与者"><a href="#2-高效会议三部曲——for-参与者" class="headerlink" title="2. 高效会议三部曲——for 参与者"></a>2. 高效会议三部曲——for 参与者</h1><h2 id="2-1-会前筹备"><a href="#2-1-会前筹备" class="headerlink" title="2.1. 会前筹备"></a>2.1. 会前筹备</h2><ul>
<li>询问会议目标及议题</li>
<li>询问参会人</li>
<li>询问会议时间</li>
<li>询问会议地点</li>
<li>询问会议议程</li>
<li>询问&#x2F;准备会议材料</li>
<li>会议前对齐</li>
</ul>
<h2 id="2-2-会中管理"><a href="#2-2-会中管理" class="headerlink" title="2.2. 会中管理"></a>2.2. 会中管理</h2><ul>
<li>认真聆听</li>
<li>积极参与</li>
<li>建设提议</li>
</ul>
<h2 id="2-3-会后跟进"><a href="#2-3-会后跟进" class="headerlink" title="2.3. 会后跟进"></a>2.3. 会后跟进</h2><ul>
<li>自己的TODO</li>
</ul>
<h1 id="3-成功会议的要素"><a href="#3-成功会议的要素" class="headerlink" title="3. 成功会议的要素"></a>3. 成功会议的要素</h1><ul>
<li>明确<b><font color="#7E3D76" style="">结论及TODO</font></b></li>
<li>明确<b><font color="#7E3D76" style="">时间节奏</font></b></li>
<li>明确<b><font color="#7E3D76" style="">事项跟进人</font></b></li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：成功的向上汇报指南</title>
    <url>/2021/08/24/workplace_note_4_a_successful_report_up_guide/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-现存问题（普遍）"><a href="#1-现存问题（普遍）" class="headerlink" title="1. 现存问题（普遍）"></a>1. 现存问题（普遍）</h1><ul>
<li>员工视角<ul>
<li>缺乏汇报经验，不清楚沟通时机与边界</li>
<li>紧张没有思路，不清楚上级的意图</li>
<li>数据和PPT应该怎么更好的呈现</li>
<li>讨论了半天，还是不能跟老板达成共识，咋办？</li>
</ul>
</li>
<li>经理视角<ul>
<li>除了抱怨，有自己思考过怎么办吗？</li>
<li>不问不同步进度&amp;问题</li>
<li>。。。！？重点是啥？</li>
<li>令人头大</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="2-为什么要汇报"><a href="#2-为什么要汇报" class="headerlink" title="2. 为什么要汇报"></a>2. 为什么要汇报</h1><h2 id="2-1-什么是向上沟通汇报"><a href="#2-1-什么是向上沟通汇报" class="headerlink" title="2.1. 什么是向上沟通汇报"></a>2.1. 什么是向上沟通汇报</h2><p>一种<strong>有意识</strong>的与上级进行<strong>信息同步</strong>的方式，以达到<strong>双方认知一致</strong>的目的，同时建立起对双方都有益的<strong>信任关系</strong>。</p>
<h2 id="2-2-汇报沟通的理想结果"><a href="#2-2-汇报沟通的理想结果" class="headerlink" title="2.2. 汇报沟通的理想结果"></a>2.2. 汇报沟通的理想结果</h2><p>Result &#x3D; Task + Trust</p>
<ul>
<li>解决问题，完成任务</li>
<li>获得认可，增强信任</li>
</ul>
<h1 id="3-汇报沟通四要素"><a href="#3-汇报沟通四要素" class="headerlink" title="3. 汇报沟通四要素"></a>3. 汇报沟通四要素</h1><p>怎样才是优秀汇报？</p>
<ul>
<li>Who，换位思考</li>
<li>What，信息完备</li>
<li>When，时机合适</li>
<li>How，形式恰当</li>
</ul>
<h2 id="3-1-换位思考"><a href="#3-1-换位思考" class="headerlink" title="3.1. 换位思考"></a>3.1. 换位思考</h2><p>站在leader的角度——思考与行动</p>
<ul>
<li><strong>升纬思考</strong><ul>
<li>高一个纬度</li>
<li>宽一个纬度</li>
</ul>
</li>
<li><strong>降纬行动</strong><ul>
<li>回归自己的工作</li>
<li>与leader双赢</li>
</ul>
</li>
</ul>
<h2 id="3-2-信息完备"><a href="#3-2-信息完备" class="headerlink" title="3.2. 信息完备"></a>3.2. 信息完备</h2><p>汇报内容包含：</p>
<ul>
<li><strong>背景</strong>：简单清晰，逻辑合理</li>
<li><strong>问题、影响</strong>：客观全面，重点突出</li>
<li><strong>方案及优缺点</strong>：若有可选方案，描述每个方案的优缺点，并给出建议方案和理由</li>
<li><strong>建议、总结</strong>：请示leader，或者对项目收益进行总结</li>
</ul>
<h2 id="3-3-时机合适"><a href="#3-3-时机合适" class="headerlink" title="3.3. 时机合适"></a>3.3. 时机合适</h2><p>汇报时机，兜底策略：“宁愿过度，也不要缺乏”</p>
<p>项目关键节点：</p>
<ul>
<li><strong>接受任务</strong><ul>
<li>请示任务：<ul>
<li>背景（目标、人、时间…）</li>
<li>风险</li>
<li>优先级</li>
</ul>
</li>
</ul>
</li>
<li><strong>工作反馈</strong><ul>
<li>阶段性汇报</li>
<li>请求指示，寻求帮助 eg.<ul>
<li>是否可以建议将项目分为两期先完成核心功能</li>
<li>或者申请增加人力来完成倒排项目</li>
</ul>
</li>
</ul>
</li>
<li><strong>交付结果</strong><ul>
<li>工作汇报&#x2F;总结<ul>
<li>所做工作，提升功能，解决问题</li>
<li>性能提升，问题闭环率提升</li>
<li>收益&#x2F;效果</li>
<li>下一期项目计划</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-形式恰当"><a href="#3-4-形式恰当" class="headerlink" title="3.4. 形式恰当"></a>3.4. 形式恰当</h2><h3 id="3-4-1-各种沟通形式优劣势分析"><a href="#3-4-1-各种沟通形式优劣势分析" class="headerlink" title="3.4.1. 各种沟通形式优劣势分析"></a>3.4.1. 各种沟通形式优劣势分析</h3><table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">优势</th>
<th align="center">劣势</th>
</tr>
</thead>
<tbody><tr>
<td align="center">面谈&#x2F;视频会议</td>
<td align="center">沟通复杂的事情<br>效率高，利于情绪沟通交流</td>
<td align="center">成本高<br>不便记录<br>给对方的思考时间较短</td>
</tr>
<tr>
<td align="center">电话</td>
<td align="center">快捷、随时、随地</td>
<td align="center">不便记录、情感交流弱</td>
</tr>
<tr>
<td align="center">邮件</td>
<td align="center">易记录，可追溯<br>信息完备，可填附件<br>方便管理哪些人接收汇报信息</td>
<td align="center">易被忽略<br>反馈不及时<br>无情感交流</td>
</tr>
<tr>
<td align="center">如流</td>
<td align="center">快捷、随时、随地</td>
<td align="center">沟通复杂事情效率低、情感交流弱</td>
</tr>
<tr>
<td align="center">周报平台</td>
<td align="center">低成本、频率固定<br>易记录，可追溯<br>信息完备，可加附件</td>
<td align="center">无情感交流</td>
</tr>
</tbody></table>
<h3 id="3-4-2-常见场景汇报方式选择"><a href="#3-4-2-常见场景汇报方式选择" class="headerlink" title="3.4.2. 常见场景汇报方式选择"></a>3.4.2. 常见场景汇报方式选择</h3><table>
<thead>
<tr>
<th align="center">汇报形式</th>
<th align="center">场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">面谈、电话、如流</td>
<td align="center">紧急问题：模块出严重线长bug，影响面较大（尽快止损）</td>
</tr>
<tr>
<td align="center">邮件</td>
<td align="center">目标方案对齐：分配了项目，完成项目启动会后（备案）<br>汇报成果：项目如期开发完成</td>
</tr>
<tr>
<td align="center">周报</td>
<td align="center">定期汇报：项目进度汇报</td>
</tr>
</tbody></table>
<h1 id="4-玩转各种汇报方式"><a href="#4-玩转各种汇报方式" class="headerlink" title="4. 玩转各种汇报方式"></a>4. 玩转各种汇报方式</h1><h2 id="4-1-口头、如流、面谈"><a href="#4-1-口头、如流、面谈" class="headerlink" title="4.1. 口头、如流、面谈"></a>4.1. 口头、如流、面谈</h2><ul>
<li><strong>结构化表达</strong>：<ul>
<li>提前梳理好沟通思路、内容；</li>
<li>控制好沟通时间、效率</li>
</ul>
</li>
<li><strong>突出中心思想</strong>：<ul>
<li>重结果，轻细节</li>
</ul>
</li>
</ul>
<h2 id="4-2-周报"><a href="#4-2-周报" class="headerlink" title="4.2. 周报"></a>4.2. 周报</h2><ul>
<li><strong>周报的意义</strong>：<ul>
<li>定期沟通的重要机会</li>
<li>争取资源和寻求帮助</li>
<li>展示工作价值</li>
</ul>
</li>
<li>**先理清本周工作价值&#x2F;问题&#x2F;(请求)**：<ul>
<li>本周工作的价值？</li>
<li>工作中存在什么问题&#x2F;困难，拟订改进方案？</li>
<li>需要上司帮助协调什么资源？</li>
</ul>
</li>
<li><strong>周报结构</strong>（按照理清的问题分点陈述即可）：<ul>
<li><strong>本周工作计划</strong>。（参考上周周报）</li>
<li><strong>本周工作进展</strong>。（重点指标的完成情况、本周取得的阶段性成果）</li>
<li><strong>下周工作计划</strong>。（计划下周工作内容，项目 + 预期进展 + 时间节点）</li>
<li><strong>遇到的问题和需要请求的支持</strong>。（遇事不要一个人抗，写下来请求协助）</li>
<li><strong>学习与反思</strong>。（写下自己的思考与成长，开启自我升级之路）</li>
</ul>
</li>
</ul>
<h2 id="4-3-邮件"><a href="#4-3-邮件" class="headerlink" title="4.3. 邮件"></a>4.3. 邮件</h2><ul>
<li><strong>标题</strong><ul>
<li>表述清晰，可统领邮件主旨</li>
<li>多次回复的场景标题最多两个”re”，超过重新命名</li>
</ul>
</li>
<li><strong>收件人&#x2F;抄送人</strong><ul>
<li><strong>收件人</strong>：为与邮件内容直接相关的人</li>
<li><strong>抄送人</strong>：为间接相关人，仅需知悉&#x2F;关注邮件内容</li>
</ul>
</li>
<li><strong>正文</strong><ul>
<li><strong>结构清晰</strong>：先总后分，<strong>结论</strong>及<strong>关键信息</strong>前置。</li>
<li><strong>条例分明</strong>：分点说明、言简意赅、大篇幅内容采用附件展示。</li>
<li><strong>内容无误</strong>：注意错别字、标点、格式、有签名。</li>
</ul>
</li>
</ul>
<h1 id="5-最后几句话"><a href="#5-最后几句话" class="headerlink" title="5. 最后几句话"></a>5. 最后几句话</h1><ul>
<li>汇报是建立信任、提升能力的好机会，不要轻视或错过！</li>
<li>汇报不难，用对方法，事半功倍！</li>
<li>实践练习，你一定可以成为汇报沟通的高手！</li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：基础横向沟通</title>
    <url>/2021/08/31/workplace_note_5_basic_horizontal_communication/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-沟通的目标及意义"><a href="#1-沟通的目标及意义" class="headerlink" title="1. 沟通的目标及意义"></a>1. 沟通的目标及意义</h1><p><b><font color="#7E3D76" style="">低效沟通的不良后果：</font></b></p>
<ul>
<li>对业务<ul>
<li>让原本的业务无法顺利推进，导致目标无法达成</li>
<li>后续需求或沟通过程会更大概率不被配合，导致个人业务推进更加困难</li>
</ul>
</li>
<li>对团队<ul>
<li>对团队间合作关系造成伤害</li>
<li>由一个人的表现导致对整个团队的能力产生了负面印象</li>
<li>可能会导致其他同学甚至 leader 为一个人的行为“擦屁股”</li>
</ul>
</li>
<li>对个人<ul>
<li>对方对你的看法：被打上“不靠谱”、“没礼貌”等负面标签，印象变差</li>
<li>老板对你的看法：被认为沟通能力差，简介影响业绩评定结果</li>
<li>吃瓜群众对你的看法：留下“难沟通”、“不好相处”的印象</li>
</ul>
</li>
</ul>
<a id="more"></a>

<p><b><font color="#7E3D76" style="">沟通的目的及意义：</font></b></p>
<ul>
<li>业务的推进无法靠单打独斗，沟通无法避免</li>
<li>沟通的目的不是分出谁对谁错</li>
<li>沟通的终极目的：为了解决问题</li>
<li>判断沟通是否闭环的标准：是否解决了问题？</li>
</ul>
<h1 id="2-沟通四部曲"><a href="#2-沟通四部曲" class="headerlink" title="2. 沟通四部曲"></a>2. 沟通四部曲</h1><h2 id="2-1-想清楚"><a href="#2-1-想清楚" class="headerlink" title="2.1. 想清楚"></a>2.1. 想清楚</h2><p>策略：</p>
<ul>
<li>（沟通的发起方的）我需要做什么（<b><font color="red" style="">沟通背景三要素</font></b>）：<ul>
<li>沟通<strong>目的</strong>（表面目的、实质目的）：多问自己几个为什么</li>
<li>希望达到什么<strong>效果</strong>：首要目的和底线目的</li>
<li>希望完成的<strong>时间点</strong></li>
</ul>
</li>
<li>（沟通的接收方的）他为什么要帮我<ul>
<li>我能给他提供什么<strong>帮助</strong>？</li>
<li>我和他的<strong>目标</strong>一致吗？（找到双方目标的共同点）</li>
<li>他有什么<strong>顾虑</strong>？（对方可能遇到哪些困难？我能帮他解决么）</li>
</ul>
</li>
<li>沟通渠道的选择<br>各种沟通形式优劣势分析：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">沟通类型</th>
<th align="center">要求对方响应时效</th>
<th align="left">优势</th>
<th align="left">劣势</th>
<th align="left">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">面谈&#x2F;视频会议</td>
<td align="center">高</td>
<td align="left">1.沟通更简单直接，更有利于传递信息、达成共识<br>2.对方能即时响应沟通中的问题</td>
<td align="left">1.时间不够灵活，要提前确定沟通对象的参会时间<br>2.整个沟通过程不一定和每个相关方相关</td>
<td align="left">1.沟通较为复杂的内容，尤其在涉及相关方较多的情况下</td>
</tr>
<tr>
<td align="center">电话</td>
<td align="center">高</td>
<td align="left">1.沟通响应时效较高，双方能及时互相反馈</td>
<td align="left">1.对于较为复杂的沟通内容信息传递效果差</td>
<td align="left">1.较为简单进击的沟通内容需要马上和对方确认</td>
</tr>
<tr>
<td align="center">如流</td>
<td align="center">中</td>
<td align="left">1.时间&#x2F;形式较为灵活，能随时针对单人&#x2F;多人沟通<br>2.信息表达较为准确<br>3.无需所有相关方参与沟通，可事后回溯沟通记录</td>
<td align="left">1.信息容易发生歧义或误解，讨论主题容易发生偏差（尤其是多人群沟通）<br>2.响应时效较低</td>
<td align="left">1.对响应时效要求在小时级的沟通内容<br>2.除沟通对象外，也需要其他相关方知晓的情况</td>
</tr>
<tr>
<td align="center">邮件</td>
<td align="center">低</td>
<td align="left">1.信息表达更为准确<br>2.更利于信息追溯<br>3.更具效力<br>4.沟通对象数量限制较小</td>
<td align="left">1.响应时效性低</td>
<td align="left">1.沟通达成一致后，邮件发送准确性结论<br>2.信息传达的对象范围较广，不便于其他方式沟通<br>3.沟通内容较为正式，需引起对方重视。</td>
</tr>
</tbody></table>
<h2 id="2-2-说到位"><a href="#2-2-说到位" class="headerlink" title="2.2. 说到位"></a>2.2. 说到位</h2><p>策略：</p>
<ul>
<li>说清需求<ul>
<li>RD：需求标准化、不要频繁变更需求</li>
<li>QA：沟通目的明确，条理清晰、预期结果明确</li>
<li>OP：从维护服务高效稳定运转立场切需求</li>
<li>UI：最好在沟通之前到网上找一些竞争对手或目标效仿网站一并发给设计，再去谈（需求细节）的话就更轻松</li>
</ul>
</li>
<li>关注角色<ul>
<li>多说客观事实，少说主观感受</li>
<li>站在对方的角度分析困难和提出解决方案</li>
<li>以谦逊的姿态与对方沟通，让对方有被尊重感</li>
<li>能将对方应答的价值显性化，让对方有成就感</li>
<li>能给对方带来额外的收益，让对方的收益更大化</li>
</ul>
</li>
<li>打动对方<ul>
<li>说到位——同理心<h2 id="2-3-听明白"><a href="#2-3-听明白" class="headerlink" title="2.3. 听明白"></a>2.3. 听明白</h2>策略：</li>
</ul>
</li>
<li>学会倾听</li>
<li>学会发问<ul>
<li>敢发问：对于需求“知其然，知其所以然”</li>
<li>会发问：向上问（效果、目标、顾虑），向下问（能举个例子吗）</li>
<li>多发问：我作为需求应答方收益是什么</li>
</ul>
</li>
<li>理解意图<ul>
<li>倾听：确保对方把话说完</li>
<li>复述：重复对方的内容确保理解一致</li>
<li>确认：确认需求<h2 id="2-4-传准确"><a href="#2-4-传准确" class="headerlink" title="2.4. 传准确"></a>2.4. 传准确</h2><blockquote>
<p>结束后做什么？</p>
</blockquote>
</li>
</ul>
</li>
<li>若沟通成功，传达结论<ul>
<li><strong>记录在案</strong>：相当于立字据 or 签合同</li>
<li><strong>再次澄清</strong>：发出前可与对方 double check</li>
<li><strong>传达成功结论</strong><ul>
<li>传达方式：邮件、如流群</li>
<li>传达内容：会议时间&#x2F;地点&#x2F;参会人、整体结论（+ 观点）、TodoList（事项、Owner、时间结点、标准）</li>
</ul>
</li>
</ul>
</li>
<li>若沟通失败，向上汇报<ul>
<li><strong>反馈问题</strong>：向上汇报结论和原因</li>
<li><strong>寻求帮助</strong>：获取指导和帮助，继续推进</li>
<li><strong>传达失败结论（To 上级）</strong><ul>
<li>传达方式：当面、如流</li>
<li>传达内容： 沟通结论（结合目标来说）、个人观点（定性一句话描述）、询问上级（进一步计划等）</li>
<li>原则：<ul>
<li>说事实：对事不对人</li>
<li>做分析：剖析原因</li>
<li>给建议：给出下一步建议</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-心得分享"><a href="#3-心得分享" class="headerlink" title="3. 心得分享"></a>3. 心得分享</h1><blockquote>
<p>费斯汀格法则：“生活中的10%由发生在你身上的事情组成，而另外的90%则由你对所发生事情如何反应决定。”<br>“其实能帮助自己的不是他人，而是自己。”</p>
</blockquote>
<h1 id="4-补充材料——开会沟通的技巧"><a href="#4-补充材料——开会沟通的技巧" class="headerlink" title="4. 补充材料——开会沟通的技巧"></a>4. 补充材料——开会沟通的技巧</h1><ul>
<li><strong>起</strong>：介绍召开会议的“背景和目标”<ul>
<li>呈现要素：时间、地点、人物、事件、起因、经过、当前结果</li>
<li>要求：把故事讲清楚，会上讲的即是官宣版本</li>
<li>意义：避免出现罗生门和各种衍生创作情节</li>
<li>提示：在这阶段多花点儿时间和精力是值得的，这是为整个时间定性的关键环节</li>
</ul>
</li>
<li><strong>承</strong>：框定开会要沟通的“内容和范围”<ul>
<li>作用：“框定”，聚焦开会沟通的内容范围以及预期达成的结果</li>
<li>“内容和范围”：承接上一阶段对事项的定性，确定参会人员承担的角色、明确会议沟通需要达成的目标</li>
<li>提示：直白地说明要讲清楚来的都是谁，要干什么事儿</li>
</ul>
</li>
<li><strong>转</strong>：找出各方的“争议点和合作点”<ul>
<li>关键要素：明确各方的观点、权责、利弊、找出争议点和合作点</li>
<li>需求把控：需要做什么事儿、谁来做这些事儿、谁来评定完成度的标准</li>
<li>提示：客观的“求同存异”是顺畅沟通的桥梁，出现争议的事后加套大圈是不错的方法，持续灌输“从整体着眼”概念</li>
</ul>
</li>
<li><strong>合</strong>：明确 TODO 和 do “TODO” 的方法<ul>
<li>即“TODO”，确立一个抓手来 do TODO；要规避”yes”和”no”的结果</li>
<li>提示：设置监督者、建立进度闹钟、在可能“传球”的环节中插入“射门”计分制</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：跨团队协作的沟通高速路</title>
    <url>/2021/09/14/workplace_note_6_cross_team_collaboration/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>跨部门沟通重要性分布</p>
<ul>
<li>沟通前准备（30%）</li>
<li>沟通中顺利（30%）</li>
<li>沟通后执行（40%）</li>
</ul>
</blockquote>
<h1 id="1-沟通的本质"><a href="#1-沟通的本质" class="headerlink" title="1. 沟通的本质"></a>1. 沟通的本质</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1. 定义"></a>1.1. 定义</h2><p>人与人之间、人与群体之间<b><font color="red" style="">思想</font></b>与<b><font color="red" style="">感情</font></b>的传递和反馈的过程，以求思想达成<b><font color="red" style="">一致</font></b>和感情的<b><font color="red" style="">通畅</font></b>。</p>
<a id="more"></a>

<h2 id="1-2-本质"><a href="#1-2-本质" class="headerlink" title="1.2. 本质"></a>1.2. 本质</h2><p>沟通的本质是<b><font color="red" style="">交换不同的意见</font></b>，再交换过不同意见之后以达到（<b><font color="red" style="">沟通目的</font></b>）：</p>
<ul>
<li>丰富个人经验（to 个人）</li>
<li>解决问题（to team &#x2F; work）</li>
<li>验证自己的猜想和被他人理解（to 述说者）</li>
<li>理解他人（to 倾听者）</li>
</ul>
<h1 id="2-高效沟通三部曲"><a href="#2-高效沟通三部曲" class="headerlink" title="2. 高效沟通三部曲"></a>2. 高效沟通三部曲</h1><h2 id="2-1-沟通前-要做好的准备"><a href="#2-1-沟通前-要做好的准备" class="headerlink" title="2.1. 沟通前 要做好的准备"></a>2.1. 沟通前 要做好的准备</h2><ul>
<li>己方情况<ul>
<li>本次沟通的目的（Check：<b><font color="red" style="">SMART</font></b>）</li>
<li>关键事项（时间点&#x2F;资源）（Check：过程节点）</li>
<li>我的底线（Check：buffer）</li>
<li>我有哪些内部资源（Check：双赢前提下的资源投入）</li>
</ul>
</li>
<li>对方情况<ul>
<li>对方沟通接口人是谁（Check：角色责任）</li>
<li>对方的述求和关注点（Check：<b><font color="red" style="">双赢</font></b>）</li>
<li>对方是哪种沟通风格（Check：DISC（狮子、猫头鹰、考拉、孔雀型））</li>
<li>对方的业务动向（Check：优先级标准）</li>
</ul>
</li>
<li>双方关系<ul>
<li>是否有合作历史（Check：尊重历史，打破惯例）</li>
<li>可能的中间人是谁（Check：对结果有帮助的第三人）</li>
<li>如何建立发展关系（Check：合作关系是天然的么？）</li>
</ul>
</li>
<li>其他条件准备<ul>
<li>良好的沟通氛围（Check：有木有历史问题）</li>
<li>对方可能会被问到的问题（Check：<b><font color="red" style="">背景、外延信息</font></b>）</li>
<li>可能发生的状况&#x2F;预估风险（Check：<b><font color="red" style="">干扰因素</font></b>）</li>
<li>Plan B（Check：备选）</li>
</ul>
</li>
</ul>
<h2 id="2-2-沟通中的必要步骤"><a href="#2-2-沟通中的必要步骤" class="headerlink" title="2.2. 沟通中的必要步骤"></a>2.2. 沟通中的必要步骤</h2><h3 id="2-2-1-沟通中的四个步骤"><a href="#2-2-1-沟通中的四个步骤" class="headerlink" title="2.2.1. 沟通中的四个步骤"></a>2.2.1. 沟通中的四个步骤</h3><ul>
<li>建立联系（Check：关键 干系人；营造安全）</li>
<li>说明目的（Check：目标<b><font color="red" style="">双赢</font></b>）</li>
<li>探讨方案（Check：<b><font color="red" style="">资源支持；取舍。。。</font></b>）</li>
<li>达成共识（Check：Milestone；马上可以开始的是？时间具体、行动具体、产出具体）<h3 id="2-2-2-详细说明"><a href="#2-2-2-详细说明" class="headerlink" title="2.2.2. 详细说明"></a>2.2.2. 详细说明</h3></li>
<li>建立联系<ul>
<li>找对人</li>
<li>找共同点</li>
<li>主动帮忙</li>
<li>价值互换</li>
</ul>
</li>
<li>说明目的（表达技巧）<ul>
<li>结论先行</li>
<li>需求明确</li>
<li>关联利益</li>
<li>把需求变成机会</li>
</ul>
</li>
<li>探讨方案（倾听技巧）<ul>
<li>了解对方想法</li>
<li>YES or NO</li>
<li>对方 Say No 如何处理</li>
</ul>
</li>
<li>达成共识（处理分歧）<ul>
<li>隐含的假设前提：（乔哈里视窗）：<ul>
<li>公开区：自知、他人知</li>
<li>不自知：盲区 —— 倾听提问</li>
<li>他不知：隐秘区 —— 表达反馈</li>
<li>未知区：不自知、他不知</li>
</ul>
</li>
<li>缺省默认的需求（个人理解差异 -&gt; 沟通明确）</li>
</ul>
</li>
</ul>
<p><b><font color="#7E3D76" style="">ps: 推荐书籍《关键对话：如何高效能沟通》</font></b></p>
<ul>
<li>两大法宝<ul>
<li>注意观察</li>
<li>营造安全感</li>
</ul>
</li>
<li>如何准备关键对话<ul>
<li>Section3. 从“心”开始</li>
<li>Section4. 注意观察</li>
<li>Section5. 保证安全</li>
<li>Section6. 控制想法</li>
<li>Section7. 陈述观点</li>
<li>Section8. 了解动机</li>
<li>Section9. 开始行动</li>
</ul>
</li>
</ul>
<h2 id="2-3-沟通后-的跟进与落实"><a href="#2-3-沟通后-的跟进与落实" class="headerlink" title="2.3. 沟通后 的跟进与落实"></a>2.3. 沟通后 的跟进与落实</h2><ul>
<li>圈定干系人（Check：推进结果是否达成各方需要）<ul>
<li>共识分解</li>
<li>风险共担</li>
<li>利益共享</li>
</ul>
</li>
<li>信息同步与跟进（Check：<b><font color="#7E3D76" style="">沟通共识信息</font></b><b><font color="red" style="">周知</font></b>相关干系人；明确沟通目标实现的节点 <b><font color="red" style="">follow up</font></b>）<ul>
<li>项目例会</li>
<li>邮件</li>
</ul>
</li>
<li>明确结束（Check：<b><font color="red" style="">明确close</font></b>，总结迭代）<ul>
<li>复盘总结</li>
</ul>
</li>
<li>表达感谢</li>
</ul>
<h1 id="3-如何避免“翻船”"><a href="#3-如何避免“翻船”" class="headerlink" title="3. 如何避免“翻船”"></a>3. 如何避免“翻船”</h1><h2 id="3-1-分歧的处理"><a href="#3-1-分歧的处理" class="headerlink" title="3.1. 分歧的处理"></a>3.1. 分歧的处理</h2><h3 id="3-1-1-产生分歧的主要原因"><a href="#3-1-1-产生分歧的主要原因" class="headerlink" title="3.1.1. 产生分歧的主要原因"></a>3.1.1. 产生分歧的主要原因</h3><ul>
<li>不同部门<ul>
<li>目标不一致</li>
<li>立场不同</li>
<li>部门偏见</li>
</ul>
</li>
<li>不同个体<ul>
<li>性格不同</li>
<li>压力状态不同</li>
<li>思维方式&#x2F;理解方式 不同</li>
</ul>
</li>
<li>不同角色<ul>
<li>关注点不同</li>
<li>期望值不同</li>
<li>专业背景不同</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-分歧处理的7大策略"><a href="#3-1-2-分歧处理的7大策略" class="headerlink" title="3.1.2. 分歧处理的7大策略"></a>3.1.2. 分歧处理的7大策略</h3><ul>
<li>倡导利益<ul>
<li>站在更高的角度（部门&#x2F;公司）向对方说明重要性</li>
<li>让利益同对方联系起来</li>
</ul>
</li>
<li>取得第三方参与<ul>
<li>获取他人的帮助（上级&#x2F;专家），对对方（或对方上级）施加影响</li>
</ul>
</li>
<li>让数据说话<ul>
<li>数据是最有说服力的，让事实说话</li>
</ul>
</li>
<li>换位思考<ul>
<li>站在对方的角度思考问题（他关注什么、他的主要顾虑）</li>
</ul>
</li>
<li>扩大公开区<ul>
<li>主动表达、反馈、多听、多问</li>
</ul>
</li>
<li>对事不对人<ul>
<li><b><font color="red" style="">多用描述性语言，少用判断性语言</font></b></li>
</ul>
</li>
<li>尊重他人<ul>
<li>尊重他人的感受和意见</li>
</ul>
</li>
</ul>
<h2 id="3-2-避免拖进度-——-主动推"><a href="#3-2-避免拖进度-——-主动推" class="headerlink" title="3.2. 避免拖进度 —— 主动推"></a>3.2. 避免拖进度 —— 主动推</h2><ul>
<li>盯过程</li>
<li>引资源</li>
<li>避免分歧</li>
</ul>
<h2 id="3-3-避免互相指责"><a href="#3-3-避免互相指责" class="headerlink" title="3.3. 避免互相指责"></a>3.3. 避免互相指责</h2><h3 id="3-3-1-指责产生的原因"><a href="#3-3-1-指责产生的原因" class="headerlink" title="3.3.1. 指责产生的原因"></a>3.3.1. 指责产生的原因</h3><ul>
<li>信息会在沟通中衰减</li>
<li>沟通不只是文字<ul>
<li>还包括：语气、语调、表情、肢体语言等<br> —— 梅拉宾法则：一个人对他人的印象，只有大约 7% 取决于谈话内容。</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-倾听技巧"><a href="#3-3-2-倾听技巧" class="headerlink" title="3.3.2. 倾听技巧"></a>3.3.2. 倾听技巧</h3><blockquote>
<p>用眼听，用心听，听他没说的</p>
</blockquote>
<ul>
<li>拆解关键字</li>
<li>肢体语言</li>
<li>去除障碍</li>
<li>话外之音</li>
</ul>
<h3 id="3-3-3-表达技巧"><a href="#3-3-3-表达技巧" class="headerlink" title="3.3.3. 表达技巧"></a>3.3.3. 表达技巧</h3><ul>
<li>搭建结构 —— 先整体后局部</li>
<li>对内容进行分类，归纳 —— 先重点后次要</li>
<li>凡事讲 <b><font color="red" style="">“3”</font></b> 点</li>
</ul>
<h3 id="3-3-4-确认理解"><a href="#3-3-4-确认理解" class="headerlink" title="3.3.4. 确认理解"></a>3.3.4. 确认理解</h3><ul>
<li>引导对方重复</li>
<li>询问对方的想法</li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：成长力</title>
    <url>/2021/09/22/workplace_note_7_growing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-高效能的成长"><a href="#1-高效能的成长" class="headerlink" title="1. 高效能的成长"></a>1. 高效能的成长</h1><blockquote>
<p>由内而外的成长</p>
</blockquote>
<h2 id="1-1-效能、效率、效果"><a href="#1-1-效能、效率、效果" class="headerlink" title="1.1. 效能、效率、效果"></a>1.1. 效能、效率、效果</h2><p>“效能”：</p>
<ul>
<li>产能与产出平衡</li>
<li>可持续发展</li>
<li>短期收益与长期结果的平衡</li>
<li>由内而外的改变</li>
</ul>
<a id="more"></a>

<p>培养高效能人士的七个习惯要“由内而外”：</p>
<ul>
<li>修身、齐家、治国、平天下</li>
<li>从自身做起，从塑造品格和思维模式入手</li>
<li>先做到独挡一面才能做到相互依赖</li>
<li>持续更新的过程，以原则为核心，螺旋向上成长</li>
</ul>
<h2 id="1-2-如何获得成长"><a href="#1-2-如何获得成长" class="headerlink" title="1.2. 如何获得成长"></a>1.2. 如何获得成长</h2><p>“实践、结果、思维” 循环</p>
<h2 id="1-3-成长的原则"><a href="#1-3-成长的原则" class="headerlink" title="1.3. 成长的原则"></a>1.3. 成长的原则</h2><blockquote>
<p>依靠品格安身立命的人有着强大而深厚的根基。他们能够经受得住生活中的种种压力，不断成长，不断进步。 – by Stepetch.R.covey</p>
</blockquote>
<ul>
<li>我的成长我做主 - 责任、选择、担当、主动、智慧</li>
<li>使命让行动更有方向感 - 愿景、承诺、目的</li>
<li>把时间花在重要的事情上 - 专注、诚信、纪律、优先级</li>
<li>“共赢”思维 - 互惠、公平、富足</li>
<li>懂你懂我 - 尊重、互相理解同理心、勇气</li>
<li>让我们 1+1 &gt; 2 - 创新、合作、多元化、谦逊</li>
<li>成长 - 更新、持续改进</li>
</ul>
<blockquote>
<p>“成功并不是因为掌握了玄妙、高深的理论，相反，成功是以不寻常的坚韧和决心来贯彻常识。” —— 帕特里克·兰西奥尼</p>
</blockquote>
<h1 id="2-成长力-——-我的成长我做主"><a href="#2-成长力-——-我的成长我做主" class="headerlink" title="2. 成长力 —— 我的成长我做主"></a>2. 成长力 —— 我的成长我做主</h1><h2 id="2-1-暂停三秒钟，根据原则和所期望的结果做出反应"><a href="#2-1-暂停三秒钟，根据原则和所期望的结果做出反应" class="headerlink" title="2.1. 暂停三秒钟，根据原则和所期望的结果做出反应"></a>2.1. 暂停三秒钟，根据原则和所期望的结果做出反应</h2><p>成长力思维 &gt;&gt; 成长实践</p>
<ul>
<li>成长力思维：我有选择的自由，我对我的选择负责。</li>
<li>成长实践：<ul>
<li>暂停三秒钟，根据<strong>原则和所期望的结果</strong>做出反应</li>
<li>绿色的语言</li>
<li>聚焦你能做的</li>
<li>传递成长</li>
</ul>
</li>
</ul>
<h2 id="2-2-主动积极的语言"><a href="#2-2-主动积极的语言" class="headerlink" title="2.2. 主动积极的语言"></a>2.2. 主动积极的语言</h2><p>绿色的语言</p>
<p>人类的四大天赋：</p>
<ul>
<li><strong>自我察觉</strong>：我们脱离自身，审视自己的想法、情绪和行为的能力。</li>
<li><strong>想象力</strong>：我们超越自身经历和当前现实的想象力。</li>
<li><strong>良知</strong>：我们感知是非善恶的能力。</li>
<li><strong>独立意识</strong>：我们不受外来的影响&#x2F;控制，来进行自行选择的能力。</li>
</ul>
<h2 id="2-3-聚焦你能做的"><a href="#2-3-聚焦你能做的" class="headerlink" title="2.3. 聚焦你能做的"></a>2.3. 聚焦你能做的</h2><p>（（行动圈）关心圈）</p>
<p>扩大行动圈：</p>
<blockquote>
<p>当人们吧注意力集中到能够影响的事情上，可以拓宽其知识和经验，让自己成长。</p>
</blockquote>
<blockquote>
<p>走出舒适区，迎接挑战，不断扩大行动圈。</p>
</blockquote>
<ul>
<li>直接控制 - 积极改变</li>
<li>简介控制 - 施加影响</li>
<li>无法控制 - 泰然面对</li>
</ul>
<h2 id="2-4-传递成长"><a href="#2-4-传递成长" class="headerlink" title="2.4. 传递成长"></a>2.4. 传递成长</h2><ul>
<li>成为主动积极、不断成长、持续成长的人。</li>
<li>具有成长思维，并把自己的成长经验传播出去。</li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：关键对话</title>
    <url>/2021/09/23/workplace_note_8_key_conversation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-聚焦关键对话"><a href="#1-聚焦关键对话" class="headerlink" title="1. 聚焦关键对话"></a>1. 聚焦关键对话</h1><p>帮你掌握一套行之有效的对话方法，提升沟通技巧，高效化解高风险对话，提升个人非职权影响力，成为关键时刻稳定发挥的高手！</p>
<a id="more"></a>

<h1 id="2-识别关键对话"><a href="#2-识别关键对话" class="headerlink" title="2. 识别关键对话"></a>2. 识别关键对话</h1><p>定义：结果会对你的工作生活质量造成巨大影响的特殊对话</p>
<p>三要素：意见不一、情绪激烈、事关重大</p>
<p>错误应对方式：</p>
<ul>
<li>沉默 Flight（拒绝观点的表达交流）：掩饰、回避。逃避</li>
<li>对抗 Flight（控制或强迫对方接受）：控制、标签、攻击</li>
</ul>
<h1 id="3-掌控关键对话"><a href="#3-掌控关键对话" class="headerlink" title="3. 掌控关键对话"></a>3. 掌控关键对话</h1><ul>
<li><strong>前提</strong>：相互尊重</li>
<li><strong>（对话前）策略</strong>：专注于你真正想要的目标！</li>
<li><strong>（对话后）策略</strong>：跟进决策行动</li>
</ul>
<p>两大法宝：</p>
<ul>
<li><strong>时刻观察</strong>：善于改善对话技巧的人总是不停地问自己是否还在对话框架中。</li>
<li><strong>营造安全感</strong>：对话的基础是观点的自由交流，而最大的障碍就是缺乏安全感。</li>
</ul>
<h2 id="3-1-心法一：专注共同目标"><a href="#3-1-心法一：专注共同目标" class="headerlink" title="3.1. 心法一：专注共同目标"></a>3.1. 心法一：专注共同目标</h2><blockquote>
<p>谋其上得其中，谋其中得其下！</p>
</blockquote>
<p>开局问自己四个问题：</p>
<ul>
<li>我希望通过对话实现什么目标？</li>
<li>我希望为对方实现什么目标？</li>
<li>我能为我们之间的人际关系实现什么目标？</li>
<li>为了达成这些目标，我该做些什么？</li>
</ul>
<h3 id="3-1-1-招式1：创建共同目标（CRIB-法）"><a href="#3-1-1-招式1：创建共同目标（CRIB-法）" class="headerlink" title="3.1.1. 招式1：创建共同目标（CRIB 法）"></a>3.1.1. 招式1：创建共同目标（CRIB 法）</h3><p>利用 <strong>CRIB</strong> 法创建共同的目标：</p>
<ul>
<li>Commit - 承诺寻找共同目标</li>
<li>Recognize - 识别策略背后的目的</li>
<li>Invent - 创建共同的目标：寻找更高层次、更长远的共同目标</li>
<li>Brainstorm - 共同头脑风暴出新方案：基于共同目标，进行头脑风暴，沟通出一个新方案。</li>
</ul>
<h2 id="3-2-心法二：营造安全氛围"><a href="#3-2-心法二：营造安全氛围" class="headerlink" title="3.2. 心法二：营造安全氛围"></a>3.2. 心法二：营造安全氛围</h2><blockquote>
<p>聚焦共同目标<br>保证安全三招式</p>
</blockquote>
<h3 id="3-2-1-招式2：及时观察，暂停对话"><a href="#3-2-1-招式2：及时观察，暂停对话" class="headerlink" title="3.2.1. 招式2：及时观察，暂停对话"></a>3.2.1. 招式2：及时观察，暂停对话</h3><blockquote>
<p>我正在陷入沉默或暴力状态么？<br>对方正在陷入沉默或暴力状态么？<br>怎样做才能重建安全感？</p>
</blockquote>
<ul>
<li><p>关注交谈何时变成关键对话</p>
</li>
<li><p>关注安全问题</p>
<h3 id="3-2-2-招式3：表示尊重，必要时道歉"><a href="#3-2-2-招式3：表示尊重，必要时道歉" class="headerlink" title="3.2.2. 招式3：表示尊重，必要时道歉"></a>3.2.2. 招式3：表示尊重，必要时道歉</h3><blockquote>
<p>我是否让对方感受到了被尊重？<br>我是否将对话导向危急状态？</p>
</blockquote>
</li>
<li><p>相互尊重，持续沟通的基础</p>
</li>
<li><p>关注你的压力应对方式</p>
</li>
<li><p>当你的做法破坏尊重感时，应当向对方道歉</p>
<h3 id="3-2-3-招式4：利用“对比法”消除误解"><a href="#3-2-3-招式4：利用“对比法”消除误解" class="headerlink" title="3.2.3. 招式4：利用“对比法”消除误解"></a>3.2.3. 招式4：利用“对比法”消除误解</h3><blockquote>
<p>我所说的是否让对方产生了误解？<br>对方不希望怎样？对方希望怎样？</p>
</blockquote>
</li>
<li><p>当对方误解你的目的或意图时，先说明你不希望如何，然后说明你想要怎样。<br>我不希望。。。（否定），而是希望。。。（肯定）<br>打消对方认为你不尊重或有不轨企图的误解（否定）<br>确认你对他们的尊重，明确你的真实目的（肯定）</p>
</li>
</ul>
<h2 id="3-3-心法三：关注事实真相"><a href="#3-3-心法三：关注事实真相" class="headerlink" title="3.3. 心法三：关注事实真相"></a>3.3. 心法三：关注事实真相</h2><h3 id="3-3-1-招式5：控制自己的情绪"><a href="#3-3-1-招式5：控制自己的情绪" class="headerlink" title="3.3.1. 招式5：控制自己的情绪"></a>3.3.1. 招式5：控制自己的情绪</h3><blockquote>
<p>情绪来源于我们的主观判断，而不是事实的本身</p>
<p>情绪是造成关键对话难度陡增的重要原因</p>
<p>情绪并非无中生有，学会控制自己情绪：我的想法是什么？我是否故意忽略自己在这个问题中的责任？一个理智正常的人为什么会这么做？</p>
</blockquote>
<p>行为方式模型：<br>所见所闻 &gt; 主观臆断 &gt; 形成感受 &gt; 展开行为</p>
<p>（1）<strong>行为模式回顾</strong><br>如果发现自己正在远离对话，问问自己在做什么：</p>
<ul>
<li>我是否陷入了沉默或暴力应对方式？</li>
<li>导致这种行为的情绪感受是什么？</li>
<li>造成这种情绪出现的想法是什么？</li>
<li>形成这种想法的<strong>事实依据</strong>是什么？</li>
<li>我的真实目的是什么？</li>
<li>要想实现这些目的现在我该怎么做？</li>
</ul>
<p>（2）<strong>区分事实和想法</strong><br>（3）<strong>改变主观臆断</strong></p>
<p>钝感力</p>
<ul>
<li>迟钝的力量，从容面对对话中的挫折和不快，坚定地朝着自己的方向前进</li>
<li>不要把别人的情绪归因到自己身上</li>
<li>自己的事儿，别人的事儿，老天的事儿</li>
<li>稳住自己，不要接招</li>
</ul>
<h3 id="3-3-2-招式6：陈述我的观点（STATE-法）"><a href="#3-3-2-招式6：陈述我的观点（STATE-法）" class="headerlink" title="3.3.2. 招式6：陈述我的观点（STATE 法）"></a>3.3.2. 招式6：陈述我的观点（STATE 法）</h3><blockquote>
<p>我是否对对方观点完全开放？<br>我讨论的是不是真正的问题？<br>我是否自信地表达自己的观点？</p>
</blockquote>
<p>“内容”方面的技巧</p>
<ul>
<li>S - 分享事实的经过</li>
<li>T - 说出你的想法</li>
<li>A - 征询对方观点</li>
</ul>
<p>“方式”方面的技巧</p>
<ul>
<li>T - 做出试探表述（说出你的想法）说明你根据这些事实得出的结论：<ul>
<li>自信表现</li>
<li>不要堆积问题</li>
<li>注意安全问题</li>
</ul>
</li>
<li>E - 鼓励做出尝试<ul>
<li>鼓励对方做出尝试。</li>
</ul>
</li>
</ul>
<p>以事实为依据 —— DIE：描述、解读、判断</p>
<h2 id="3-4-心法四：了解对方真实动机"><a href="#3-4-心法四：了解对方真实动机" class="headerlink" title="3.4. 心法四：了解对方真实动机"></a>3.4. 心法四：了解对方真实动机</h2><blockquote>
<p>主动（并鼓励对方）探寻对方的行为模式</p>
</blockquote>
<p>自我审视：真诚、好奇、坚持、耐心。</p>
<h3 id="3-4-1-招式7：探寻对方想法（AMPP-法）"><a href="#3-4-1-招式7：探寻对方想法（AMPP-法）" class="headerlink" title="3.4.1. 招式7：探寻对方想法（AMPP 法）"></a>3.4.1. 招式7：探寻对方想法（AMPP 法）</h3><blockquote>
<p>我是否积极开放地了解对方想法?</p>
</blockquote>
<p>四种有效的倾听技巧 —— AMPP</p>
<ul>
<li>Ask - 询问观点</li>
<li>Mirror - 确认感受</li>
<li>Paraphrase - 重新描述</li>
<li>Prime - 主动引导</li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>职场笔记：洞察用户需求的创新思维</title>
    <url>/2021/09/24/workplace_note_9_innovative_thinking_with_insights_into_user_needs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>创新是为了解决某个问题，达成某个目标<br>创意 !&#x3D; 创新</p>
</blockquote>
<ul>
<li>Idea：一个想法</li>
<li>创意：一个新奇的想法</li>
<li>创新：一个新奇的、有价值的、可行的想法</li>
</ul>
<p>创新：</p>
<ul>
<li>技术可行</li>
<li>商业可行</li>
<li>用户需求</li>
</ul>
<a id="more"></a>

<p>课程目的：</p>
<ul>
<li>洞察问题&#x2F;用户需求本质</li>
<li>提供创新思维工具</li>
<li>介绍快速验证原则</li>
</ul>
<h1 id="1-搞清楚要解决的问题究竟是什么？"><a href="#1-搞清楚要解决的问题究竟是什么？" class="headerlink" title="1. 搞清楚要解决的问题究竟是什么？"></a>1. 搞清楚要解决的问题究竟是什么？</h1><h2 id="1-1-同理心洞察"><a href="#1-1-同理心洞察" class="headerlink" title="1.1. 同理心洞察"></a>1.1. 同理心洞察</h2><p>洞察问题&#x2F;需求本质</p>
<ul>
<li><strong>一问</strong>：<ul>
<li>通过访谈，了解到用户的真实想法&#x2F;需求，</li>
<li>发现问题的本质</li>
<li>Need：用户真正需要的是什么？</li>
</ul>
</li>
<li><strong>二看</strong>：<ul>
<li>把用户的行为作为他生活的一部分，在真是的场景下进行观察</li>
<li>User：目标用户有哪些行为和表现？（目标用户是谁？）</li>
</ul>
</li>
<li><strong>三体</strong>：<ul>
<li>体验到用户所体验到的所有，挖掘客户潜在的真正感受、想法、思考</li>
<li>Insight：用户有这样的需求的内心情感是？</li>
</ul>
</li>
</ul>
<p><strong>目标</strong>：如何明确 Need 让 User 满足 Insight。</p>
<h1 id="2-创新思维工具"><a href="#2-创新思维工具" class="headerlink" title="2. 创新思维工具"></a>2. 创新思维工具</h1><p>创新思维工具箱</p>
<h2 id="2-1-拆解要素"><a href="#2-1-拆解要素" class="headerlink" title="2.1. 拆解要素"></a>2.1. 拆解要素</h2><h2 id="2-2-强制关联"><a href="#2-2-强制关联" class="headerlink" title="2.2. 强制关联"></a>2.2. 强制关联</h2><ul>
<li>楼梯 + 钢琴 &#x3D; 创意楼梯</li>
<li>字典 + 语音合成 + 液晶屏幕 &#x3D; 电子英语词典</li>
</ul>
<h2 id="2-3-反转思维"><a href="#2-3-反转思维" class="headerlink" title="2.3. 反转思维"></a>2.3. 反转思维</h2><p>“刻意”打破现有规定！</p>
<h1 id="3-创新着陆"><a href="#3-创新着陆" class="headerlink" title="3. 创新着陆"></a>3. 创新着陆</h1><p><b><font color="#7E3D76" style="">四种解决方案原型</font></b></p>
<ul>
<li>理论原型</li>
<li>虚拟原型（伪造解决方案）</li>
<li>最小化可行原型（MVP）</li>
<li>最小化卓越产品</li>
</ul>
<p><b><font color="#7E3D76" style="">三种测试</font></b></p>
<ul>
<li>惊喜测试</li>
<li>NPS 测试</li>
<li>付款测试</li>
</ul>
<p><b><font color="#7E3D76" style="">创新着陆步骤</font></b></p>
<ul>
<li>解决方案（头脑风暴） &#x3D;&#x3D; 功能和解决方案变化 &#x3D;&#x3D;&gt;&gt;</li>
<li>理论原型 &#x3D;&#x3D; 惊喜测试 &#x3D;&#x3D;&gt;&gt;</li>
<li>虚拟原型 &#x3D;&#x3D; 惊喜、净推荐值和付款测试 &#x3D;&#x3D;&gt;&gt;</li>
<li>最小化可行原型 &#x3D;&#x3D; 付款或净推荐值测试 &#x3D;&#x3D;&gt;&gt;</li>
<li>最小化卓越产品</li>
</ul>
<p>推荐书目：《创新者的方法》</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>职场笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的Markdown博文语法简介</title>
    <url>/2018/08/31/write-a-md-file/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="../../../../uploads/write-a-md-file.jpg" class="full-image" />

<h1 id="1-md文件预定义参数"><a href="#1-md文件预定义参数" class="headerlink" title="1. md文件预定义参数"></a>1. md文件预定义参数</h1><h2 id="1-1-预定义参数"><a href="#1-1-预定义参数" class="headerlink" title="1.1. 预定义参数"></a>1.1. 预定义参数</h2><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<a id="more"></a>

<p>layout|布局|post<br>title|标题|<br>date|建立日期|文件建立日期<br>updated|更新日期|文件更新日期<br>comments|开启文章的评论功能|true<br>tags|标签（不适用于分页）|<br>categories|分类（不适用于分页）|<br>permalink|覆盖文章网址|</p>
<h2 id="1-2-本文的md文件预定义参数"><a href="#1-2-本文的md文件预定义参数" class="headerlink" title="1.2. 本文的md文件预定义参数"></a>1.2. 本文的md文件预定义参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout: post</span><br><span class="line">title: Markdown文章写作格式＆语法</span><br><span class="line">date: 2018&#x2F;8&#x2F;31 12:10:30</span><br><span class="line">updated: 2018&#x2F;9&#x2F;1 19:24:45</span><br><span class="line">comments: true</span><br><span class="line">tags:</span><br><span class="line">- Markdown</span><br><span class="line">- Hexo</span><br><span class="line">categories:</span><br><span class="line">- Markdown</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="2-Hexo下的Markdown语法"><a href="#2-Hexo下的Markdown语法" class="headerlink" title="2. Hexo下的Markdown语法"></a>2. Hexo下的Markdown语法</h1><h2 id="2-1-语法简明描述"><a href="#2-1-语法简明描述" class="headerlink" title="2.1. 语法简明描述"></a>2.1. 语法简明描述</h2><ol>
<li><strong>分段：</strong> <code>两个回车</code></li>
<li><strong>换行：</strong> <code>两个空格 + 回车</code></li>
<li><strong>标题：</strong> # ~ ######，#号的个数表示几级标题，即表示一～六级标题。(eg: <code>### 三级标题</code>)</li>
<li><strong>强调：</strong> <em>倾斜</em>(<code>*倾斜*</code>) 、 <strong>加粗</strong>(<code>**加粗**</code> or <code>__加粗__</code>) 、<em><strong>倾斜加粗</strong></em>(<code>***倾斜加粗***</code>) 、 <del>删除线</del>(<code>~~删除线~~</code>) 、 <code>标记</code>  (<code>`标记`</code>)</li>
<li><strong>列表：</strong> <code>* </code> 、<code>+ </code> 、<code>- </code> 、<code>数字序号. </code>(有序)  选其中之一，注意后面都紧跟一个空格</li>
<li><strong>引用：</strong> <code>&gt; </code> ，注意&gt;后面紧跟一个空格(eg: <code>&gt; 引用文字</code>)，结束引用时输入<code>两个回车</code>以结束引用</li>
<li><strong>图片：</strong> 在需要添加图片的位置<code>![图片](图片地址)</code>便可，图片地址可以是本地路径，或网络地址</li>
<li><strong>表格：</strong> - 和 | 分割行和列 ，<code>:</code>与<code>-</code>的相对位置控制当前列的左对齐、居中对齐、右对齐方式(<code>:----|:----:|----:</code>)，表格代码段可能需要与上部分代码空一行</li>
<li><strong>代码块：</strong> 每行代码前加四个空格(不显示行号)，或 使用<code>```代码内容```</code>(显示行号，<code>`</code>为键盘Esc下方按键)</li>
<li><strong>文本链接：</strong> [文字链接名称](链接地址)，eg: <a href="https://haoleeson.github.io/">我的博客</a> (<code>[我的博客](<a href="https://haoleeson.github.io/">https://haoleeson.github.io/</a></code>)</li>
<li><strong>小型文本：</strong> <small>小型文本</small><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;small&gt;小型文本&lt;&#x2F;small&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>高亮：</strong> 比如<code>突出背景色</code>来显示强调效果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;code&gt;突出背景色&lt;&#x2F;code&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>代码注释：</strong> 注释内容有助于理解代码，而不会被编译<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注释内容 --&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>网址链接：</strong> &lt;网址链接&gt;，eg: 我的博客:<a href="https://eisenhao.cn/">https://eisenhao.cn/</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我的博客:&lt;https:&#x2F;&#x2F;eisenhao.cn&#x2F;&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>阅读全文：</strong> 常用于文章过长，只显示文章前半部分，结合Hexo实现文章截断，点击阅读更多后显示全文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>文本右对齐：</strong><br>正常文本<div align = center>文本居中</div>
<div align = right>文本右对齐</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正常文本</span><br><span class="line">&lt;div align &#x3D; center&gt;文本居中&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div align &#x3D; right&gt;文本右对齐&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>代码块高级用法</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 请忽视&quot;&#96;\&#96;&#96;&quot;中的转移符&quot;\&quot;</span><br><span class="line">&#96;\&#96;&#96;[language] [title] [url] [link-text]</span><br><span class="line">代码块内容</span><br><span class="line">&#96;\&#96;&#96;</span><br><span class="line">[language] 是代码语言的名称，用来设置代码块颜色高亮，非必须；</span><br><span class="line">[title] 是顶部左边的说明，非必须；</span><br><span class="line">[url] 是顶部右边的超链接地址，非必须；</span><br><span class="line">[link text] 如它的字面意思，超链接的名称，非必须。</span><br></pre></td></tr></table></figure>
亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]，更多关于代码块的高级用法可参考文档：<a href="https://www.ofind.cn/blog/HEXO/HEXO%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%8B%93%E5%B1%95%E4%BF%AE%E6%94%B9.html">HEXO下的语法高亮拓展修改</a>。<br>例如以下代码:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 请忽视&quot;&#96;\&#96;&#96;&quot;中的转移符&quot;\&quot;</span><br><span class="line">&#96;\&#96;&#96;c++ 文件位置：~&#x2F;GitHub&#x2F;Cpp_Learning&#x2F;Cpp_demo.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#96;\&#96;&#96;</span><br></pre></td></tr></table></figure>
效果如下:<figure class="highlight c++"><figcaption><span>文件位置：~/GitHub/Cpp_Learning/Cpp_demo.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-2-引用嵌套"><a href="#2-2-引用嵌套" class="headerlink" title="2.2. 引用嵌套"></a>2.2. 引用嵌套</h2><p>引用的嵌套使用，注意引用字段结束后输入两个回车结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 植物</span><br><span class="line">&gt;&gt; 陆生植物</span><br><span class="line">&gt;&gt;&gt; 树</span><br><span class="line">&gt;&gt;&gt; 草</span><br><span class="line">&gt;&gt;&gt;&gt; 苹果树</span><br><span class="line">&gt;&gt;&gt;&gt; 梨树</span><br><span class="line">&gt;&gt;橘子树 &#x2F;&#x2F;由于没有用没有空行间隔，忽略降级引用标记</span><br><span class="line">香蕉树 &#x2F;&#x2F;由于没有用没有空行间隔，忽略降级引用标记</span><br><span class="line"></span><br><span class="line">&gt;&gt; 水生植物</span><br><span class="line">&gt;&gt;&gt; 藻</span><br><span class="line">海草</span><br><span class="line"></span><br><span class="line">共输入两个回车，结束引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>植物</p>
<blockquote>
<p>陆生植物</p>
<blockquote>
<p>树<br>草</p>
<blockquote>
<p>苹果树<br>梨树<br>橘子树 &#x2F;&#x2F;由于没有用没有空行间隔，忽略降级引用标记<br>香蕉树 &#x2F;&#x2F;由于没有用没有空行间隔，忽略降级引用标记</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>水生植物</p>
<blockquote>
<p>藻<br>海草</p>
</blockquote>
</blockquote>
</blockquote>
<p>共输入两个回车，结束引用</p>
<h2 id="2-3-列表"><a href="#2-3-列表" class="headerlink" title="2.3. 列表"></a>2.3. 列表</h2><h3 id="2-3-1-无序列表"><a href="#2-3-1-无序列表" class="headerlink" title="2.3.1. 无序列表"></a>2.3.1. 无序列表</h3><p><code>* </code>、<code>+ </code>、<code>- </code>三种方式都能表示无序列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 无序列表1</span><br><span class="line">+ 无序列表2</span><br><span class="line">- 无序列表3</span><br></pre></td></tr></table></figure>
<ul>
<li>无序列表1</li>
</ul>
<ul>
<li>无序列表2</li>
</ul>
<ul>
<li>无序列表3</li>
</ul>
<h3 id="2-3-2-有序列表"><a href="#2-3-2-有序列表" class="headerlink" title="2.3.2. 有序列表"></a>2.3.2. 有序列表</h3><p>只取第一个列表的数字序号，序号依次增加，与接下来的数字序号无关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 有序列表3</span><br><span class="line">9. 有序列表9</span><br><span class="line">2. 有序列表2</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>有序列表3</li>
<li>有序列表9</li>
<li>有序列表2</li>
</ol>
<h2 id="2-4-分割线"><a href="#2-4-分割线" class="headerlink" title="2.4. 分割线"></a>2.4. 分割线</h2><p>分割线可以由<code>*</code>、<code>-</code>、<code>_</code>这3种符号每种至少3个来表示(不必严格连续)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- * *</span><br><span class="line">-- -</span><br><span class="line">_ _ _</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对应效果:</p>
<ul>
<li><ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="3-内置标签"><a href="#3-内置标签" class="headerlink" title="3. 内置标签"></a>3. 内置标签</h1><p>标签(Tag Plugin)是Hexo提供的一种快速生成特定内容的方式。例如，在标准Markdown语法中，我们无法指定图片的大小。这种情景，我们即可使用标签来解决。Hexo内置来许多标签来帮助写作者可以更快的书写，参考Hexo的<a href="https://hexo.io/zh-cn/docs/tag-plugins.html">完整的标签列表</a>。Hexo也开放来接口给主题，使提供给写作者更简便的写作方法成为可能。</p>
<h2 id="3-1-文本居中的引用"><a href="#3-1-文本居中的引用" class="headerlink" title="3.1. 文本居中的引用"></a>3.1. 文本居中的引用</h2><p>此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。例如作为文章开篇引用或者结束语之前的总结引用。</p>
<h3 id="3-1-1-HTML引用方式"><a href="#3-1-1-HTML引用方式" class="headerlink" title="3.1.1. HTML引用方式:"></a>3.1.1. HTML引用方式:</h3><p>使用HTML方式：直接在Markdown文件中编写HTML来调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class&#x3D;&quot;blockquote-center&quot; 是必须的 --&gt;</span><br><span class="line">&lt;blockquote class&#x3D;&quot;blockquote-center&quot;&gt;HTML引用方式&lt;&#x2F;blockquote&gt;</span><br></pre></td></tr></table></figure>
<!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="blockquote-center" 是必须的 -->
<blockquote class="blockquote-center">HTML引用方式</blockquote>

<h3 id="3-1-2-标签引用方式"><a href="#3-1-2-标签引用方式" class="headerlink" title="3.1.2. 标签引用方式:"></a>3.1.2. 标签引用方式:</h3><p>使用<code>centerquote</code>或者<code>cq</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;</span><br><span class="line">&#123;% centerquote %&#125;标签引用方式1&#123;% endcenterquote %&#125;</span><br><span class="line">&lt;!-- 标签别名 --&gt;</span><br><span class="line">&#123;% cq %&#125;标签引用方式2&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>
<!-- 标签 方式，要求版本在0.4.5或以上 -->
<blockquote class="blockquote-center">
<p>标签引用方式1</p>

</blockquote>
<!-- 标签别名 -->
<blockquote class="blockquote-center">
<p>标签引用方式2</p>

</blockquote>

<h2 id="3-2-突破容器宽度限制的图片引用"><a href="#3-2-突破容器宽度限制的图片引用" class="headerlink" title="3.2. 突破容器宽度限制的图片引用"></a>3.2. 突破容器宽度限制的图片引用</h2><p>当使用此标签引用图片时，图片将自动扩大26%，并突破文章容器的宽度。此标签使用于需要突出显示的图片,图片的扩大与容器的偏差从视觉上提升图片的吸引力。此标签有两种调用方式（详细参看底下示例）：</p>
<h3 id="3-2-1-HTML引用图片方式"><a href="#3-2-1-HTML引用图片方式" class="headerlink" title="3.2.1. HTML引用图片方式"></a>3.2.1. HTML引用图片方式</h3><p>使用这种方式时，为<code>img</code>添加属性<code>class="full-image"</code>即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML引用图片方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class&#x3D;&quot;full-image&quot; 是必须的 --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;cdn.wfolio.ru&#x2F;w&#x2F;4b318a3da2f7d3a89fa5957a8dd9a00dd2609616&#x2F;m_limit%2Cw_1920&#x2F;sites&#x2F;181&#x2F;assets&#x2F;1524794399_7fc3ff.jpg&quot; class&#x3D;&quot;full-image&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<!-- HTML引用图片方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="full-image" 是必须的 -->

<img data-src="https://cdn.wfolio.ru/w/4b318a3da2f7d3a89fa5957a8dd9a00dd2609616/m_limit%2Cw_1920/sites/181/assets/1524794399_7fc3ff.jpg" class="full-image" />


<h1 id="4-Bootstrap-Callout"><a href="#4-Bootstrap-Callout" class="headerlink" title="4. Bootstrap Callout"></a>4. Bootstrap Callout</h1><p>这些样式出现在<a href="http://getbootstrap.com/">Bootstrap官方文档</a>中。</p>
<p><strong>使用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code>可以是以下一个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">primary</span><br><span class="line">success</span><br><span class="line">info</span><br><span class="line">warning</span><br><span class="line">danger</span><br></pre></td></tr></table></figure>
<p>代码实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;1.default效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary %&#125;2.primary效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success %&#125;3.success效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info %&#125;4.info效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning %&#125;5.warning效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger %&#125;6.danger效果&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note default"><p>1.default效果</p>
</div>
<div class="note primary"><p>2.primary效果</p>
</div>
<div class="note success"><p>3.success效果</p>
</div>
<div class="note info"><p>4.info效果</p>
</div>
<div class="note warning"><p>5.warning效果</p>
</div>
<div class="note danger"><p>6.danger效果</p>
</div>

<h1 id="5-主题自带样式-label-标签"><a href="#5-主题自带样式-label-标签" class="headerlink" title="5. 主题自带样式 label 标签"></a>5. 主题自带样式 label 标签</h1><p>首先需要在主题配置文件中有配置，需要配置下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit &#x2F;你的Hexo站点目录&#x2F;themes&#x2F;next&#x2F;_config.yml</span><br><span class="line"># Label tag.</span><br><span class="line">label: true</span><br></pre></td></tr></table></figure>
<p>效果如下：(目前存在一个 bug，如果把它加在一段文字的段首，则会有点问题，issue 页面。)</p>
<mark class="label default">default</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label default@default %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label primary">primary</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label primary@primary %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label success">success</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label success@success %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label info">info</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label info@info %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label warning">warning</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label warning@warning %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label danger">danger</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label danger@danger %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-NexT主题自带样式-tabs-标签"><a href="#6-NexT主题自带样式-tabs-标签" class="headerlink" title="6. NexT主题自带样式 tabs 标签"></a>6. NexT主题自带样式 tabs 标签</h1><p>在主题配置文件中有配置，需要配置下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit &#x2F;你的Hexo站点目录&#x2F;themes&#x2F;next&#x2F;_config.yml</span><br><span class="line"># Tabs tag.</span><br><span class="line">tabs:</span><br><span class="line">  enable: true</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 0</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong> 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong></p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong> 哇，你找到我了!</p></div></div></div>

<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 选项卡, 2 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 1** 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 2**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<p>然后上面源码中, 2表示一开始在第二个选项卡，非必须，若数值为-1则隐藏选项卡内容。更多用法请查看 <a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Tab-tag-test">这个页面</a>。</p>
<h1 id="7-主题自带样式–按钮"><a href="#7-主题自带样式–按钮" class="headerlink" title="7. 主题自带样式–按钮"></a>7. 主题自带样式–<strong>按钮</strong></h1><p>效果：</p>
<a class="btn" href="https://www.baidu.com"><i class="fa fa-download fa-lg fa-fw"></i>点击下载百度</a>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% btn https:&#x2F;&#x2F;www.baidu.com, 点击下载百度, download fa-lg fa-fw %&#125;</span><br></pre></td></tr></table></figure>
<p>关于按钮的更多使用可以前往 <a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test">这个网页</a>查看。</p>
<h1 id="8-插入音乐"><a href="#8-插入音乐" class="headerlink" title="8. 插入音乐"></a>8. 插入音乐</h1><p>音乐的话，网易云音乐的外链很好用，不仅有可以单曲，还能有歌单，有兴趣的自己去网易云音乐找首歌尝试。但是有一些音乐因为版权原因放不了，还有就是不完全支持 https，导致小绿锁不见了。要解决这些缺点，就需要安装插件alien。</p>
<h2 id="8-1-方法1：可以直接用-HTML-的标签，写法如下："><a href="#8-1-方法1：可以直接用-HTML-的标签，写法如下：" class="headerlink" title="8.1. 方法1：可以直接用 HTML 的标签，写法如下："></a>8.1. 方法1：可以直接用 HTML 的标签，写法如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;audio src&#x3D;&quot;https:&#x2F;&#x2F;什么什么什么.mp3&quot; style&#x3D;&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls&#x3D;&quot;controls&quot; loop&#x3D;&quot;loop&quot; preload&#x3D;&quot;meta&quot;&gt;Your browser does not support the audio tag.&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-方法2：用插件，有显示歌词功能，也美观，建议使用这种方法。"><a href="#8-2-方法2：用插件，有显示歌词功能，也美观，建议使用这种方法。" class="headerlink" title="8.2. 方法2：用插件，有显示歌词功能，也美观，建议使用这种方法。"></a>8.2. 方法2：用插件，有显示歌词功能，也美观，建议使用这种方法。</h2><p>首先在<code>站点</code>文件夹根目录安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>

<p>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;歌曲名&quot; &quot;歌手名&quot; &quot;https:&#x2F;&#x2F;什么什么什么.mp3&quot; &quot;https:&#x2F;&#x2F;封面图.jpg&quot; &quot;lrc:https:&#x2F;&#x2F;歌词.lrc&quot; %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外可以支持歌单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlist %&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;autoplay&quot;: false,</span><br><span class="line">    &quot;showlrc&quot;: 3,</span><br><span class="line">    &quot;mutex&quot;: true,</span><br><span class="line">    &quot;music&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;title&quot;: &quot;歌曲名&quot;,</span><br><span class="line">            &quot;author&quot;: &quot;歌手名&quot;,</span><br><span class="line">            &quot;url&quot;: &quot;https:&#x2F;&#x2F;什么什么什么.mp3&quot;,</span><br><span class="line">            &quot;pic&quot;: &quot;https:&#x2F;&#x2F;封面图.jpg&quot;,</span><br><span class="line">            &quot;lrc&quot;: &quot;https:&#x2F;&#x2F;歌词.lrc&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;title&quot;: &quot;歌曲名&quot;,</span><br><span class="line">            &quot;author&quot;: &quot;歌手名&quot;,</span><br><span class="line">            &quot;url&quot;: &quot;https:&#x2F;&#x2F;什么什么什么.mp3&quot;,</span><br><span class="line">            &quot;pic&quot;: &quot;https:&#x2F;&#x2F;封面图.jpg&quot;,</span><br><span class="line">            &quot;lrc&quot;: &quot;https:&#x2F;&#x2F;歌词.lrc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>

<p>效果可以见<a href="https://reuixiy.github.io/uncategorized/2010/01/01/test.html">易象辞的 Hello World</a>，里面的详细参数见<a href="https://github.com/MoePlayer/hexo-tag-aplayer">README</a> 和这插件的“母亲” Aplayer 的<a href="https://aplayer.js.org/">官方文档</a>。</p>
<h2 id="8-3-下方测试插入音乐"><a href="#8-3-下方测试插入音乐" class="headerlink" title="8.3. 下方测试插入音乐"></a>8.3. 下方测试插入音乐</h2><h3 id="8-3-1-方式1：HTML的标签插入音乐（网易云音乐）"><a href="#8-3-1-方式1：HTML的标签插入音乐（网易云音乐）" class="headerlink" title="8.3.1. 方式1：HTML的标签插入音乐（网易云音乐）"></a>8.3.1. 方式1：HTML的标签插入音乐（网易云音乐）</h3><p>网易云音乐 -&gt; 生成外链播放器 -&gt; 复制代码 -&gt; 粘贴到md文档</p>
<p>网易云iframe插件：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=414611053&auto=1&height=66"></iframe>

<p>网易云flash插件：</p>
<p><embed src="//music.163.com/style/swf/widget.swf?sid=414611053&type=2&auto=1&width=320&height=66" width="340" height="86"  allowNetworking="all"></embed></p>
<h3 id="8-3-2-方式2：用hexo-tag-aplayer插件音乐"><a href="#8-3-2-方式2：用hexo-tag-aplayer插件音乐" class="headerlink" title="8.3.2. 方式2：用hexo-tag-aplayer插件音乐"></a>8.3.2. 方式2：用hexo-tag-aplayer插件音乐</h3><p>巧取网易云音乐mp3外链方法，不知到现在有没有被禁<br>例如：在网易云网页版点击”陈芳语-爱你”，从浏览器地址栏发现”陈芳语-爱你”的id为：22852057，则将下方代码’id&#x3D;’后的数字更改为‘22852057’之后就是”陈芳语-爱你”mp3格式的外链，新建标签页粘贴该地址可直接播放，应用在博客里插入外链还是很方便的（ps:在网易云还没禁用此bug之前）。</p>
<p>将歌词文件放在“hexo站点文件夹&#x2F;source&#x2F;uploads&#x2F;”文件夹内，封面图、歌词文件引用地址为：<br>“<a href="https://haoleeson.github.io/uploads/%E5%B0%81%E9%9D%A2%E5%9B%BE.jpg&quot;%E3%80%81&quot;https://haoleeson.github.io/uploads/%E6%AD%8C%E8%AF%8D.lrc&quot;">https://haoleeson.github.io/uploads/封面图.jpg&quot;、&quot;https://haoleeson.github.io/uploads/歌词.lrc&quot;</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 网易云网页版关于&quot;陈芳语-爱你&quot;的歌曲id&#x3D;22852057</span><br><span class="line">http:&#x2F;&#x2F;music.163.com&#x2F;song&#x2F;media&#x2F;outer&#x2F;url?id&#x3D;22852057.mp3 #可直接播放外链（已失效）</span><br><span class="line">https:&#x2F;&#x2F;haoleeson.github.io&#x2F;uploads&#x2F;loveYou.jpg #封面图</span><br><span class="line">https:&#x2F;&#x2F;haoleeson.github.io&#x2F;uploads&#x2F;fangyuchen_loveyou.lrc #歌词 &#x2F;&#x2F;暂时无法添加lrc歌词，只能内嵌歌词</span><br></pre></td></tr></table></figure>

<h2 id="8-4-下方测试插件插入音乐（无歌词，lrc方式歌词失效）："><a href="#8-4-下方测试插件插入音乐（无歌词，lrc方式歌词失效）：" class="headerlink" title="8.4. 下方测试插件插入音乐（无歌词，lrc方式歌词失效）："></a>8.4. 下方测试插件插入音乐（无歌词，lrc方式歌词失效）：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;爱你&quot; &quot;陈芳语&quot; &quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;uploads&#x2F;22852057.mp3&quot; &quot;https:&#x2F;&#x2F;haoleeson.github.io&#x2F;uploads&#x2F;loveYou.jpg&quot; &quot;lrc:https:&#x2F;&#x2F;haoleeson.github.io&#x2F;uploads&#x2F;fangyuchen_loveyou.lrc&quot; %&#125;</span><br></pre></td></tr></table></figure>


        <div id="aplayer-WlswoDzX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-WlswoDzX"),
            narrow: false,
            autoplay: false,
            showlrc: 3,
            music: {
              title: "爱你",
              author: "陈芳语",
              url: "../../../../uploads/22852057.mp3",
              pic: "https://haoleeson.github.io/uploads/loveYou.jpg",
              lrc: "https://haoleeson.github.io/uploads/fangyuchen_loveyou.lrc"
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h2 id="8-5-下方测试插件插入内嵌音乐歌词："><a href="#8-5-下方测试插件插入内嵌音乐歌词：" class="headerlink" title="8.5. 下方测试插件插入内嵌音乐歌词："></a>8.5. 下方测试插件插入内嵌音乐歌词：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlrc &quot;爱你&quot; &quot;陈芳语&quot; &quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;uploads&#x2F;22852057.mp3&quot; &quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;uploads&#x2F;loveYou.jpg&quot; %&#125;</span><br><span class="line">[00:00.25]Kimberley(陈芳语) - 爱你[00:06.43]我闭上眼睛 贴着你心跳呼吸[00:13.42]而此刻地球 只剩我们而已[00:20.16]你微笑的唇型 总勾着我的心[00:26.73]每一秒初吻 我每一秒都想要吻你[00:36.11]就这样 爱你 爱你 爱你 随时都要一起[00:42.43]我喜欢 爱你 外套 味道 还有你的怀里[00:49.11]把我们 衣服 钮扣 互扣 那就不用分离[00:56.49]美好爱情 我就爱这样贴近 因为你[01:16.85]有时没生气 故意闹脾气[01:23.42]你的紧张在意 让我觉得安心[01:30.04]从你某个角度 我总看见自己[01:36.76]到底你懂我 或其时我本来就像你[01:46.17]就这样 爱你 爱你 爱你 随时都要一起[01:52.70]我喜欢 爱你 外套 味道 还有你的怀里[01:59.28]把我们 衣服 钮扣 互扣 那就不用分离[02:06.80]美好爱情 我就爱这样贴近 因为你[02:17.73]想变成你的氧气 溜进你身体里[02:31.49]好好看看在你心里 你有多麽宝贝 我爱你[02:44.44]就这样 爱你 爱你 爱你 随时都要一起 （爱你）[02:49.27]我喜欢 爱你 外套 味道 还有你的怀里[02:55.92]把我们 衣服 钮扣 互扣 那就不用分离[03:03.50]美好爱情 我就爱这样贴近 因为你[03:10.28]我们爱情 会一直没有距离 最美丽</span><br><span class="line">&#123;% endaplayerlrc %&#125;</span><br></pre></td></tr></table></figure>


			<script>
				console.error("Error: [hexo-tag-aplayer] Specified asset file not found (../../../../uploads/loveYou.jpg)");
			</script>

<h1 id="9-插入视频"><a href="#9-插入视频" class="headerlink" title="9. 插入视频"></a>9. 插入视频</h1><h2 id="9-1-可以直接用-HTML-的标签，写法如下："><a href="#9-1-可以直接用-HTML-的标签，写法如下：" class="headerlink" title="9.1. 可以直接用 HTML 的标签，写法如下："></a>9.1. 可以直接用 HTML 的标签，写法如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video poster&#x3D;&quot;https:&#x2F;&#x2F;封面图.jpg&quot; src&#x3D;&quot;https:&#x2F;&#x2F;什么什么什么.mp4&quot; style&#x3D;&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls&#x3D;&quot;controls&quot; loop&#x3D;&quot;loop&quot; preload&#x3D;&quot;meta&quot;&gt;Your browser does not support the video tag.&lt;&#x2F;video&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-2-用第三方视频网站提供的嵌入式代码"><a href="#9-2-用第三方视频网站提供的嵌入式代码" class="headerlink" title="9.2. 用第三方视频网站提供的嵌入式代码"></a>9.2. 用第三方视频网站提供的嵌入式代码</h2><p>如bilibili提供的iframe插件，可在博客md文件中插入以下代码插入视频。获取iframe代码简诉：</p>
<ul>
<li>找到想要分享的视频</li>
<li>点击视频右上角三个竖点按钮 -&gt; 点击功能窗口 -&gt; 点击分享 -&gt; 复制视频的唯一嵌入代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;26361000&amp;cid&#x3D;49053680&amp;page&#x3D;1&amp;season_type&#x3D;1&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>
<iframe src="//player.bilibili.com/player.html?aid=26361000&cid=49053680&page=1&season_type=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></li>
</ul>
<h2 id="9-3-用插件，功能更加强大，比如可以弹幕，非常建议食用。"><a href="#9-3-用插件，功能更加强大，比如可以弹幕，非常建议食用。" class="headerlink" title="9.3. 用插件，功能更加强大，比如可以弹幕，非常建议食用。"></a>9.3. 用插件，功能更加强大，比如可以弹幕，非常建议食用。</h2><p>首先在站点文件夹根目录安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure>
<p>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer &quot;url&#x3D;https:&#x2F;&#x2F;什么什么什么.mp4&quot; &quot;https:&#x2F;&#x2F;封面图.jpg&quot; &quot;api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer&#x2F;&quot; &quot;id&#x3D;&quot; &quot;loop&#x3D;false&quot; %&#125;</span><br></pre></td></tr></table></figure>
<p>要使用弹幕，必须有<code>api</code>和<code>id</code>两项，并且若使用的是官方的api地址（即上面的），id的值不能与<a href="https://api.prprpr.me/dplayer/list">这个列表</a>的值一样。id的值自己随便取，唯一要求就是前面这点。</p>
<p>如果唯一要求难倒了你，可以使用<a href="http://tool.oschina.net/encrypt?type=2">这个工具</a>将一段与众不同的文字joy生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>效果，在这<a href="https://reuixiy.github.io/tags/video/">易象辞的博客的video</a>标签里自己找一篇文章看看。</p>
<p>当然，这个插件的功能还有很多，可以去<a href="https://github.com/MoePlayer/hexo-tag-dplayer">README</a>和这插件的“母亲” Dplayer 的<a href="https://dplayer.js.org/">官方文档</a>看看。</p>
<ul>
<li><ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="10-Linux-技巧每日一练：cp命令"><a href="#10-Linux-技巧每日一练：cp命令" class="headerlink" title="10. Linux 技巧每日一练：cp命令"></a>10. Linux 技巧每日一练：cp命令</h1><blockquote>
<p>cp命令。用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。</p>
</blockquote>
<blockquote>
<p>cp语法: cp(选项)(参数)</p>
</blockquote>
<p>复制Folder文件夹所有文件到Backup文件夹，并显示所有改动的文件，常用于文件备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -ruv Folder&#x2F;* Backup</span><br></pre></td></tr></table></figure>

<h2 id="10-1-选项参数及说明"><a href="#10-1-选项参数及说明" class="headerlink" title="10.1. 选项参数及说明"></a>10.1. 选项参数及说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a    此参数的效果和同时指定&quot;-dpR&quot;参数相同；</span><br><span class="line">-d    当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；</span><br><span class="line">-f    强行复制文件或目录，不论目标文件或目录是否已存在；</span><br><span class="line">-i    覆盖既有文件之前先询问用户；</span><br><span class="line">-l    对源文件建立硬连接，而非复制文件；</span><br><span class="line">-p    保留源文件或目录的属性；</span><br><span class="line">-R&#x2F;r  递归处理，将指定目录下的所有文件与子目录一并处理；</span><br><span class="line">-s    对源文件建立符号连接，而非复制文件；</span><br><span class="line">-u    使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；</span><br><span class="line">-S    在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；</span><br><span class="line">-b    覆盖已存在的文件目标前将目标文件备份；</span><br><span class="line">-v    详细显示命令执行的操作。</span><br></pre></td></tr></table></figure>

<h1 id="11-参考文档"><a href="#11-参考文档" class="headerlink" title="11. 参考文档"></a>11. 参考文档</h1><ul>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98">reuixiy</a></li>
<li><a href="https://blog.csdn.net/WilliamZ98/article/details/81074219">Hexo 使用 Markdown 编辑技巧大全</a></li>
<li><a href="https://blog.csdn.net/chwshuang/article/details/52350551">Hexo在Github中搭建博客系统(5)Markdown语法</a></li>
<li><a href="http://theme-next.iissnan.com/tag-plugins.html">Next-内置标签</a></li>
<li><a href="http://man.linuxde.net/cp">Linux命令大全</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
