<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>配置Manjaro</title>
    <url>/2018/09/23/AfterInstallManjaro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AfterInstallManjaro.png" class="full-image" />

<h1 id="1-Manjaro设置国内源"><a href="#1-Manjaro设置国内源" class="headerlink" title="1. Manjaro设置国内源"></a>1. Manjaro设置国内源</h1><h2 id="1-1-添加官方镜像源-包括-core-extra-community-multilib"><a href="#1-1-添加官方镜像源-包括-core-extra-community-multilib" class="headerlink" title="1.1. 添加官方镜像源(包括: core, extra, community, multilib)"></a>1.1. 添加官方镜像源(包括: core, extra, community, multilib)</h2><figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank &#x2F;&#x2F;更新镜像排名</span><br><span class="line">sudo pacman -Syy &#x2F;&#x2F;更新数据源</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-2-添加archlinxCN源-中科大"><a href="#1-2-添加archlinxCN源-中科大" class="headerlink" title="1.2. 添加archlinxCN源(中科大)"></a>1.2. 添加archlinxCN源(中科大)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;pacman.conf</span><br></pre></td></tr></table></figure>
<p>以管理员权限修改/etc/pacman.conf，在pacman.conf文件末尾添加以下内容</p>
<figure class="highlight plain"><figcaption><span>文件位置：/etc/pacman.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"># USTC</span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel &#x3D; Optional TrustedOnly</span><br><span class="line">Server &#x3D;https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure>
<p>修改配置文件后，执行下面的命令：</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -Syy</span><br><span class="line">sudo pacman -Syyu #(可选) 升级系统到最新</span><br><span class="line">sudo pacman -S archlinuxcn-keyring &#x2F;&#x2F;安装导入GPG key</span><br></pre></td></tr></table></figure>

<h2 id="1-3-添加AUR源"><a href="#1-3-添加AUR源" class="headerlink" title="1.3. 添加AUR源"></a>1.3. 添加AUR源</h2><p>修改/etc/yaourtrc文件，去掉 # AURURL 的注释，添加清华AUR源</p>
<figure class="highlight plain"><figcaption><span>文件位置：/etc/yaourtrc</span></figcaption><table><tr><td class="code"><pre><span class="line">AURURL&#x3D;&quot;https:&#x2F;&#x2F;aur.tuna.tsinghua.edu.cn&quot;  #添加清华AUR源</span><br></pre></td></tr></table></figure>

<h1 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h1><figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S git</span><br></pre></td></tr></table></figure>
<ul>
<li>Git配置</li>
</ul>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;youremail@example.com&quot;</span><br><span class="line">git config --list #查看配置</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑配置信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure>
<p>查看内容是否如下：</p>
<figure class="highlight plain"><figcaption><span>文件位置：~/.gitconfig</span></figcaption><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">name &#x3D; Your Name</span><br><span class="line">email &#x3D; youremail@domain.com</span><br></pre></td></tr></table></figure>

<ul>
<li>创建公钥(一路回车，全部默认)：</li>
</ul>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">ssh-keygen -C &#39;you email address@gmail.com&#39; -t rsa</span><br></pre></td></tr></table></figure>

<ul>
<li><p>复制公钥<br>打开刚刚新建的公钥，并复制文件所有内容 Ctrl + A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit &#x2F;home&#x2F;eisenhao&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传公钥到GitHub<br>将复制的代码上传到GitHub，打开 <a href="https://www.github.com/">GitHub.com</a>，登录后点击界面右上角用户图标，选择 Account Settings ==&gt; SSH Public Keys ==&gt; 粘贴刚刚复制的代码。</p>
</li>
<li><p>测试验证</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">ssh -v git@github.com</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="3-安装VIM"><a href="#3-安装VIM" class="headerlink" title="3. 安装VIM"></a>3. 安装VIM</h1><ul>
<li><p>安装vim, ctags<br>打开ADD/REMOVE软件管理包，搜索vim、ctags并安装，或输入以下命令安装</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S vim #vim文本编辑器</span><br><span class="line">sudo pacman -S ctags #generates index tool</span><br></pre></td></tr></table></figure>
<p>vim已安装完成，以下为导入GitHub大神分享的vim的IDE配置步骤，可调至下一个标题</p>
</li>
<li><p>打开终端，执行下面的命令自动下载<a href="https://github.com/ma6174/vim-deprecated">GitHub上一个做好的IDE式VIM:</a>组件</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">wget -qO- https:&#x2F;&#x2F;raw.github.com&#x2F;ma6174&#x2F;vim&#x2F;master&#x2F;setup.sh | sh -x</span><br></pre></td></tr></table></figure>
</li>
<li><p>终端输入:”vim”, 打开vim</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">vim</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令模式输入:”:BundleInstall”自动安装<br>“Shift” + “;”进入命令模式，在窗口左下角粘贴(Ctrl+Shift+V)以下代码后回车以自动安装组件</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：vim命令模式下</span></figcaption><table><tr><td class="code"><pre><span class="line">BundleInstall</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后打开配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加如下配置</p>
<figure class="highlight plain"><figcaption><span>文件位置：~/.vimrc</span></figcaption><table><tr><td class="code"><pre><span class="line">&quot;显示空格 回车符</span><br><span class="line">&quot; set listchars&#x3D;eol:$(行尾),tab:&gt;-(制表符),trail:~(空格),extends:&gt;,precedes:&lt;</span><br><span class="line">set listchars&#x3D;tab:&gt;-,trail:-,extends:&gt;,precedes:&lt;</span><br><span class="line">highlight WhitespaceEOL ctermbg&#x3D;red guibg&#x3D;red</span><br><span class="line">match WhitespaceEOL &#x2F;\s\+$&#x2F;</span><br><span class="line">set list</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="4-安装Node-js"><a href="#4-安装Node-js" class="headerlink" title="4. 安装Node.js"></a>4. 安装Node.js</h1><p>安装 Node.js 的最佳方式是使用 nvm。先卸载系统预装的nvm和nodejs</p>
<ul>
<li>卸载预装nvm<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Q | grep nvm</span><br><span class="line">sudo pacman -Rns nvm</span><br></pre></td></tr></table></figure></li>
<li>卸载预装nodejs<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Q | grep nodejs</span><br><span class="line">sudo pacman -Rns nodejs #</span><br></pre></td></tr></table></figure></li>
<li>先通过cURL方式安装nvm:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.11&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure></li>
<li>待nvm安装完成后，重启终端 并执行下列命令即可安装 Node.js。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install stable #安装 Node.js</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="5-安装ZSH-可不更改，默认bash也不错"><a href="#5-安装ZSH-可不更改，默认bash也不错" class="headerlink" title="5. 安装ZSH(可不更改，默认bash也不错)"></a>5. <del>安装ZSH</del>(可不更改，默认bash也不错)</h1><p>ZSH可以说是shell中的极品，它的优点太多了，我就不一一写出来，有兴趣的同学可以看这篇文章知乎-为什么说zsh是shell中的极品，参考<a href="https://me.csdn.net/gatieme">JeanCheng</a>的这篇博文：<a href="https://blog.csdn.net/gatieme/article/details/52741221">Linux终极shell-Z Shell–用强大的zsh &amp; oh-my-zsh把Bash换掉</a></p>
<ul>
<li><p>安装zsh</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S zsh</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置oh-my-zsh</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取代bash，设为默认shell</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo usermod -s &#x2F;bin&#x2F;zsh username1</span><br><span class="line">或者</span><br><span class="line">chsh -s &#x2F;bin&#x2F;zsha</span><br><span class="line">chsh -s &#x2F;bin&#x2F;zsh1</span><br><span class="line">chsh -s &#96;which zsh&#96;1</span><br></pre></td></tr></table></figure>
<p>Finish，zsh已经安装完了</p>
</li>
<li><p>如果要切换回去bash：<br>想知道你的系统有几种shell，可以通过以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;shells</span><br></pre></td></tr></table></figure>
<p>切换回去bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>当然你实在不愿意把zsh当成默认的shell, 而又想使用它, 那么你可以每次进入是都使用<strong>zsh</strong>进入, 而输入exit退出</p>
</li>
</ul>
<h1 id="6-安装IBus拼音输入法"><a href="#6-安装IBus拼音输入法" class="headerlink" title="6. 安装IBus拼音输入法"></a>6. 安装IBus拼音输入法</h1><ul>
<li><p>搜索安装ibus-pinyin</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S ibus-pinyin</span><br></pre></td></tr></table></figure>
</li>
<li><p>在”系统设置” ==&gt; “语言-配置” 中点击“+”添加刚刚安装的chinese-pinyin输入法</p>
</li>
</ul>
<h1 id="7-用Terminator替换默认的Terminal终端"><a href="#7-用Terminator替换默认的Terminal终端" class="headerlink" title="7. 用Terminator替换默认的Terminal终端"></a>7. 用Terminator替换默认的Terminal终端</h1><h2 id="7-1-安装Terminator"><a href="#7-1-安装Terminator" class="headerlink" title="7.1. 安装Terminator"></a>7.1. 安装Terminator</h2><figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S Terminator</span><br></pre></td></tr></table></figure>
<h2 id="7-2-设置Terminator启动快捷键。"><a href="#7-2-设置Terminator启动快捷键。" class="headerlink" title="7.2. 设置Terminator启动快捷键。"></a>7.2. 设置Terminator启动快捷键。</h2><p>打开系统设置，依次”Devices” ==&gt; “keyboard” ==&gt; 点击最末’+’ ==&gt; Name:”Open Terminator” ==&gt; Command:”/usr/bin/terminator” ==&gt; 设置启动快捷键(如：Ctrl+Alt+T)。</p>
<h2 id="7-3-配置Terminator配色及透明度。"><a href="#7-3-配置Terminator配色及透明度。" class="headerlink" title="7.3. 配置Terminator配色及透明度。"></a>7.3. 配置Terminator配色及透明度。</h2><p>右键窗体点击”Preferences” ==&gt; “Colors” ==&gt; Built-in schemes选择配色(如:”Green on black”) ==&gt; “Background” ==&gt; 勾选”Transparent background” ==&gt; 设置透明度Shade transparent background:(推荐0.8)</p>
<h2 id="7-4-Terminator常用快捷键"><a href="#7-4-Terminator常用快捷键" class="headerlink" title="7.4. Terminator常用快捷键"></a>7.4. Terminator常用快捷键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+Shift+C            #复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V            #粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+O            #上下开新窗口</span><br><span class="line">Ctrl+Shift+Up&#x2F;Down      #分割条向上、下移动（终端上下多开窗口时）</span><br><span class="line">Alt+Up&#x2F;Down             #上、下窗口切换（终端上下多开窗口时）</span><br><span class="line">Ctrl+Shift+W            #关闭当前终端</span><br><span class="line">Ctrl+Shift+F            #搜索</span><br><span class="line">#标签页快捷键</span><br><span class="line">F11                     #全屏开关</span><br><span class="line">Ctrl+Shift+T            #打开一个新的标签</span><br><span class="line">Ctrl+PageDown           #移动到下一个标签</span><br><span class="line">Ctrl+PageUp             #移动到上一个标签</span><br></pre></td></tr></table></figure>

<h1 id="8-编译环境安装-Gcc-Java-Python"><a href="#8-编译环境安装-Gcc-Java-Python" class="headerlink" title="8. 编译环境安装(Gcc, Java, Python)"></a>8. 编译环境安装(Gcc, Java, Python)</h1><h2 id="8-1-安装gcc-make-cmake-gdb环境"><a href="#8-1-安装gcc-make-cmake-gdb环境" class="headerlink" title="8.1. 安装gcc make cmake gdb环境"></a>8.1. 安装gcc make cmake gdb环境</h2><ul>
<li><p>安装gcc, make, cmake, gdb</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S gcc make cmake gdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看GCC环境是否配置成功</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="8-2-安装JAVA环境"><a href="#8-2-安装JAVA环境" class="headerlink" title="8.2. 安装JAVA环境"></a>8.2. 安装JAVA环境</h2><ul>
<li><p><del>在主目录下，创建JAVA环境包存放目录</del>（用更简便方式代替）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~&#x2F;Environment&#x2F;JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>下载JDK <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JAVA SE下载地址</a>，下载到刚刚创建的目录。选择自己的安装平台，我选择的是”jdk-8u181-linux-x64.tar.gz”，如果下载的不是这个JDK包，后面的涉及JDK包文件时跟换到你的JDK包名就可。</del></p>
</li>
<li><p><del>跳转到压缩包目录解压</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Environment&#x2F;JAVA  #跳转到压缩包目录</span><br><span class="line">tar -xvf jdk-8u181-linux-x64.tar.gz  #解压JDK包</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>解压完成后，打开环境配置文件.bashrc(若配置了刚刚的zsh，则打开～/.zshrc)</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.bashrc</span><br><span class="line">#或</span><br><span class="line">vim ~&#x2F;.zshrc #若刚刚已配置zsh</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>添加如下Java环境配置代码到文件末尾</del></p>
<figure class="highlight plain"><figcaption><span>文件位置：~/.bashrc 或 ~/.zshrc</span></figcaption><table><tr><td class="code"><pre><span class="line">#JAVA环境配置</span><br><span class="line">export JAVA_HOME&#x3D;$HOME&#x2F;Environment&#x2F;JAVA&#x2F;jdk1.8.0_181</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;dt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;tools.jar</span><br><span class="line">#IDEA软件需用到</span><br><span class="line">export IDEA_JDK&#x3D;$HOME&#x2F;Environment&#x2F;JAVA&#x2F;jdk1.8.0_181</span><br><span class="line">export IDEA_JDK_64&#x3D;$HOME&#x2F;Environment&#x2F;JAVA&#x2F;jdk1.8.0_181</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>生效刚刚配置的JAVA环境：</del></p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br><span class="line">或</span><br><span class="line">source ~&#x2F;.zshrc #若刚刚已配置zsh</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>查看JAVA环境是否配置成功</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="8-3-通过’Add-Remove-Software’软件自动安装JAVA环境"><a href="#8-3-通过’Add-Remove-Software’软件自动安装JAVA环境" class="headerlink" title="8.3. 通过’Add/Remove Software’软件自动安装JAVA环境"></a>8.3. 通过’Add/Remove Software’软件<strong>自动安装JAVA环境</strong></h2><ul>
<li>删除系统预装的openjdk<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Q | grep opnjdk #删除openjdk,&#39;sudo pacman -Q&#39;为查询已装软件，&#39;| grep&#39; 只显示与&#39;opnjdk&#39;相关内容</span><br><span class="line">sudo pacman -Rns openjdk # sudo pacman -Rns 最小破换性地卸载（推荐），有效防止删除A软件时误删B软件所需的依赖(大致是这意思吧)..</span><br><span class="line">sudo pacman -Rns openjdkheadless #删除openjdk相关</span><br></pre></td></tr></table></figure></li>
<li>使用’Add/Remove Software’软件智能安装JAVA环境，不需手动配置(推荐)<br>在搜索框中搜索’jdk8’关键字，勾选’jdk8’(Oracle Java 8 Development Kit)’，再点击应用即可安装。</li>
</ul>
<h2 id="8-4-安装Python环境-系统已经预装Python2-7和Python3-7-默认"><a href="#8-4-安装Python环境-系统已经预装Python2-7和Python3-7-默认" class="headerlink" title="8.4. 安装Python环境(系统已经预装Python2.7和Python3.7(默认))"></a>8.4. <del>安装Python环境</del>(系统已经预装Python2.7和Python3.7(默认))</h2><h3 id="8-4-1-安装Python3-7"><a href="#8-4-1-安装Python3-7" class="headerlink" title="8.4.1. 安装Python3.7"></a>8.4.1. 安装Python3.7</h3><ul>
<li>直接在软件管理包中搜索”python  3.7.0-3”手动安装即可</li>
<li>或用pacman安装安装Python3.7<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S python3.7</span><br></pre></td></tr></table></figure></li>
<li>查看Python环境是否配置成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-4-2-手动安装数据处理必备Numpy模块-较麻烦且容易失败，后文介绍用pip3方式安装"><a href="#8-4-2-手动安装数据处理必备Numpy模块-较麻烦且容易失败，后文介绍用pip3方式安装" class="headerlink" title="8.4.2. 手动安装数据处理必备Numpy模块(较麻烦且容易失败，后文介绍用pip3方式安装)"></a>8.4.2. <del>手动安装数据处理必备Numpy模块</del>(较麻烦且容易失败，后文介绍用pip3方式安装)</h3><p><del>参考自<a href="https://blog.csdn.net/chenyefei/article/details/77289289?utm_source=blogxgwz0">linux下python3安装numpy与scipy</a>，由于numpy依赖于nose，故在需先安装依赖包nose，再安装numpy。</del></p>
<ul>
<li><p><del>安装Python的nose模块</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Downloads</span><br><span class="line">wget https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;38&#x2F;96&#x2F;7aa1c2583ddec558a230175d6aeddba796cde7191852bf3e6eb3cfb873e1&#x2F;nose-1.1.2.tar.gz &#x2F;&#x2F;下载nose-1.1.2</span><br><span class="line">tar -zxvf nose-1.1.2.tar.gz &#x2F;&#x2F;解压nose安装包(以实际下载的包名为准)</span><br><span class="line">cd nose-1.1.2 &#x2F;&#x2F;进入刚刚解压的目录</span><br><span class="line">sudo python3 setup.py install &#x2F;&#x2F;执行安装命令以安装nose </span><br></pre></td></tr></table></figure>
</li>
<li><p><del>安装Python的atlas模块</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Downloads</span><br><span class="line">wget https:&#x2F;&#x2F;files.pythonhosted.org&#x2F;packages&#x2F;3b&#x2F;30&#x2F;a02c60e3a232cfcfdb9910ea2b5b83a567efeb1d3f1cb4622ce3eba63f9d&#x2F;atlas-0.27.0.tar.gz &#x2F;&#x2F;下载atlas-0.27.0</span><br><span class="line">tar -zxvf atlas-0.27.0.tar.gz &#x2F;&#x2F;解压atlas安装包(以实际下载的包名为准)</span><br><span class="line">cd atlas-0.27.0 &#x2F;&#x2F;进入刚刚解压的目录</span><br><span class="line">sudo python3 setup.py install &#x2F;&#x2F;执行安装命令以安装atlas</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>安装Python的numpy模块</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Downloads</span><br><span class="line">wget https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;numpy&#x2F;files&#x2F;NumPy&#x2F;1.9.0&#x2F;numpy-1.9.0.zip &#x2F;&#x2F;下载numpy包</span><br><span class="line">unzip numpy-1.9.0.zip &#x2F;&#x2F;解压numpy包</span><br><span class="line">cd numpy-1.9.0 &#x2F;&#x2F;进入刚刚解压的目录</span><br><span class="line">sudo python3 setup.py install &#x2F;&#x2F;执行安装命令安装numpy</span><br></pre></td></tr></table></figure>
<p>安装完成后可用以下命令测试是否成功安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import numpy; numpy.test()&#39;</span><br></pre></td></tr></table></figure></li>
<li><p><del>Python数据处理常用包</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">各个安装包：</span><br><span class="line">scipy-0.19.0  下载：https:&#x2F;&#x2F;github.com&#x2F;scipy&#x2F;scipy</span><br><span class="line">numpy-1.9.0  下载：https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;numpy&#x2F;files&#x2F;NumPy&#x2F;1.9.0&#x2F;numpy-1.9.0.zip</span><br><span class="line">nose-1.1.2   下载：https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;38&#x2F;96&#x2F;7aa1c2583ddec558a230175d6aeddba796cde7191852bf3e6eb3cfb873e1&#x2F;nose-1.1.2.tar.gz</span><br><span class="line">lapack-3.7.1   下载： www.netlib.org&#x2F;lapack&#x2F;lapack-3.7.1.tgz</span><br><span class="line">atlas-0.27.0   下载： https:&#x2F;&#x2F;files.pythonhosted.org&#x2F;packages&#x2F;3b&#x2F;30&#x2F;a02c60e3a232cfcfdb9910ea2b5b83a567efeb1d3f1cb4622ce3eba63f9d&#x2F;atlas-0.27.0.tar.gz</span><br><span class="line">Cython-0.26    下载： https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;Cython&#x2F;0.26</span><br><span class="line">依赖关系：scipy 的安装需要依赖于 numpy、lapack、atlas（后两者都是线性代数工具包，而 numpy 和scipy 的测试程序的运行又依赖于 nose，因此，整个安装过程必须要按顺序执行的，否则是无法执行下去的。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-4-3-使用pip3安装Numpy模块"><a href="#8-4-3-使用pip3安装Numpy模块" class="headerlink" title="8.4.3. 使用pip3安装Numpy模块"></a>8.4.3. 使用pip3安装Numpy模块</h3><p>访问<a href="https://pypi.org/">Python packages</a>网站搜索相应模块(如”Numpy”),本地管理员运行其pip3安装代码<code>pip3 install numpy</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple numpy</span><br></pre></td></tr></table></figure>

<p><strong>同理顺序安装其他模块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple numpy        &#x2F;&#x2F;安装Numpy库:提供数组支持，以及相应的高效的处理函数</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple SciPy        &#x2F;&#x2F;安装SciPy库：提供矩阵支持，以及矩阵相关的数值计算模块</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple matplotlib   &#x2F;&#x2F;安装Matplotlib库：强大的数据可视化工具、作图库</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple pandas       &#x2F;&#x2F;安装Pandas库：强大、灵活的数据分析和探索工具</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple statsmodels  &#x2F;&#x2F;安装StatsModels库：统计建模和计量经济学，包括描述统计、统计模型估计和推断</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple scikit-learn &#x2F;&#x2F;安装Scikit-Learn库：支持回归、分类、聚类等强大的机器学习库</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple keras        &#x2F;&#x2F;安装Keras库：深度学习库，用于建立神经网络以及深度学习模型</span><br><span class="line">sudo pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple gensim       &#x2F;&#x2F;安装Gensim库：用来做文本主题模型的库，可能用于文本挖掘</span><br></pre></td></tr></table></figure>

<h1 id="9-常用软件安装"><a href="#9-常用软件安装" class="headerlink" title="9. 常用软件安装"></a>9. 常用软件安装</h1><ul>
<li>工具软件<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S git #代码仓库</span><br><span class="line">sudo pacman -S ctags #generates index tool</span><br><span class="line">sudo pacman -S vim #vim文本编辑器</span><br><span class="line">sudo pacman -S zsh #shell中的极品</span><br><span class="line">sudo pacman -S ibus-pinyin #中文输入法支持</span><br><span class="line">sudo pacman -S python-pip #Python Packages安装工具</span><br><span class="line">sudo pacman -S nvm #Nodejs版本管理器，可以轻松切换Nodejs版本</span><br><span class="line">sudo pacman -S nodejs #Nodejs</span><br><span class="line">sudo pacman -S npm</span><br></pre></td></tr></table></figure></li>
<li>应用软件<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S google-chrome #谷歌浏览器</span><br><span class="line">sudo pacman -S netease-cloud-music #网易云音乐</span><br><span class="line">sudo pacman -S electronic-wechat #微信</span><br><span class="line">sudo pacman -S typora #Typora,Markdown文档编辑器</span><br><span class="line">sudo pacman -S Shadowsocks-Qt5 #VPN梯子</span><br></pre></td></tr></table></figure></li>
<li>生产工具<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S gcc make cmake gdb #安装gcc，make, cmake，gdb环境</span><br><span class="line">sudo pacman -S clion #C&#x2F;C++集成IDE开发工具</span><br><span class="line">sudo pacman -S IntelliJ IDEA #Java集成IDE开发工具</span><br><span class="line">sudo pacman -S pycharm-professional #python集成IDE开发工具</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="10-系统常见问题及解决方案："><a href="#10-系统常见问题及解决方案：" class="headerlink" title="10. 系统常见问题及解决方案："></a>10. 系统常见问题及解决方案：</h1><h2 id="10-1-Windows和Linux双系统时间不一致问题"><a href="#10-1-Windows和Linux双系统时间不一致问题" class="headerlink" title="10.1. Windows和Linux双系统时间不一致问题"></a>10.1. Windows和Linux双系统时间不一致问题</h2><p>如何解决 Windows 和 Linux 双系统时间差8小时的问题 ， <a href="https://blog.csdn.net/aaazz47/article/details/78696899">可参考文章</a></p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo timedatectl set-local-rtc 1</span><br></pre></td></tr></table></figure>
<p>在系统设置-&gt;Details-&gt;Date &amp; Time 中点击Automatic Date &amp; Time联网更新时间</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo hwclock --localtime --systohc #将时间写入硬件</span><br></pre></td></tr></table></figure>
<h2 id="10-2-桌面某些组建不正常显示时，重装gnome即可"><a href="#10-2-桌面某些组建不正常显示时，重装gnome即可" class="headerlink" title="10.2. 桌面某些组建不正常显示时，重装gnome即可"></a>10.2. 桌面某些组建不正常显示时，重装gnome即可</h2><p>桌面不正常显示，或某些显示功能不正常可能出现在通过软件管理包卸载软件时卸载部分未知依赖导致出错，如“系统设置未出现“，重新安装gnome所有组建可解决问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gnome</span><br><span class="line">&#x2F;&#x2F;选择&quot;all&quot;,然后一直确定覆盖安装&quot;y</span><br></pre></td></tr></table></figure>
<h2 id="10-3-解决GitHub访问慢，修改host"><a href="#10-3-解决GitHub访问慢，修改host" class="headerlink" title="10.3. 解决GitHub访问慢，修改host"></a>10.3. 解决GitHub访问慢，修改host</h2><ul>
<li><p>修改hosts文件配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure></li>
<li><p>a.手动查询DNS<br>打开 <a href="http://tool.chinaz.com/dns,%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%90%8D%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%9A%84%E5%B7%A5%E5%85%B7">http://tool.chinaz.com/dns,这是一个查询域名映射关系的工具</a><br>查询 github.global.ssl.fastly.net 和 assets-cdn.github.com 两个地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.global.ssl.fastly.net</span><br><span class="line">assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<p>多查几次，选择一个稳定，延迟较低的 ip 按如下方式添加到host文件</p>
</li>
<li><p>b.使用大神分享的, eg:</p>
<figure class="highlight plain"><figcaption><span>文件位置：/etc/hosts</span></figcaption><table><tr><td class="code"><pre><span class="line"># Github  直接输入IP，可以让git变得非常快</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net </span><br><span class="line">192.30.253.113 github.com </span><br><span class="line">103.245.222.133 assets-cdn.github.com </span><br><span class="line">23.235.47.133 assets-cdn.github.com </span><br><span class="line">203.208.39.104 assets-cdn.github.com </span><br><span class="line">204.232.175.78 documentcloud.github.com </span><br><span class="line">204.232.175.94 gist.github.com </span><br><span class="line">107.21.116.220 help.github.com </span><br><span class="line">207.97.227.252 nodeload.github.com </span><br><span class="line">199.27.76.130 raw.github.com </span><br><span class="line">107.22.3.110 status.github.com </span><br><span class="line">204.232.175.78 training.github.com </span><br><span class="line">207.97.227.243 www.github.com </span><br><span class="line">185.31.16.184 github.global.ssl.fastly.net </span><br><span class="line">185.31.18.133 avatars0.githubusercontent.com </span><br><span class="line">185.31.19.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure></li>
<li><p>刷新DNS</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager</span><br></pre></td></tr></table></figure>
<p>Finish, 享受飞速GitHub吧!</p>
</li>
</ul>
<h2 id="10-4-解决pip3命令安装软件速度慢，使用-i参数"><a href="#10-4-解决pip3命令安装软件速度慢，使用-i参数" class="headerlink" title="10.4. 解决pip3命令安装软件速度慢，使用-i参数"></a>10.4. 解决pip3命令安装软件速度慢，使用-i参数</h2><p>参考<a href="https://blog.csdn.net/wukai0909/article/details/62427437">Python-解决pip3下载安装速度慢</a><br>临时使用：<br>可以在使用pip3的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple numpy</span><br><span class="line">#这样就会从清华这边的镜像去安装numpy库。</span><br></pre></td></tr></table></figure>
<h2 id="10-5-解决打开IDEA时弹出JDK路径错误"><a href="#10-5-解决打开IDEA时弹出JDK路径错误" class="headerlink" title="10.5. 解决打开IDEA时弹出JDK路径错误"></a>10.5. 解决打开IDEA时弹出JDK路径错误</h2><p>错误出现原因，删除原系统open-jdk后手动安装JDK时可能出现未知bug，导致终端JDK配置没问题，致使IDEA的idea.sh启动时并不能正确找到JDK路径。因此我们的解决思路是可以修改idea.sh文件的某些位置，强制设置JDK路径为上一步我们配置的地址。</p>
<figure class="highlight plain"><figcaption><span>修改文件:/usr/share/idea/bin/idea.sh</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;usr&#x2F;share&#x2F;idea&#x2F;bin&#x2F;idea.sh #打开idea.sh文件</span><br><span class="line"># Ctrl + F 搜索 “JAVA_BIN”</span><br><span class="line">JDK&#x3D;$HOME&#x2F;Environment&#x2F;JAVA&#x2F;jdk1.8.0_181 #待添加强制定义JDK路径代码，将此行代码添加到idea.sh中的“JAVA_BIN&#x3D;&quot;$JDK&#x2F;bin&#x2F;java”代码的上方一行，强制定义JDK路径，问题解决 Done:)</span><br></pre></td></tr></table></figure>

<h1 id="11-Linux-每日一练"><a href="#11-Linux-每日一练" class="headerlink" title="11. Linux 每日一练"></a>11. Linux 每日一练</h1><p>压缩文件／文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7za a -t7z -r Mytest.7z &#x2F;opt&#x2F;phpMyAdmin-3.3.8.1-all-languages&#x2F;*</span><br><span class="line">7za a -t7z -r eisenhao.github.io_backup20180928.7z &#x2F;home&#x2F;eisenhao&#x2F;eisenhao.github.io&#x2F;*  #压缩本站所有文件</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>a  代表添加文件／文件夹到压缩包</li>
<li>-t 是指定压缩类型，这里定为7z，可不指定，因为7za默认压缩类型就是7z。</li>
<li>-r 表示递归所有的子文件夹</li>
<li>Mytest.7z 是压缩好后的压缩包名</li>
<li>/opt/phpMyAdmin-3.3.8.1-all-languages/*：是压缩目标。</li>
</ul>
<p>注意：7za不仅仅支持.7z压缩格式，还支持.tar.bz2等压缩类型的。如上所述，用-t指定即可。</p>
<h1 id="12-参考文档"><a href="#12-参考文档" class="headerlink" title="12. 参考文档"></a>12. 参考文档</h1><ul>
<li><a href="https://www.jianshu.com/p/79dae972b1e9">简书Manjaro安装后配置</a></li>
<li><a href="https://www.lulinux.com/archives/category/linux_newbie">系统安装|鲁Linux</a></li>
<li><a href="https://blog.csdn.net/dp_dp/article/details/80139283">Manjaro安装后配置</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《人生七年》、《人间世》观后感</title>
    <url>/2019/04/06/AfterWatch7upAndRenJianShi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AfterWatch7upAndRenJianShi.jpg" class="full-image" />

<p>最近疲于找实习，感觉自己能力不足，有些迷茫，遂重温了《人生七年》、《人间世》，竟有些新的感受。</p>
<h1 id="1-《人生七年》观后感"><a href="#1-《人生七年》观后感" class="headerlink" title="1. 《人生七年》观后感"></a>1. 《人生七年》观后感</h1><ul>
<li>《人生七年》感受到阶级血淋淋地存在，且每个人深受其影响。从一出生，影响就潜移默化地开始了，从家庭背景、思维方式、教育资源、人生规划等方面。7岁的高富帅三人组John、Andrew和Charles的谈吐和未来规划就能初见端倪</li>
</ul>
<a id="more"></a>

<ul>
<li>岁月无情，每隔七年都能看到孩子们又衰老了许多</li>
<li>没有那么多的理所应当，人们只会看到意气风发春风得意，而不会深挖其背后的坚毅与努力，John、Nick是真的唯有努力才能让这一切看起来毫不费力的践行者</li>
<li>阶级壁垒极难打破，但我们却可以选择属于自己的追求与幸福，以及给予孩子的教育</li>
<li>成功从来没有一个权威的定义，有的只是我们从小遵循的普世模式——上个好学校，找个好工作，赚很多很多钱，然后等中年终于获得经济自由时才能放下一切？<ul>
<li>可绝大多数人到老年也不能达到自己限定的条件，壮志难酬，抑郁寡欢，这时才开始反思是否什么错了啊？</li>
<li>这条普世的成功之路真的能导向成功么，且只有获得成功之后才能实现人生价值和自我实现么？</li>
</ul>
</li>
<li>从纪录片中可发现不同阶级的人追逐自我价值的方式多样，但大多都能从帮助他人的博爱与服务社会的奉献中找到自我满足和实现人生价值。<ul>
<li>精英阶层的律师John也说：“在法庭上依据枯燥的条文拿下一场大官司的胜利，远没有他尽自己的能力帮助别人得到的幸福感多”。</li>
<li>伦敦的平民Lynn事业上开始是在图书馆，后来是流动图书馆，再后来回到图书馆给孩子们讲故事，她很喜欢教孩子们看书，生活平淡而满足。</li>
<li>福利院孩子Paul，后来与妻子一起去一家养老社区工作，在那打下手，修补房子呀，送东西之类，服务别人让他们体会到了更大的满足。</li>
<li>单亲家庭的Symon收养了几千个孩子，付出了许多，也收获了无与伦比的快乐。</li>
</ul>
</li>
<li>思考自己究竟以什么模式活着，找到自己内心真正想要什么？当然，这值得我们用一生来寻找答案。</li>
</ul>
<img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/RenJianShiNewLife.jpg" class="full-image" />

<h1 id="2-《人间世》观后感"><a href="#2-《人间世》观后感" class="headerlink" title="2. 《人间世》观后感"></a>2. 《人间世》观后感</h1><ul>
<li>感受到人间疾苦和生命的规律。从我们呱呱坠地来到人间，经历短暂的一生，然后无可避免地生病、衰老与死去。这是亘古不变的规律，生命或脆弱，却也坚强，总有能在危难之际爆发出难以置信的生命力。</li>
<li>身体健康，家人平安本就是一种即为难得的奢望</li>
<li>亲情、爱情、友情总有缺席的一天，珍惜珍重眼前人</li>
</ul>
<div class="note success"><p>人生不如意之事十之八九，安静平和，身心舒畅，便是清欢。</p>
</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>人生观触动</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析与设计练习</title>
    <url>/2019/01/03/AnalysisOfAlgorithmsLesson/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AnalysisOfAlgorithmsLesson.jpg" class="full-image" />

<h1 id="1-算法分析与设计练习"><a href="#1-算法分析与设计练习" class="headerlink" title="1. 算法分析与设计练习"></a>1. 算法分析与设计练习</h1><p>完整源代码已在本文尾部给出</p>
<h2 id="1-1-No1-优先级队列（大小顶堆）"><a href="#1-1-No1-优先级队列（大小顶堆）" class="headerlink" title="1.1. No1. 优先级队列（大小顶堆）"></a>1.1. No1. 优先级队列（大小顶堆）</h2><p>堆是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于（或不小于）其左子节点和右子节点的值。最小(大)堆能保证堆顶元素最小(大)，相比于用数组存放数据，如果要查找所有数据中最小(大)的数据时，数组的时间复杂度为O(n)，而最小(大)堆的时间复杂度为O(1)。而数据增删数据时，需要保证最小(大)堆的动态可维护性仅需O(logN)。因此对于特定的需求环境，最小(大)堆这种数据结构非常高效。</p>
<a id="more"></a>

<h3 id="1-1-1-最大堆概念"><a href="#1-1-1-最大堆概念" class="headerlink" title="1.1.1. 最大堆概念"></a>1.1.1. 最大堆概念</h3><p>最大堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不小于其左子节点和右子节点的值。</p>
<h4 id="1-1-1-1-最大堆实现思路"><a href="#1-1-1-1-最大堆实现思路" class="headerlink" title="1.1.1.1. 最大堆实现思路"></a>1.1.1.1. 最大堆实现思路</h4><p>将最大堆二叉树存储到数组内，非根节点元素的父节点下标为(i-1)/2，若子节点存在则下标为2*i+1。</p>
<p><strong>插入操作</strong>：每当插入一个元素，将元素插入到容器（数组）尾部，然后执行迭代的上升操作，将插入的元素与其父节点比较，若比父节点大则交换，然后再与交换后节点的父节点相互比较交换，直到放置到合适位置。（最坏递归到根节点终止迭代）</p>
<p><strong>弹出操作</strong>：弹出最大值（即数组首地址元素a[0]）。先交换交换堆顶与堆末，再弹出堆末（最大值），然后再将现堆顶元素执行迭代的下降操作，若其子节点存在与其子节点比较，若比子节点小则交换，然后再与交换后的子节点相互比较交换，直到放置在合适位置。（最坏递归到叶子节点）</p>
<p><strong>最大堆运行结果</strong><br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AnalysisOfAlgorithmsLesson_Max_Heap.png" alt="1_Max_Heap"></p>
<h3 id="1-1-2-最小堆概念"><a href="#1-1-2-最小堆概念" class="headerlink" title="1.1.2. 最小堆概念"></a>1.1.2. 最小堆概念</h3><p>最小堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节点的值。堆内的所有数据中最小的元素始终在堆顶，而增删一个元素而动态维护最小堆性质的时间复杂度仅为O(logN)</p>
<h4 id="1-1-2-1-最小堆实现思路"><a href="#1-1-2-1-最小堆实现思路" class="headerlink" title="1.1.2.1. 最小堆实现思路"></a>1.1.2.1. 最小堆实现思路</h4><p>将最小堆二叉树存储到数组内，非根节点元素的父节点下标为(i-1)/2，若子节点存在则下标为2*i+1。</p>
<p><strong>插入操作</strong>：每当插入一个元素，将元素插入到容器（数组）尾部，然后执行迭代的上升操作，将插入的元素与其父节点比较，若比父节点小则交换，然后再与交换后节点的父节点相互比较交换，直到放置到合适位置。（最坏递归到根节点终止迭代）</p>
<p><strong>弹出操作</strong>：弹出最小值（即数组首地址元素a[0]）。先交换交换堆顶与堆末，再弹出堆末（最小值），然后再将现堆顶元素执行迭代的下降操作，若其子节点存在与其子节点比较，若比子节点小则交换，然后再与交换后的子节点相互比较交换，直到放置在合适位置。（最坏递归到叶子节点）</p>
<p>最小堆运行结果<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AnalysisOfAlgorithmsLesson_Min_Heap.png" alt="1_Min_Heap"></p>
<h2 id="1-2-No2-Quicksort"><a href="#1-2-No2-Quicksort" class="headerlink" title="1.2. No2. Quicksort"></a>1.2. No2. Quicksort</h2><p>快速排序（Quick Sort）由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br>快速排序是不稳定的算法，时间复杂度在最坏情况下是O(N^2)，平均的时间复杂度是O(N*lgN)。</p>
<h3 id="1-2-1-Quick-Sort-实现思想"><a href="#1-2-1-Quick-Sort-实现思想" class="headerlink" title="1.2.1. Quick Sort 实现思想"></a>1.2.1. Quick Sort 实现思想</h3><p>快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：</p>
<ul>
<li>1、从数列中取出一个数作为基准数（枢轴，pivot）。 </li>
<li>2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。</li>
<li>3、再对左右的子区间重复第二步的划分操作，直至每个子区间只有Cutoff（阈值）个元素。</li>
<li>4、对Cutoff（阈值）个元素进行插入排序（实践经验小于一定数量后插入排序快于快速排序），然后返回上一调用堆栈。</li>
</ul>
<h3 id="1-2-2-实现Quicksort核心代码"><a href="#1-2-2-实现Quicksort核心代码" class="headerlink" title="1.2.2. 实现Quicksort核心代码"></a>1.2.2. 实现Quicksort核心代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序算法实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cutoff 5 <span class="comment">//定义快速排序（递归）阈值，数组元素小于Cutoff直接插入排序</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">( <span class="built_in">vector</span>&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Left, <span class="keyword">long</span> <span class="keyword">int</span> Right )</span> </span>&#123;</span><br><span class="line">    ElementType pivot;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">//是否进行快速排序，阈值判断</span></span><br><span class="line">    <span class="keyword">if</span> ( (Right - Left) &gt;= Cutoff ) &#123;</span><br><span class="line">        <span class="comment">//选主元pivot，藏于A[Right-1]</span></span><br><span class="line">        pivot = Median3 ( A, Left, Right );<span class="comment">//让这段元素的左、中、右三个有序，并且将中间与这段元素的最右边-1个元素互换，然后返回这段元素的最右边元素-1的下标</span></span><br><span class="line">        i = Left ;</span><br><span class="line">        j = Right - <span class="number">1</span> ;</span><br><span class="line">        <span class="comment">//子集划分(pivot左边全小于pivot；pivot右边全大于pivot)</span></span><br><span class="line">        <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( A[++i] &lt; pivot ) &#123;&#125; <span class="comment">//找到A[i] &gt; pivot, 跳出</span></span><br><span class="line">            <span class="keyword">while</span> ( A[--j] &gt; pivot ) &#123;&#125; <span class="comment">//找到A[j] &lt; pivot, 跳出</span></span><br><span class="line">            <span class="keyword">if</span> ( i &lt; j ) &#123;</span><br><span class="line">                <span class="comment">//说明A[i]与A[j]之间还有其他元素，可交换</span></span><br><span class="line">                Swap( &amp;A[i], &amp;A[j] );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Swap( &amp;A[i], &amp;A[Right<span class="number">-1</span>] ); <span class="comment">//将pivot 放到中间，即i下标处</span></span><br><span class="line">        Quicksort( A, Left, i<span class="number">-1</span> );<span class="comment">//递归处理左边</span></span><br><span class="line">        Quicksort( A, i+<span class="number">1</span>, Right );<span class="comment">//递归处理右边</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//低于阈值，直接调用插入排序</span></span><br><span class="line">        <span class="comment">//递归到最小一层用插入排序(每段的插入排序地址为：&amp;A + Left (即：绝对地址A 加相对地址Left)</span></span><br><span class="line">        <span class="comment">//最小一层插入排序元素个数Number = Right-Left+1</span></span><br><span class="line">        Insertion_Sort (  &amp;A[Left], Right-Left+<span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序（统一接口，加壳）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span> <span class="params">( <span class="built_in">vector</span>&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Number )</span> </span>&#123;</span><br><span class="line">    Quicksort ( A, <span class="number">0</span>, Number<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-Quick-Sort-运行结果"><a href="#1-2-3-Quick-Sort-运行结果" class="headerlink" title="1.2.3. Quick Sort 运行结果"></a>1.2.3. Quick Sort 运行结果</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AnalysisOfAlgorithmsLesson_QuickSort.png" alt="2_QuickSort"></p>
<h3 id="1-2-4-延伸思考🤔"><a href="#1-2-4-延伸思考🤔" class="headerlink" title="1.2.4. 延伸思考🤔:"></a>1.2.4. 延伸思考🤔:</h3><h4 id="1-2-4-1-1-Quick-sort会在n个具有相同的值的元素列表中进行多少次比较？"><a href="#1-2-4-1-1-Quick-sort会在n个具有相同的值的元素列表中进行多少次比较？" class="headerlink" title="1.2.4.1. (1)Quick sort会在n个具有相同的值的元素列表中进行多少次比较？"></a>1.2.4.1. (1)Quick sort会在n个具有相同的值的元素列表中进行多少次比较？</h4><p>答：N(lgN-1)-lgN次比较。<br>归纳得：子数组长度大于1时，每层的对比次数是上一层元素个数-上一层子数组个数。由于子数组长度大于1时才有比较，所以有比较的层次数是 1(顶层)+lgN-1(底层)=lgN。顶层有对比，但未减少元素。底层没有对比。倒数第二层的减少元素数与倒数第三层相关，那么有减少元素个数的层数有lgN-1(底层)-1(倒数第二层)=lgN-2。归纳总结后：总的对比次数=N<em>对比层数 - 各层的元素减少数之和 = N</em>lgN - 各层的元素减少数之和。而第n层的减少元素个数 = 2^n-1，各层的减少元素个数和累加为 = N-lgN。故总的比较次数为：N(lgN-1)-lgN</p>
<h4 id="1-2-4-2-2-Quick-sort在n个元素列表上进行的最大和最小比较次数是多少，分别给出最大和最小情况的实例。"><a href="#1-2-4-2-2-Quick-sort在n个元素列表上进行的最大和最小比较次数是多少，分别给出最大和最小情况的实例。" class="headerlink" title="1.2.4.2. (2)Quick sort在n个元素列表上进行的最大和最小比较次数是多少，分别给出最大和最小情况的实例。"></a>1.2.4.2. (2)Quick sort在n个元素列表上进行的最大和最小比较次数是多少，分别给出最大和最小情况的实例。</h4><p>答：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？<br>最多需要遍历N次，至少需要遍历lg(N+1)次。</p>
<ul>
<li><p>(1).为什么最少是lg(N+1)次？<br>快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。</p>
</li>
<li><p>(2).为什么最多是N次？<br>将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。</p>
</li>
</ul>
<h2 id="1-3-No3．Matrix-chain-product-The-following-are-some-instances"><a href="#1-3-No3．Matrix-chain-product-The-following-are-some-instances" class="headerlink" title="1.3. No3．Matrix-chain product. The following are some instances"></a>1.3. No3．<strong>Matrix-chain product</strong>. The following are some instances</h2><ul>
<li>a)&lt;3, 5, 2, 1,10&gt;  答：55， 计算次序为：2，1，3</li>
<li>b)&lt;2, 7, 3, 6, 10&gt; 答：198， 计算次序为：1，2，3</li>
<li>c)&lt;10, 3, 15, 12, 7, 2&gt;答：678， 计算次序为：4，2，3，1</li>
<li>d)&lt;7, 2, 4, 15, 20, 5&gt;答：990，计算次序为：2，3，4，1</li>
</ul>
<p>用备忘录解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> length 5 <span class="comment">//矩阵元素个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> numOfMatrix length-1 <span class="comment">//矩阵个数 = length - 1</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="comment">//定义规模为：矩阵链的个数^2 的二维数组,并赋初值无穷大WuQiongDa</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">m</span><span class="params">(numOfMatrix)</span></span>; <span class="comment">//numOfMatrix 矩阵个数 = length - 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算第i到j段的最小计算次数</span></span><br><span class="line"><span class="comment"> * 返回值&lt;int&gt;：第i到j段的最小运算次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WuQiongDa 69999999</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LookUp_Chain</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//备忘录：若已计算，则返回已计算值</span></span><br><span class="line">    <span class="keyword">if</span> (m[i<span class="number">-1</span>][j<span class="number">-1</span>] != WuQiongDa)&#123;</span><br><span class="line">        <span class="keyword">return</span> m[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若没计算</span></span><br><span class="line">    <span class="comment">//a.过小只有两个矩阵</span></span><br><span class="line">    <span class="keyword">if</span>(j == i+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p[i<span class="number">-1</span>] * p[i] * p[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//b.有可分性</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//计算从 k 处划分(k取值：i到j-1)，后的两边的值 + 两边相乘的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=i; k&lt;=j<span class="number">-1</span>; k++) &#123;</span><br><span class="line">            <span class="comment">//中间值q</span></span><br><span class="line">            <span class="keyword">int</span> q = LookUp_Chain(p, i, k) + LookUp_Chain(p, k+<span class="number">1</span>, j)</span><br><span class="line">                    + p[i<span class="number">-1</span>] * p[k] * p[j];</span><br><span class="line">            <span class="comment">//记录从k处划分的m[i][j]最小值</span></span><br><span class="line">            <span class="keyword">if</span>(q &lt; m[i<span class="number">-1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;k = &quot;</span> &lt;&lt;  k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                m[i<span class="number">-1</span>][j<span class="number">-1</span>] = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 备忘录，矩阵链最小计算次数</span></span><br><span class="line"><span class="comment"> * 传入参数：矩阵链容器，存储顺序的矩阵相乘下标</span></span><br><span class="line"><span class="comment"> * 如：&lt;3, 5, 2, 1, 10&gt; 即为：(3, 5) x (5, 2) x (2, 1) x (1, 10)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Memory_Matrix_Chain</span><span class="params">(<span class="keyword">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numOfMatrix; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;numOfMatrix; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                m[i].push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m[i].push_back(WuQiongDa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = LookUp_Chain(p, <span class="number">1</span>, numOfMatrix);<span class="comment">//下标</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>&#125;;<span class="comment">//答：55, 计算次序为：2，1，3</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">5</span>] = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;<span class="comment">//答：198， 计算次序为：1，2，3</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">6</span>] = &#123;<span class="number">10</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>&#125;;<span class="comment">//答：654038</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">6</span>] = &#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Memory_Matrix_Chain(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Min Calc times = &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-4-No4．最长公共子序列（LCS）"><a href="#1-4-No4．最长公共子序列（LCS）" class="headerlink" title="1.4. No4．最长公共子序列（LCS）"></a>1.4. No4．<strong>最长公共子序列</strong>（LCS）</h2><p>实例输入：</p>
<ul>
<li>a)X: xzyzzyx   Y: zxyyzxz</li>
<li>b)X:MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCALLAAQANKESSSESFISRLLAIVAD<br>Y:MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCTLLAAQANKENSNESFISRLLAIVAG</li>
</ul>
<h3 id="1-4-1-求解思路"><a href="#1-4-1-求解思路" class="headerlink" title="1.4.1. 求解思路"></a>1.4.1. 求解思路</h3><p>因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。最长公共子序列的递归式如下：<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AnalysisOfAlgorithmsLesson_LCS_Formula.png" alt="最长公共子序列的递归式"></p>
<h3 id="1-4-2-C-编程实现LCS"><a href="#1-4-2-C-编程实现LCS" class="headerlink" title="1.4.2. C++编程实现LCS"></a>1.4.2. C++编程实现LCS</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxNum</span><span class="params">(<span class="keyword">int</span> firstNum, <span class="keyword">int</span> secondNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstNum &gt; secondNum ? firstNum : secondNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> direct;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> matrix Matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="keyword">char</span> *strA, <span class="keyword">char</span> *strB, <span class="keyword">int</span> lengthA, <span class="keyword">int</span> lengthB, Matrix *resultMatrix[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//若i = 0 或 j = 0， 返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (lengthA == <span class="number">0</span> || lengthB == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化存储数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lengthA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lengthB; j++) &#123;</span><br><span class="line">            resultMatrix[i][j].num = <span class="number">0</span>; <span class="comment">//设置所有默认的最长为0</span></span><br><span class="line">            resultMatrix[i][j].direct = <span class="number">1</span>; <span class="comment">//所有默认方向变成上 0斜上，1上，-1左</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=lengthB; j++)&#123;</span><br><span class="line">        resultMatrix[<span class="number">0</span>][j].direct = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lengthB; j++) &#123;</span><br><span class="line">            <span class="comment">//若字符串A，字符串B 末尾元素相同</span></span><br><span class="line">            <span class="keyword">if</span> (strA[i] == strB[j]) &#123;</span><br><span class="line">                resultMatrix[i+<span class="number">1</span>][j+<span class="number">1</span>].num = resultMatrix[i][j].num + <span class="number">1</span>;</span><br><span class="line">                resultMatrix[i+<span class="number">1</span>][j+<span class="number">1</span>].direct = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，分别计算子问题求最大</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                resultMatrix[i+<span class="number">1</span>][j+<span class="number">1</span>].num = MaxNum(resultMatrix[i+<span class="number">1</span>][j].num, resultMatrix[i][j+<span class="number">1</span>].num);</span><br><span class="line">                resultMatrix[i+<span class="number">1</span>][j+<span class="number">1</span>].direct = resultMatrix[i+<span class="number">1</span>][j].num &gt; resultMatrix[i][j+<span class="number">1</span>].num ? (<span class="number">-1</span>) : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMatrix[lengthA][lengthB].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strA[] = &#123;<span class="string">&quot;xzyzzyx&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> strB[] = &#123;<span class="string">&quot;zxyyzxz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> lengthA = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(strA);</span><br><span class="line">    <span class="keyword">int</span> lengthB = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(strB);</span><br><span class="line">    Matrix *resultMatrix[lengthA+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lengthA; i++) &#123;</span><br><span class="line">        resultMatrix[i] = (Matrix*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct matrix)* (lengthB+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = LCS(strA, strB, lengthA, lengthB, resultMatrix);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max = &quot;</span> &lt;&lt; max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; result_LCS;</span><br><span class="line">    <span class="comment">//便利二维数组，求解最长公共子序列</span></span><br><span class="line">    <span class="comment">//所有默认方向变成上 0斜上，1上，-1左</span></span><br><span class="line">    <span class="keyword">int</span> i=lengthA, j=lengthB;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = resultMatrix[i][j].direct;</span><br><span class="line">        <span class="keyword">switch</span> (k)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                result_LCS.push_back(strA[i<span class="number">-1</span>]);</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;something Error!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=result_LCS.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;result_LCS[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-3-程序运行结果："><a href="#1-4-3-程序运行结果：" class="headerlink" title="1.4.3. 程序运行结果："></a>1.4.3. 程序运行结果：</h3><ul>
<li>a)X: xzyzzyx   Y: zxyyzxz<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max = <span class="number">4</span></span><br><span class="line">xyzz</span><br></pre></td></tr></table></figure></li>
<li>b)X:MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCALLAAQANKESSSESFISRLLAIVAD<br>Y:MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCTLLAAQANKENSNESFISRLLAIVAG<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max = <span class="number">56</span></span><br><span class="line">MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCLLAAQANKESESFISRLLAIVA</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-5-No5-多级图中的最短路径"><a href="#1-5-No5-多级图中的最短路径" class="headerlink" title="1.5. No5. 多级图中的最短路径"></a>1.5. No5. 多级图中的最短路径</h2><p><strong>多级图是图(1)G=(V,E),其中V被划分为K&gt;=2个不相交的子集,使得如果(a,b)在E中,则a在Vi中,并且b在Vi+1对于分区中的某些子集中;和(2)|V1|=|Vk|=1.</strong><br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AnalysisOfAlgorithmsLesson_SPIMG.png" alt="Shortest_path_in_multistage_graphs"></p>
<h3 id="1-5-1-求解思路"><a href="#1-5-1-求解思路" class="headerlink" title="1.5.1. 求解思路"></a>1.5.1. 求解思路</h3><p>Dijkstra算法。以起始点为中心向外层层扩展，直到扩展到终点为止。</p>
<h3 id="1-5-2-Dijkstra算法实现："><a href="#1-5-2-Dijkstra算法实现：" class="headerlink" title="1.5.2. Dijkstra算法实现："></a>1.5.2. Dijkstra算法实现：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="comment">/** 构建并初始化一维矩阵dist距离</span></span><br><span class="line"><span class="comment">     * 表示：起始节点v 到其他所有节点的距离</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        dist.push_back(WuQiongDa);</span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>;<span class="comment">//节点到自身的距离为0</span></span><br><span class="line">    <span class="comment">//构建存储中间前驱节点变量的一维</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        path.push_back(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    path[v] = v;<span class="comment">// 起始节点的前驱节点为其自身</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个结点都尝试做中间节点 k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="keyword">this</span>-&gt;n; k++)&#123;</span><br><span class="line">        <span class="comment">//临时的目的节点(j)： 从v到j： v-&gt;k、k-&gt;j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="keyword">this</span>-&gt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[k]!=WuQiongDa &amp;&amp; g[k][j]!=WuQiongDa &amp;&amp; (dist[j] &gt; dist[k]+g[k][j]))&#123;</span><br><span class="line">                dist[j] = dist[k]+g[k][j];<span class="comment">//更新 v到j 距离</span></span><br><span class="line">                path[j] = k;<span class="comment">// 记录前驱节点 k</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The shortest path Length of (&quot;</span>&lt;&lt; v &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; dist[w] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Path: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> from = <span class="keyword">this</span>-&gt;n <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; OutPath;</span><br><span class="line">    OutPath.push_back(w);</span><br><span class="line">    <span class="keyword">while</span>(path[from]!=v)&#123;</span><br><span class="line">        OutPath.push_back(path[from]);</span><br><span class="line">        from = path[from];</span><br><span class="line">    &#125;</span><br><span class="line">    OutPath.push_back(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=OutPath.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; OutPath[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">The shortest path Length <span class="title">of</span> <span class="params">(<span class="number">0</span>-&gt;<span class="number">15</span>)</span> </span>= <span class="number">18</span></span><br><span class="line">Path: <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">4</span> -&gt; <span class="number">7</span> -&gt; <span class="number">11</span> -&gt; <span class="number">14</span> -&gt; <span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-No6-简单的调度问题"><a href="#1-6-No6-简单的调度问题" class="headerlink" title="1.6. No6. 简单的调度问题"></a>1.6. No6. 简单的<strong>调度问题</strong></h2><p>我们给出了作业j1，j2 … jn，它们分别具有已知的运行时间t1，t2 … tn。 我们有一个处理器。安排这些工作以最小化平均完成时间的最佳方法是什么。假设它是非抢先式调度：一旦作业启动，它必须运行完成。 以下是一些实例：</p>
<p>a)(j1, j2, j3, j4) : (15，8，3，10)</p>
<h3 id="1-6-1-解题思路"><a href="#1-6-1-解题思路" class="headerlink" title="1.6.1. 解题思路"></a>1.6.1. 解题思路</h3><p>将工作时长做为贪心算法的参数，贪工作时长最小的工作，时长越短，安排越前。</p>
<h3 id="1-6-2-简单贪心实现"><a href="#1-6-2-简单贪心实现" class="headerlink" title="1.6.2. 简单贪心实现"></a>1.6.2. 简单贪心实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//用贪心求工作时序安排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedulGreedy</span><span class="params">(<span class="keyword">int</span> jobs[], <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">jobSchedule</span><span class="params">(num, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        jobSchedule[i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;num; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jobs[i] &gt; jobs[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = jobs[i];</span><br><span class="line">                jobs[i] = jobs[j];</span><br><span class="line">                jobs[j] = temp;</span><br><span class="line">                temp = jobSchedule[i];</span><br><span class="line">                jobSchedule[i] = jobSchedule[j];</span><br><span class="line">                jobSchedule[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;job schedule is:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;j&quot;</span> &lt;&lt; jobSchedule[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=num<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> jobs[<span class="number">4</span>] = &#123;<span class="number">15</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    schedulGreedy(jobs, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">job schedule is:</span><br><span class="line">j3 -&gt; j2 -&gt; j4 -&gt; j1</span><br></pre></td></tr></table></figure>

<h2 id="1-7-No7-单源最短路径"><a href="#1-7-No7-单源最短路径" class="headerlink" title="1.7. No7. 单源最短路径"></a>1.7. No7. 单源最短路径</h2><p>以下是邻接矩阵，顶点A是源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  A  B  C  D  E</span><br><span class="line">A    <span class="number">-1</span> <span class="number">3</span></span><br><span class="line">B       <span class="number">3</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line">C       </span><br><span class="line">D    <span class="number">1</span>  <span class="number">5</span></span><br><span class="line">E          <span class="number">-3</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-1-分析"><a href="#1-7-1-分析" class="headerlink" title="1.7.1. 分析"></a>1.7.1. 分析</h3><p>手动绘制单向图如下所示：<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AnalysisOfAlgorithmsLesson_single_source_graph.jpg" alt="single source graph"><br>由图可知，图中节点A只有出度，节点C只有入度，其他不得而知，且题目给的较为模糊，不知是(1)求解从节点A-&gt;节点C的最短路径，或是（2）求解从节点A出发到任意节点中路径最短的一条。姑且按（2）求解</p>
<h3 id="1-7-2-解题思路"><a href="#1-7-2-解题思路" class="headerlink" title="1.7.2. 解题思路"></a>1.7.2. 解题思路</h3><p>与求解第5题类似，参数是否为有向图为:true，仍采用Dijkstra算法。以起始点为中心向外层层扩展，直到扩展到终点为止，可以得到从起始节点到所有节点的最短距离。</p>
<h3 id="1-7-3-核心代码"><a href="#1-7-3-核心代码" class="headerlink" title="1.7.3. 核心代码"></a>1.7.3. 核心代码</h3><p>代码与第五题代码部分有所区别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dijkstra算法实现</span></span><br><span class="line"><span class="comment"> * 参数：起始节点 v</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">/** 构建并初始化一维矩阵dist距离</span></span><br><span class="line"><span class="comment">     * 表示：起始节点v 到其他所有节点的距离</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        dist.push_back(WuQiongDa);</span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>;<span class="comment">//节点到自身的距离为0</span></span><br><span class="line">    <span class="comment">//构建存储中间前驱节点变量的一维</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        path.push_back(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    path[v] = v;<span class="comment">// 起始节点的前驱节点为其自身</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个结点都尝试做中间节点 k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="keyword">this</span>-&gt;n; k++)&#123;</span><br><span class="line">        <span class="comment">//临时的目的节点(j)： 从v到j： v-&gt;k、k-&gt;j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="keyword">this</span>-&gt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[k]!=WuQiongDa &amp;&amp; g[k][j]!=WuQiongDa &amp;&amp; (dist[j] &gt; dist[k]+g[k][j]))&#123;</span><br><span class="line">                dist[j] = dist[k]+g[k][j];<span class="comment">//更新 v到j 距离</span></span><br><span class="line">                path[j] = k;<span class="comment">// 记录前驱节点 k</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出起始节点到所有节点的距离，顺便找出最短的距离</span></span><br><span class="line">    <span class="keyword">int</span> recordTheShortestPath;</span><br><span class="line">    <span class="keyword">int</span> temp = WuQiongDa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="keyword">this</span>-&gt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[dist] A-&gt;&quot;</span> &lt;&lt; (<span class="keyword">char</span>)(i+<span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; dist[i] &lt;&lt; <span class="string">&quot;;  &quot;</span>;</span><br><span class="line">        showPathFrom0To(i, path);</span><br><span class="line">        <span class="keyword">if</span>(dist[i] &lt; temp)&#123;</span><br><span class="line">            temp = dist[i];</span><br><span class="line">            recordTheShortestPath = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示从起始节点出发到各节点的最短路径</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The shortest Path is [dist] A-&gt;&quot;</span> &lt;&lt; (<span class="keyword">char</span>)(recordTheShortestPath+<span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; dist[recordTheShortestPath] &lt;&lt; <span class="string">&quot;;  &quot;</span>;</span><br><span class="line">    showPathFrom0To(recordTheShortestPath, path);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示从起始节点0， 到第w个节点的路径（通过传入的前驱节点path数组显示）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPathFrom0To</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Path from (A-&gt;&quot;</span> &lt;&lt; (<span class="keyword">char</span>)(w+<span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot;): &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> from = w;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; OutPath;</span><br><span class="line">    OutPath.push_back(w);</span><br><span class="line">    <span class="keyword">while</span>(path[from]!=<span class="number">0</span>)&#123;</span><br><span class="line">        OutPath.push_back(path[from]);</span><br><span class="line">        from = path[from];</span><br><span class="line">    &#125;</span><br><span class="line">    OutPath.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=OutPath.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)(OutPath[i]+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[dist] A-&gt;B = -1;  Path from (A-&gt;B): A -&gt; B</span><br><span class="line">[dist] A-&gt;C =  2;  Path from (A-&gt;C): A -&gt; B -&gt; C</span><br><span class="line">[dist] A-&gt;D = -2;  Path from (A-&gt;D): A -&gt; B -&gt; E -&gt; D</span><br><span class="line">[dist] A-&gt;E =  1;  Path from (A-&gt;E): A -&gt; B -&gt; E</span><br><span class="line">The shortest Path is [dist] A-&gt;D = -2;  Path from (A-&gt;D): A -&gt; B -&gt; E -&gt; D</span><br></pre></td></tr></table></figure>
<p>可知</p>
<ul>
<li><p>(1)求解从节点A-&gt;节点C的最短路径<br>[dist] A-&gt;C =  2;  Path from (A-&gt;C): A -&gt; B -&gt; C</p>
</li>
<li><p>(2)求解从节点A出发到任意节点中路径最短的一条。<br>The shortest Path is [dist] A-&gt;D = -2;  Path from (A-&gt;D): A -&gt; B -&gt; E -&gt; D</p>
</li>
</ul>
<h2 id="1-8-No8．回溯算法（8皇后问题）"><a href="#1-8-No8．回溯算法（8皇后问题）" class="headerlink" title="1.8. No8．回溯算法（8皇后问题）"></a>1.8. No8．回溯算法（8皇后问题）</h2><h3 id="1-8-1-回溯算法"><a href="#1-8-1-回溯算法" class="headerlink" title="1.8.1. 回溯算法"></a>1.8.1. 回溯算法</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h3 id="1-8-2-回溯算法在N皇后问题求解算发中实现（核心代码）"><a href="#1-8-2-回溯算法在N皇后问题求解算发中实现（核心代码）" class="headerlink" title="1.8.2. 回溯算法在N皇后问题求解算发中实现（核心代码）"></a>1.8.2. 回溯算法在N皇后问题求解算发中实现（核心代码）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用回溯算法求解8皇后问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueensByBackTracking</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//k:表示行数，从第0行开始</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(n, <span class="number">-1</span>)</span></span>;<span class="comment">//创建int x[n]容器，x[k]用于存储第k行皇后放置的列数</span></span><br><span class="line">    <span class="keyword">while</span> (k&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        x[k]++;<span class="comment">//第k行皇后放置位置右移，初次正好到0； 回溯时在上一次失败尝试下右移</span></span><br><span class="line">        <span class="comment">//试探右移找到不冲突的列</span></span><br><span class="line">        <span class="keyword">while</span>(x[k]&lt;n &amp;&amp; !PLACE(k, x))&#123;</span><br><span class="line">            x[k]++;<span class="comment">//列右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【判断】上一步退出while的原因（是否找到不冲突的列）</span></span><br><span class="line">        <span class="comment">//一、若已找到不冲突的列</span></span><br><span class="line">        <span class="keyword">if</span> (x[k] &lt; n)&#123;</span><br><span class="line">            <span class="comment">//【判断】：是否所有行均找到结果</span></span><br><span class="line">            <span class="comment">//1.所有行结果均已找到：输出结果</span></span><br><span class="line">            <span class="keyword">if</span>(k == n<span class="number">-1</span>)&#123;</span><br><span class="line">                showResult(x);<span class="comment">//显示n皇后结果</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.k行后面行还没找到结果</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k++;<span class="comment">//行数后移</span></span><br><span class="line">                x[k] = <span class="number">-1</span>;<span class="comment">//初始值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二、（未找到不冲突的列）当前行k的所有结果均冲突时，回溯，行数k-1</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; queens problem has no answer&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">The answer of <span class="number">8</span> queens problem is:   <span class="number">0</span>  <span class="number">4</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">3</span></span><br><span class="line">============= Draw =============</span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"><span class="number">0</span>  Q  -  -  -  -  -  -  -</span><br><span class="line"><span class="number">1</span>  -  -  -  -  Q  -  -  -</span><br><span class="line"><span class="number">2</span>  -  -  -  -  -  -  -  Q</span><br><span class="line"><span class="number">3</span>  -  -  -  -  -  Q  -  -</span><br><span class="line"><span class="number">4</span>  -  -  Q  -  -  -  -  -</span><br><span class="line"><span class="number">5</span>  -  -  -  -  -  -  Q  -</span><br><span class="line"><span class="number">6</span>  -  Q  -  -  -  -  -  -</span><br><span class="line"><span class="number">7</span>  -  -  -  Q  -  -  -  -</span><br></pre></td></tr></table></figure>

<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ul>
<li>在求解No3时：边界条件的判断、容器vector的使用、中间选择过程的记录；</li>
<li>在求解最长公共子序列时，对Dp中间求解的过程变量存储，选取的(i,j+1)还是（i+1,j）的细节判断，及后续逆便利中间过程记录二维矩阵时的走向与方向的细节执行；</li>
<li>Dijkstra算法实现过程中的问题，图节点的遍历，及根据中间记录的选择过程逆向遍历得到最短路径；</li>
<li>回溯算法中什么时候k++,什么时候k–，以及x[k]的初值问题；</li>
<li>及各类算法编程实现的通用问题，算法实现、边界条件、状态转换、初值等等。</li>
</ul>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：C++<br><strong>所有实验题目完整源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AnalysisOfAlgorithmsLesson_code.zip">AnalysisOfAlgorithmsLesson_code.zip</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树与B*树</title>
    <url>/2020/12/24/BPlusTreeAndBStartTree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BPlusTree1.jpg" class="full-image" />

<h1 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1. B+树"></a>1. B+树</h1><h2 id="1-1-B-树简介"><a href="#1-1-B-树简介" class="headerlink" title="1.1. B+树简介"></a>1.1. B+树简介</h2><p>B+树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</p>
<a id="more"></a>

<h2 id="1-2-B-树应用场景"><a href="#1-2-B-树应用场景" class="headerlink" title="1.2. B+树应用场景"></a>1.2. B+树应用场景</h2><p>B+树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入。</p>
<h2 id="1-3-B-树定义"><a href="#1-3-B-树定义" class="headerlink" title="1.3. B+树定义"></a>1.3. B+树定义</h2><ul>
<li>B+树是应文件系统所需而出的一种B树的变型树。一棵m阶的B+树和m阶的B树的差异在于：<ul>
<li>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。</li>
</ul>
</li>
</ul>
<p>备注：通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>
<ul>
<li>B+树是B树的变体，也是一种多路搜索树，其定义除以下存有差异的定义外基本与B树同：<ul>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ul>
</li>
</ul>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BPlusTree2.PNG" alt="B+树"></p>
<p>备注：B+的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<h2 id="1-4-B-的特性"><a href="#1-4-B-的特性" class="headerlink" title="1.4. B+的特性"></a>1.4. B+的特性</h2><ul>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ul>
<h1 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B*树"></a>2. B*树</h1><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BStartTree.PNG" alt="B*树"></p>
<h2 id="2-1-B-树的定义"><a href="#2-1-B-树的定义" class="headerlink" title="2.1. B*树的定义"></a>2.1. B*树的定义</h2><ul>
<li>是B+树的变体，在B+树的非根和非叶子结点再增加<strong>指向兄弟的指针</strong>；</li>
<li>B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；</li>
</ul>
<h1 id="3-B树，B-树，B-树小结"><a href="#3-B树，B-树，B-树小结" class="headerlink" title="3. B树，B+树，B*树小结"></a>3. B树，B+树，B*树小结</h1><table>
<thead>
<tr>
<th align="left">数据结构</th>
<th align="left">小结</th>
</tr>
</thead>
<tbody><tr>
<td align="left">B树</td>
<td align="left">多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</td>
</tr>
<tr>
<td align="left">B+树</td>
<td align="left">在B树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</td>
</tr>
<tr>
<td align="left">B*树</td>
<td align="left">在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</td>
</tr>
</tbody></table>
<h1 id="4-B树，B-树与B-树的优缺点比较"><a href="#4-B树，B-树与B-树的优缺点比较" class="headerlink" title="4. B树，B+树与B*树的优缺点比较"></a>4. B树，B+树与B*树的优缺点比较</h1><p>备注：B-树就是B树，”-“是个连字符号，不是减号。</p>
<h2 id="4-1-B树-vs-B-树"><a href="#4-1-B树-vs-B-树" class="headerlink" title="4.1. B树 vs B+树"></a>4.1. B树 vs B+树</h2><ul>
<li>B树是一种平衡的多路查找(又称排序)树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance)</li>
<li>B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。</li>
<li>B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。</li>
<li>B树的优势是当你要查找的值恰好处在一个非叶子节点时，查找到该节点就会成功并结束查询，而B+树由于非叶节点只是索引部分，这些节点中只含有其子树中的最大(或最小)关键字，当非终端节点上的关键字等于给点值时，查找并不终止，而是继续向下直到叶子节点。因此在B+树中，无论查找成功与否，都是走了一条从根到叶子节点的路径。有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。</li>
<li>另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。 mysql底层存储是用B+树实现的，因为内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了。</li>
</ul>
<h2 id="4-2-B-树-vs-B-树"><a href="#4-2-B-树-vs-B-树" class="headerlink" title="4.2. B+树 vs B*树"></a>4.2. B+树 vs B*树</h2><ul>
<li>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3（代替B+树的1/2）；</li>
<li>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</li>
<li>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针； 所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</li>
</ul>
<h1 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h1><ul>
<li><a href="https://www.jianshu.com/p/7323130d351b">讲点”B树”，一文详解B树，B+树，B*树及其优缺点比较</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>测试内存中变量的存储方式</title>
    <url>/2019/07/24/BitPrint/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/bitPrint.jpg" class="full-image" />

<p>众所周知，程序中的变量存放于计算机内存中，程序对这些变量执行特定的赋值和计算等操作以实现某种功能。你是否好奇变量是如何被存储和表示于内存之中呢？</p>
<a id="more"></a>

<p>不同类型的变量所占字节大小不同、相同类型的变量在不同操作系统内所占字节大小也可能不同。而对于超过1字节的变量，根据不同的操作系统，还涉及字节序、字节对齐、大端or小端等其他问题。接下来让我们探究一下变量在内存中的表示与存放吧！</p>
<p><strong>关键词:</strong> 比特打印、字节序、字节对齐</p>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>一般初学一门编程语言时，最开始了解的就是这门语言支持的基本变量类型、其大小（占多少字节），可表示的数值范围。如在C/C++语言中，char类型的变量占一个字节(一个字节含8bit，为减少内存管理负担，一字节通常也是操作系统内存的最小单位，但应用时各bit可被赋予不同的语义）。char变量有8bit，除去最高位为符号位用于表示数的正负外，剩余的低7位可以表示到(0 ~ 2^7 - 1，即0～127)，加上符号位即 + - (0～127)，又由于”-0”(0x80)与我们常用的数学方式不符，而被译为-128，故在C/C++程序语言中，一个char类型的变量，仅占用一个字节，却被可以表示 -128 ~ 127 的数值范围。</p>
<h1 id="2-存储方式探究"><a href="#2-存储方式探究" class="headerlink" title="2. 存储方式探究"></a>2. 存储方式探究</h1><h2 id="2-1-打印各比特原理概述"><a href="#2-1-打印各比特原理概述" class="headerlink" title="2.1. 打印各比特原理概述"></a>2.1. 打印各比特原理概述</h2><p>运用C/C++中提供的位操作符和与操作原理“a &amp; 1 = a” 和 “a &amp; 0 = 0”获得各位的0/1值。依次从最高位开始提取，若为1则打印“1”，若为0则打印“0”，然后提取次高位的0/1值并打印，直至提取打印到最低位。至此一个字节的各比特的值都以打印出来。</p>
<h2 id="2-2-编码测试"><a href="#2-2-编码测试" class="headerlink" title="2.2. 编码测试"></a>2.2. 编码测试</h2><h3 id="2-2-1-byte-变量各比特位打印实现"><a href="#2-2-1-byte-变量各比特位打印实现" class="headerlink" title="2.2.1. byte 变量各比特位打印实现"></a>2.2.1. byte 变量各比特位打印实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印一个 byte 变量的各位</span></span><br><span class="line"><span class="comment"> * 默认各字节从左至右 对应 高位至地位</span></span><br><span class="line"><span class="comment"> * eg. 0x80  --&gt; [1000 0000]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitPrint::bitPrint_Byte</span><span class="params">(<span class="keyword">const</span> byte val)</span> </span>&#123;</span><br><span class="line">    byte comp = <span class="number">0x80</span>;<span class="comment">//相当于标尺，当前取最高位</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; [&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (comp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comp == <span class="number">0x08</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((val &amp; comp) == comp)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        comp &gt;&gt;= <span class="number">1</span>;<span class="comment">//逻辑右移，依次取各位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在调用该函数并传入参数0x55时，其执行结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="number">0101</span> <span class="number">0101</span>]</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：<br>由于传入参数0x55其高低字节都为5，二进制中表示为0101，而我们可以看到其在内存中存储结果其高低字节分别为[0101 0101]，与分析相符。</p>
<h3 id="2-2-2-char-变量各比特的打印实现"><a href="#2-2-2-char-变量各比特的打印实现" class="headerlink" title="2.2.2. char 变量各比特的打印实现"></a>2.2.2. char 变量各比特的打印实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印一个 char 变量的各位</span></span><br><span class="line"><span class="comment"> * 默认各字节从左至右 对应 高位至地位</span></span><br><span class="line"><span class="comment"> * eg. 0x80  --&gt; [1000 0000]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitPrint::bitPrint_Char</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;char = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Bits:&quot;</span>;</span><br><span class="line">    bitPrint_Byte((byte)val);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在调用该函数并传入参数’M’时，其执行结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> = M</span><br><span class="line">Bits: [<span class="number">0100</span> <span class="number">1101</span>]</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：<br>char类型与byte类型十分相似，都占用一个字节，但其最高位拥有特殊语义，最高位为0表示正数，最高位为1表示负数。当传入参数为’M’，查询ASCII（美国信息交换标准代码）表可知’M’的为表中第77个字符，用0x4D表示。其中高字节4二进制表示为0100，低字节D二进制表示为1101，且最高位（最左位）为0表示正数，结果与分析一致。</p>
<h3 id="2-2-3-int-变量各比特的打印实现"><a href="#2-2-3-int-变量各比特的打印实现" class="headerlink" title="2.2.3. int 变量各比特的打印实现"></a>2.2.3. int 变量各比特的打印实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印一个 int 变量的各位</span></span><br><span class="line"><span class="comment"> * 默认各字节从左至右 对应 高位至地位,</span></span><br><span class="line"><span class="comment"> * 默认从左至右为内存地址的增长方向</span></span><br><span class="line"><span class="comment"> * 小端字节序（正序）：高字节对应内存的高地址</span></span><br><span class="line"><span class="comment"> * 大端字节序（逆序）：高字节对应内存的低地址（网络传输统一用大端字节序）</span></span><br><span class="line"><span class="comment"> * eg. 0x00001234</span></span><br><span class="line"><span class="comment"> * 小端（正序） [0011 0100] [0001 0010] [0000 0000] [0000 0000]</span></span><br><span class="line"><span class="comment"> * 大端（逆序） [0000 0000] [0000 0000] [0001 0010] [0011 0100]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitPrint::bitPrint_Int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    byte* byteBuf = (byte *) &amp;val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;int = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Bits:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;IntLen; i++) &#123;</span><br><span class="line">        bitPrint_Byte(byteBuf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在调用该函数并传入参数19088743时，其执行结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> = <span class="number">19088743</span></span><br><span class="line">Bits: [<span class="number">0110</span> <span class="number">0111</span>] [<span class="number">0100</span> <span class="number">0101</span>] [<span class="number">0010</span> <span class="number">0011</span>] [<span class="number">0000</span> <span class="number">0001</span>]</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>int变量类型占用四个字节，其最高位拥有特殊语义，最高位为0表示正数，最高位为1表示负数。int变量占四个字节，所以就会引发这样一个问题——“字节在电脑中存放时的序列与输入（输出）时的序列是先到的在前还是后到的在前？”针对此问题，产生两种不同的字节序，即规定多字节变量在内存中连续存放时的顺序是低地址对应高字节or低地址对应低字节。产生了两种字节序：</p>
<ul>
<li>小端字节序（正序）：高字节对应内存的高地址</li>
<li>大端字节序（逆序）：高字节对应内存的低地址（网络传输统一用大端字节序）<br>由于不同的系统采用的字节序不同，正好也可验证下自己的操作系统采用哪种字节序。<br>当传入参数为19088743，其十六进制表示为0x01234567。而分析其执行结果，低地址存放为[0110 0111]，十六进制为0x67，对应int值的低字节；而高地址存放为[0000 0001]，十六进制为0x01，对应int值的高字节。故可得知博主操作系统字节序为小端字节序（正序）。</li>
</ul>
<h2 id="2-3-扩展延伸"><a href="#2-3-扩展延伸" class="headerlink" title="2.3. 扩展延伸"></a>2.3. 扩展延伸</h2><h3 id="2-3-1-打印-任意-变量的各比特"><a href="#2-3-1-打印-任意-变量的各比特" class="headerlink" title="2.3.1. 打印 任意 变量的各比特"></a>2.3.1. 打印 任意 变量的各比特</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印一个 任意 变量的各位</span></span><br><span class="line"><span class="comment"> * 默认各字节从左至右 对应 高位至地位,</span></span><br><span class="line"><span class="comment"> * 默认从左至右为内存地址的增长方向</span></span><br><span class="line"><span class="comment"> * 小端字节序（正序）：高字节对应内存的高地址</span></span><br><span class="line"><span class="comment"> * 大端字节序（逆序）：高字节对应内存的低地址（网络传输统一用大端字节序）</span></span><br><span class="line"><span class="comment"> * eg. 0x00001234</span></span><br><span class="line"><span class="comment"> * 小端（正序） [0011 0100] [0001 0010] [0000 0000] [0000 0000]</span></span><br><span class="line"><span class="comment"> * 大端（逆序） [0000 0000] [0000 0000] [0001 0010] [0011 0100]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitPrint::bitPrint_Element</span><span class="params">(<span class="keyword">void</span> *val, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    byte* byteBuf = <span class="keyword">new</span> byte[len];<span class="comment">//申请len长度的内存用于存放变量的所有字节</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(byteBuf, val, len);<span class="comment">//深拷贝</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bits:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        bitPrint_Byte(byteBuf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> byteBuf;<span class="comment">//释放byteBuf内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在调用该函数并传入参数为一个自定义类（或结构体）时，其执行结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数：学生成绩类的首地址</span></span><br><span class="line"><span class="comment">//学生成绩类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> id;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Student(<span class="keyword">char</span> id, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主函数内运行</span></span><br><span class="line">Student* xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;A&#x27;</span>, <span class="number">88</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class = &#123;&quot;</span> &lt;&lt; xiaoming-&gt;id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; xiaoming-&gt;score &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">bitPrint-&gt;bitPrint_Element(xiaoming, <span class="keyword">sizeof</span>(Student));</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> =</span> &#123;A, <span class="number">88</span>&#125;</span><br><span class="line">Bits: [<span class="number">0100</span> <span class="number">0001</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0101</span> <span class="number">1000</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0000</span> <span class="number">0000</span>] [<span class="number">0000</span> <span class="number">0000</span>]</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：<br>从学生成绩类的定义可以看出，此类含有两个属性：char类型的学生编号id 和 int类型的学生成绩score，按理说这个类实例化后分配的内存应该是（1+4）为5个字节，但结果确是8个字节，这是为了方便快速地寻址，编译器会采用字节对齐，将下一个变量地址放置在系统能快速读取的位置（如：32位系统，放在偶地址的变量能够1个读周期取到值，而放在奇地址的变量却需要2个读周期才能取到值，故会存在字节对齐）。所以在第一个char变量后跳过了3个字节，将第二个int变量首地址设置为第5个字节。故此Student类在内存中的存放为：0x41、连续3个0x00对齐字节，4个字节的int变量[0101 1000] [0000 0000] [0000 0000] [0000 0000]，合计8个字节。</p>
<h3 id="2-3-2-判断系统是否为大端字节序"><a href="#2-3-2-判断系统是否为大端字节序" class="headerlink" title="2.3.2. 判断系统是否为大端字节序"></a>2.3.2. 判断系统是否为大端字节序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 判断系统是否为大端字节序</span></span><br><span class="line"><span class="comment"> * 小端字节序（正序）：高字节对应内存的高地址</span></span><br><span class="line"><span class="comment"> * 大端字节序（逆序）：高字节对应内存的低地址（网络传输统一用大端字节序）</span></span><br><span class="line"><span class="comment"> * @Return 是大端字节序（true）；是小端字节序（false）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BitPrint::isBigEndian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">0x01</span>;</span><br><span class="line">    byte* byteBuf = (byte *) &amp;test;</span><br><span class="line">    <span class="comment">//取低地址的一个字节为Byte变量，若其值等于低字节0x01则为正序（小端）</span></span><br><span class="line">    <span class="keyword">return</span> (byteBuf[<span class="number">0</span>] == <span class="number">0x01</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数内运行 main.cpp</span></span><br><span class="line"><span class="comment">//判断系统是否为大端字节序</span></span><br><span class="line"><span class="keyword">if</span> (bitPrint-&gt;isBigEndian()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Yes, this system is Big Endian System&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;No, this system is Small Endian System&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line">No, <span class="keyword">this</span> system is Small Endian System</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>通过判断特定的int变量在内存中存放的次序即可判断当前系统采用的字节序。实际操作为取特定值为0x01的int变量的低地址的一个字节为Byte变量，若其值等于低字节0x01则为正序（小端），反之则为大端字节序。</p>
<h1 id="3-字节对齐"><a href="#3-字节对齐" class="headerlink" title="3. 字节对齐"></a>3. 字节对齐</h1><p>前面分析到为了方便快速地寻址，编译器会采用字节对齐，将下一个变量地址放置在系统能快速读取的位置（如：32位系统，放在偶地址的变量能够1个读周期取到值，而放在奇地址的变量却需要2个读周期才能取到值，故会存在字节对齐）。<br>即对待结构体内的各位元素就像对待sizeof为n的数组一样，从结构体首地址开始依次向后为每个成员寻找第一个满足“addr % N == 0”的地址，如果不够则在前一个成员变量后补空字节使之满足条件。上面的N为对齐参数(N = min(sizeof(第i个成员类型),n))，n，可以设置，在c++中缺省值为8。<br>下面一起来验证一下吧！</p>
<h2 id="3-1-先自定义一个包含多类型变量的结构体"><a href="#3-1-先自定义一个包含多类型变量的结构体" class="headerlink" title="3.1. 先自定义一个包含多类型变量的结构体"></a>3.1. 先自定义一个包含多类型变量的结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MSG1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">16</span>];<span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> type;<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">char</span> flag;<span class="comment">// 1  --&gt;   字节对齐（其后闲置1字节，共占2字节）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uiHashValue;<span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uiDataLen;<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> contentData[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MSG0</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">16</span>];<span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> type;<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">char</span> flag; <span class="comment">// 1  --&gt;   字节对齐（其后闲置1字节）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uiHashValue;<span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uiDataLen;<span class="comment">// 4  --&gt;   字节对齐（其后闲置4字节，共占8字节）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ulStartTime;<span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ulEndTime;<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> contentData[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个该结构体变量并打印出各成员变量的地址如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MSG1 msg1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1:\t\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.ID:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.ID &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.ID - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.type:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.type &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.type - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.flag:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.flag &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.flag - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.uiHashValue:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.uiHashValue &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.uiHashValue - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.uiDataLen:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg1.uiDataLen &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.uiDataLen - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg1.contentData:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)msg1.contentData &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1.contentData - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    MSG0 msg0;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0:\t\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.ID:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.ID &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.ID - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.type:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.type &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.type - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.flag:\t\t\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.flag &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.flag - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.uiHashValue:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.uiHashValue &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.uiHashValue - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.uiDataLen:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.uiDataLen &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.uiDataLen - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.ulStartTime:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.ulStartTime &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.ulStartTime - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.ulEndTime:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;msg0.ulEndTime &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.ulEndTime - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">        <span class="string">&quot;&amp;msg0.contentData:\t&quot;</span> &lt;&lt; (<span class="keyword">void</span>*)msg0.contentData &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0.contentData - (<span class="keyword">uint64_t</span>)(<span class="keyword">void</span>*)&amp;msg0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line">&amp;msg1:				<span class="number">0x7ffeed56a8d8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg1.ID:			<span class="number">0x7ffeed56a8d8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg1.type:			<span class="number">0x7ffeed56a8e8</span> , <span class="number">16</span></span><br><span class="line">&amp;msg1.flag:			<span class="number">0x7ffeed56a8ea</span> , <span class="number">18</span></span><br><span class="line">&amp;msg1.uiHashValue:	<span class="number">0x7ffeed56a8ec</span> , <span class="number">20</span></span><br><span class="line">&amp;msg1.uiDataLen:	<span class="number">0x7ffeed56a8f0</span> , <span class="number">24</span></span><br><span class="line">&amp;msg1.contentData:	<span class="number">0x7ffeed56a8f4</span> , <span class="number">28</span></span><br><span class="line"></span><br><span class="line">&amp;msg0:				<span class="number">0x7ffeecdd38c0</span> , <span class="number">0</span></span><br><span class="line">&amp;msg0.ID:			<span class="number">0x7ffeecdd38c0</span> , <span class="number">0</span></span><br><span class="line">&amp;msg0.type:			<span class="number">0x7ffeecdd38d0</span> , <span class="number">16</span></span><br><span class="line">&amp;msg0.flag:			<span class="number">0x7ffeecdd38d2</span> , <span class="number">18</span></span><br><span class="line">&amp;msg0.uiHashValue:	<span class="number">0x7ffeecdd38d4</span> , <span class="number">20</span></span><br><span class="line">&amp;msg0.uiDataLen:	<span class="number">0x7ffeecdd38d8</span> , <span class="number">24</span></span><br><span class="line">&amp;msg0.ulStartTime:	<span class="number">0x7ffeecdd38e0</span> , <span class="number">32</span></span><br><span class="line">&amp;msg0.ulEndTime:	<span class="number">0x7ffeecdd38e8</span> , <span class="number">40</span></span><br><span class="line">&amp;msg0.contentData:	<span class="number">0x7ffeecdd38f0</span> , <span class="number">48</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>通过结构体MSG1定义的变量，其成员变量的地址于首地址的偏差可以看出，第三个成员变量flag虽为char类型，只占1字节，但编译器为了访问后续自变量更方便（放在偶地址，若为奇地址需要2个读周期才能取到值），所以编译器将下一个变量uiHashValue的首地址向后挪动一位到偏移地址为20处（偶地址的变量能够1个读周期取到值），相当于第三个成员变量占用2各字节（后一字节闲置）</p>
<ul>
<li>第一个成员地址为0，已对齐。</li>
<li>第二个成员，由于上一个成员大小为16所以当前准地址为：16，N = min(sizeof(unsigned short),8)等于2，满足“addr % N == 0”，已对齐</li>
<li>第三个成员，由于上一个成员大小为2所以当前准地址为：18，N = min(sizeof(char),8)等于1，满足“addr % N == 0”，已对齐</li>
<li>第四个成员，由于上一个成员大小为1所以当前准地址为：19，N = min(sizeof(unsigned int),8)等于4，不满足“addr % N == 0”，19%4余1，故在前一个变量后补1个字节，使当前地址20满足“addr % N == 0”</li>
<li>第五个成员，由于上一个成员大小为4所以当前准地址为：24，N = min(sizeof(unsigned int),8)等于4，满足“addr % N == 0”，已对齐</li>
<li>第六个成员，由于上一个成员大小为4所以当前准地址为：28，N = min(sizeof(char),8)等于1，满足“addr % N == 0”，已对齐</li>
</ul>
<p>同理对结构体MSG0的实际变量定义的变量，齐成员变量的地址于首地址的偏差可看出除了同样在第三个成员变量flag后跳过了1个字节，将下一个变量uiHashValue的首地址向后挪动一位到偏移地址为20处外，还在第5个变量uiDataLen后插入4字节闲置字节{8+8},{2+(1+1)+4},{(4+4)},{8},{8}。</p>
<ul>
<li>第一个成员地址为0，已对齐。</li>
<li>第二个成员，由于上一个成员大小为16所以当前准地址为：16，N = min(sizeof(unsigned short),8)等于2，满足“addr % N == 0”，已对齐</li>
<li>第三个成员，由于上一个成员大小为2所以当前准地址为：18，N = min(sizeof(char),8)等于1，满足“addr % N == 0”，已对齐</li>
<li>第四个成员，由于上一个成员大小为1所以当前准地址为：19，N = min(sizeof(unsigned int),8)等于4，不满足“addr % N == 0”，19%4余1，故在前一个成员后补1个字节，使当前地址20满足“addr % N == 0”</li>
<li>第五个成员，由于上一个成员大小为4所以当前准地址为：24，N = min(sizeof(unsigned int),8)等于4，满足“addr % N == 0”，已对齐</li>
<li>第六个成员，由于上一个成员大小为4所以当前准地址为：28，N = min(sizeof(unsigned long long int),8)等于8，不满足“addr % N == 0”，28%8余4，故在前一字成员后补4个字节，使当前地址为32满足“addr % N == 0”</li>
<li>第七个成员，由于上一个成员大小为8所以当前准地址为：40，N = min(sizeof(unsigned int),8)等于8，满足“addr % N == 0”，已对齐</li>
<li>第八个成员，由于上一个成员大小为8所以当前准地址为：48，N = min(sizeof(char),8)等于1，满足“addr % N == 0”，已对齐</li>
</ul>
<h2 id="3-2-禁止编译器自动字节对齐"><a href="#3-2-禁止编译器自动字节对齐" class="headerlink" title="3.2. 禁止编译器自动字节对齐"></a>3.2. 禁止编译器自动字节对齐</h2><p>我们可以在定义结构体上方加一句配置，设置对齐参数为1字节从而实现关闭编译器自动对齐的目的（可能带来性能损失或其他错误）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">// 编译使用1字节对齐，未设置则自动字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MSG1</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MSG0</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出各成员变量的地址如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp;msg1:				<span class="number">0x7ffee5ce28d8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg1.ID:			<span class="number">0x7ffee5ce28d8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg1.type:			<span class="number">0x7ffee5ce28e8</span> , <span class="number">16</span></span><br><span class="line">&amp;msg1.flag:			<span class="number">0x7ffee5ce28ea</span> , <span class="number">18</span></span><br><span class="line">&amp;msg1.uiHashValue:	<span class="number">0x7ffee5ce28eb</span> , <span class="number">19</span></span><br><span class="line">&amp;msg1.uiDataLen:	<span class="number">0x7ffee5ce28ef</span> , <span class="number">23</span></span><br><span class="line">&amp;msg1.contentData:	<span class="number">0x7ffee5ce28f3</span> , <span class="number">27</span></span><br><span class="line"></span><br><span class="line">&amp;msg0:				<span class="number">0x7ffee5ce28a8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg0.ID:			<span class="number">0x7ffee5ce28a8</span> , <span class="number">0</span></span><br><span class="line">&amp;msg0.type:			<span class="number">0x7ffee5ce28b8</span> , <span class="number">16</span></span><br><span class="line">&amp;msg0.flag:			<span class="number">0x7ffee5ce28ba</span> , <span class="number">18</span></span><br><span class="line">&amp;msg0.uiHashValue:	<span class="number">0x7ffee5ce28bb</span> , <span class="number">19</span></span><br><span class="line">&amp;msg0.uiDataLen:	<span class="number">0x7ffee5ce28bf</span> , <span class="number">23</span></span><br><span class="line">&amp;msg0.ulStartTime:	<span class="number">0x7ffee5ce28c3</span> , <span class="number">27</span></span><br><span class="line">&amp;msg0.ulEndTime:	<span class="number">0x7ffee5ce28cb</span> , <span class="number">35</span></span><br><span class="line">&amp;msg0.contentData:	<span class="number">0x7ffee5ce28d3</span> , <span class="number">43</span></span><br></pre></td></tr></table></figure>
<p>可以看出设置字节对齐参数为1字节后，相当于关闭了字节对齐</p>
<h1 id="4-按字节访问"><a href="#4-按字节访问" class="headerlink" title="4. 按字节访问"></a>4. 按字节访问</h1><p>所有对结构体成员的指针访问，都可以理解为用特定的类型去解读一个地址。下方为示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG1_HEAD_LEN  (offsetof(MSG1,contentData))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG0_HEAD_LEN  (offsetof(MSG0,contentData))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MSG0_HEAD_LEN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MSG1_HEAD_LEN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    MSG0 msg0;</span><br><span class="line">    msg0.ulStartTime = <span class="number">20181112U</span>LL;</span><br><span class="line">    msg0.ulEndTime = <span class="number">561341235U</span>LL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* p = &amp;msg0;</span><br><span class="line"></span><br><span class="line">    MSG1* msg1Ptr = (MSG1*)p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>  &lt;&lt; <span class="string">&quot;(msg1Ptr-&gt;contentData): &quot;</span> &lt;&lt; (<span class="keyword">void</span> *)(msg1Ptr-&gt;contentData) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt;  *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>*)(msg1Ptr-&gt;contentData)  &lt;&lt; <span class="string">&quot; ULL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>  &lt;&lt; <span class="string">&quot;(msg1Ptr-&gt;contentData + 8): &quot;</span> &lt;&lt; (<span class="keyword">void</span> *)(msg1Ptr-&gt;contentData + <span class="number">8</span>)&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt;  *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>*)(msg1Ptr-&gt;contentData + <span class="number">8</span>) &lt;&lt; <span class="string">&quot; ULL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line">(msg1Ptr-&gt;contentData): <span class="number">0x7ffeeb5118e3</span>, <span class="number">20181112</span> ULL</span><br><span class="line">(msg1Ptr-&gt;contentData + <span class="number">8</span>): <span class="number">0x7ffeeb5118eb</span>, <span class="number">561341235</span> ULL</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<p>代码主要是有结构体MSG0定义了一个变量并未其相对于MSG1多出的两个变量赋值，然后实现用MSG1类型的指针访问MSG0中多出的变量（默认没有指针），来例证c++的访问变量的机制为“以特定的类型去解读一个地址”，无论其是否真的被定义成那样（前提条件：该地址是被定义过的且可访问的地址，否则会被认为内存越界）。</p>
<p>附录：完整代码详见个人git仓库：<a href="https://github.com/EisenHao/Cpp_Learning/blob/master/BitPrint.cpp">BitPrint.cpp</a>,<a href="https://github.com/EisenHao/Cpp_Learning/blob/master/BitPrint.h">BitPrint.h</a></p>
<h1 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h1><ul>
<li><a href="https://wenku.baidu.com/view/ec9cba000740be1e650e9aa5.html">结构体内存分配分析</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算学习笔记</title>
    <url>/2019/07/05/CloudComputingNote/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/cloudComputing.jpg" class="full-image" />

<h1 id="1-Bigtable————分布式结构化数据表"><a href="#1-Bigtable————分布式结构化数据表" class="headerlink" title="1. Bigtable————分布式结构化数据表"></a>1. Bigtable————分布式结构化数据表</h1><h2 id="1-1-Bigtable特点"><a href="#1-1-Bigtable特点" class="headerlink" title="1.1. Bigtable特点"></a>1.1. Bigtable特点</h2><ul>
<li> 数据种类繁多，满足一系列Google产品的存储要求</li>
<li>吞吐量大，响应海量的服务请求</li>
<li>高可用性，几乎所有情况下的系统均可用</li>
<li>高扩展性，可根据需要随时加入或撤销服务器</li>
<li>简单，简单的底层系统，既减小了系统出错概念，又使上层应用开发更简单</li>
</ul>
<a id="more"></a>
<h2 id="1-2-Bigtable存储结构"><a href="#1-2-Bigtable存储结构" class="headerlink" title="1.2. Bigtable存储结构"></a>1.2. Bigtable存储结构</h2><p>Bigtable是一个分布式多维映射表，表中的数据通过一个行关键字（Row Key）、一个列关键字（Column Key）以及一个时间戳（Time Stamp）进行索引</p>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190617095713134.png" alt="CloudComputing-20190617095713134"></p>
<h3 id="1-2-1-行关键字（Row-Key）"><a href="#1-2-1-行关键字（Row-Key）" class="headerlink" title="1.2.1. 行关键字（Row Key）"></a>1.2.1. 行关键字（Row Key）</h3><ul>
<li>可为任意字符串，最大64KB</li>
<li>表中数据根据行关键字排序（词典序）</li>
<li>同一地址域的网页关键字会存储在表中连续位置</li>
<li>压缩倒排以提高压缩率</li>
</ul>
<h3 id="1-2-2-列关键字（Column-Key）"><a href="#1-2-2-列关键字（Column-Key）" class="headerlink" title="1.2.2. 列关键字（Column Key）"></a>1.2.2. 列关键字（Column Key）</h3><ul>
<li>列的关键字应有其意义</li>
<li>列的簇名同时也是Bigtable中ACL访问控制的基本单元</li>
</ul>
<h3 id="1-2-3-时间戳（Time-Stamp）"><a href="#1-2-3-时间戳（Time-Stamp）" class="headerlink" title="1.2.3. 时间戳（Time Stamp）"></a>1.2.3. 时间戳（Time Stamp）</h3><ul>
<li>相同的内容需要保存不同时刻的数据版本（eg.网页检索数据、用户个性化设置数据）</li>
<li>64位整形存储，用户自定义赋值方式和意义</li>
</ul>
<h3 id="1-2-4-Bigtable数据存储及读写操作"><a href="#1-2-4-Bigtable数据存储及读写操作" class="headerlink" title="1.2.4. Bigtable数据存储及读写操作"></a>1.2.4. Bigtable数据存储及读写操作</h3><ul>
<li>较新的数据存储在内存中称为内存表（Memtable）的有序缓冲里</li>
<li>较旧的数据以SSTable格式保存在GFS中</li>
</ul>
<h4 id="1-2-4-1-读写操作有很大差异"><a href="#1-2-4-1-读写操作有很大差异" class="headerlink" title="1.2.4.1. 读写操作有很大差异"></a>1.2.4.1. 读写操作有很大差异</h4><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618161018598.png" alt="CloudComputing-20190618161018598"></p>
<h2 id="1-3-Bigtable基本架构"><a href="#1-3-Bigtable基本架构" class="headerlink" title="1.3. Bigtable基本架构"></a>1.3. Bigtable基本架构</h2><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190617100822880.png" alt="CloudComputing-20190617100822880"></p>
<h3 id="1-3-1-其中Chubby的作用"><a href="#1-3-1-其中Chubby的作用" class="headerlink" title="1.3.1. 其中Chubby的作用"></a>1.3.1. 其中Chubby的作用</h3><ul>
<li>保证一致性（使所有子表服务器选取唯一一个主服务器）</li>
<li>获取子表服务器列表。扫描并发现目前活跃的子表服务器列表</li>
<li>保存Bigtable的模式信息和ACL访问控制列表。与所有活跃的子表服务器联系，并获取所有子表的分配情况；通过扫描元数据表发现未分配的子表，并将其分配到合适的子表服务器</li>
</ul>
<h3 id="1-3-2-其中主服务器的作用"><a href="#1-3-2-其中主服务器的作用" class="headerlink" title="1.3.2. 其中主服务器的作用"></a>1.3.2. 其中主服务器的作用</h3><ul>
<li>新子表分配。当新子表产生时，主服务器通过一个加载命令将新子表分配给一个拥有足够空间的子表服务器，子表服务器分割完成后会向主服务器返回一个通知（创建新表、合并表、大表分裂都会产生一个或多个子表）</li>
<li>子表服务器集群的状态监控。主服务器对子表服务器状态进行监控，以便于及时监测到服务器的加入和撤销</li>
<li>子表服务器之间的负载均衡</li>
</ul>
<h3 id="1-3-3-其中子表服务器"><a href="#1-3-3-其中子表服务器" class="headerlink" title="1.3.3. 其中子表服务器"></a>1.3.3. 其中子表服务器</h3><h4 id="1-3-3-1-子表SSTable-Sorted-String-Table"><a href="#1-3-3-1-子表SSTable-Sorted-String-Table" class="headerlink" title="1.3.3.1. 子表SSTable(Sorted String Table)"></a>1.3.3.1. 子表SSTable(Sorted String Table)</h4><p>每个子表服务器上保存几十～几千哥子表。SSTable是Google为Bigtable设计的内部数据存储格式。所有的SSTable文件都存储在GFS上，用户可以通过键来查询相应的值。</p>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190617104500323.png" alt="CloudComputing-20190617104500323"></p>
<h4 id="1-3-3-2-子表的组成"><a href="#1-3-3-2-子表的组成" class="headerlink" title="1.3.3.2. 子表的组成"></a>1.3.3.2. 子表的组成</h4><ul>
<li>不同子表的SSTable可以共享</li>
<li>每个子表服务器上仅保存一个日志文件</li>
<li>日志内容按照键值排序</li>
<li>每个子表服务器上保存几十～几千个子表（平均100个子表）</li>
</ul>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190617104904894.png" alt="CloudComputing-20190617104904894"></p>
<h4 id="1-3-3-3-子表地址"><a href="#1-3-3-3-子表地址" class="headerlink" title="1.3.3.3. 子表地址"></a>1.3.3.3. 子表地址</h4><p>Bigtable系统内部采用的是一种类似B+树的三层查询体系</p>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190617110037290.png" alt="CloudComputing-20190617110037290"></p>
<h4 id="1-3-3-4-三种形式压缩之间的关系"><a href="#1-3-3-4-三种形式压缩之间的关系" class="headerlink" title="1.3.3.4. 三种形式压缩之间的关系"></a>1.3.3.4. 三种形式压缩之间的关系</h4><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618161124154.png" alt="CloudComputing-20190618161124154"></p>
<h2 id="1-4-Bigtable中的性能优化"><a href="#1-4-Bigtable中的性能优化" class="headerlink" title="1.4. Bigtable中的性能优化"></a>1.4. Bigtable中的性能优化</h2><h3 id="1-4-1-局部性群组"><a href="#1-4-1-局部性群组" class="headerlink" title="1.4.1. 局部性群组"></a>1.4.1. 局部性群组</h3><p>Bigtable允许用户将存储在不同区域的数据组织在一个单独的SSTable中（以列簇为单位），以构成一个局部性群组。（类似数据库中两个表的自然连接）</p>
<ul>
<li>可筛选在意的数据内容（类似数据库中投影）</li>
<li>改善经常被读取的局部数据的访问速率</li>
</ul>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618161816332.png" alt="CloudComputing-20190618161816332"></p>
<h3 id="1-4-2-压缩"><a href="#1-4-2-压缩" class="headerlink" title="1.4.2. 压缩"></a>1.4.2. 压缩</h3><p>Bigtable中广泛应用压缩（eg.用于构成局部性群组的SSTable中）</p>
<ul>
<li>利用Bentley &amp; McIlroy方式（BMDiff）在大的扫描窗口将常见的长串进行压缩</li>
<li>采取Zippy技术进行快速压缩，它在一个16KB大小的扫描窗口内寻找重复数据，这个过程非常快</li>
</ul>
<h3 id="1-4-3-布隆过滤器"><a href="#1-4-3-布隆过滤器" class="headerlink" title="1.4.3. 布隆过滤器"></a>1.4.3. 布隆过滤器</h3><p>巴顿·布隆于1970年提出，它实际上是一个很长的二进制向量和一系列随机映射函数。在Bigtable中用于读写操作中确定子表位置</p>
<p>优点：</p>
<ul>
<li>速度快，省空间</li>
<li>不会将一个子表误判成不存在</li>
</ul>
<p>缺点：</p>
<ul>
<li>某些情况下，会将不存在的子表误判成存在</li>
</ul>
<h1 id="2-Megastore————分布式存储系统"><a href="#2-Megastore————分布式存储系统" class="headerlink" title="2. Megastore————分布式存储系统"></a>2. Megastore————分布式存储系统</h1><h2 id="2-1-产生原因（业务驱动）："><a href="#2-1-产生原因（业务驱动）：" class="headerlink" title="2.1. 产生原因（业务驱动）："></a>2.1. 产生原因（业务驱动）：</h2><ul>
<li>高负载的交互式应用，传统关系型数据库通过连接（join）提升性能代价过于高昂</li>
<li>业务需求中读操作远远大于写操作</li>
<li>基于Bigtable这样的key/value存储系统之上，设计存储和查询级联数据的分布式存储系统非常方便</li>
</ul>
<h2 id="2-2-说明"><a href="#2-2-说明" class="headerlink" title="2.2. 说明"></a>2.2. 说明</h2><ul>
<li>介于传统关系型数据库和NoSQL之间的存储技术，并尽可能地实现高可用性和高可扩展性的统一。</li>
<li>对于高可用性，Megastore实现了一个同步的、容错的、适合远距离传输的<strong>复制机制</strong></li>
<li>对高扩展性，Megastore将数据分割成很多小数据分区（存放于NoSQL数据库中）</li>
</ul>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618163837063.png" alt="CloudComputing-20190618163837063"></p>
<ul>
<li>在Megastore中，这些小的数据分区被称为实体组集（Entity Groups）</li>
<li>每个实体组集包含若干的实体组（Entity Group，相当于分区中表的概念）</li>
<li>一个实体组中包含很多的实体（Entity，相当于表中记录的概念）</li>
</ul>
<p>性能</p>
<ul>
<li>平均读取延迟在<strong>万分之一毫秒</strong>之内，平均写入延迟在<strong>100至400毫秒</strong>之间 </li>
</ul>
<h2 id="2-3-Megastore数据模型"><a href="#2-3-Megastore数据模型" class="headerlink" title="2.3. Megastore数据模型"></a>2.3. Megastore数据模型</h2><ul>
<li>同关系型数据库一样，Megastore的数据模型是在模式（schema）中定义的且是强类型的（strongly typed）</li>
<li>每个模式都由一系列的表（tables）构成，表又包含有一系列的实体（entities），每实体中包含一系列属性（properties）</li>
<li>属性是命名的且具有类型，这些类型包括字符型（strings）、数字类型（numbers）或者Google的Protocol Buffers。</li>
</ul>
<h2 id="2-4-Megastore索引"><a href="#2-4-Megastore索引" class="headerlink" title="2.4. Megastore索引"></a>2.4. Megastore索引</h2><ul>
<li>局部索引。定义在单个实体组中，作用域仅限于单个实体组（ 如PhotosByTime ）</li>
<li>全局索引。可以横跨多个实体组集进行数据读取操作（ 如PhotosByTag ）</li>
<li>额外索引。STORING子句、可重复的索引、内联索引</li>
</ul>
<h2 id="2-5-在Bigtable中的存储情况"><a href="#2-5-在Bigtable中的存储情况" class="headerlink" title="2.5. 在Bigtable中的存储情况"></a>2.5. 在Bigtable中的存储情况</h2><table>
<thead>
<tr>
<th>行键（Row Key）</th>
<th><strong>User.name</strong></th>
<th><strong>Photo.time</strong></th>
<th><strong>Photo.tag</strong></th>
<th><strong>Photo._**</strong>url**</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>John</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>101,500</td>
<td></td>
<td>12:30:01</td>
<td>Dinner,   Paris</td>
<td>…</td>
</tr>
<tr>
<td>101,502</td>
<td></td>
<td>12:15:22</td>
<td>Betty, Paris</td>
<td>…</td>
</tr>
<tr>
<td>102</td>
<td>Mary</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Bigtable的列名实际上是表名和属性名结合在一起得到，不同表中实体可存储在同一个Bigtable行中</p>
<h2 id="2-6-Megastore中的事务及并发控制"><a href="#2-6-Megastore中的事务及并发控制" class="headerlink" title="2.6. Megastore中的事务及并发控制"></a>2.6. Megastore中的事务及并发控制</h2><h3 id="2-6-1-读操作"><a href="#2-6-1-读操作" class="headerlink" title="2.6.1. 读操作"></a>2.6.1. 读操作</h3><ul>
<li>current。总是在单个实体组中完成</li>
<li>snapshot。总是在单个实体组中完成、系统取出已知的最后一个完整提交的事务的时间戳，接着从这个位置读数据</li>
<li>inconsistent。忽略日志的状态直接读取最新的值</li>
</ul>
<h3 id="2-6-2-完整的事物周期"><a href="#2-6-2-完整的事物周期" class="headerlink" title="2.6.2. 完整的事物周期"></a>2.6.2. 完整的事物周期</h3><ul>
<li><p>读。获取最后一次提交的事务的时间戳和日志位置</p>
</li>
<li><p>应用逻辑。从Bigtable读取且聚集数据到日志入口</p>
</li>
<li><p>提交。使用Paxos协议达成一致性，将一个入口追加到日志</p>
</li>
<li><p>生效。将数据更新到Bigtable中的实体和索引中</p>
</li>
<li><p>清除。清除不需要的数据</p>
</li>
</ul>
<h3 id="2-6-3-Megastore中的事务机制"><a href="#2-6-3-Megastore中的事务机制" class="headerlink" title="2.6.3. Megastore中的事务机制"></a>2.6.3. Megastore中的事务机制</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618171208831.png" alt="CloudComputing-20190618171208831"></p>
<h2 id="2-7-Megastore基本架构"><a href="#2-7-Megastore基本架构" class="headerlink" title="2.7. Megastore基本架构"></a>2.7. Megastore基本架构</h2><p>在Megastore中共有三种副本：</p>
<ul>
<li>完整副本（Full Replica）</li>
<li>见证者副本（Witness Replica）</li>
<li>只读副本（Read-only Replica）</li>
</ul>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618171436506.png" alt="CloudComputing-20190618171436506"></p>
<h2 id="2-8-快速读与快速写"><a href="#2-8-快速读与快速写" class="headerlink" title="2.8. 快速读与快速写"></a>2.8. 快速读与快速写</h2><h3 id="2-8-1-快速读"><a href="#2-8-1-快速读" class="headerlink" title="2.8.1. 快速读"></a>2.8.1. 快速读</h3><ul>
<li>利用本地读取实现快速读，带来更好的用户体验及更低的延迟</li>
<li>关键是保证选择的副本上数据是最新的</li>
<li>协调者是一个服务，该服务分布在每个副本的数据中心里面。它的主要作用就是跟踪一个实体组集合</li>
<li>协调者的状态是由写算法来保证 </li>
</ul>
<h3 id="2-8-2-快速写"><a href="#2-8-2-快速写" class="headerlink" title="2.8.2. 快速写"></a>2.8.2. 快速写</h3><ul>
<li>如果一次写成功，那么下一次写的时候就跳过准备过程，直接进入接受阶段</li>
<li>Megastore没有使用专门的主服务器，而是使用leaders </li>
<li>leader主要是来裁决哪个写入的值可以获取0号提议</li>
<li>客户端、网络及Bigtable的故障都会导致一个写操作处于不确定的状态 </li>
</ul>
<h2 id="2-9-Megastore核心技术–复制"><a href="#2-9-Megastore核心技术–复制" class="headerlink" title="2.9. Megastore核心技术–复制"></a>2.9. Megastore核心技术–复制</h2><h3 id="2-9-1-复制的日志"><a href="#2-9-1-复制的日志" class="headerlink" title="2.9.1. 复制的日志"></a>2.9.1. 复制的日志</h3><ul>
<li><p>每个副本都存有记录所有更新的数据</p>
</li>
<li><p>Megastore允许副本不按顺序接受日志，这些日志将独立的存储在Bigtable中</p>
</li>
</ul>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618171942921.png" alt="CloudComputing-20190618171942921"></p>
<h3 id="2-9-2-读取数据"><a href="#2-9-2-读取数据" class="headerlink" title="2.9.2. 读取数据"></a>2.9.2. 读取数据</h3><p>本地查询 -&gt; 发现位置 -&gt; 追赶 -&gt; 验证 -&gt; 查询数据</p>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618172138062.png" alt="CloudComputing-20190618172138062"></p>
<h3 id="2-9-3-写入数据"><a href="#2-9-3-写入数据" class="headerlink" title="2.9.3. 写入数据"></a>2.9.3. 写入数据</h3><p>接收leader -&gt; 准备 -&gt; 接收 -&gt; 失效 -&gt; 生效</p>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190618172312027.png" alt="CloudComputing-20190618172312027"></p>
<h3 id="2-9-4-协调者的可用性"><a href="#2-9-4-协调者的可用性" class="headerlink" title="2.9.4. 协调者的可用性"></a>2.9.4. 协调者的可用性</h3><ul>
<li>协调者在系统中是比较重要的——协调者的进程运行在每个数据中心。每次的写操作中都要涉及协调者，因此协调者的故障将会导致系统的不可用</li>
<li>Megastore使用了Chubby锁服务，为了处理请求，一个协调者必须持有多数锁。一旦因为出现问题导致它丢失了大部分锁，协调者就会恢复到一个默认保守状态</li>
<li>除了可用性问题，对于协调者的读写协议必须满足一系列的竞争条件 </li>
</ul>
<h1 id="3-Dapper————大规模分布式系统的监控基础架构"><a href="#3-Dapper————大规模分布式系统的监控基础架构" class="headerlink" title="3. Dapper————大规模分布式系统的监控基础架构"></a>3. Dapper————大规模分布式系统的监控基础架构</h1><h2 id="3-1-三个基本概念"><a href="#3-1-三个基本概念" class="headerlink" title="3.1. 三个基本概念"></a>3.1. 三个基本概念</h2><ul>
<li>监控树（Trace Tree）。一个同特定事件相关的所有消息</li>
<li>区间（Span）。实际上就是一条记录</li>
<li>注释（Annotation）。主要用来辅助推断区间关系，也可以包含一些自定义的内容</li>
</ul>
<h2 id="3-2-监控信息的汇总"><a href="#3-2-监控信息的汇总" class="headerlink" title="3.2. 监控信息的汇总"></a>3.2. 监控信息的汇总</h2><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190710111630677.png" alt="CloudComputing-20190710111630677"></p>
<h2 id="3-3-关键性技术"><a href="#3-3-关键性技术" class="headerlink" title="3.3. 关键性技术"></a>3.3. 关键性技术</h2><h3 id="3-3-1-轻量级核心功能库"><a href="#3-3-1-轻量级核心功能库" class="headerlink" title="3.3.1. 轻量级核心功能库"></a>3.3.1. 轻量级核心功能库</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190710111819223.png" alt="CloudComputing-20190710111819223"></p>
<ul>
<li>最关键的代码基础是——基本RPC、线程和控制流函数库的实现</li>
<li>主要功能是——实现区间创建、抽样和在本地磁盘上记录日志。</li>
<li>将复杂的功能实现限制在一个轻量级的核心功能库中——保证了Dapper的监控过程基本对应用层透明。</li>
</ul>
<h3 id="3-3-2-二次抽样技术"><a href="#3-3-2-二次抽样技术" class="headerlink" title="3.3.2. 二次抽样技术"></a>3.3.2. 二次抽样技术</h3><p>利用二次抽样技术成功地解决了<strong>低开销及广泛可部署性</strong>的问题。</p>
<ol>
<li>第一次抽样。实践中，设计人员发现当抽样率低至1/1024时也能够产生足够多的有效监控数据，即在1024个请求中抽取1个进行监控也是可行的，从而可以捕获有效数据</li>
<li>第二次抽样。发生在数据写入Bigtable前，具体方法是将监控id散列成一个标量z（0≤z≤1），如果某个区间的z小于事先定义好的汇总抽样系数，则保留这个区间并将它写入Bigtable，否则丢弃 </li>
</ol>
<h2 id="3-4-Dapper使用心得"><a href="#3-4-Dapper使用心得" class="headerlink" title="3.4. Dapper使用心得"></a>3.4. Dapper使用心得</h2><ol>
<li>新服务部署中Dapper的使用。利用Dapper对系统延迟情况进行一系列的跟踪，进而发现存在的问题</li>
<li>定位长尾延迟（Addressing Long Tail Latency）。端到端性能和关键路径上的网络延迟有着极大的关系</li>
<li>推断服务间的依存关系（Inferring Service Dependencies）。Google的“服务依存关系”项目使用监控注释和DPAI的MapReduce接口实现了服务依存关系确定的自动化</li>
<li>确定不同服务的网络使用情况。利用Dapper平台构建了一个连续不断更新的控制台，用来显示内部集群网络通信中最活跃的应用层终端</li>
<li>分层的共享式存储系统。没有Dapper之类的工具的情况下对于这种共享式服务资源的争用也同样难以调试</li>
<li>利用Dapper进行“火拼”（Firefighting with Dapper）。Dapper用户可以通过和Dapper守护进程的直接通信，将所需的最新数据汇总在一起 </li>
</ol>
<h1 id="4-Dremel————海量数据的交互式分析工具"><a href="#4-Dremel————海量数据的交互式分析工具" class="headerlink" title="4. Dremel————海量数据的交互式分析工具"></a>4. Dremel————海量数据的交互式分析工具</h1><h2 id="4-1-Dremel支持的典型应用"><a href="#4-1-Dremel支持的典型应用" class="headerlink" title="4.1. Dremel支持的典型应用"></a>4.1. Dremel支持的典型应用</h2><ul>
<li>Web文档的分析</li>
<li>Android市场的应用安装数据的跟踪</li>
<li>Google产品的错误报告</li>
<li>Google图书的光学字符识别</li>
<li>欺诈信息的分析</li>
<li>Google地图的调试</li>
<li>Bigtable实例上的tablet迁移</li>
<li>Google分布式构建系统的测试结果分析</li>
<li>磁盘I/O信息的统计</li>
<li>Google数据中心上运行任务的资源监控</li>
<li>Google代码库的符号和依赖关系分析</li>
</ul>
<h1 id="5-Dremel的数据模型"><a href="#5-Dremel的数据模型" class="headerlink" title="5. Dremel的数据模型"></a>5. Dremel的数据模型</h1><h3 id="5-0-1-两方面的技术支撑"><a href="#5-0-1-两方面的技术支撑" class="headerlink" title="5.0.1. 两方面的技术支撑"></a>5.0.1. 两方面的技术支撑</h3><ul>
<li>一方面：统一的存储平台<br>实现高效的数据存储，Dremel使用的底层数据存储平台是GFS</li>
<li>另一方面：统一的数据存储格式<br>存储的数据才可以被不同的平台所使用</li>
</ul>
<h3 id="5-0-2-面向记录和面向列的存储"><a href="#5-0-2-面向记录和面向列的存储" class="headerlink" title="5.0.2. 面向记录和面向列的存储"></a>5.0.2. 面向记录和面向列的存储</h3><p>Google的Dremel是第一个在嵌套数据模型基础上实现列存储的系统。</p>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-Dremel.png" alt="Dremel面向记录和面向列的存储"></p>
<p>优势：</p>
<ul>
<li>处理时只需要使用涉及的列数据</li>
<li>列存储更利于数据的压缩</li>
</ul>
<h3 id="5-0-3-Dremel小结"><a href="#5-0-3-Dremel小结" class="headerlink" title="5.0.3. Dremel小结"></a>5.0.3. Dremel小结</h3><ul>
<li>Dremel和MapReduce并不是互相替代，而是相互补充的技术。在不同的应用场景下各有其用武之地。</li>
<li>Drill的设计目标就是复制一个开源的Dremel，但是从目前来看，该项目无论是进展还是影响力都达不到Hadoop的高度。</li>
<li>希望未来能出现一个真正有影响力的开源系统实现Dremel的主要功能并被广泛采用。</li>
</ul>
<h1 id="6-PowerDrill————内存大数据分析系统"><a href="#6-PowerDrill————内存大数据分析系统" class="headerlink" title="6. PowerDrill————内存大数据分析系统"></a>6. PowerDrill————内存大数据分析系统</h1><h2 id="6-1-PowerDrill产生背景与设计目标"><a href="#6-1-PowerDrill产生背景与设计目标" class="headerlink" title="6.1. PowerDrill产生背景与设计目标"></a>6.1. PowerDrill产生背景与设计目标</h2><p>现象：</p>
<ul>
<li>在查询过程中，平均<strong>92.41%**的数据被略去</strong>5.02%<strong>的数据会直接被缓存命中，一般仅须扫描</strong>2.66%**的数据即可得到查询结果</li>
<li>超过<strong>70%**的查询是不需要从磁盘访问任何数据的这些查询的平均访问延迟大约是</strong>25秒<strong>，</strong>96.5%<strong>的查询需要访问的磁盘量不超过</strong>1GB**</li>
</ul>
<p>背景：</p>
<ul>
<li>绝大多数的查询是类似和一致的；</li>
<li>存储系统中的表只有一小部分是经常被使用的，绝大部分的表使用频率不高。</li>
</ul>
<p>目的：</p>
<ul>
<li>尽可能在查询中略去不需要的数据分块；</li>
<li>尽可能地减少数据在内存中的占用。（越少的内存占用意味着内存中可加载和处理的数据越多）</li>
</ul>
<h2 id="6-2-ProwerDrill系统组成"><a href="#6-2-ProwerDrill系统组成" class="headerlink" title="6.2. ProwerDrill系统组成"></a>6.2. ProwerDrill系统组成</h2><ul>
<li>Web UI</li>
<li>一个抽象层</li>
<li>列式存储</li>
</ul>
<h2 id="6-3-PowerDrill数据结构"><a href="#6-3-PowerDrill数据结构" class="headerlink" title="6.3. PowerDrill数据结构"></a>6.3. PowerDrill数据结构</h2><p>PowerDrill采用的是一个双层数据字典结构</p>
<p><img data-src="/Users/eisenhao/Documents/CloudComputing/CloudComputing-20190710154540235.png" alt="CloudComputing-20190710154540235"></p>
<h2 id="6-4-PowerDrill采用的性能优化"><a href="#6-4-PowerDrill采用的性能优化" class="headerlink" title="6.4. PowerDrill采用的性能优化"></a>6.4. PowerDrill采用的性能优化</h2><h3 id="6-4-1-数据分块"><a href="#6-4-1-数据分块" class="headerlink" title="6.4.1. 数据分块"></a>6.4.1. 数据分块</h3><ul>
<li>背景：传统的索引对于PowerDrill的查询场景作用不是很大，因此一个很自然的考虑就是对数据进行分块，过滤查询中不需要的数据块来减少数据量</li>
<li>分块方法：常见的分区方法有范围分区、散列分区等。PowerDrill实际采用的是一种组合范围分区方法。</li>
<li>分块步骤：a. 领域专家确定若干个划分的域；b. 利用这几个域对数据进行划分；c. 每个块的行数达到阈值时就停止划分。</li>
<li>局限性：域的确定需要领域专家（需要经验划分域）</li>
</ul>
<h3 id="6-4-2-数据编码的优化"><a href="#6-4-2-数据编码的优化" class="headerlink" title="6.4.2. 数据编码的优化"></a>6.4.2. 数据编码的优化</h3><ul>
<li>对于不同的块，如果我们可以确定块中不同值的数量，那么就可以根据这个数量值来选择可变的比特位来记录块id</li>
<li>有一个专有名词用于统计一组数中不同值的个数，称为“基数估计”</li>
<li>对于小规模的数据集，可以比较容易地统计出精确的基数。但是在大数据的环境下，精确的基数统计非常耗时，因此能保证一定精度的基数估计就可以满足实际的需求</li>
<li>基数估计的方法很多，大多利用了散列函数的一些特性，Google内部使用的是一种称为Hyperloglog的基数估计方法的变种</li>
</ul>
<h3 id="6-4-3-全局字典优化"><a href="#6-4-3-全局字典优化" class="headerlink" title="6.4.3. 全局字典优化"></a>6.4.3. 全局字典优化</h3><p>特性：</p>
<ul>
<li>全局字典是有序的</li>
<li>排序后的数据常常有共同的前缀</li>
</ul>
<p>备注：</p>
<ul>
<li>实际使用中为了进一步减少查询中需要加载到内存的全局字典，对全局字典又进行了分块</li>
<li>对每个全局字典块还会维护一个布隆过滤器（bloom filter）来快速确定某个值是否在字典中</li>
</ul>
<h3 id="6-4-4-压缩算法"><a href="#6-4-4-压缩算法" class="headerlink" title="6.4.4. 压缩算法"></a>6.4.4. 压缩算法</h3><p>不管压缩算法的解压速度多快，总会消耗一定的物理资源与时间。对此PowerDrill采用了一种<strong>冷热数据</strong>分别对待的策略。</p>
<p>在冷热数据切换策略中，比较常用的是LRU算法。PowerDrill开发团队采用了<strong>启发式的缓存策略</strong>来代替原始的LRU算法。</p>
<h3 id="6-4-5-行的重排"><a href="#6-4-5-行的重排" class="headerlink" title="6.4.5. 行的重排"></a>6.4.5. 行的重排</h3><p>PowerDrill在实际生产环境中对数据分块时选定的那几个域按照字典序进行排序来得到重排的结果。数据压缩的算法有很多，比较常用的一种称为游程编码（Run-Length Encoding，RLE），又称行程长度编码，其好处是压缩和解压缩都非常快。</p>
<h2 id="6-5-PowerDrill与Dremel的对比"><a href="#6-5-PowerDrill与Dremel的对比" class="headerlink" title="6.5. PowerDrill与Dremel的对比"></a>6.5. PowerDrill与Dremel的对比</h2><table>
<thead>
<tr>
<th><strong>设计目标</strong></th>
<th><strong>处理非常大量的数据集</strong></th>
<th><strong>分析少量的核心数据集</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>设计理念</strong></td>
<td>处理的数据来自外存</td>
<td>处理的数据尽可能地存于内存</td>
</tr>
<tr>
<td></td>
<td>未进行数据分区，分析时要扫描所有需要的列</td>
<td>使用了组合范围分区，分析时可以跳过很多不需要的分区</td>
</tr>
<tr>
<td></td>
<td>数据通常不需要加载，增加数据很方便</td>
<td>数据需要加载，增加数据相对不便</td>
</tr>
</tbody></table>
<h1 id="7-Google应用程序引擎"><a href="#7-Google应用程序引擎" class="headerlink" title="7. Google应用程序引擎"></a>7. Google应用程序引擎</h1><p>Google App Engine是一个由Python应用服务器群、Bigtable数据库及GFS数据存储服务组成的平台，它能为开发者提供一体化的可自动升级的在线应用服务。</p>
<p>特点：</p>
<ul>
<li>Google App Engine可以让开发人员在Google的基础架构上运行网络应用程序。</li>
<li>在Google App Engine中，用户可以使用appspot.com域上的免费域名为应用程序提供服务，也可以使用Google企业应用套件从自己的域为它提供服务。</li>
<li>可以免费使用Google App Engine。注册一个免费账户即可开发和发布应用程序，而且不需要承担任何费用和责任。</li>
</ul>
<h2 id="7-1-Google-App-Engine的整体架构"><a href="#7-1-Google-App-Engine的整体架构" class="headerlink" title="7.1. Google App Engine的整体架构"></a>7.1. Google App Engine的整体架构</h2><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CloudComputing-20190710161656740.png" alt="CloudComputing-20190710161656740"></p>
<h2 id="7-2-应用程序环境的特性"><a href="#7-2-应用程序环境的特性" class="headerlink" title="7.2. 应用程序环境的特性"></a>7.2. 应用程序环境的特性</h2><ul>
<li><strong>动态网络服务</strong>功能。能够完全支持常用的网络技术。</li>
<li>具有<strong>持久存储的空间</strong>。在这个空间里平台可以支持一些基本操作，如查询、分类和事务的操作。</li>
<li>具有自主平衡网络和系统的负载、自动进行<strong>扩展</strong>的功能。</li>
<li>可以对用户的<strong>身份进行验证</strong>，并且支持使用Google账户发送邮件。</li>
<li>有一个功能完整的<strong>本地开发环境</strong>，可以在自身的计算机上模拟Google          App Engine环境。</li>
<li>支持在指定时间或定期触发事件的<strong>计划任务</strong>。</li>
</ul>
<h2 id="7-3-沙盒的限制"><a href="#7-3-沙盒的限制" class="headerlink" title="7.3. 沙盒的限制"></a>7.3. 沙盒的限制</h2><ul>
<li>用户的应用程序只能通过Google App Engine提供的网址抓取API和电子邮件服务API来访问互联网中其他的计算机，其他计算机如请求与该应用程序相连接，只能在标准接口上通过HTTP或HTTPS进行</li>
<li>应用程序无法对Google App Engine的文件系统进行写入操作，只能读取应用程序代码上的文件，并且该应用程序必须使用Google App Engine的Data Store数据库来存储应用程序运行期间持续存在的数据</li>
<li>应用程序只有在响应网络请求时才运行，并且这个响应时间必须极短，在几秒之内必须完成。与此同时，请求处理的程序不能在自己的响应发送后产生子进程或执行代码</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell易混淆基本语法总结</title>
    <url>/2020/05/29/ConfusedShellLang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/ConfusedShellLang.jpg" class="full-image" />

<p>主要整理了常用易混淆Shell语法，以备不时查询之需。</p>
<a id="more"></a>

<h1 id="1-单引号、双引号、倒引号的区别"><a href="#1-单引号、双引号、倒引号的区别" class="headerlink" title="1. 单引号、双引号、倒引号的区别"></a>1. 单引号、双引号、倒引号的区别</h1><h2 id="1-1-单引号-‘-vs-双引号-“"><a href="#1-1-单引号-‘-vs-双引号-“" class="headerlink" title="1.1. 单引号 ‘ vs 双引号 “"></a>1.1. 单引号 ‘ vs 双引号 “</h2><ul>
<li>单引号作用：将位于单引号之间的所有内容全部视为普通字符，即不处理任何特殊字符</li>
<li>双引号作用：先将双引号之间的特殊字符做预处理（若存在），再将双引号之间的内容（特殊字符的结果）视为字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">ans=15</span><br><span class="line"><span class="meta">#</span><span class="bash"> 单引号，不处理特殊字符</span></span><br><span class="line">echo ‘Petter: 3 * 5 = $ans’</span><br><span class="line"><span class="meta">#</span><span class="bash"> 双引号，处理特殊字符</span></span><br><span class="line">echo “Petter: 3 * 5 = $ans”</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下</span></span><br><span class="line">Petter: 3 * 5 = $ans</span><br><span class="line">Petter: 3 * 5 = 15</span><br></pre></td></tr></table></figure>

<h2 id="1-2-倒引号"><a href="#1-2-倒引号" class="headerlink" title="1.2. 倒引号 `"></a>1.2. 倒引号 `</h2><ul>
<li>坐标：位于键盘Esc键下方及数字1键左侧。</li>
<li>作用：用位于倒引号之间的命令执行结果替换倒引号及之间的命令。等价于$()，新用法$()中则不需要考虑\的问题，推荐使用后者。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;this path is `pwd`&quot;</span><br><span class="line">echo &quot;this path is $(pwd)&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下</span></span><br><span class="line">this path is /home</span><br><span class="line">this path is /home</span><br></pre></td></tr></table></figure>

<h1 id="2-括号-vs-花括号"><a href="#2-括号-vs-花括号" class="headerlink" title="2. 括号() vs 花括号{}"></a>2. 括号() vs 花括号{}</h1><h2 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1. 作用"></a>2.1. 作用</h2><p>对命令的执行</p>
<h2 id="2-2-应用场景"><a href="#2-2-应用场景" class="headerlink" title="2.2. 应用场景"></a>2.2. 应用场景</h2><p>变量名后要附加一些内容时（如：字符串、数字、下划线），为了分割变量名与附加内容；用执行命令的结果替换字符串中的部分内容；需要在括号内执行一串命令时；</p>
<p>示例：批量改名（加后缀）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for fileName in $(ls)</span><br><span class="line">do</span><br><span class="line">    mv $fileName $(fileName).tmp</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="2-3-括号-与花括号-的异同"><a href="#2-3-括号-与花括号-的异同" class="headerlink" title="2.3. 括号()与花括号{}的异同"></a>2.3. 括号()与花括号{}的异同</h2><table>
<thead>
<tr>
<th align="left">\</th>
<th align="center">括号()</th>
<th align="center">花括号{}</th>
</tr>
</thead>
<tbody><tr>
<td align="left">执行位置</td>
<td align="center">对一串命令重开一个子Shell执行</td>
<td align="center">对一串命令在当前Shell执行</td>
</tr>
<tr>
<td align="left">变量作用域</td>
<td align="center">可视为局部变量</td>
<td align="center">会改变全局同名变量的值</td>
</tr>
<tr>
<td align="left">分号</td>
<td align="center">最后一个命令可以不用分号结尾</td>
<td align="center">最后一个命令要用分号结尾</td>
</tr>
<tr>
<td align="left">空格</td>
<td align="center">不必用空格与括号隔开</td>
<td align="center">第一个命令和左括号之间必须要有一个空格</td>
</tr>
<tr>
<td align="left">重定向</td>
<td align="center">括号里的某个命令的重定向只影响该命令，括号外的重定向则影响到括号里的所有命令</td>
<td align="center">括号里的某个命令的重定向只影响该命令，括号外的重定向则影响到括号里的所有命令</td>
</tr>
</tbody></table>
<h1 id="3-几种特殊的替换用法"><a href="#3-几种特殊的替换用法" class="headerlink" title="3. 几种特殊的替换用法"></a>3. 几种特殊的替换用法</h1><ul>
<li>若变量为空，则用默认值执行${var:-string}<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var=</span><br><span class="line">echo $&#123;var:-NULL&#125;</span><br><span class="line">echo $var</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">NULL</span><br></pre></td></tr></table></figure></li>
<li>若变量为空，则用默认值赋值给空变量${var:=abc}<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var=</span><br><span class="line">echo $&#123;var:=abc&#125;</span><br><span class="line">echo $var</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></li>
<li>若变量非空，则用默认值执行，若变量为空，则不作为${var:+string}<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var1=abc</span><br><span class="line">var2=</span><br><span class="line">echo $&#123;var1:+FULL&#125;</span><br><span class="line">echo $&#123;var2:+FULL&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">FULL</span><br></pre></td></tr></table></figure></li>
<li>若变量非空，则用其值，若变量为空，则输出string到标准错误中后退出脚本${var:?string}<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var1=abc</span><br><span class="line">var2=</span><br><span class="line">echo $&#123;var1:+FULL&#125;</span><br><span class="line">echo $&#123;var2:+FULL&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">FULL</span><br></pre></td></tr></table></figure>
<h1 id="4-支持POSIX标准的扩展计算-exp"><a href="#4-支持POSIX标准的扩展计算-exp" class="headerlink" title="4. 支持POSIX标准的扩展计算$((exp))"></a>4. 支持POSIX标准的扩展计算$((exp))</h1>其中exp为符合C语言的运算符<h2 id="4-1-举例说明"><a href="#4-1-举例说明" class="headerlink" title="4.1. 举例说明"></a>4.1. 举例说明</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo $((1+2))</span><br><span class="line">echo $((1&lt;2))</span><br><span class="line">echo $((5&lt;4?0:1))</span><br><span class="line">echo $((var=2+3))</span><br><span class="line">echo $((var++))</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果如下：</span></span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="5-四种模式匹配替换"><a href="#5-四种模式匹配替换" class="headerlink" title="5. 四种模式匹配替换"></a>5. 四种模式匹配替换</h1><ul>
<li># 是去掉左边(在键盘上#在$之左边)；</li>
<li>% 是去掉右边(在键盘上%在$之右边)；</li>
<li>#和%中的单一符号是最小匹配，两个相同符号是最大匹配。</li>
<li>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。</li>
<li>结构中的pattern支持通配符:<ul>
<li>*表示零个或多个任意字符</li>
<li>?表示仅与一个任意字符匹配</li>
<li>[…]表示匹配中括号里面的字符</li>
<li>[!…]表示不匹配中括号里面的字符</li>
</ul>
</li>
</ul>
<h2 id="5-1-第一种模式：-variable-pattern"><a href="#5-1-第一种模式：-variable-pattern" class="headerlink" title="5.1. 第一种模式：${variable%pattern}"></a>5.1. 第一种模式：${variable%pattern}</h2><p>说明：shell在variable中查找，判断variable是否以pattern结尾，如果是，就从命令行把variable中的内容去掉右边<em>最短的</em>匹配模式</p>
<h2 id="5-2-第二种模式：-variable-pattern"><a href="#5-2-第二种模式：-variable-pattern" class="headerlink" title="5.2. 第二种模式：${variable%%pattern}"></a>5.2. 第二种模式：${variable%%pattern}</h2><p>说明：shell在variable中查找，判断variable是否以pattern结尾，如果是，就从命令行把variable中的内容去掉右边<em>最长的</em>匹配模式</p>
<h2 id="5-3-第三种模式：-variable-pattern"><a href="#5-3-第三种模式：-variable-pattern" class="headerlink" title="5.3. 第三种模式：${variable#pattern}"></a>5.3. 第三种模式：${variable#pattern}</h2><p>说明：shell在variable中查找，判断variable是否以pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式</p>
<h2 id="5-4-第四种模式：-variable-pattern"><a href="#5-4-第四种模式：-variable-pattern" class="headerlink" title="5.4. 第四种模式：${variable##pattern}"></a>5.4. 第四种模式：${variable##pattern}</h2><p>shell在variable中查找，判断variable是否以pattern开始，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">VAR=ABCABCDEFDEF</span><br><span class="line">PATTERN1=DEF</span><br><span class="line">PATTERN2=ABC</span><br><span class="line"></span><br><span class="line">echo &quot;VAR=$VAR&quot;</span><br><span class="line">echo &quot;PATTERN1=$PATTERN1&quot;</span><br><span class="line">echo &quot;PATTERN2=$PATTERN2&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;M1.$&#123;VAR%*$PATTERN1&#125;&#x27;</span><br><span class="line">echo $&#123;VAR%*$PATTERN1&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M2.$&#123;VAR%%*$PATTERN1&#125;&#x27;</span><br><span class="line">echo $&#123;VAR%%*$PATTERN1&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M2.$&#123;VAR%%?$PATTERN1&#125;&#x27;</span><br><span class="line">echo $&#123;VAR%%?$PATTERN1&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M3.$&#123;VAR#*$PATTERN2&#125;&#x27;</span><br><span class="line">echo $&#123;VAR#*$PATTERN2&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M4.$&#123;VAR##*$PATTERN2&#125;&#x27;</span><br><span class="line">echo $&#123;VAR##*$PATTERN2&#125;</span><br><span class="line"></span><br><span class="line">echo &#x27;M4.$&#123;VAR##$PATTERN2*&#125;&#x27;</span><br><span class="line">echo $&#123;VAR##$PATTERN2*&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果</span></span><br><span class="line">VAR=ABCABCDEFDEF</span><br><span class="line">PATTERN1=DEF</span><br><span class="line">PATTERN2=ABC</span><br><span class="line">M1.$&#123;VAR%*$PATTERN1&#125;</span><br><span class="line">ABCABCDEF</span><br><span class="line">M2.$&#123;VAR%%*$PATTERN1&#125;</span><br><span class="line">(空)</span><br><span class="line">M2.$&#123;VAR%%?$PATTERN1&#125;</span><br><span class="line">ABCABCDE</span><br><span class="line">M3.$&#123;VAR#*$PATTERN2&#125;</span><br><span class="line">ABCDEFDEF</span><br><span class="line">M4.$&#123;VAR##*$PATTERN2&#125;</span><br><span class="line">DEFDEF</span><br><span class="line">M4.$&#123;VAR##$PATTERN2*&#125;</span><br><span class="line">(空)</span><br></pre></td></tr></table></figure>

<h1 id="6-变量判空"><a href="#6-变量判空" class="headerlink" title="6. 变量判空"></a>6. 变量判空</h1><ul>
<li>判空必要性：某些环境下执行空变量可能造成严重后果，如执行rm删除操作时，rm -rf 空路径变量会删除根目录，造成无法挽回的严重后果。</li>
<li>正确操作：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断DIR变量非空，才会执行rm命令</span></span><br><span class="line">[ -n $DIR ] &amp;&amp; rm -rf $DIR</span><br></pre></td></tr></table></figure></li>
<li>变量判空常用方法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">para=</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判空方式1. 直接判断变量</span></span><br><span class="line">if [ ! $para ];then</span><br><span class="line">    echo &quot;NULL&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判空方式2. 作字符串判空</span></span><br><span class="line">if [ ! -n &quot;$para&quot; ];then</span><br><span class="line">    echo &quot;NULL&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判空方式3. 与“空字符串”比较判空</span></span><br><span class="line">if [ &quot;$para&quot; = &quot;&quot; ];then</span><br><span class="line">    echo &quot;NULL&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判空方式4. 利用<span class="built_in">test</span>判空</span></span><br><span class="line">if test -z &quot;$para&quot;</span><br><span class="line">then</span><br><span class="line">    echo &quot;NULL&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="7-参考文档"><a href="#7-参考文档" class="headerlink" title="7. 参考文档"></a>7. 参考文档</h1><ul>
<li><a href="https://blog.csdn.net/zhan570556752/article/details/80515376?utm_source=blogxgwz1">Shell 命令中的特殊替换、模式匹配替换、字符串提取和替换</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编译过程总结</title>
    <url>/2019/12/19/CppCompile/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CppCompile.jpg" class="full-image" />


<h1 id="1-step1-预编译"><a href="#1-step1-预编译" class="headerlink" title="1. step1.预编译"></a>1. step1.预编译</h1><p>“宏展开”，也就是对那些#***的命令的一种展开。例如define MAX 1000就是建立起MAX和1000之间的对等关系，好在编译阶段进行替换。例如ifdef/ifndef就是从一个文件中有选择性的挑出一些符合条件的代码来交给下一步的编译阶段来处理。这里面最复杂的莫过于include了，相当于把那个对应的文件里面的内容一下子替换到这条include***语句的地方来。</p>
<a id="more"></a>

<h1 id="2-step2-编译"><a href="#2-step2-编译" class="headerlink" title="2. step2.编译"></a>2. step2.编译</h1><p>编译是以一个个独立的文件作为单元的，一个文件就会编译出一个目标文件。（这里插入一点关于编译的文件的说明，编译器通过后缀名来辨识是否编译该文件，因此“.h”的头文件一概不理会，而“.cpp”的源文件一律都要被编译，我实验过把.h文件的后缀名改为.cpp，然后在include的地方相应的改为***.cpp，这样一来，编译器就会编译许多不必要的头文件，只不过头文件里我们通常只放置声明而不是定义，因此最后链接生成的可执行文件的大小是不会改变的）。<br>清楚编译是以一个个单独的文件为单元的，这一点很重要，因此编译只负责本单元的那些事，而对外部的事情一概不理会，在这一步里，我们可以调用一个函数而不必给出这个函数的定义，但是要在调用前得到这个函数的声明（其实这就是include的本质，不就是为了给你提前提供个声明而好让你使用吗？至于那个函数到底是如何实现的，需要在链接这一步里去找函数的入口地址。因此提供声明的方式可以是用include把放在别的文件中的声明拿过来，也可以是在调用之前自己写一句void max(int,int);都行。），编译阶段剩下的事情就是分析语法的正确性之类的工作了。</p>
<ul>
<li>第一步，检验函数或者变量是否存在它们的声明；</li>
<li>第二步，检查语句是否符合C++语法。</li>
</ul>
<h1 id="3-step3-链接"><a href="#3-step3-链接" class="headerlink" title="3. step3.链接"></a>3. step3.链接</h1><p>它会把所有编译好的单元全部链接为一个整体文件，其实这一步可以比作一个“连线”的过程，比如A文件用了B文件中的函数，那么链接的这一步会建立起这个关联。链接时最重要的我认为是检查全局空间里面是不是有重复定义或者缺失定义。这也就解释了为什么我们一般不在头文件中出现定义，因为头文件有可能被释放到多个源文件中，每个源文件都会单独编译，链接时就会发现全局空间中有多个定义了。</p>
<h1 id="4-标准C和C-将编译过程定义为9个阶段"><a href="#4-标准C和C-将编译过程定义为9个阶段" class="headerlink" title="4. 标准C和C++将编译过程定义为9个阶段"></a>4. 标准C和C++将编译过程定义为9个阶段</h1><h2 id="4-1-字符映射-Character-Mapping"><a href="#4-1-字符映射-Character-Mapping" class="headerlink" title="4.1. 字符映射(Character Mapping)"></a>4.1. 字符映射(Character Mapping)</h2><p>文件中的物理源字符被映射到源字符集中，其中包括三字符运算符的替换、控制字符(行尾的回车换行)的替换。许多非美式键盘不支持基本源字符集中的一些字符，文件中可用三字符来代替这些基本源字符，以??为前导。但如果所用键盘是美式键盘，有些编译器可能不对三字符进行查找和替换，需要增加-trigraphs编译参数。在C++程序中，任何不在基本源字符集中的字符都被它的通用字符名替换。</p>
<h2 id="4-2-行合并-Line-Splicing"><a href="#4-2-行合并-Line-Splicing" class="headerlink" title="4.2. 行合并(Line Splicing)"></a>4.2. 行合并(Line Splicing)</h2><p>以反斜杠/结束的行和它接下来的行合并。</p>
<h2 id="4-3-标记化-Tokenization"><a href="#4-3-标记化-Tokenization" class="headerlink" title="4.3. 标记化(Tokenization)"></a>4.3. 标记化(Tokenization)</h2><p>每一条注释被一个单独的空字符所替换。C++双字符运算符被识别为标记(为了开发可读性更强的程序，C++为非ASCII码开发者定义了一套双字符运算符集和新的保留字集)。源代码被分析成预处理标记。</p>
<h2 id="4-4-预处理-Preprocessing"><a href="#4-4-预处理-Preprocessing" class="headerlink" title="4.4. 预处理(Preprocessing)"></a>4.4. 预处理(Preprocessing)</h2><p>调用预处理指令并扩展宏。使用#include指令包含的文件，重复步骤1到4。上述四个阶段统称为预处理阶段。</p>
<h2 id="4-5-字符集映射-Character-set-Mapping"><a href="#4-5-字符集映射-Character-set-Mapping" class="headerlink" title="4.5. 字符集映射(Character-set Mapping)"></a>4.5. 字符集映射(Character-set Mapping)</h2><p>源字符集成员、转义序列被转换成等价的执行字符集成员。例如：’/a’在ASCII环境下会被转换成值为一个字节，值为7。</p>
<h2 id="4-6-字符串连接-String-Concatenation"><a href="#4-6-字符串连接-String-Concatenation" class="headerlink" title="4.6. 字符串连接(String Concatenation)"></a>4.6. 字符串连接(String Concatenation)</h2><p>相邻的字符串被连接。例如：”””hahaha””huohuohuo”将成为”hahahahuohuohuo”。</p>
<h2 id="4-7-翻译-Translation"><a href="#4-7-翻译-Translation" class="headerlink" title="4.7. 翻译(Translation)"></a>4.7. 翻译(Translation)</h2><p>进行语法和语义分析编译，并翻译成目标代码。</p>
<h2 id="4-8-处理模板"><a href="#4-8-处理模板" class="headerlink" title="4.8. 处理模板"></a>4.8. 处理模板</h2><p>处理模板实例。</p>
<h2 id="4-9-连接-Linkage"><a href="#4-9-连接-Linkage" class="headerlink" title="4.9. 连接(Linkage)"></a>4.9. 连接(Linkage)</h2><p>解决外部引用的问题，准备好程序映像以便执行。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++易混淆知识点总结</title>
    <url>/2020/08/11/CppConfusedNotes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/CppConfusedNotes.png" class="full-image" />

<h1 id="1-struct-和-union-的区别"><a href="#1-struct-和-union-的区别" class="headerlink" title="1. struct 和 union 的区别"></a>1. struct 和 union 的区别</h1><ul>
<li>结构体struct：把不同类型的数据组合成一个整体，自定义类型。</li>
<li>共同体union：使几个不同类型的变量共同占用一段内存<a id="more"></a>

</li>
</ul>
<h1 id="2-字节对齐"><a href="#2-字节对齐" class="headerlink" title="2. 字节对齐"></a>2. 字节对齐</h1><p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2，4或8)的倍数。为了方便快速地寻址，编译器会采用字节对齐，将下一个变量地址放置在系统能快速读取的位置（如：32 位系统，放在偶地址的变量能够 1 个读周期取到值，而放在奇地址的变量却需要 2 个读周期才能取到值，故会存在字节对齐）。</p>
<p>关于内存对齐，有四个重要的基本概念：</p>
<ul>
<li>数据类型自身的对齐值：<br>对于char型数据，其自身对齐值为1，对于short型为2，对于int，float，double类型，其自身对齐值为4，单位字节。</li>
<li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</li>
<li>指定对齐值：#pragma pack(n)，n=1，2，4，8，16改变系统的对齐系数</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</li>
</ul>
<h1 id="3-字节序（小正逆大）"><a href="#3-字节序（小正逆大）" class="headerlink" title="3. 字节序（小正逆大）"></a>3. 字节序（小正逆大）</h1><ul>
<li>小端模式：Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</li>
<li>大端模式：Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>网络字节顺序(大端)是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。</li>
</ul>
<h1 id="4-static的作用"><a href="#4-static的作用" class="headerlink" title="4. static的作用"></a>4. static的作用</h1><h2 id="4-1-对普通变量的作用"><a href="#4-1-对普通变量的作用" class="headerlink" title="4.1. 对普通变量的作用"></a>4.1. 对普通变量的作用</h2><ul>
<li>static修饰局部变量</li>
</ul>
<p>它改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。</p>
<ul>
<li>static修饰全局变量。</li>
</ul>
<p>并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，好处如下：（1）不会被其他文件所访问修改（2）其他文件中可以使用相同名字的变量，不会发生冲突。</p>
<h2 id="4-2-对成员变量的作用"><a href="#4-2-对成员变量的作用" class="headerlink" title="4.2. 对成员变量的作用"></a>4.2. 对成员变量的作用</h2><p>用static修饰类的数据成员成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化(初始化格式： int base::var=10; )，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。</p>
<h2 id="4-3-对成员函数的作用"><a href="#4-3-对成员函数的作用" class="headerlink" title="4.3. 对成员函数的作用"></a>4.3. 对成员函数的作用</h2><p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。<br>静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。base::func(5，3)；当static成员函数在类外定义时不需要加static修饰符。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。</p>
<h1 id="5-const的作用"><a href="#5-const的作用" class="headerlink" title="5. const的作用"></a>5. const的作用</h1><ul>
<li>限定变量为不可修改。</li>
<li>限定成员函数不可以修改任何数据成员。</li>
<li>const与指针：<ul>
<li>const char *p，不能改变指向的内容；</li>
<li>char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。</li>
</ul>
</li>
</ul>
<h1 id="6-不能同时使用const和static修饰类的成员函数"><a href="#6-不能同时使用const和static修饰类的成员函数" class="headerlink" title="6. 不能同时使用const和static修饰类的成员函数"></a>6. 不能同时使用const和static修饰类的成员函数</h1><p>static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。</p>
<h1 id="7-指针常量和常量指针"><a href="#7-指针常量和常量指针" class="headerlink" title="7. 指针常量和常量指针"></a>7. 指针常量和常量指针</h1><ul>
<li>指针常量（char * const p）：指针变量的值一经初始化（初始化是必要的），不可以改变指向另一个变量（但可以改变已经指向的变量的内容）。</li>
<li>常量指针（const char *p）：指向常量的指针。不可以改变指向某变量的值，可以改变指向另一个变量。</li>
</ul>
<h1 id="8-指针和引用的区别"><a href="#8-指针和引用的区别" class="headerlink" title="8. 指针和引用的区别"></a>8. 指针和引用的区别</h1><ul>
<li>指针是一个新的变量，只是这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量。</li>
<li>引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。</li>
<li>引用在定义的时候必须初始化；指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。</li>
<li>指针和引用的自增(++)运算意义不一样。</li>
</ul>
<h1 id="9-多态及其用途"><a href="#9-多态及其用途" class="headerlink" title="9. 多态及其用途"></a>9. 多态及其用途</h1><ul>
<li>定义：“一个接口，多种方法”，程序在运行时才决定调用的函数。</li>
<li>实现：C++多态性主要是通过虚函数实现的，虚函数允许子类重写override(注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表/类型不同）。</li>
<li>目的：接口重用。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。</li>
<li>用法：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。</li>
<li>详见：<a href="https://eisenhao.cn/2018/10/14/PolymorphismTest/">C++ 中的四种多态</a></li>
</ul>
<h1 id="10-重载、覆盖与重写的区别"><a href="#10-重载、覆盖与重写的区别" class="headerlink" title="10. 重载、覆盖与重写的区别"></a>10. 重载、覆盖与重写的区别</h1><h2 id="10-1-Overload-重载"><a href="#10-1-Overload-重载" class="headerlink" title="10.1. Overload(重载)"></a>10.1. Overload(重载)</h2><p>在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。</p>
<ul>
<li>相同的范围（在同一个类中）；</li>
<li>函数名字相同；</li>
<li>参数不同；</li>
<li>virtual 关键字可有可无。</li>
</ul>
<h2 id="10-2-Override-覆盖"><a href="#10-2-Override-覆盖" class="headerlink" title="10.2. Override(覆盖)"></a>10.2. Override(覆盖)</h2><p>是指派生类函数覆盖基类函数，特征是：</p>
<ul>
<li>不同的范围（分别位于派生类与基类）；</li>
<li>函数名字相同；</li>
<li>参数相同；</li>
<li>基类函数必须有virtual 关键字。</li>
</ul>
<p>注：重写基类虚函数的时候，会自动转换这个函数为virtual函数，不管有没有加virtual，因此重写的时候不加virtual也是可以的，不过为了易读性，还是加上比较好。</p>
<h2 id="10-3-Overwrite-重写"><a href="#10-3-Overwrite-重写" class="headerlink" title="10.3. Overwrite(重写)"></a>10.3. Overwrite(重写)</h2><p>是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</p>
<ul>
<li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</li>
</ul>
<h1 id="11-面向对象的三要素"><a href="#11-面向对象的三要素" class="headerlink" title="11. 面向对象的三要素"></a>11. 面向对象的三要素</h1><p>封装、继承、多态</p>
<h1 id="12-纯虚函数与抽象类"><a href="#12-纯虚函数与抽象类" class="headerlink" title="12. 纯虚函数与抽象类"></a>12. 纯虚函数与抽象类</h1><p>将函数定义为纯虚函数<code>virtual ReturnType Function() = 0;</code>，纯虚函数不能再在基类中实现，编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。<br>特点：</p>
<ul>
<li>在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；（避免类被实例化且在编译时候被发现，可以采用此方法）</li>
<li>这个方法必须在派生类(derived class)中被实现;目的：使派生类仅仅只是继承函数的接口。</li>
<li>抽象类只能作为基类来使用，而继承了抽象类的派生类如果没有实现纯虚函数，而只是继承纯虚函数，那么该类仍旧是一个抽象类，如果实现了纯虚函数，就不再是抽象类。</li>
</ul>
<h1 id="13-虚函数的作用"><a href="#13-虚函数的作用" class="headerlink" title="13. 虚函数的作用"></a>13. 虚函数的作用</h1><p>实现动态绑定，即运行期绑定</p>
<h1 id="14-析构函数定义为虚函数的原因"><a href="#14-析构函数定义为虚函数的原因" class="headerlink" title="14. 析构函数定义为虚函数的原因"></a>14. 析构函数定义为虚函数的原因</h1><p>基类指针可以指向派生类的对象（多态性），如果删除该指针delete p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。</p>
<p>构造函数为什么不能为虚函数（延伸）<br>虚函数对应一个指向虚函数表的指针，而这个指向vtable的指针是存储在对象的内存空间的。假设构造函数是虚的，就需要要通过查询vtable来调用，但是对象还没有实例化，因此也就不存在vtable，所以构造函数不能是虚函数。</p>
<h1 id="15-深拷贝与浅拷贝："><a href="#15-深拷贝与浅拷贝：" class="headerlink" title="15. 深拷贝与浅拷贝："></a>15. 深拷贝与浅拷贝：</h1><ul>
<li>浅拷贝，默认的拷贝构造函数只是完成了对象之间的位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存（并未另申请内存）。这就会导致野指针问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</li>
<li>深拷贝，自定义复制构造函数需要注意，对象之间发生复制，资源重新分配，即A有5个空间，B也应该有5个空间，而不是指向A的5个空间。</li>
</ul>
<h1 id="16-vector中size-和capacity-的区别。"><a href="#16-vector中size-和capacity-的区别。" class="headerlink" title="16. vector中size()和capacity()的区别。"></a>16. vector中size()和capacity()的区别。</h1><ul>
<li>size()指容器当前拥有的元素个数；</li>
<li>capacity()指容器在必须分配存储空间之前可以存储的元素总数。</li>
</ul>
<h1 id="17-map和set默认是排序的"><a href="#17-map和set默认是排序的" class="headerlink" title="17. map和set默认是排序的"></a>17. map和set默认是排序的</h1><p>map和set的底层实现主要是由红黑树实现的</p>
<h1 id="18-在TCP连接建立过程中，若client发送了SYN消息后，client、server可能状态"><a href="#18-在TCP连接建立过程中，若client发送了SYN消息后，client、server可能状态" class="headerlink" title="18. 在TCP连接建立过程中，若client发送了SYN消息后，client、server可能状态"></a>18. 在TCP连接建立过程中，若client发送了SYN消息后，client、server可能状态</h1><ul>
<li>client处于SYN_SENT状态；</li>
<li>server可能仍处于listen状态（未收到SYN消息），或处于SYN_RCVD状态</li>
</ul>
<h1 id="19-析构函数不推荐抛出异常"><a href="#19-析构函数不推荐抛出异常" class="headerlink" title="19. 析构函数不推荐抛出异常"></a>19. 析构函数不推荐抛出异常</h1><p>从语法上面讲，析构函数抛出异常是可以的，C++并没有禁止析构函数引发异常，但是C++不推荐这一做法，从析构函数中抛出异常是及其危险的。</p>
<p>析构函数可能在对象正常结束生命周期时调用，也可能在有异常发生时从函数堆栈清理时调用。前一种情况抛出异常不会有无法预料的结果，可以正常捕获；但后一种情况下，因为函数发生了异常而导致函数的局部变量的析构函数被调用，析构函数又抛出异常，本来局部对象抛出的异常应该是由它所在的函数负责捕获的，现在函数既然已经发生了异常，必定不能捕获，因此，异常处理机制只能调用terminate()。</p>
<h1 id="20-进程和线程"><a href="#20-进程和线程" class="headerlink" title="20. 进程和线程"></a>20. 进程和线程</h1><h2 id="20-1-进程"><a href="#20-1-进程" class="headerlink" title="20.1. 进程"></a>20.1. 进程</h2><p>是并发执行的程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。</p>
<h2 id="20-2-线程"><a href="#20-2-线程" class="headerlink" title="20.2. 线程"></a>20.2. 线程</h2><p>是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。</p>
<h2 id="20-3-进程和线程的区别"><a href="#20-3-进程和线程的区别" class="headerlink" title="20.3. 进程和线程的区别"></a>20.3. 进程和线程的区别</h2><p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于：</p>
<ul>
<li>地址空间：线程是进程内的一个执行单元；一个程序至少有一个进程，一个进程至少有一个线程；它们共享进程的地址空间；而各个进程有自己独立的地址空间；</li>
<li>资源拥有：进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源</li>
<li>划分尺度：线程的划分尺度小于进程，使得多线程程序的并发性高（进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。）</li>
<li>执行过程：每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>线程是处理器调度的基本单位，而进程不是</li>
<li>管理与分配：多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
</ul>
<h1 id="21-进程间通信方式"><a href="#21-进程间通信方式" class="headerlink" title="21. 进程间通信方式"></a>21. 进程间通信方式</h1><ul>
<li>管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>命名管道（FIFO）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>消息队列（MessageQueue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存（SharedMemory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>信号量（Semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>套接字（Socket）：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
<li>信号（sinal）： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>AdaBoost算法——数据挖掘</title>
    <url>/2018/12/03/DataMining_AdaBoost/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_AdaBoost.png" class="full-image" />

<h1 id="1-集成学习AdaBoost算法简介"><a href="#1-集成学习AdaBoost算法简介" class="headerlink" title="1. 集成学习AdaBoost算法简介"></a>1. 集成学习AdaBoost算法简介</h1><p>AdaBoost全称是adaptive boosting，该算法基本思想:多个结构较为简单，分类或预测精度较低的弱学习算法可以通过某种方式结合成具有较强学习能力的强学习算法。根据统计学习方法的三要素，AdaBoost 方法=加法模型+指数损失函数(策略)+前向分步 算法。</p>
<a id="more"></a>
<h1 id="2-AdaBoost运行原理如下"><a href="#2-AdaBoost运行原理如下" class="headerlink" title="2. AdaBoost运行原理如下:"></a>2. AdaBoost运行原理如下:</h1><ul>
<li><p>S1.初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值:1/N。</p>
</li>
<li><p>S2.训练弱分类器。</p>
<ul>
<li>具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低;</li>
<li>相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。</li>
<li>然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</li>
</ul>
</li>
<li><p>S3.将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。</p>
</li>
</ul>
<h1 id="3-Python编程实现基于单层决策树的AdaBoost算法"><a href="#3-Python编程实现基于单层决策树的AdaBoost算法" class="headerlink" title="3. Python编程实现基于单层决策树的AdaBoost算法"></a>3. Python编程实现基于单层决策树的AdaBoost算法</h1><h2 id="3-1-基于单层决策树的AdaBoost算法步骤"><a href="#3-1-基于单层决策树的AdaBoost算法步骤" class="headerlink" title="3.1. 基于单层决策树的AdaBoost算法步骤"></a>3.1. 基于单层决策树的AdaBoost算法步骤</h2><ul>
<li>S1.找出最佳单层决策树: a.将最小分类误差率minerror=inf b.对数据集中的每一个特征: c.对该特征的每个步长(找出决策阈值): d.对每个不等号(&gt;=，&lt;): e.建立一颗单层决策树(只包含树桩)并利用加权数据集并计算该决策树的分类误差率 f.如果分类误差率小于minerror，则将当前单层决策树设置成最佳单层决策树。</li>
<li>S2.利用单层决策树的分类误差率计算该决策树的比例系数alpha</li>
<li>S3.计算更新权重向量D</li>
<li>S4.更新累计类别估计值，计算AdaBoost模型的错误率</li>
<li>S5.如果错误率为0或者分类器数目i&gt;M，则退出循环</li>
</ul>
<h2 id="3-2-寻找最优决策树"><a href="#3-2-寻找最优决策树" class="headerlink" title="3.2. 寻找最优决策树"></a>3.2. 寻找最优决策树</h2><p>找到加权错误率(分类错误率)最小的单层决策树(会被不断迭代)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildStump</span>(<span class="params">dataArray， classLabels， D</span>):</span></span><br><span class="line">    dataMatrix = np.mat(dataArray); labelMat = np.mat(classLabels).T</span><br><span class="line">    m， n = np.shape(dataMatrix)</span><br><span class="line">    stepNum = <span class="number">10.0</span>; bestStump = &#123;&#125;; bestClassEst = np.mat(np.zeros((m， <span class="number">1</span>)))</span><br><span class="line">    minError = np.inf</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        rangeMin = dataMatrix[:， i].<span class="built_in">min</span>(); rangeMax = dataMatrix[:， i].<span class="built_in">max</span>()</span><br><span class="line">        stepSize = (rangeMax - rangeMin)/stepNum</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1</span>， <span class="built_in">int</span>(stepNum)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> thresholdIneq <span class="keyword">in</span> [<span class="string">&#x27;lt&#x27;</span>， <span class="string">&#x27;gt&#x27;</span>]:</span><br><span class="line">                thresholdValue =  rangeMin + <span class="built_in">float</span>(j) * stepSize</span><br><span class="line">                predictClass = stumpClassify(dataMatrix， i， thresholdValue， thresholdIneq)</span><br><span class="line">                errArray =  np.mat(np.ones((m， <span class="number">1</span>)))</span><br><span class="line">                errArray[predictClass == labelMat] = <span class="number">0</span></span><br><span class="line">                weightError = D.T * errArray</span><br><span class="line">                <span class="comment">#print &quot;split: dim %d， thresh: %.2f， threIneq:%s， weghtError %.3F&quot; %(i， thresholdValue， thresholdIneq， weightError)</span></span><br><span class="line">                <span class="keyword">if</span> weightError &lt; minError:</span><br><span class="line">                    minError = weightError</span><br><span class="line">                    bestClassEst = predictClass.copy()</span><br><span class="line">                    bestStump[<span class="string">&#x27;dimen&#x27;</span>] = i</span><br><span class="line">                    bestStump[<span class="string">&#x27;thresholdValue&#x27;</span>] = thresholdValue</span><br><span class="line">                    bestStump[<span class="string">&#x27;thresholdIneq&#x27;</span>] = thresholdIneq</span><br><span class="line">    <span class="keyword">return</span> bestClassEst， minError， bestStump</span><br></pre></td></tr></table></figure>

<h2 id="3-3-输出多个弱分类器的数组"><a href="#3-3-输出多个弱分类器的数组" class="headerlink" title="3.3. 输出多个弱分类器的数组"></a>3.3. 输出多个弱分类器的数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adaBoostTrainDS</span>(<span class="params">dataArray， classLabels， numIt=<span class="number">40</span></span>):</span></span><br><span class="line">    weakClass = []<span class="comment">#定义弱分类数组，保存每个基本分类器bestStump</span></span><br><span class="line">    m， n = np.shape(dataArray)</span><br><span class="line">    D = np.mat(np.ones((m， <span class="number">1</span>))/m)</span><br><span class="line">    aggClassEst = np.mat(np.zeros((m， <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numIt):</span><br><span class="line">        print(<span class="string">&quot;i:&quot;</span>， i)</span><br><span class="line">        bestClassEst， minError， bestStump = buildStump(dataArray， classLabels， D)<span class="comment">#step1:找到最佳的单层决策树</span></span><br><span class="line">        print(<span class="string">&quot;D.T:&quot;</span>， D.T)</span><br><span class="line">        alpha = <span class="built_in">float</span>(<span class="number">0.5</span>*np.log((<span class="number">1</span>-minError)/<span class="built_in">max</span>(minError， <span class="number">1e-16</span>)))<span class="comment">#step2: 更新alpha</span></span><br><span class="line">        print(<span class="string">&quot;alpha:&quot;</span>， alpha)</span><br><span class="line">        bestStump[<span class="string">&#x27;alpha&#x27;</span>] = alpha</span><br><span class="line">        weakClass.append(bestStump)<span class="comment">#step3:将基本分类器添加到弱分类的数组中</span></span><br><span class="line">        print(<span class="string">&quot;classEst:&quot;</span>， bestClassEst)</span><br><span class="line">        expon = np.multiply(-<span class="number">1</span>*alpha*np.mat(classLabels).T， bestClassEst)</span><br><span class="line">        D = np.multiply(D， np.exp(expon))</span><br><span class="line">        D = D/D.<span class="built_in">sum</span>()<span class="comment">#step4:更新权重，该式是让D服从概率分布</span></span><br><span class="line">        aggClassEst += alpha*bestClassEst<span class="comment">#steo5:更新累计类别估计值</span></span><br><span class="line">        print(<span class="string">&quot;aggClassEst:&quot;</span>， aggClassEst.T)</span><br><span class="line">        print(np.sign(aggClassEst) != np.mat(classLabels).T)</span><br><span class="line">        aggError = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T， np.ones((m， <span class="number">1</span>)))</span><br><span class="line">        print(<span class="string">&quot;aggError&quot;</span>， aggError)</span><br><span class="line">        aggErrorRate = aggError.<span class="built_in">sum</span>()/m</span><br><span class="line">        print(<span class="string">&quot;total error:&quot;</span>， aggErrorRate)</span><br><span class="line">        <span class="keyword">if</span> aggErrorRate == <span class="number">0.0</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> weakClass</span><br></pre></td></tr></table></figure>

<h2 id="3-4-输出分类结果"><a href="#3-4-输出分类结果" class="headerlink" title="3.4. 输出分类结果"></a>3.4. 输出分类结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adaTestClassify</span>(<span class="params">dataToClassify， weakClass</span>):</span></span><br><span class="line">    dataMatrix = np.mat(dataToClassify)        </span><br><span class="line">    m =np.shape(dataMatrix)[<span class="number">0</span>]</span><br><span class="line">    aggClassEst = np.mat(np.zeros((m， <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weakClass)):</span><br><span class="line">        <span class="comment"># 输出决策树桩标签</span></span><br><span class="line">        classEst = stumpClassify(dataToClassify， weakClass[i][<span class="string">&#x27;dimen&#x27;</span>]， weakClass[i][<span class="string">&#x27;thresholdValue&#x27;</span>]， weakClass[i][<span class="string">&#x27;thresholdIneq&#x27;</span>])</span><br><span class="line">        aggClassEst += weakClass[i][<span class="string">&#x27;alpha&#x27;</span>] * classEst</span><br><span class="line">        print(<span class="string">&#x27;第&#x27;</span>， i， <span class="string">&#x27;个弱分类器权值：&#x27;</span>， aggClassEst)</span><br><span class="line">    <span class="keyword">return</span> np.sign(aggClassEst)</span><br></pre></td></tr></table></figure>

<h2 id="3-5-主函数"><a href="#3-5-主函数" class="headerlink" title="3.5. 主函数"></a>3.5. 主函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__  ==  <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    D =np.mat(np.ones((<span class="number">5</span>， <span class="number">1</span>))/<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 加载一个两个特征的数据集</span></span><br><span class="line">    dataMatrix， classLabels = loadSimData()</span><br><span class="line">    <span class="comment"># 找到加权错误率（分类错误率）最小的单层决策树</span></span><br><span class="line">    bestClassEst， minError， bestStump = buildStump(dataMatrix， classLabels， D)</span><br><span class="line">    <span class="comment"># 输出：多个弱分类器的数组</span></span><br><span class="line">    weakClass = adaBoostTrainDS(dataMatrix， classLabels， <span class="number">9</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    testClass = adaTestClassify(np.mat([<span class="number">0</span>， <span class="number">0</span>])， weakClass)</span><br><span class="line">    print(<span class="string">&#x27;最终分类标签：&#x27;</span>， testClass)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D.T: [[<span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span>]]</span><br><span class="line">alpha: <span class="number">0.6931471805599453</span></span><br><span class="line">classEst: [[-<span class="number">1.</span>]</span><br><span class="line">[ <span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]</span><br><span class="line">[ <span class="number">1.</span>]]</span><br><span class="line">aggClassEst: [[-<span class="number">0.69314718</span> <span class="number">0.69314718</span> -<span class="number">0.69314718</span> -<span class="number">0.69314718</span> <span class="number">0.69314718</span>]]</span><br><span class="line">[[ <span class="literal">True</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]]</span><br><span class="line">aggError [[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]]</span><br><span class="line">total error: <span class="number">0.2</span></span><br><span class="line">i: <span class="number">1</span></span><br><span class="line">D.T: [[<span class="number">0.5</span></span><br><span class="line"><span class="number">0.125</span> <span class="number">0.125</span> <span class="number">0.125</span> <span class="number">0.125</span>]]</span><br><span class="line">alpha: <span class="number">0.9729550745276565</span></span><br><span class="line">classEst: [[ <span class="number">1.</span>]</span><br><span class="line">[ <span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]</span><br><span class="line">[-<span class="number">1.</span>]]</span><br><span class="line">aggClassEst: [[ <span class="number">0.27980789</span> <span class="number">1.66610226</span> -<span class="number">1.66610226</span> -<span class="number">1.66610226</span> -<span class="number">0.27980789</span>]]</span><br><span class="line">[[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[ <span class="literal">True</span>]]</span><br><span class="line">aggError [[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">1.</span>]]</span><br><span class="line">total error: <span class="number">0.2</span></span><br><span class="line">i: <span class="number">2</span></span><br><span class="line">D.T: [[<span class="number">0.28571429</span> <span class="number">0.07142857</span> <span class="number">0.07142857</span> <span class="number">0.07142857</span> <span class="number">0.5</span>  ]]</span><br><span class="line">alpha: <span class="number">0.8958797346140273</span></span><br><span class="line">classEst: [[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">1.</span>]</span><br><span class="line">[<span class="number">1.</span>]]</span><br><span class="line">aggClassEst: [[ <span class="number">1.17568763</span> <span class="number">2.56198199</span> -<span class="number">0.77022252</span> -<span class="number">0.77022252</span> <span class="number">0.61607184</span>]]</span><br><span class="line">[[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]</span><br><span class="line">[<span class="literal">False</span>]]</span><br><span class="line">aggError [[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>]]</span><br><span class="line">total error: <span class="number">0.0</span></span><br><span class="line">第 <span class="number">0</span> 个弱分类器权值: [[-<span class="number">0.69314718</span>]]</span><br><span class="line">第 <span class="number">1</span> 个弱分类器权值: [[-<span class="number">1.66610226</span>]]</span><br><span class="line">第 <span class="number">2</span> 个弱分类器权值: [[-<span class="number">2.56198199</span>]]</span><br><span class="line">最终分类标签: [[-<span class="number">1.</span>]]</span><br></pre></td></tr></table></figure>


<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AdaBoost.py">AdaBoost.py</a></p>
</div>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Apriori算法——数据挖掘</title>
    <url>/2018/12/10/DataMining_Apriori/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Apriori.png" class="full-image" />

<h1 id="1-Apriori算法简介"><a href="#1-Apriori算法简介" class="headerlink" title="1. Apriori算法简介"></a>1. Apriori算法简介</h1><ul>
<li>Apriori是一种在事务数据库上进行频繁项集挖掘和关联规则学习的算法。</li>
<li>它通过识别数据库中的频繁单项，并将经常出现的项扩展到越来越大的项目集。</li>
<li>Apriori确定的频繁项目集可用于确定关联规则，能够显示出数据库中项的一般趋势，故常应用于诸如市场购物栏分析的领域中（决策分析）。</li>
</ul>
<a id="more"></a>

<ul>
<li>Apriori算法由Agrawal和Srikant于1994年提出。Apriori旨在对包含交易的数据库(例如：客户购买的项目集合，或网站频繁或IP地址的详细信息)进行操作。</li>
<li>其他算法设计用于在没有事务(Winepi和Minepi)或没有时间戳(DNA序列)的数据中查找关联规则。</li>
<li>每个事务都被视为一组项(项集)。给出一个门槛 C，Apriori算法识别至少是子集的项集 C 数据库中的事务。Apriori使用“自下而上”方法，其中频繁的子集一次扩展一个项目(称为候选生成的步骤)，并且针对数据测试候选组。当没有找到进一步成功的扩展时，算法终止。</li>
</ul>
<h1 id="2-Python编程实现Apriori算法"><a href="#2-Python编程实现Apriori算法" class="headerlink" title="2. Python编程实现Apriori算法"></a>2. Python编程实现Apriori算法</h1><h2 id="2-1-Apriori算法步骤"><a href="#2-1-Apriori算法步骤" class="headerlink" title="2.1. Apriori算法步骤"></a>2.1. Apriori算法步骤</h2><ul>
<li>S1.令 k=1</li>
<li>S2.扫描数据库，生成长度为k的候选项集的集合Ck</li>
<li>S3.重复S4~S8直到找不到新的候选项集的集合Ck</li>
<li>S4.从长度为k的频繁项集Lk生成长度为(k + 1)的候选项集</li>
<li>S5.修剪长度为(k + 1)的候选项集中的出现频率低于(min_support阈值)的候选项目</li>
<li>S6.通过扫描数据库，统计每个候选项的数目</li>
<li>S7.删除出现频率低于(min_support阈值)的候选项，只留下频繁出现的候选项目集Lk</li>
<li>S8. k = k + 1</li>
</ul>
<h2 id="2-2-生成长度为1的候选项集C1"><a href="#2-2-生成长度为1的候选项集C1" class="headerlink" title="2.2. 生成长度为1的候选项集C1"></a>2.2. 生成长度为1的候选项集C1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># C1 是大小为1的所有候选项集的集合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createC1</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    C1 = []</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> transaction:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> [item] <span class="keyword">in</span> C1:</span><br><span class="line">                C1.append([item]) <span class="comment">#store all the item unrepeatly</span></span><br><span class="line">    <span class="comment"># C1.sort()</span></span><br><span class="line">    <span class="comment">#return map(frozenset， C1)#frozen set， user can&#x27;t change it.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">frozenset</span>， C1))</span><br></pre></td></tr></table></figure>

<h2 id="2-3-扫描数据库，返回频繁出现的候选项目集Lk-出现频率大于给定阈值minSupport"><a href="#2-3-扫描数据库，返回频繁出现的候选项目集Lk-出现频率大于给定阈值minSupport" class="headerlink" title="2.3. 扫描数据库，返回频繁出现的候选项目集Lk(出现频率大于给定阈值minSupport)"></a>2.3. 扫描数据库，返回频繁出现的候选项目集Lk(出现频率大于给定阈值minSupport)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanD</span>(<span class="params">D， Ck， minSupport</span>):</span></span><br><span class="line">    ssCnt=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tid <span class="keyword">in</span> D:</span><br><span class="line">        <span class="keyword">for</span> can <span class="keyword">in</span> Ck:</span><br><span class="line">            <span class="keyword">if</span> can.issubset(tid):</span><br><span class="line">                <span class="comment">#if not ssCnt.has_key(can):</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> can <span class="keyword">in</span> ssCnt:</span><br><span class="line">                    ssCnt[can]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: ssCnt[can]+=<span class="number">1</span></span><br><span class="line">    numItems=<span class="built_in">float</span>(<span class="built_in">len</span>(D))</span><br><span class="line">    retList = []</span><br><span class="line">    supportData = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> ssCnt:</span><br><span class="line">        support = ssCnt[key]/numItems <span class="comment">#compute support</span></span><br><span class="line">        <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">            retList.insert(<span class="number">0</span>， key)</span><br><span class="line">        supportData[key] = support</span><br><span class="line">    <span class="keyword">return</span> retList， supportData</span><br></pre></td></tr></table></figure>

<h2 id="2-4-apriori组合，向上合并L"><a href="#2-4-apriori组合，向上合并L" class="headerlink" title="2.4. apriori组合，向上合并L"></a>2.4. apriori组合，向上合并L</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aprioriGen</span>(<span class="params">Lk， k</span>):</span></span><br><span class="line">    <span class="comment">#creates Ck 参数：频繁项集列表 Lk 与项集元素个数 k</span></span><br><span class="line">    retList = []</span><br><span class="line">    lenLk = <span class="built_in">len</span>(Lk)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenLk):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>， lenLk): <span class="comment">#两两组合遍历</span></span><br><span class="line">            L1 = <span class="built_in">list</span>(Lk[i])[:k-<span class="number">2</span>]; L2 = <span class="built_in">list</span>(Lk[j])[:k-<span class="number">2</span>]</span><br><span class="line">            L1.sort(); L2.sort()</span><br><span class="line">            <span class="keyword">if</span> L1 == L2: <span class="comment">#若两个集合的前k-2个项相同时， 则将两个集合合并</span></span><br><span class="line">                retList.append(Lk[i] | Lk[j]) <span class="comment">#set union</span></span><br><span class="line">    <span class="keyword">return</span> retList</span><br></pre></td></tr></table></figure>

<h2 id="2-5-apriori算法核心函数"><a href="#2-5-apriori算法核心函数" class="headerlink" title="2.5. apriori算法核心函数"></a>2.5. apriori算法核心函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apriori</span>(<span class="params">dataSet， minSupport = <span class="number">0.5</span></span>):</span></span><br><span class="line">    C1 = createC1(dataSet)</span><br><span class="line">    D = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">set</span>， dataSet)) <span class="comment">#python3</span></span><br><span class="line">    L1， supportData = scanD(D， C1， minSupport)<span class="comment">#单项最小支持度判断 0.5，生成L1</span></span><br><span class="line">    L = [L1]</span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(L[k-<span class="number">2</span>]) &gt; <span class="number">0</span>):<span class="comment">#创建包含更大项集的更大列表， 直到下一个大的项集为空</span></span><br><span class="line">        Ck = aprioriGen(L[k-<span class="number">2</span>]， k)<span class="comment">#Ck</span></span><br><span class="line">        Lk， supK = scanD(D， Ck， minSupport)<span class="comment">#get Lk</span></span><br><span class="line">        supportData.update(supK)</span><br><span class="line">        L.append(Lk)</span><br><span class="line">        k += <span class="number">1</span> <span class="comment">#继续向上合并 生成项集个数更多的</span></span><br><span class="line">    <span class="keyword">return</span> L， supportData</span><br></pre></td></tr></table></figure>

<h2 id="2-6-主函数"><a href="#2-6-主函数" class="headerlink" title="2.6. 主函数"></a>2.6. 主函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#加载数据集</span></span><br><span class="line">    dataSet = loadDataSet()</span><br><span class="line">    <span class="comment">#挖掘频繁项集</span></span><br><span class="line">    L， supportData = apriori(dataSet， <span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">&#x27;L = &#x27;</span>， L)</span><br><span class="line">    print(<span class="string">&#x27;supportData = &#x27;</span>， supportData)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [[<span class="built_in">frozenset</span>(&#123;<span class="number">5</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">3</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>&#125;)]， [<span class="built_in">frozenset</span>(&#123;<span class="number">2</span>，</span><br><span class="line"><span class="number">5</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>， <span class="number">3</span>&#125;)， <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>， <span class="number">3</span>&#125;)]， []]</span><br><span class="line">supportData = &#123;<span class="built_in">frozenset</span>(&#123;<span class="number">1</span>&#125;): <span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">3</span>&#125;): <span class="number">0.75</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">4</span>&#125;): <span class="number">0.25</span>，</span><br><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">2</span>&#125;): <span class="number">0.75</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">5</span>&#125;): <span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>， <span class="number">3</span>&#125;): <span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>， <span class="number">3</span>&#125;):</span><br><span class="line"><span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>， <span class="number">5</span>&#125;): <span class="number">0.5</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">3</span>， <span class="number">5</span>&#125;): <span class="number">0.25</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>， <span class="number">5</span>&#125;): <span class="number">0.25</span>，</span><br><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">1</span>， <span class="number">2</span>&#125;): <span class="number">0.25</span>， <span class="built_in">frozenset</span>(&#123;<span class="number">2</span>， <span class="number">3</span>， <span class="number">5</span>&#125;): <span class="number">0.25</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>对于数据集[[1， 3， 4]， [2， 3]， [1， 2， 3， 5]， [2， 5]]，运行apriori挖掘(出现频率大于阈值0.5)的频繁项集合为:[5]， [2]，<br>[3]， [1]， [2，5]， [2，3]， [1，3]，其中[2，5]， [2，3]， [1，3]在数据库中出现的频率均为0.5</p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Apriori.py">Apriori.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>DBSCAN算法——数据挖掘</title>
    <url>/2018/11/10/DataMining_DBSCAN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN.png" class="full-image" />

<h1 id="1-DBSCAN算法简介"><a href="#1-DBSCAN算法简介" class="headerlink" title="1. DBSCAN算法简介"></a>1. DBSCAN算法简介</h1><ul>
<li>基于密度的噪声应用空间聚类（DBSCAN）是Martin Ester，Hans-Peter Kriegel，JörgSander和Xiaowei Xu于1996年提出的数据聚类算法。</li>
<li>它是一种基于密度的聚类算法：给定一些空间中的一组点，它将紧密堆积在一起的点（具有许多邻近邻居的点）组合在一起，标记为单独位于低密度区域的离群点（最近的点）邻居们太远了）。</li>
<li>DBSCAN是最常见的聚类算法之一，也是科学文献中引用最多的算法。</li>
<li>2014年，该算法在领先的数据挖掘会议KDD上获得了时间奖的测试（在理论和实践中获得了大量关注的算法奖）。<a id="more"></a>

</li>
</ul>
<h1 id="2-Python编程实现DBSCAN算法"><a href="#2-Python编程实现DBSCAN算法" class="headerlink" title="2. Python编程实现DBSCAN算法"></a>2. Python编程实现DBSCAN算法</h1><p><strong>DBSCAN算法主要分为以下步骤实现</strong>：</p>
<ul>
<li>S1. 任意选择一个未访问过的点 P</li>
<li>S2. 标记点 P为已访问</li>
<li>S3. 计算得到所有从p 关于 Eps 和 MinPts 密度可达的点的集合 NeighborPts</li>
<li>S4. 若 P 不是核心对象，标记点 P 为噪声，跳转步骤S1重新选取 P；若 P 为核心对象，则扩展当前核心对象 P 的所属簇（expandCluster函数）</li>
<li>S5. 判断是否所有点均已被访问，若是则跳转S6; 若否则继续 S1 ~ S5步骤</li>
<li>S6. DBSCAN算法运行结束，返回二维分类数组Cluster</li>
</ul>
<h1 id="3-DBSCAN算法Python代码实现如下"><a href="#3-DBSCAN算法Python代码实现如下" class="headerlink" title="3. DBSCAN算法Python代码实现如下"></a>3. DBSCAN算法Python代码实现如下</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于密度的DBSCAN算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DBSCAN</span>(<span class="params">data, Eps, MinPts</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;开始DBSCAN...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建一个同规模数组，记录每个点的 分类、是否访问</span></span><br><span class="line">    classification = np.ones(<span class="built_in">len</span>(data)) * NoVisitedValue  <span class="comment"># 存储是否访问及分类信息: -3，未访问； -2，噪声点；</span></span><br><span class="line">    Cluster = [] <span class="comment">#记录分簇信息，第i行存储所有归类于第i簇的元素下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="comment"># 选择一个 未访问的 点 P</span></span><br><span class="line">        P = chooseOneNoVisitedP(data, classification)</span><br><span class="line">        <span class="keyword">if</span> (P == isAllVisitedValue): <span class="comment">#已经全部遍历，退出While循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment"># # 若点 P 已被访问，跳过（注释，包含点P）</span></span><br><span class="line">        <span class="comment"># if (isVisited(classification, P) == True):</span></span><br><span class="line">        <span class="comment">#     continue</span></span><br><span class="line">        <span class="comment">#  若点 P 未被访问， 标记 P 为已访问</span></span><br><span class="line">        classification[P] = VisitedValue</span><br><span class="line">        NeighborPts = regionQuery(data, P, Eps)</span><br><span class="line">        <span class="comment"># print(P,&#x27;\&#x27;s NeighborPts is: &#x27;, NeighborPts)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(NeighborPts) &lt; MinPts):  <span class="comment"># 若 P非核心对象</span></span><br><span class="line">            <span class="comment">#标记 P 为 NOISE</span></span><br><span class="line">            classification[P] = NoiseValue</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print(&#x27;扩展当前核心对象 P = &#x27;, P, &#x27;的所属簇&#x27;)</span></span><br><span class="line">            classification, Cluster = expandCluster(data, classification, P, NeighborPts, Cluster, Eps, MinPts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Cluster</span><br></pre></td></tr></table></figure>

<h2 id="3-1-DBSCAN算法中的关键函数–expandCluster函数实现步骤"><a href="#3-1-DBSCAN算法中的关键函数–expandCluster函数实现步骤" class="headerlink" title="3.1. DBSCAN算法中的关键函数–expandCluster函数实现步骤"></a>3.1. DBSCAN算法中的关键函数–expandCluster函数实现步骤</h2><ul>
<li>S1. 将当前核心对象 P 添加到新的 P 的所属类Cluster_P中</li>
<li>S2. 从点 P 的邻域列表 NeighborPts 中取一个点 P’</li>
<li>S3. 判断点 P’ 是否已被访问。若已被访问，跳转步骤S7；若未被访问，继续执行下一步骤</li>
<li>S4. 标记点 P’ 为已被访问，并计算得到所有从P’ 关于 Eps 和 MinPts 密度可达的点的集合 NeighborPts_i</li>
<li>S5. 判断点 P’ 是否为核心对象，若是，将 P’ 的邻域内点 NeighborPts_i 非重复地添加到点 P 的扩展邻域列表NeighborPts中；若否，继续执行下一步骤</li>
<li>S6. 判断点 P’ 是否已经被分类，若否，添加点 P’ 到列表 Cluster_P 中；若是，继续执行下一步骤</li>
<li>S7. 判断是否 P 扩展邻域列表 NeighborPts 中的所有元素均已被访问，若否，则循环步骤 S2 ～ S7; 若是，继续执行下一步骤</li>
<li>S8. 将列表 Cluster_P 添加到总分类列表 Cluster 中</li>
</ul>
<h2 id="3-2-expandCluster函数Python代码实现如下："><a href="#3-2-expandCluster函数Python代码实现如下：" class="headerlink" title="3.2. expandCluster函数Python代码实现如下："></a>3.2. expandCluster函数Python代码实现如下：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 扩展当前核心对象 P 的所属簇</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expandCluster</span>(<span class="params">data, classification, P, NeighborPts, Cluster, Eps, MinPts</span>):</span></span><br><span class="line">    Cluster_P = []</span><br><span class="line">    Cluster_P += [P] <span class="comment">#将核心对象添加到 P 的临时所属簇</span></span><br><span class="line">    <span class="comment"># 遍历点 P 的所有 NeighborPts， 这个NeighborPts可能会增加</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="comment"># 若邻域内的 P&#x27; 正好是 P，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (NeighborPts[i] == P):</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 若所有 NeighborPts 均已遍历，退出while</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="built_in">len</span>(NeighborPts)):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 跳过</span></span><br><span class="line">        <span class="comment"># 若 P&#x27; 未访问</span></span><br><span class="line">        <span class="keyword">if</span> (isVisited(classification, NeighborPts[i]) == <span class="literal">False</span>):</span><br><span class="line">            classification[NeighborPts[i]] = VisitedValue <span class="comment"># 标记 P&#x27; 已访问</span></span><br><span class="line">            NeighborPts_i = regionQuery(data, NeighborPts[i], Eps) <span class="comment"># 求 P&#x27; Eps邻域内的点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">len</span>(NeighborPts_i) &gt;= MinPts): <span class="comment"># 若 P&#x27; 也为 核心对象</span></span><br><span class="line">                NeighborPts = addNeighborPts(NeighborPts, NeighborPts_i) <span class="comment">#增加P&#x27; Eps邻域内的点到 点 P 的邻域元素 NeighborPts中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若 P&#x27; 不属于任何一个已有类(将当前邻域内元素添加到核心对象 P 的所属簇)</span></span><br><span class="line">            <span class="keyword">if</span> (isNoBelongsToAnyCluster(Cluster, Cluster_P, NeighborPts[i]) == <span class="literal">True</span>):</span><br><span class="line">                Cluster_P += [NeighborPts[i]]</span><br><span class="line"></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若所有 NeighborPts 均已遍历，退出while</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="built_in">len</span>(NeighborPts)):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    Cluster += [Cluster_P]</span><br><span class="line">    <span class="keyword">return</span> classification, Cluster</span><br></pre></td></tr></table></figure>

<h1 id="4-DBSCAN算法执行、参数调整并分析"><a href="#4-DBSCAN算法执行、参数调整并分析" class="headerlink" title="4. DBSCAN算法执行、参数调整并分析"></a>4. DBSCAN算法执行、参数调整并分析</h1><h2 id="4-1-显示聚类前后对比图函数"><a href="#4-1-显示聚类前后对比图函数" class="headerlink" title="4.1. 显示聚类前后对比图函数"></a>4.1. 显示聚类前后对比图函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示聚类前后对比图（最多表示8种颜色的集群）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showClusterImage</span>(<span class="params">data, Cluster, Eps, MinPts</span>):</span></span><br><span class="line">    num_Cluster = <span class="built_in">len</span>(Cluster) <span class="comment"># 分类个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制第 i 个类的 颜色列表</span></span><br><span class="line">    <span class="comment"># b--blue, c--cyan, g--green, k--black</span></span><br><span class="line">    <span class="comment"># m--magenta, r--red, w--white, y--yellow</span></span><br><span class="line">    color = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">    <span class="comment"># 绘制第 i 个类的 形状列表</span></span><br><span class="line">    mark = [<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> num_Cluster &gt; <span class="built_in">len</span>(color):</span><br><span class="line">        print(<span class="string">&#x27;Sorry! Your len(Cluster)=&#x27;</span>, <span class="built_in">len</span>(Cluster), <span class="string">&#x27; is too large!( &gt; len(color)=&#x27;</span>, <span class="built_in">len</span>(color), <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制图片</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&#x27;Eps=&#x27;</span>+<span class="built_in">str</span>(Eps)+<span class="string">&#x27;, MinPts=&#x27;</span>+<span class="built_in">str</span>(MinPts)+<span class="string">&#x27;  Result Cluster=&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(Cluster)), fontsize=<span class="number">12</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    fig.gca().xaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">    fig.gca().yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图1: 绘制原图</span></span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    len_data = <span class="built_in">len</span>(data)</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_data):</span><br><span class="line">        x += [data[i][<span class="number">0</span>]]</span><br><span class="line">        y += [data[i][<span class="number">1</span>]]</span><br><span class="line">    ax1.scatter(x, y, s=<span class="number">4</span>, c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置标题并加上轴标签</span></span><br><span class="line">    ax1.set_title(<span class="string">&#x27;Original Graph&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置坐标的取值范围</span></span><br><span class="line">    ax1.axis(getMinMaxXandY(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图2: 绘制DBSCAN</span></span><br><span class="line">    ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 分别绘制不同 类别点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Cluster)):</span><br><span class="line">        <span class="comment"># 提取第 i 个类别的(x, y)坐标</span></span><br><span class="line">        x = []</span><br><span class="line">        y = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Cluster[i])):</span><br><span class="line">            x += [data[Cluster[i][j]][<span class="number">0</span>]]</span><br><span class="line">            y += [data[Cluster[i][j]][<span class="number">1</span>]]</span><br><span class="line">        <span class="comment"># 对第 i 个类别内所有点 以不同颜色绘制</span></span><br><span class="line">        ax2.scatter(x, y, s=<span class="number">4</span>, c=color[i], marker=mark[i])</span><br><span class="line">    ax2.set_title(<span class="string">&#x27;DBSCAN Graph&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置坐标的取值范围</span></span><br><span class="line">    ax2.axis(getMinMaxXandY(data))</span><br><span class="line"></span><br><span class="line">    plt.show() <span class="comment"># 显示绘制图像</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2-主函数"><a href="#4-2-主函数" class="headerlink" title="4.2. 主函数"></a>4.2. 主函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 加载long.mat数据</span></span><br><span class="line">    data = loadDataFile(<span class="string">&#x27;long.mat&#x27;</span>)</span><br><span class="line">    data = data[<span class="string">&#x27;long1&#x27;</span>] <span class="comment">#Eps=0.15， MinPts=8，最终分类数：2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># DBSCAN两个重要参数</span></span><br><span class="line">    Eps = <span class="number">0.15</span> <span class="comment">#邻域半径</span></span><br><span class="line">    MinPts = <span class="number">8</span> <span class="comment">#邻域内元素个数（包括点P）</span></span><br><span class="line">    Cluster = DBSCAN(data, Eps, MinPts) <span class="comment"># 执行 DBSCAN 算法，返回聚类后的下标二维数组</span></span><br><span class="line">    print(<span class="string">&#x27;All Done&#x27;</span>)</span><br><span class="line">    PrintCluster(Cluster) <span class="comment"># 打印簇信息</span></span><br><span class="line">    showClusterImage(data, Cluster, Eps, MinPts) <span class="comment"># 绘制基于密度的DBSCAN算法后的效果图</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-long-mat文件的DBSCAN算法聚类效果"><a href="#4-3-long-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.3. long.mat文件的DBSCAN算法聚类效果"></a>4.3. long.mat文件的DBSCAN算法聚类效果</h2><p>尝试设置Eps#邻域半径、MinPts#邻域内元素个数（包括点P）两个参数，由于Eps及MinPts两个参数没设置好导致被分成许多类，不方便绘图显示每个类。调试参数时也确认了两个参数设置的重要性，参数对分类结果的影响如下：</p>
<h3 id="Eps-0-08-MinPts-7"><a href="#Eps-0-08-MinPts-7" class="headerlink" title="Eps=0.08, MinPts=7"></a>Eps=0.08, MinPts=7</h3><p>当设置Eps=0.08, MinPts=7时已经能够成功绘制图形，但数据被分成6个类，效果不是很理想，如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_longEps=0.08MinPts=7ResultCluster=6.png" alt="Eps=0.08,MinPts=7的效果图"><br><strong>分析：</strong>虽然能从图中明确看出被分成6个类，但视觉分析应该分成2个类更合适，间接说明分类数过多，表明在扩展其中两个大类时与另外两个类“断开了”，下面分别尝试增加领域半径Eps值、减小MinPts#邻域内元素个数，尝试让小类与大类“连接”起来。</p>
<h3 id="Eps-0-1-MinPts-7"><a href="#Eps-0-1-MinPts-7" class="headerlink" title="Eps=0.1, MinPts=7"></a>Eps=0.1, MinPts=7</h3><p>当只增加领域半径Eps值，MinPts不变，设置Eps=0.1, MinPts=7，分类结果如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_longEps=0.1MinPts=7ResultCluster=3.png" alt="Eps=0.1,MinPts=7的效果图"><br><strong>分析：</strong>增加领域半径Eps值已有明显效果，此时分类数为3，继续尝试增大领域半径Eps值</p>
<h3 id="Eps-0-18-MinPts-7"><a href="#Eps-0-18-MinPts-7" class="headerlink" title="Eps=0.18, MinPts=7"></a>Eps=0.18, MinPts=7</h3><p>继续增大Eps值直到Eps=0.18, MinPts=7时才能被分为两类，分类结果如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_longEps=0.18MinPts=7ResultCluster=2.png" alt="Eps=0.18,MinPts=7的效果图"><br><strong>分析：</strong>虽然此时按密度被成功聚类为2类，但相比之下每个类变得更“松散”，包括了许多不需要的边界非核心对象</p>
<h3 id="Eps-0-08，MinPts-5"><a href="#Eps-0-08，MinPts-5" class="headerlink" title="Eps=0.08，MinPts=5"></a>Eps=0.08，MinPts=5</h3><p>当只减小MinPts，领域半径Eps值不变，设置Eps=0.08, MinPts=5时，数据分类数为5，如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_longEps=0.08MinPts=5ResultCluster=5.png" alt="Eps=0.08,MinPts=5的效果图"><br><strong>分析：</strong>一味只减少MinPts并没有得到很好的聚类结果，尝试减少MinPts并不能实现只分为两类的效果</p>
<h3 id="Eps-0-15，MinPts-8"><a href="#Eps-0-15，MinPts-8" class="headerlink" title="Eps=0.15，MinPts=8"></a>Eps=0.15，MinPts=8</h3><p>综合调节Eps邻域半径大小与MinPts邻域内元素个数，设置Eps=0.15, MinPts=8时分类数为2，分类结果如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_longEps=0.15MinPts=8ResultCluster=2.png" alt="Eps=0.15,MinPts=8的效果图"><br><strong>分析：</strong>联合调整参数Eps和MinPts比只更改单一变量更难调节，在能够分类成2个类的结果下，Eps邻域半径越小、MinPts邻域内元素个数越小，得到的聚类内部对象间隔越“紧密”</p>
<h2 id="4-4-其他文件数据的DBSCAN聚类结果"><a href="#4-4-其他文件数据的DBSCAN聚类结果" class="headerlink" title="4.4. 其他文件数据的DBSCAN聚类结果"></a>4.4. 其他文件数据的DBSCAN聚类结果</h2><p>由于调整Eps#邻域半径、MinPts#邻域内元素个数参数方法与上面一致，为直观显示效果，只给出聚类较理想的结果图及其对应Eps、MinPts参数</p>
<h3 id="4-4-1-moon-mat文件的DBSCAN算法聚类效果"><a href="#4-4-1-moon-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.4.1. moon.mat文件的DBSCAN算法聚类效果"></a>4.4.1. moon.mat文件的DBSCAN算法聚类效果</h3><p>当设置Eps=0.11, MinPts=5时，数据被分成2个类，效果较理想，如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_moonEps=0.11MinPts=5ResultCluster=2.png" alt="Eps=0.11,MinPts=5的效果图"></p>
<h3 id="4-4-2-sizes5-mat文件的DBSCAN算法聚类效果"><a href="#4-4-2-sizes5-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.4.2. sizes5.mat文件的DBSCAN算法聚类效果"></a>4.4.2. sizes5.mat文件的DBSCAN算法聚类效果</h3><p>当设置Eps=1.32, MinPts=10时，数据分类数Cluster=4，效果较理想，如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_sizes5Eps=1.32MinPts=10ResultCluster=4.png" alt="Eps=1.32,MinPts=10的效果图"></p>
<h3 id="4-4-3-smile-mat文件的DBSCAN算法聚类效果"><a href="#4-4-3-smile-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.4.3. smile.mat文件的DBSCAN算法聚类效果"></a>4.4.3. smile.mat文件的DBSCAN算法聚类效果</h3><p>当设置Eps=0.08, MinPts=10时，数据分类数Cluster=3，效果较理想，如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_smileEps=0.08MinPts=10ResultCluster=3.png" alt="Eps=0.08,MinPts=10的效果图"></p>
<h3 id="4-4-4-spiral-mat文件的DBSCAN算法聚类效果"><a href="#4-4-4-spiral-mat文件的DBSCAN算法聚类效果" class="headerlink" title="4.4.4. spiral.mat文件的DBSCAN算法聚类效果"></a>4.4.4. spiral.mat文件的DBSCAN算法聚类效果</h3><p>当设置Eps=1, MinPts=8时，数据分类数Cluster=2，效果较理想，如下图所示<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DBSCAN_spiralEps=1MinPts=8ResultCluster=2.png" alt="Eps=1,MinPts=8的效果图"></p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待聚类数据集文件</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/long.mat">long.mat</a>、<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/moon.mat">moon.mat</a>、<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/sizes5.mat">sizes5.mat</a>、<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/smile.mat">smile.mat</a>、<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/spiral.mat">spiral.mat</a><br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DensityBasedClustering.py">DensityBasedClustering.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理——数据挖掘</title>
    <url>/2018/10/21/DataMining_DataPreprocess/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DataPreprocess.jpg" class="full-image" />

<h1 id="1-在Linux系统安装Python及数据处理所需的numpy、pandas库"><a href="#1-在Linux系统安装Python及数据处理所需的numpy、pandas库" class="headerlink" title="1. 在Linux系统安装Python及数据处理所需的numpy、pandas库"></a>1. 在Linux系统安装Python及数据处理所需的numpy、pandas库</h1><p>之前尝试手动下载numpy库，解压，然后按提示安装，却发现numpy库依赖上级库nose,又下载nose库，但在手动安装pandas库时出错…后发现可通过pip的简单方式安装，自动解决依赖，相比于需要手动下载安装上级依赖的手动安装方式更方便，安装代码如下</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy        //安装Numpy库:提供数组支持，以及相应的高效的处理函数</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple SciPy        //安装SciPy库：提供矩阵支持，以及矩阵相关的数值计算模块</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple matplotlib   //安装Matplotlib库：强大的数据可视化工具、作图库</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas       //安装Pandas库：强大、灵活的数据分析和探索工具</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple statsmodels  //安装StatsModels库：统计建模和计量经济学，包括描述统计、统计模型估计和推断</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple scikit-learn //安装Scikit-Learn库：支持回归、分类、聚类等强大的机器学习库</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple keras        //安装Keras库：深度学习库，用于建立神经网络以及深度学习模型</span><br><span class="line">sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple gensim       //安装Gensim库：用来做文本主题模型的库，可能用于文本挖掘</span><br></pre></td></tr></table></figure>

<h1 id="2-数据加载"><a href="#2-数据加载" class="headerlink" title="2. 数据加载"></a>2. 数据加载</h1><p>使用python的pandas库提供的数据处理支持，读取特定文件中庞大数据到到程序的运行内存中以便进行处理。如读取存放于“Train_UWu5bXk.csv”文件中的Bigmart销售数据到变量data中，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># Pandas库：强大、灵活的数据分析和探索工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line">print(<span class="string">&quot;数据加载:\n&quot;</span>)</span><br><span class="line"><span class="comment"># 定义销售数据12个列名</span></span><br><span class="line">variables=[<span class="string">&#x27;Item_Identifier&#x27;</span>, <span class="string">&#x27;Item_Weight&#x27;</span>, <span class="string">&#x27;Item_Fat_Content&#x27;</span>, <span class="string">&#x27;Item_Visibility&#x27;</span>, <span class="string">&#x27;Item_Type&#x27;</span>, <span class="string">&#x27;Item_MRP&#x27;</span>, <span class="string">&#x27;Outlet_Identifier&#x27;</span>, <span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>, <span class="string">&#x27;Outlet_Size&#x27;</span>, <span class="string">&#x27;Outlet_Location_Type&#x27;</span>, <span class="string">&#x27;Outlet_Type&#x27;</span>, <span class="string">&#x27;Item_Outlet_Sales&#x27;</span>] <span class="comment"># Train_UWu5bXk.csv</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;Train_UWu5bXk.csv&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, header=<span class="literal">None</span>, skiprows=<span class="number">1</span>, names=variables) <span class="comment"># Train_UWu5bXk.csv</span></span><br></pre></td></tr></table></figure>

<h1 id="3-粗略查看数据规模分布等信息"><a href="#3-粗略查看数据规模分布等信息" class="headerlink" title="3. 粗略查看数据规模分布等信息"></a>3. 粗略查看数据规模分布等信息</h1><p>通过上一步数据加载已经成功加载了Bigmart销售数据，接下来先粗略了解Bigmart销售数据的矩阵规模信息，然后再根据信息对销售数据有粗略认识，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据粗略查看</span></span><br><span class="line">print(<span class="string">&quot;\n查看各字段的信息&quot;</span>)</span><br><span class="line">data.info()     <span class="comment">#查看各字段的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最小值、最大值、四分位数和数值型变量的均值，以及因子向量和逻辑型向量的频数统计</span></span><br><span class="line">print(<span class="string">&#x27;\n数据粗略查看:&#x27;</span>)</span><br><span class="line">list_view = data.describe()    <span class="comment">#使用describe函数输出计算结果</span></span><br><span class="line">list_view.loc[<span class="string">&#x27;jicha&#x27;</span>] = list_view.loc[<span class="string">&#x27;max&#x27;</span>] - list_view.loc[<span class="string">&#x27;min&#x27;</span>]    <span class="comment">#求极差</span></span><br><span class="line">list_view.loc[<span class="string">&#x27;bianyixishu&#x27;</span>] = list_view.loc[<span class="string">&#x27;std&#x27;</span>]/list_view.loc[<span class="string">&#x27;mean&#x27;</span>]    <span class="comment">#变异系数</span></span><br><span class="line">list_view.loc[<span class="string">&#x27;sifenweijianju&#x27;</span>] = list_view.loc[<span class="string">&#x27;75%&#x27;</span>] - list_view.loc[<span class="string">&#x27;25%&#x27;</span>]    <span class="comment">#四分位间距</span></span><br><span class="line">print(list_view)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询丢失信息</span></span><br><span class="line">print(<span class="string">&#x27;\n输出每个列丢失值也即值为NaN的数据和，并从多到少排序：&#x27;</span>)</span><br><span class="line">total = data.isnull().<span class="built_in">sum</span>().sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">percent =(data.isnull().<span class="built_in">sum</span>()/data.isnull().count()).sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">missing_data = pd.concat([total, percent], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;Total&#x27;</span>, <span class="string">&#x27;Percent&#x27;</span>])</span><br><span class="line">print(missing_data)</span><br></pre></td></tr></table></figure>
<p>显示“Train_UWu5bXk.csv”文件中的Bigmart销售数据粗略信息如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查看各字段的信息</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">8523</span> entries, <span class="number">0</span> to <span class="number">8522</span></span><br><span class="line">Data columns (total <span class="number">12</span> columns):</span><br><span class="line">Item_Identifier              <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Item_Weight                  <span class="number">7060</span> non-null float64</span><br><span class="line">Item_Fat_Content             <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Item_Visibility              <span class="number">8523</span> non-null float64</span><br><span class="line">Item_Type                    <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Item_MRP                     <span class="number">8523</span> non-null float64</span><br><span class="line">Outlet_Identifier            <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Outlet_Establishment_Year    <span class="number">8523</span> non-null int64</span><br><span class="line">Outlet_Size                  <span class="number">6113</span> non-null <span class="built_in">object</span></span><br><span class="line">Outlet_Location_Type         <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Outlet_Type                  <span class="number">8523</span> non-null <span class="built_in">object</span></span><br><span class="line">Item_Outlet_Sales            <span class="number">8523</span> non-null float64</span><br><span class="line">dtypes: float64(<span class="number">4</span>), int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">7</span>)</span><br><span class="line">memory usage: <span class="number">799.1</span>+ KB</span><br><span class="line"></span><br><span class="line">数据粗略查看:</span><br><span class="line">                Item_Weight  Item_Visibility     Item_MRP  Outlet_Establishment_Year  Item_Outlet_Sales</span><br><span class="line">count           <span class="number">7060.000000</span>      <span class="number">8523.000000</span>  <span class="number">8523.000000</span>                <span class="number">8523.000000</span>        <span class="number">8523.000000</span></span><br><span class="line">mean              <span class="number">12.857645</span>         <span class="number">0.066132</span>   <span class="number">140.992782</span>                <span class="number">1997.831867</span>        <span class="number">2181.288914</span></span><br><span class="line">std                <span class="number">4.643456</span>         <span class="number">0.051598</span>    <span class="number">62.275067</span>                   <span class="number">8.371760</span>        <span class="number">1706.499616</span></span><br><span class="line"><span class="built_in">min</span>                <span class="number">4.555000</span>         <span class="number">0.000000</span>    <span class="number">31.290000</span>                <span class="number">1985.000000</span>          <span class="number">33.290000</span></span><br><span class="line"><span class="number">25</span>%                <span class="number">8.773750</span>         <span class="number">0.026989</span>    <span class="number">93.826500</span>                <span class="number">1987.000000</span>         <span class="number">834.247400</span></span><br><span class="line"><span class="number">50</span>%               <span class="number">12.600000</span>         <span class="number">0.053931</span>   <span class="number">143.012800</span>                <span class="number">1999.000000</span>        <span class="number">1794.331000</span></span><br><span class="line"><span class="number">75</span>%               <span class="number">16.850000</span>         <span class="number">0.094585</span>   <span class="number">185.643700</span>                <span class="number">2004.000000</span>        <span class="number">3101.296400</span></span><br><span class="line"><span class="built_in">max</span>               <span class="number">21.350000</span>         <span class="number">0.328391</span>   <span class="number">266.888400</span>                <span class="number">2009.000000</span>       <span class="number">13086.964800</span></span><br><span class="line">jicha             <span class="number">16.795000</span>         <span class="number">0.328391</span>   <span class="number">235.598400</span>                  <span class="number">24.000000</span>       <span class="number">13053.674800</span></span><br><span class="line">bianyixishu        <span class="number">0.361144</span>         <span class="number">0.780224</span>     <span class="number">0.441690</span>                   <span class="number">0.004190</span>           <span class="number">0.782335</span></span><br><span class="line">sifenweijianju     <span class="number">8.076250</span>         <span class="number">0.067596</span>    <span class="number">91.817200</span>                  <span class="number">17.000000</span>        <span class="number">2267.049000</span></span><br><span class="line"></span><br><span class="line">输出每个列丢失值也即值为NaN的数据和，并从多到少排序：</span><br><span class="line">                           Total   Percent</span><br><span class="line">Outlet_Size                 <span class="number">2410</span>  <span class="number">0.282764</span></span><br><span class="line">Item_Weight                 <span class="number">1463</span>  <span class="number">0.171653</span></span><br><span class="line">Item_Outlet_Sales              <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Outlet_Type                    <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Outlet_Location_Type           <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Outlet_Establishment_Year      <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Outlet_Identifier              <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_MRP                       <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_Type                      <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_Visibility                <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_Fat_Content               <span class="number">0</span>  <span class="number">0.000000</span></span><br><span class="line">Item_Identifier                <span class="number">0</span>  <span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
<p>从以上信息我们可初步了解到”Train_UWu5bXk.csv”文件中的数据的规模为：8523x12。且可看出在12列属性中有些列的数据有缺失如：’产品重量Item_Weight’列（7060，缺失1463, 占17.2%）和’商店覆盖面积Outlet_Size’列（6113，缺失2410, 占28.3%）。对于数据的分布情况，从中可看出：</p>
<ul>
<li>产品重量’Item_Weight’变量：值集为4.555～21.35，均值为：12.857645，方差为4.643456，变异系数为0.361144，四分位间距为8.076250，说明分布较为均匀但数据较分散，存在缺失项（占17.2%）。</li>
<li>分配给特定产品的商店中所有产品的总显示区域的百分比’Item_Visibility’变量：值集为0～0.328391,均值为0.066132，方差为0.051598，变异系数为0.780224，四分位间距为0.067596，说明数据较为集中在平均值附近，数据较为紧凑，无缺项。</li>
<li>产品的最大零售价’Item_MRP’变量：值集为31.29～266.8884，均值为140.992782，方差为62.275067，变异系数为0.441690，四分位间距为91.817200，数据较分散，无缺项。</li>
<li>商店开店年份’Outlet_Establishment_Year’变量：值集为1985～2009，均值为1997.831867，方差为8.371760，变异系数为0.004190，四分位间距为17，数据较紧凑，且无缺项。</li>
<li>在特定商店销售产品’Item_Outlet_Sales’(这是要预测的结果变量)</li>
</ul>
<h1 id="4-数据清洗"><a href="#4-数据清洗" class="headerlink" title="4. 数据清洗"></a>4. 数据清洗</h1><h2 id="4-1-缺失值处理"><a href="#4-1-缺失值处理" class="headerlink" title="4.1. 缺失值处理"></a>4.1. 缺失值处理</h2><p><strong>判断缺失值的分布情况：</strong><br>从上一步粗略查看已知’产品重量Item_Weight’、’商店覆盖面积utlet_Size’两列的数据有缺失。而缺失值处理常用的方法有以下几种：1.直接删除、2.使用一个全局常量填充、3.使用均值或中位数代替、4.插补法（包括：随机插补法、多重插补法、热平台插补、拉格朗日差值法和牛顿插值法）、5.建模法。</p>
<ul>
<li>由数据粗略查看知,’Item_Weight’分布较为均匀但数据较分散,存在缺失项,故决定缺失内容采用均值填补</li>
<li>对于商店覆盖面积’Outlet_Size’变量：为有限个字符串变量，故对缺失内容采用出现次数最多的值填补<br>代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用平均数填补 Item_Weight</span></span><br><span class="line">Item_Weight_mean = data[<span class="string">&#x27;Item_Weight&#x27;</span>].mean() <span class="comment">#计算&#x27;Item_Weight&#x27;平均值</span></span><br><span class="line">data[<span class="string">&#x27;Item_Weight&#x27;</span>] = data[<span class="string">&#x27;Item_Weight&#x27;</span>].fillna(Item_Weight_mean) <span class="comment">#用&#x27;Item_Weight&#x27;平均值填充缺失值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用出现次数最多的值填补 utlet_Size</span></span><br><span class="line">utlet_Size_mode = data[<span class="string">&#x27;utlet_Size&#x27;</span>].mode() <span class="comment">#获取&#x27;utlet_Size&#x27;众数</span></span><br><span class="line">data[<span class="string">&#x27;utlet_Size&#x27;</span>] = data[<span class="string">&#x27;utlet_Size&#x27;</span>].fillna(utlet_Size_mode[<span class="number">0</span>]) <span class="comment">#用&#x27;utlet_Size&#x27;出现最多的值填充缺失值</span></span><br></pre></td></tr></table></figure>
对于此Train_UWu5bXk.csv数据，执行上放代码后会用’Item_Weight’平均值12.857645184135976填充’Item_Weight’缺失值，用’utlet_Size’出现最多的值’Medium’填充缺失值。</li>
</ul>
<h1 id="5-异常值处理"><a href="#5-异常值处理" class="headerlink" title="5. 异常值处理"></a>5. 异常值处理</h1><p>调用matplotlib库将各个数据可视化（python中的pyplot），观察异常值</p>
<h2 id="5-1-产品重量’Item-Weight’"><a href="#5-1-产品重量’Item-Weight’" class="headerlink" title="5.1. 产品重量’Item_Weight’"></a>5.1. 产品重量’Item_Weight’</h2><p>打印’Item_Weight’数据分布散点图代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Plot Item_Weight</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_Weight&#x27;</span>])))</span><br><span class="line">y_Item_Weight = data[<span class="string">&#x27;Item_Weight&#x27;</span>]</span><br><span class="line">plt.scatter(x, y_Item_Weight, s=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#设置标题并加上轴标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Item_Weight&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置每个坐标的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_Weight&#x27;</span>]), <span class="built_in">min</span>(data[<span class="string">&#x27;Item_Weight&#x27;</span>]), <span class="built_in">max</span>(data[<span class="string">&#x27;Item_Weight&#x27;</span>])])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DataPreprocess_Item_Weight.png" alt="&#39;Item_Weight&#39;数据分布散点图"></p>
<p>从图中可看出’Item_Weight’分布较为均匀（5.5～21之间），未发现异常值</p>
<h2 id="5-2-分配给特定产品的商店中所有产品的总显示区域的百分比’Item-Visibility’"><a href="#5-2-分配给特定产品的商店中所有产品的总显示区域的百分比’Item-Visibility’" class="headerlink" title="5.2. 分配给特定产品的商店中所有产品的总显示区域的百分比’Item_Visibility’"></a>5.2. 分配给特定产品的商店中所有产品的总显示区域的百分比’Item_Visibility’</h2><p>打印’Item_Visibility’数据分布散点图代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Plot Item_Visibility</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_Visibility&#x27;</span>])))</span><br><span class="line">y_Item_Visibility = data[<span class="string">&#x27;Item_Visibility&#x27;</span>]</span><br><span class="line">plt.scatter(x, y_Item_Visibility, s=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#设置标题并加上轴标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Item_Visibility&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置每个坐标的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_Visibility&#x27;</span>]), <span class="built_in">min</span>(data[<span class="string">&#x27;Item_Visibility&#x27;</span>]), <span class="built_in">max</span>(data[<span class="string">&#x27;Item_Visibility&#x27;</span>])])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DataPreprocess_Item_Visibility.png" alt="&#39;Item_Visibility&#39;数据分布散点图"></p>
<p>从图中可看出’Item_Visibility’分布主要集中于0～0.2区间内，分布随着值增加逐渐稀疏，未发现异常值</p>
<h2 id="5-3-产品的最大零售价’Item-MRP’"><a href="#5-3-产品的最大零售价’Item-MRP’" class="headerlink" title="5.3. 产品的最大零售价’Item_MRP’"></a>5.3. 产品的最大零售价’Item_MRP’</h2><p>打印’Item_MRP’数据分布散点图代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Plot Item_MRP</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_MRP&#x27;</span>])))</span><br><span class="line">y_Item_MRP = data[<span class="string">&#x27;Item_MRP&#x27;</span>]</span><br><span class="line">plt.scatter(x, y_Item_MRP, s=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#设置标题并加上轴标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Item_MRP&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">    <span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置每个坐标的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Item_MRP&#x27;</span>]), <span class="built_in">min</span>(data[<span class="string">&#x27;Item_MRP&#x27;</span>]), <span class="built_in">max</span>(data[<span class="string">&#x27;Item_MRP&#x27;</span>])])</span><br><span class="line">plt.psd(y_Item_MRP, <span class="number">10</span>, <span class="number">10</span>) <span class="comment">#Draw Grid</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DataPreprocess_Item_MRP.png" alt="&#39;Item_MRP&#39;数据分布散点图"></p>
<p>从图中可看出’Item_MRP’分布较为阶梯型分布，大致可分为4段(31<del>70, 70</del>135, 135~200, &gt;200)，未发现异常值</p>
<h3 id="5-3-1-商店成立年份’Outlet-Establishment-Year’"><a href="#5-3-1-商店成立年份’Outlet-Establishment-Year’" class="headerlink" title="5.3.1. 商店成立年份’Outlet_Establishment_Year’"></a>5.3.1. 商店成立年份’Outlet_Establishment_Year’</h3><p>打印’Outlet_Establishment_Year’数据分布散点图代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Plot Outlet_Establishment_Year</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>])))</span><br><span class="line">y_Outlet_Establishment_Year = data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>]</span><br><span class="line">plt.scatter(x, y_Outlet_Establishment_Year, s=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#设置标题并加上轴标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Outlet_Establishment_Year&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">    <span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置每个坐标的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="built_in">len</span>(data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>]), <span class="built_in">min</span>(data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>]), <span class="built_in">max</span>(data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>])])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DataPreprocess_Outlet_Establishment_Year.png" alt="&#39;Outlet_Establishment_Year&#39;数据分布散点图"></p>
<p>从图中可看出’Outlet_Establishment_Year’值集仅有有限几个，值集为1985～2009，未发现异常值</p>
<h1 id="6-数据转换"><a href="#6-数据转换" class="headerlink" title="6. 数据转换"></a>6. 数据转换</h1><p>将数据中字符串数据映射为数字</p>
<h2 id="6-1-产品是否低脂肪’Item-Fat-Content’"><a href="#6-1-产品是否低脂肪’Item-Fat-Content’" class="headerlink" title="6.1. 产品是否低脂肪’Item_Fat_Content’"></a>6.1. 产品是否低脂肪’Item_Fat_Content’</h2><p>打印’Item_Fat_Content’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Item_Fat_Content’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Low Fat    5089</span><br><span class="line">Regular    2889</span><br><span class="line">LF          316</span><br><span class="line">reg         117</span><br><span class="line">low fat     112</span><br></pre></td></tr></table></figure>
<p>以下代码将’Item_Fat_Content’的字符串值:’Low Fat’,’LF’,’low fat’映射成数字2; 将字符串值:’Regular’, ‘reg’映射成数字1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Item_Fat_Content</span></span><br><span class="line">Item_Fat_Content_mapping = &#123;<span class="string">&#x27;Regular&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;reg&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;Low Fat&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;LF&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;low fat&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>] = data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].<span class="built_in">map</span>(Item_Fat_Content_mapping)</span><br><span class="line">data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>] = data[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-2-产品所属的类别-‘Item-Type’"><a href="#6-2-产品所属的类别-‘Item-Type’" class="headerlink" title="6.2. 产品所属的类别 ‘Item_Type’"></a>6.2. 产品所属的类别 ‘Item_Type’</h2><p>打印’Item_Type’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data[<span class="string">&#x27;Item_Type&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Item_Type’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fruits and Vegetables    1232</span><br><span class="line">Snack Foods              1200</span><br><span class="line">Household                 910</span><br><span class="line">Frozen Foods              856</span><br><span class="line">Dairy                     682</span><br><span class="line">Canned                    649</span><br><span class="line">Baking Goods              648</span><br><span class="line">Health and Hygiene        520</span><br><span class="line">Soft Drinks               445</span><br><span class="line">Meat                      425</span><br><span class="line">Breads                    251</span><br><span class="line">Hard Drinks               214</span><br><span class="line">Others                    169</span><br><span class="line">Starchy Foods             148</span><br><span class="line">Breakfast                 110</span><br><span class="line">Seafood                    64</span><br></pre></td></tr></table></figure>
<p>以下代码将’Item_Type’按照出现字符串次数，正序将字符串映射成数字1～16。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Item_Type</span></span><br><span class="line">Item_Type_mapping = &#123;<span class="string">&#x27;Seafood&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>),</span><br><span class="line">                     <span class="string">&#x27;Breakfast&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>),</span><br><span class="line">                     <span class="string">&#x27;Starchy Foods&#x27;</span>:<span class="built_in">int</span>(<span class="number">3</span>),</span><br><span class="line">                     <span class="string">&#x27;Others&#x27;</span>:<span class="built_in">int</span>(<span class="number">4</span>),</span><br><span class="line">                     <span class="string">&#x27;Hard Drinks&#x27;</span>:<span class="built_in">int</span>(<span class="number">5</span>),</span><br><span class="line">                     <span class="string">&#x27;Breads&#x27;</span>:<span class="built_in">int</span>(<span class="number">6</span>),</span><br><span class="line">                     <span class="string">&#x27;Meat&#x27;</span>:<span class="built_in">int</span>(<span class="number">7</span>),</span><br><span class="line">                     <span class="string">&#x27;Soft Drinks&#x27;</span>:<span class="built_in">int</span>(<span class="number">8</span>),</span><br><span class="line">                     <span class="string">&#x27;Health and Hygiene&#x27;</span>:<span class="built_in">int</span>(<span class="number">9</span>),</span><br><span class="line">                     <span class="string">&#x27;Baking Goods&#x27;</span>:<span class="built_in">int</span>(<span class="number">10</span>),</span><br><span class="line">                     <span class="string">&#x27;Canned&#x27;</span>:<span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">                     <span class="string">&#x27;Dairy&#x27;</span>:<span class="built_in">int</span>(<span class="number">12</span>),</span><br><span class="line">                     <span class="string">&#x27;Frozen Foods&#x27;</span>:<span class="built_in">int</span>(<span class="number">13</span>),</span><br><span class="line">                     <span class="string">&#x27;Household&#x27;</span>:<span class="built_in">int</span>(<span class="number">14</span>),</span><br><span class="line">                     <span class="string">&#x27;Snack Foods&#x27;</span>:<span class="built_in">int</span>(<span class="number">15</span>),</span><br><span class="line">                     <span class="string">&#x27;Fruits and Vegetables&#x27;</span>:<span class="built_in">int</span>(<span class="number">16</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Item_Type&#x27;</span>] = data[<span class="string">&#x27;Item_Type&#x27;</span>].<span class="built_in">map</span>(Item_Type_mapping)</span><br><span class="line">data[<span class="string">&#x27;Item_Type&#x27;</span>] = data[<span class="string">&#x27;Item_Type&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-3-唯一商店ID-‘Outlet-Identifier’"><a href="#6-3-唯一商店ID-‘Outlet-Identifier’" class="headerlink" title="6.3. 唯一商店ID ‘Outlet_Identifier’"></a>6.3. 唯一商店ID ‘Outlet_Identifier’</h2><p>打印’Outlet_Identifier’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data[<span class="string">&#x27;Outlet_Identifier&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Outlet_Identifier’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OUT027    935</span><br><span class="line">OUT013    932</span><br><span class="line">OUT035    930</span><br><span class="line">OUT046    930</span><br><span class="line">OUT049    930</span><br><span class="line">OUT045    929</span><br><span class="line">OUT018    928</span><br><span class="line">OUT017    926</span><br><span class="line">OUT010    555</span><br><span class="line">OUT019    528</span><br></pre></td></tr></table></figure>
<p>以下代码将’Outlet_Identifier’值的字符串中提取数字，并覆盖原先str变量为int。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义函数清理数据:去除&#x27;OUT&#x27;并将剩余str转换为数字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_currency</span>(<span class="params">var</span>):</span></span><br><span class="line">    new_value = var.replace(<span class="string">&#x27;OUT&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">#new_value = var[3:6]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(new_value)</span><br><span class="line"></span><br><span class="line">data[<span class="string">&#x27;Outlet_Identifier&#x27;</span>] = data[<span class="string">&#x27;Outlet_Identifier&#x27;</span>].apply(convert_currency)</span><br></pre></td></tr></table></figure>
<p>转换后数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27    935</span><br><span class="line">13    932</span><br><span class="line">46    930</span><br><span class="line">35    930</span><br><span class="line">49    930</span><br><span class="line">45    929</span><br><span class="line">18    928</span><br><span class="line">17    926</span><br><span class="line">10    555</span><br><span class="line">19    528</span><br><span class="line">Name: Outlet_Identifier, dtype: int64</span><br></pre></td></tr></table></figure>

<h2 id="6-4-商店的面积覆盖面积-‘Outlet-Size’"><a href="#6-4-商店的面积覆盖面积-‘Outlet-Size’" class="headerlink" title="6.4. 商店的面积覆盖面积 ‘Outlet_Size’"></a>6.4. 商店的面积覆盖面积 ‘Outlet_Size’</h2><p>打印’Outlet_Size’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data[<span class="string">&#x27;Outlet_Size&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Outlet_Size’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Medium    5203</span><br><span class="line">Small     2388</span><br><span class="line">High       932</span><br></pre></td></tr></table></figure>
<p>以下代码将’Outlet_Size’的字符串值:’Small’映射成数字1; ‘Medium’映射成数字2; 将字符串值:’High’映射成数字3。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Outlet_Size</span></span><br><span class="line">Outlet_Size_mapping = &#123;<span class="string">&#x27;Small&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;Medium&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;High&#x27;</span>:<span class="built_in">int</span>(<span class="number">3</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Outlet_Size&#x27;</span>] = data[<span class="string">&#x27;Outlet_Size&#x27;</span>].<span class="built_in">map</span>(Outlet_Size_mapping)</span><br><span class="line">data[<span class="string">&#x27;Outlet_Size&#x27;</span>] = data[<span class="string">&#x27;Outlet_Size&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-5-商店所在的城市类型-‘Outlet-Location-Type’"><a href="#6-5-商店所在的城市类型-‘Outlet-Location-Type’" class="headerlink" title="6.5. 商店所在的城市类型 ‘Outlet_Location_Type’"></a>6.5. 商店所在的城市类型 ‘Outlet_Location_Type’</h2><p>打印’Outlet_Location_Type’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Outlet_Location_Type’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tier 3    3350</span><br><span class="line">Tier 2    2785</span><br><span class="line">Tier 1    2388</span><br></pre></td></tr></table></figure>
<p>以下代码将’Outlet_Location_Type’的字符串值:’Tier 1’映射成数字1; ‘Tier 2’映射成数字2; 将字符串值:’Tier 3’映射成数字3。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Outlet_Location_Type</span></span><br><span class="line">Outlet_Location_Type_mapping = &#123;<span class="string">&#x27;Tier 1&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;Tier 2&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;Tier 3&#x27;</span>:<span class="built_in">int</span>(<span class="number">3</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>] = data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>].<span class="built_in">map</span>(Outlet_Location_Type_mapping)</span><br><span class="line">data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>] = data[<span class="string">&#x27;Outlet_Location_Type&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-6-出口是一家杂货店还是某种超市-‘Outlet-Type’"><a href="#6-6-出口是一家杂货店还是某种超市-‘Outlet-Type’" class="headerlink" title="6.6. 出口是一家杂货店还是某种超市 ‘Outlet_Type’"></a>6.6. 出口是一家杂货店还是某种超市 ‘Outlet_Type’</h2><p>打印’Outlet_Type’数据情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data[<span class="string">&#x27;Outlet_Type&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>
<p>显示’Outlet_Type’数据情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Supermarket Type1    5577</span><br><span class="line">Grocery Store        1083</span><br><span class="line">Supermarket Type3     935</span><br><span class="line">Supermarket Type2     928</span><br></pre></td></tr></table></figure>
<p>以下代码将’Outlet_Type’的字符串值:’Supermarket Type1’映射成数字1; ‘Supermarket Type2’映射成数字2; ‘Supermarket Type3’映射成数字3; ‘Grocery Store’映射成数字4。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Outlet_Type</span></span><br><span class="line">Outlet_Type_mapping = &#123;<span class="string">&#x27;Supermarket Type1&#x27;</span>:<span class="built_in">int</span>(<span class="number">1</span>), <span class="string">&#x27;Supermarket Type2&#x27;</span>:<span class="built_in">int</span>(<span class="number">2</span>), <span class="string">&#x27;Supermarket Type3&#x27;</span>:<span class="built_in">int</span>(<span class="number">3</span>), <span class="string">&#x27;Grocery Store&#x27;</span>:<span class="built_in">int</span>(<span class="number">4</span>)&#125;</span><br><span class="line">data[<span class="string">&#x27;Outlet_Type&#x27;</span>] = data[<span class="string">&#x27;Outlet_Type&#x27;</span>].<span class="built_in">map</span>(Outlet_Type_mapping)</span><br><span class="line">data[<span class="string">&#x27;Outlet_Type&#x27;</span>] = data[<span class="string">&#x27;Outlet_Type&#x27;</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h1 id="7-数据归一化"><a href="#7-数据归一化" class="headerlink" title="7. 数据归一化"></a>7. 数据归一化</h1><h2 id="7-1-产品重量’Item-Weight’"><a href="#7-1-产品重量’Item-Weight’" class="headerlink" title="7.1. 产品重量’Item_Weight’"></a>7.1. 产品重量’Item_Weight’</h2><p>由前几步可看出’Item_Weight’分布较为均匀（5.5～21之间），故规范化时采用最小-最大规范化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Item_Weight_min = data[<span class="string">&#x27;Item_Weight&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Item_Weight_max = data[<span class="string">&#x27;Item_Weight&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Item_Weight&#x27;</span>] = (data[<span class="string">&#x27;Item_Weight&#x27;</span>] - Item_Weight_min) / (Item_Weight_max - Item_Weight_min)</span><br></pre></td></tr></table></figure>
<p>类似的适合数据归一化的还有:’Item_Visibility’, ‘Item_MRP’, ‘Outlet_Establishment_Year’, ‘Outlet_Size’,将这些变量也进行归一化处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 分配给特定产品的商店中所有产品的总显示区域的百分比&#x27;Item_Visibility&#x27;</span></span><br><span class="line">Item_Visibility_min = data[<span class="string">&#x27;Item_Visibility&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Item_Visibility_max = data[<span class="string">&#x27;Item_Visibility&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Item_Visibility&#x27;</span>] = (data[<span class="string">&#x27;Item_Visibility&#x27;</span>] - Item_Visibility_min) / (Item_Visibility_max - Item_Visibility_min)</span><br><span class="line"><span class="comment">## 产品的最大零售价 &#x27;Item_MRP&#x27;</span></span><br><span class="line">Item_MRP_min = data[<span class="string">&#x27;Item_MRP&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Item_MRP_max = data[<span class="string">&#x27;Item_MRP&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Item_MRP&#x27;</span>] = (data[<span class="string">&#x27;Item_MRP&#x27;</span>] - Item_MRP_min) / (Item_MRP_max - Item_MRP_min)</span><br><span class="line"><span class="comment">## 商店成立的年份 &#x27;Outlet_Establishment_Year&#x27;</span></span><br><span class="line">Outlet_Establishment_Year_min = data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Outlet_Establishment_Year_max = data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>] = (data[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>] - Outlet_Establishment_Year_min) / (Outlet_Establishment_Year_max - Outlet_Establishment_Year_min)</span><br><span class="line"><span class="comment">## 商店的面积覆盖面积 &#x27;Outlet_Size&#x27;</span></span><br><span class="line">Outlet_Size_min = data[<span class="string">&#x27;Outlet_Size&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">Outlet_Size_max = data[<span class="string">&#x27;Outlet_Size&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">data[<span class="string">&#x27;Outlet_Size&#x27;</span>] = (data[<span class="string">&#x27;Outlet_Size&#x27;</span>] - Outlet_Size_min) / (Outlet_Size_max - Outlet_Size_min)</span><br></pre></td></tr></table></figure>
<p>数据预处理后如下：</p>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_DataPreprocess_Output_Train_afterProprecess.png" alt="“Train_UWu5bXk.csv”文件中的Bigmart销售数据预处理后"></p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待处理文件</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Test_u94Q5KV.csv">Test_u94Q5KV.csv</a>、<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Train_UWu5bXk.csv">Train_UWu5bXk.csv</a><br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/datapreprocess.py">datapreprocess.py</a></p>
</div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>ID3算法——数据挖掘</title>
    <url>/2018/11/16/DataMining_ID3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_ID3.png" class="full-image" />

<h1 id="1-ID3算法简介"><a href="#1-ID3算法简介" class="headerlink" title="1. ID3算法简介"></a>1. ID3算法简介</h1><ul>
<li>ID3算法最早是由罗斯昆（J.Ross Quinlan）于1975年在悉尼大学提出的一种分类预测算法，算法的核心是“信息熵（Information entropy）”。</li>
<li>ID3算法通过计算每个属性的信息增益，认为信息增益高的是好属性，每次划分选取信息增益最高的属性为划分标准，重复这个过程，直至生成一个能完美分类训练样例的决策树。</li>
</ul>
<a id="more"></a>

<h1 id="2-Python编程实现ID3决策树建立算法"><a href="#2-Python编程实现ID3决策树建立算法" class="headerlink" title="2. Python编程实现ID3决策树建立算法"></a>2. Python编程实现ID3决策树建立算法</h1><p><strong>ID3决策树建立算法步骤</strong>：</p>
<ul>
<li>S1.决定分类属性；</li>
<li>S2.对目前的数据表，建立一个节点N</li>
<li>S3.如果数据库中的数据都属于同一个类，N就是树叶，在树叶上标出所属的类</li>
<li>S4.如果数据表中没有其他属性可以考虑，则N也是树叶，按照少数服从多数的原则在树叶上标出所属类别</li>
<li>S5.否则，根据平均信息期望值E或GAIN值选出一个最佳属性作为节点N的测试属性</li>
<li>S6.节点属性选定后，对于该属性中的每个值：从N生成一个分支，并将数据表中与该分支有关的数据收集形成分支节点的数据表，在表中删除节点属性那一栏如果分支数据表非空，则运用以上算法从该节点建立子树。</li>
</ul>
<h2 id="2-1-计算样本的信息期望"><a href="#2-1-计算样本的信息期望" class="headerlink" title="2.1. 计算样本的信息期望"></a>2.1. 计算样本的信息期望</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算样本的信息期望</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcH</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    numOfRow = <span class="built_in">len</span>(dataSet) <span class="comment">#得到行数，数据量个数</span></span><br><span class="line">    <span class="comment">#为所有的分类类目创建字典</span></span><br><span class="line">    <span class="comment"># labelCounts： 表示最后一列的字典统计信息(属性值种类及个数)</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> iRow <span class="keyword">in</span> dataSet:</span><br><span class="line">        currentLable = iRow[-<span class="number">1</span>] <span class="comment">#取得当前行最后一列数据（决策属性值）</span></span><br><span class="line">        <span class="keyword">if</span> currentLable <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): <span class="comment">#如果不在字典中，则添加到字典中</span></span><br><span class="line">            labelCounts[currentLable] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLable] += <span class="number">1</span> <span class="comment">#如果在字典中，则对应的key计数+1</span></span><br><span class="line">    <span class="comment">#计算给定样本所需的数学期望信息（香农熵）</span></span><br><span class="line">    H = <span class="number">0.0</span> <span class="comment">#测试样本的信息期望</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = <span class="built_in">float</span>(labelCounts[key]) / numOfRow <span class="comment">#即p(t)</span></span><br><span class="line">        H -= prob * math.log(prob, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> H <span class="comment">#返回样本的信息期望</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-根据第-i-列属性值A划分子集"><a href="#2-2-根据第-i-列属性值A划分子集" class="headerlink" title="2.2. 根据第 i 列属性值A划分子集"></a>2.2. 根据第 i 列属性值A划分子集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#得到根据第 i 列属性值A划分成的子集</span></span><br><span class="line"><span class="comment">#输入三个变量（待划分的数据集，特征，分类值）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span></span><br><span class="line">    retDataSet = [] <span class="comment">#表示由当第 i 列属性值A划分成的子集</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reduceFeatVec = featVec[:axis]</span><br><span class="line">            reduceFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reduceFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet <span class="comment">#表示由当第 i 列属性值A划分成的子集（不含划分特征A）</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-得到最大信息增益条件属性列下标"><a href="#2-3-得到最大信息增益条件属性列下标" class="headerlink" title="2.3. 得到最大信息增益条件属性列下标"></a>2.3. 得到最大信息增益条件属性列下标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    numOfFeature = <span class="built_in">len</span>(dataSet[<span class="number">0</span>])-<span class="number">1</span>  <span class="comment">#条件属性值个数</span></span><br><span class="line">    H = calcH(dataSet)<span class="comment">#返回样本的信息期望</span></span><br><span class="line">    bestInforGain = <span class="number">0</span> <span class="comment">#最大信息增益值，初始化为0</span></span><br><span class="line">    bestFeature = -<span class="number">1</span> <span class="comment">##最大信息增益值对应的条件属性列，，初始化为 -1</span></span><br><span class="line">    <span class="comment">#分别计算每一个条件属性的熵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numOfFeature):</span><br><span class="line">        <span class="comment"># featList 表示第 i 列的所有值</span></span><br><span class="line">        featList = [number[i] <span class="keyword">for</span> number <span class="keyword">in</span> dataSet] <span class="comment">#得到某个特征下所有值（某列）</span></span><br><span class="line">        <span class="comment"># uniqualVals 表示当前第 i 列的条件属性内的属性值的列表</span></span><br><span class="line">        uniqualVals = <span class="built_in">set</span>(featList) <span class="comment">#set无重复的属性特征值</span></span><br><span class="line">        <span class="comment"># E_A：表示由属性 A 划分子集的熵或平均期望</span></span><br><span class="line">        E_A = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqualVals:</span><br><span class="line">            <span class="comment"># subDataSet： 表示由当第 i 列属性值A划分成的子集</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            prob = <span class="built_in">float</span>(<span class="built_in">len</span>(subDataSet)) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet)) <span class="comment">#即p(t)</span></span><br><span class="line">            E_A += prob * calcH(subDataSet)<span class="comment">#对各子集香农熵求和</span></span><br><span class="line">        Gain_A = H - E_A <span class="comment">#计算条件属性 第 i 列 的信息增益</span></span><br><span class="line">        <span class="comment"># 从所有条件属性对应的信息增益中挑选最大信息增益（的列下标）</span></span><br><span class="line">        <span class="keyword">if</span> (Gain_A &gt; bestInforGain):</span><br><span class="line">            bestInforGain = Gain_A</span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature <span class="comment">#返回特征值（最佳分类列下标）</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-建立ID3决策树核心函数"><a href="#2-4-建立ID3决策树核心函数" class="headerlink" title="2.4. 建立ID3决策树核心函数"></a>2.4. 建立ID3决策树核心函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 决策树构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span>(<span class="params">dataSet, labels</span>):</span></span><br><span class="line">    classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment">#如果类别相同，停止划分</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[-<span class="number">1</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#长度为1，返回出现次数最多的类别</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(classList[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    <span class="comment">#按照信息增益最高选取分类特征属性</span></span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)<span class="comment">#返回分类的特征序号</span></span><br><span class="line">    bestFeatLable = labels[bestFeat] <span class="comment">#该特征的label</span></span><br><span class="line">    myTree = &#123;bestFeatLable:&#123;&#125;&#125; <span class="comment">#构建树的字典</span></span><br><span class="line">    <span class="keyword">del</span>(labels[bestFeat]) <span class="comment">#从labels的list中删除该label</span></span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = <span class="built_in">set</span>(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subLables = labels[:] <span class="comment">#子集合</span></span><br><span class="line">        <span class="comment">#构建数据的子集合，并进行递归</span></span><br><span class="line">        myTree[bestFeatLable][value] = createTree(splitDataSet(dataSet,bestFeat,value),subLables)</span><br><span class="line">    <span class="keyword">return</span> myTree <span class="comment"># 最后生成的决策树myTree是一个多层嵌套的字典</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-使用Matplotlib绘制决策树"><a href="#2-5-使用Matplotlib绘制决策树" class="headerlink" title="2.5. 使用Matplotlib绘制决策树"></a>2.5. 使用Matplotlib绘制决策树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==================使用Matplotlib绘制决策树============================</span></span><br><span class="line">decisionNode = <span class="built_in">dict</span>(boxstyle=<span class="string">&quot;square&quot;</span>, ec=<span class="string">&#x27;k&#x27;</span>, fc=<span class="string">&#x27;yellow&#x27;</span>,)<span class="comment">#决策点样式</span></span><br><span class="line">leafNode = <span class="built_in">dict</span>(boxstyle=<span class="string">&quot;round&quot;</span>, ec=(<span class="number">1.</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), fc=(<span class="number">1.</span>, <span class="number">0.8</span>, <span class="number">0.8</span>),)<span class="comment">#叶节点样式</span></span><br><span class="line">arrow_args = <span class="built_in">dict</span>(arrowstyle=<span class="string">&#x27;&lt;-&#x27;</span>) <span class="comment">#箭头样式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotNode</span>(<span class="params">nodeTxt, centerPt, parentPt, nodeType</span>):</span></span><br><span class="line">    createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=<span class="string">&#x27;axes fraction&#x27;</span>,</span><br><span class="line">                            xytext=centerPt, textcoords=<span class="string">&#x27;axes fraction&#x27;</span>,</span><br><span class="line">                            va=<span class="string">&#x27;center&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, bbox=nodeType, arrowprops=arrow_args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span>():</span></span><br><span class="line">    fig=plt.figure(<span class="number">1</span>,facecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.clf()</span><br><span class="line">    createPlot.ax1=plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">    plotNode(<span class="string">&#x27;决策节点&#x27;</span>, (<span class="number">0.5</span>,<span class="number">0.1</span>), (<span class="number">0.1</span>,<span class="number">0.5</span>), decisionNode)</span><br><span class="line">    plotNode(<span class="string">&#x27;叶节点&#x27;</span>, (<span class="number">0.8</span>,<span class="number">0.1</span>), (<span class="number">0.3</span>,<span class="number">0.8</span>), leafNode)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取叶节点数量（广度）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumLeafs</span>(<span class="params">myTree</span>):</span></span><br><span class="line">    numLeafs=<span class="number">0</span></span><br><span class="line">    firstStr=<span class="built_in">list</span>(myTree.keys())[<span class="number">0</span>]<span class="comment">#&#x27;dict_keys&#x27; object does not support indexing</span></span><br><span class="line">    secondDict=myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__==<span class="string">&#x27;dict&#x27;</span>:</span><br><span class="line">            numLeafs+=getNumLeafs(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>:numLeafs+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取树的深度的函数（深度）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTreeDepth</span>(<span class="params">myTree</span>):</span></span><br><span class="line">    maxDepth=<span class="number">0</span></span><br><span class="line">    firstStr=<span class="built_in">list</span>(myTree.keys())[<span class="number">0</span>]</span><br><span class="line">    secondDict=myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__==<span class="string">&#x27;dict&#x27;</span>:</span><br><span class="line">            thisDepth=<span class="number">1</span>+getTreeDepth(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>: thisDepth=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> thisDepth &gt; maxDepth:</span><br><span class="line">            maxDepth=thisDepth</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义在父子节点之间填充文本信息的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMidText</span>(<span class="params">cntrPt,parentPt,txtString</span>):</span></span><br><span class="line">    xMid=(parentPt[<span class="number">0</span>]-cntrPt[<span class="number">0</span>])/<span class="number">2</span>+cntrPt[<span class="number">0</span>]</span><br><span class="line">    yMid=(parentPt[<span class="number">1</span>]-cntrPt[<span class="number">1</span>])/<span class="number">2</span>+cntrPt[<span class="number">1</span>]</span><br><span class="line">    createPlot.ax1.text(xMid,yMid,txtString)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义树绘制的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTree</span>(<span class="params">myTree, parentPt, nodeTxt</span>):</span></span><br><span class="line">    numLeafs=getNumLeafs(myTree)</span><br><span class="line">    depth=getTreeDepth(myTree)</span><br><span class="line">    firstStr=<span class="built_in">list</span>(myTree.keys())[<span class="number">0</span>]</span><br><span class="line">    cntrPt=(plotTree.xOff+(<span class="number">1.0</span>+<span class="built_in">float</span>(numLeafs))/<span class="number">2</span>/plotTree.totalW,plotTree.yOff)</span><br><span class="line">    plotMidText(cntrPt, parentPt, nodeTxt)</span><br><span class="line">    plotNode(firstStr, cntrPt, parentPt, decisionNode)</span><br><span class="line">    secondDict=myTree[firstStr]</span><br><span class="line">    plotTree.yOff=plotTree.yOff -<span class="number">1</span>/plotTree.totalD</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[key]).__name__==<span class="string">&#x27;dict&#x27;</span>:</span><br><span class="line">            plotTree(secondDict[key], cntrPt, <span class="built_in">str</span>(key))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plotTree.xOff=plotTree.xOff+<span class="number">1.0</span>/plotTree.totalW</span><br><span class="line">            plotNode(secondDict[key],(plotTree.xOff,plotTree.yOff),cntrPt,leafNode)</span><br><span class="line">            plotMidText((plotTree.xOff,plotTree.yOff),cntrPt,<span class="built_in">str</span>(key))</span><br><span class="line">    plotTree.yOff=plotTree.yOff+<span class="number">1</span>/plotTree.totalD</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示决策树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span>(<span class="params">inTree</span>):</span></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.clf()</span><br><span class="line">    axprops = <span class="built_in">dict</span>(xticks=[], yticks=[])</span><br><span class="line">    createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>, **axprops)</span><br><span class="line">    plotTree.totalW = <span class="built_in">float</span>(getNumLeafs(inTree))</span><br><span class="line">    plotTree.totalD = <span class="built_in">float</span>(getTreeDepth(inTree))</span><br><span class="line">    plotTree.xOff = -<span class="number">0.5</span>/plotTree.totalW; plotTree.yOff = <span class="number">1.0</span>;</span><br><span class="line">    plotTree(inTree, (<span class="number">0.5</span>, <span class="number">1.0</span>), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="2-6-处理得到运动和不运动与天气之间的规则树"><a href="#2-6-处理得到运动和不运动与天气之间的规则树" class="headerlink" title="2.6. 处理得到运动和不运动与天气之间的规则树"></a>2.6. 处理得到运动和不运动与天气之间的规则树</h2><p>数据存放于<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/ID3dataEn.csv">ID3dataEn.csv</a>文件</p>
<figure class="highlight plain"><figcaption><span>文件：ID3dataEn.csv</span></figcaption><table><tr><td class="code"><pre><span class="line">sunny,85,85,unwindy,unsuitable</span><br><span class="line">sunny,80,90,windy,unsuitable</span><br><span class="line">cloudy,83,78,unwindy,suitable</span><br><span class="line">rain,70,96,unwindy,suitable</span><br><span class="line">rain,68,80,unwindy,suitable</span><br><span class="line">rain,65,70,windy,unsuitable</span><br><span class="line">cloudy,64,65,windy,suitable</span><br><span class="line">sunny,72,95,unwindy,unsuitable</span><br><span class="line">sunny,69,70,unwindy,suitable</span><br><span class="line">rain,75,80,unwindy,suitable</span><br><span class="line">sunny,75,70,windy,suitable</span><br><span class="line">cloudy,72,90,windy,suitable</span><br><span class="line">cloudy,81,75,unwindy,suitable</span><br><span class="line">rain,71,80,windy,unsuitable</span><br></pre></td></tr></table></figure>

<h2 id="2-7-加载数据"><a href="#2-7-加载数据" class="headerlink" title="2.7. 加载数据"></a>2.7. 加载数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据文件函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataFile</span>(<span class="params">filename</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;加载&#x27;</span>, filename, <span class="string">&#x27;文件数据...&#x27;</span>)</span><br><span class="line">    fr = <span class="built_in">open</span>(filename)</span><br><span class="line">    data = [inst.strip().split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">dataLabels = [<span class="string">&#x27;weather&#x27;</span>, <span class="string">&#x27;temperature&#x27;</span>, <span class="string">&#x27;humidity&#x27;</span>, <span class="string">&#x27;wind conditions&#x27;</span>, <span class="string">&#x27;exercise&#x27;</span>] <span class="comment">#数据的属性名称</span></span><br><span class="line">data = loadDataFile(<span class="string">&#x27;ID3dataEn.csv&#x27;</span>) <span class="comment">#加载数据文件</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-预处理-温度和湿度-数据"><a href="#2-8-预处理-温度和湿度-数据" class="headerlink" title="2.8. 预处理 温度和湿度 数据"></a>2.8. 预处理 温度和湿度 数据</h2><p>由于温度和湿度数据量过多，故将温度和湿度数据进行整合，将数据取十位整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#预处理 温度和湿度 数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataWrangling</span>(<span class="params">data, iColumn</span>):</span></span><br><span class="line">    <span class="keyword">for</span> iRow <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        num = <span class="built_in">int</span>(data[iRow][iColumn])</span><br><span class="line">        num = num - (num%<span class="number">10</span>)</span><br><span class="line">        data[iRow][iColumn] = <span class="built_in">str</span>(num)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="comment">#预处理 温度和湿度 数据</span></span><br><span class="line">data = dataWrangling(data, <span class="number">1</span>) <span class="comment">#整理 温度数据 取“十位”整数</span></span><br><span class="line">data = dataWrangling(data, <span class="number">2</span>) <span class="comment">#整理 湿度数据 取“十位”整数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-9-主函数"><a href="#2-9-主函数" class="headerlink" title="2.9. 主函数"></a>2.9. 主函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dataLabels = [<span class="string">&#x27;weather&#x27;</span>, <span class="string">&#x27;temperature&#x27;</span>, <span class="string">&#x27;humidity&#x27;</span>, <span class="string">&#x27;wind conditions&#x27;</span>, <span class="string">&#x27;exercise&#x27;</span>] <span class="comment">#数据的属性名称</span></span><br><span class="line">    data = loadDataFile(<span class="string">&#x27;ID3dataEn.csv&#x27;</span>) <span class="comment">#加载数据文件</span></span><br><span class="line">    print(<span class="string">&#x27;预处理前数据：&#x27;</span>, data)</span><br><span class="line">    <span class="comment">#预处理 温度和湿度 数据</span></span><br><span class="line">    data = dataWrangling(data, <span class="number">1</span>) <span class="comment">#整理 温度数据 取十位数</span></span><br><span class="line">    data = dataWrangling(data, <span class="number">2</span>) <span class="comment">#整理 湿度数据 取十位数</span></span><br><span class="line">    print(<span class="string">&#x27;处理后数据：&#x27;</span>, data)</span><br><span class="line">    myTree = createTree(data, dataLabels) <span class="comment">#构造决策树</span></span><br><span class="line">    print(<span class="string">&#x27;决策树构造函数测试&#x27;</span>, myTree)</span><br><span class="line">    createPlot(myTree) <span class="comment">#显示决策树</span></span><br></pre></td></tr></table></figure>

<h2 id="2-10-得到的决策树图如下所示"><a href="#2-10-得到的决策树图如下所示" class="headerlink" title="2.10. 得到的决策树图如下所示"></a>2.10. 得到的决策树图如下所示</h2><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_ID3_Result_myTree.png" alt="myTree决策树图"></p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待分类数据集文件</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/ID3dataEn.csv">ID3dataEn.csv</a><br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/ID3.py">ID3.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘简介与发展动向</title>
    <url>/2018/09/27/DataMining_Introduction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Introduction.jpg" class="full-image" />

<blockquote class="blockquote-center">
<p>Data mining, the science of extracting useful knowledge from such huge data repositories, has emerged as a young and interdisciplinary field in computer science.  – by <strong>KDD</strong></p>

</blockquote>

<h1 id="1-数据挖掘简介"><a href="#1-数据挖掘简介" class="headerlink" title="1. 数据挖掘简介"></a>1. 数据挖掘简介</h1><a id="more"></a>

<ul>
<li>数据挖掘是一个动态的、强势快速扩展的领域。可简要将数据挖掘研究的主要问题分为五组：挖掘方法、用户交互、有效性与可伸缩性、数据类型的多样性、数据挖掘与社会。</li>
<li>数据挖掘吸纳了诸如<strong>统计学</strong>、<strong>机器学习</strong>、<strong>模式识别</strong>、<strong>数据库和数据仓库</strong>、<strong>信息检索</strong>、<strong>可视化</strong>、<strong>算法</strong>、<strong>高性能计算</strong>和许多应用领域的大量技术。</li>
</ul>
<h2 id="1-1-数据挖掘的意义"><a href="#1-1-数据挖掘的意义" class="headerlink" title="1.1. 数据挖掘的意义"></a>1.1. 数据挖掘的意义</h2><ul>
<li>利用大数据帮助做出<strong>预测</strong>或<strong>决策</strong></li>
<li>发现数据中潜在的<strong>有趣模式</strong>或<strong>知识</strong></li>
</ul>
<h1 id="2-最新技术与发展动向"><a href="#2-最新技术与发展动向" class="headerlink" title="2. 最新技术与发展动向"></a>2. 最新技术与发展动向</h1><h2 id="2-1-数据挖掘最新技术"><a href="#2-1-数据挖掘最新技术" class="headerlink" title="2.1. 数据挖掘最新技术"></a>2.1. 数据挖掘最新技术</h2><ul>
<li>超越传统技术和数据分析工具的能力的数据集催生了许多新的技术和工具–by<a href="https://link.springer.com/content/pdf/10.1007/978-3-319-08254-7.pdf">Information granularity, big data, and computational intelligence</a></li>
</ul>
<p>面对数据挖掘中3V的挑战（即：超大数据量、多样化的数据种类、处理数据的速度要求），如大型零售商的客户交易，天气监测，情报收集等数据集快速超越传统技术和数据分析工具的能力等问题，驱使数据可视化，采集和序列化中诞生了许多新的技术和工具。</p>
<h3 id="2-1-1-数据预处理技术"><a href="#2-1-1-数据预处理技术" class="headerlink" title="2.1.1. 数据预处理技术"></a>2.1.1. 数据预处理技术</h3><p>数据清理、数据集成、数据归约、数据变换和数据离散化。</p>
<ul>
<li>Deren Li methods 2015，为了揭示空间数据挖掘的各向异性，挖掘视图方法利用尺度、层次和粒度来区分不同的需求。Deren Li方法对数据进行预处理，为进一步的知识发现做准备，方法是选择一个权重进行迭代，以便尽可能多地清理观察到的空间数据。–by<a href="https://link.springer.com/content/pdf/10.1007/978-3-662-48538-5.pdf">Spatial data mining</a></li>
</ul>
<h3 id="2-1-2-数据仓库、OLAP、数据立方体技术"><a href="#2-1-2-数据仓库、OLAP、数据立方体技术" class="headerlink" title="2.1.2. 数据仓库、OLAP、数据立方体技术"></a>2.1.2. 数据仓库、OLAP、数据立方体技术</h3><p><strong>数据仓库</strong>：是一种数据库，它与单位的操作数据库分别维护。数据仓库的建立为工商企业主管提供了体系结构和工具，以便他们系统地组织、理解和使用数据进行决策。</p>
<p><strong>OLAP</strong>：OLAP是在线分析处理的缩写。OLAP实现业务数据的多维分析，并提供复杂计算、趋势分析和复杂数据建模的能力。</p>
<p><strong>数据立方体</strong>：一种多维数据模型。数据立方体创建了灵活而强有力的手段，对数据的子集分组和聚集。它们使得用户可以在多维组合和变化的聚集粒度上探索数据。这种能力极大地开阔了分析的范围，有助于从数据中有效地发现有趣的模式和知识。</p>
<h3 id="2-1-3-Apriori算法及其变形"><a href="#2-1-3-Apriori算法及其变形" class="headerlink" title="2.1.3. Apriori算法及其变形"></a>2.1.3. Apriori算法及其变形</h3><p>Apriori是一种用于在事务数据库上进行频繁项集挖掘和关联规则学习的算法。 它通过识别数据库中的频繁单个项目并将它们扩展到越来越大的项目集来进行，只要这些项目集在数据库中经常出现。</p>
<h3 id="2-1-4-基于约束模式挖掘和挖掘近似模式"><a href="#2-1-4-基于约束模式挖掘和挖掘近似模式" class="headerlink" title="2.1.4. 基于约束模式挖掘和挖掘近似模式"></a>2.1.4. 基于约束模式挖掘和挖掘近似模式</h3><p>一种好的启发式方法是让用户说明他们对挖掘导致的有趣模式的直观或期望，作为限制搜索空间的约束条件。这种策略称为基于约束的挖掘。</p>
<h3 id="2-1-5-分类"><a href="#2-1-5-分类" class="headerlink" title="2.1.5. 分类"></a>2.1.5. 分类</h3><p><strong>基本分类方法</strong>：包括决策树归纳、贝叶斯分类和基于规则的分类。</p>
<p><strong>高级分类方法</strong>：贝叶斯信念网络、后向传播的神经网络技术、支持向量机、使用频繁模式的分类、k-最邻近分类、基于案例的推理、遗传算法、模糊集方法、多类分类、半监督分类、主动学习和迁移学习。</p>
<h4 id="2-1-5-1-数据挖掘中的分类算法对比"><a href="#2-1-5-1-数据挖掘中的分类算法对比" class="headerlink" title="2.1.5.1. 数据挖掘中的分类算法对比"></a>2.1.5.1. 数据挖掘中的分类算法对比</h4><p>分类是一种重要的数据挖掘技术，具有广泛的应用前景。分类用于找出在给定数据集中每个数据实例在哪个组中相关。分类算法主要有：<strong>C4.5</strong>、<strong>ID3</strong>、<strong>k近邻分类器</strong>、<strong>朴素贝叶斯</strong>、<strong>SVM</strong>、<strong>ANN</strong>等。分类技术一般采用统计方法、机器学习方法和神经网络方法进行分类。Nikam对不同的分类算法及其特点和局限性进行了全面的综述。</p>
<p>– <a href="https://pdfs.semanticscholar.org/7c97/57ee09afa570db37f04e3b6cc4da0e2f3571.pdf">A comparative study of classification techniques in data mining algorithms</a></p>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/AdvantagesAndDisadvantagesOfClassificationAlgorithm.png" alt="AdvantagesAndDisadvantagesOfClassificationAlgorithm"></p>
<ul>
<li>基于<strong>神经网络</strong>和<strong>遗传算法</strong>的数据挖掘技术</li>
</ul>
<p><strong>Ali, Sayyed Muzammil</strong>概述了常见的知识发现任务以及解决这些任务的方法。总结了数据挖掘的概念，阐述了数据挖掘对其方法论的意义。详细研究了基于神经网络和遗传算法的数据挖掘技术，综述了实现神经网络和遗传算法数据挖掘的关键技术和方法。</p>
<p>– <a href="http://www.academia.edu/download/33555810/V3I4201499a89.pdf">data mining Techniques</a></p>
<h3 id="2-1-6-聚类分析"><a href="#2-1-6-聚类分析" class="headerlink" title="2.1.6. 聚类分析"></a>2.1.6. 聚类分析</h3><p><strong>基本聚类分析</strong>：</p>
<ul>
<li>k-均值和k-中心点划分算法、凝聚的与分裂的层次聚类算法、</li>
<li>基于密度的DBSCAN、OPTICS、DENCLUE聚类分析</li>
<li>基于网络的STING、CLIQUE聚类分析</li>
</ul>
<p><strong>高级聚类分析</strong>：</p>
<ul>
<li><p>基于概率模型的模糊簇、期望最大化算法的聚类分析</p>
</li>
<li><p>子空间聚类方法、双聚类（聚类高维数据）</p>
</li>
<li><p>SCAN算法（用于聚类图数据）</p>
</li>
<li><p>具有约束的COP-k-均值算法</p>
</li>
<li><p>数据挖掘问题的<strong>多目标进化算法</strong>的最新进展</p>
</li>
</ul>
<p><strong>Mukhopadhyay, Anirban</strong>对数据挖掘问题的多目标进化算法的最新进展进行了全面的综述。本文第一部分给出了多目标优化和数据挖掘的一些基本概念。随后，对两大数据挖掘任务特征选择和分类的多目标演化方法进行了研究。在本文的第二部分中，我们调查了用于聚类、关联规则挖掘等多个数据挖掘任务的不同多目标进化算法，并对该领域未来的研究范围进行了一般性讨论。</p>
<p>– <a href="https://ieeexplore.ieee.org/iel7/4235/4358751/06658835.pdf">A Survey of Multiobjective Evolutionary Algorithms for data mining: Part I.</a></p>
<h3 id="2-1-7-基于随机选择选项的算法"><a href="#2-1-7-基于随机选择选项的算法" class="headerlink" title="2.1.7. 基于随机选择选项的算法"></a>2.1.7. 基于随机选择选项的算法</h3><p>有时基于<strong>随机选择选项</strong>的算法收效良好。在数据挖掘和控制领域，当一个问题需要“蛮力”选择选项时，基于<strong>随机选择选项</strong>的算法在有限的时间内提供了一定概率的良好结果，并显著减少了操作量。</p>
<p>– <a href="https://pdfs.semanticscholar.org/7c97/57ee09afa570db37f04e3b6cc4da0e2f3571.pdf">A comparative study of classification techniques in data mining algorithms</a></p>
<h3 id="2-1-8-流算法"><a href="#2-1-8-流算法" class="headerlink" title="2.1.8. 流算法"></a>2.1.8. 流算法</h3><ul>
<li><strong>APSO加速粒子群优化算法</strong></li>
</ul>
<p><strong>Fong, Simon</strong>为解决当涉及到在高维数据上的挖掘时，获得最优特征子集的搜索空间以指数级增长，这导致了计算上的一个棘手需求这一问题，<strong>提出了一种新的轻量级特征选择方法</strong>。该特征选择是为了实时挖掘流数据，采用加速粒子群优化算法(APSO)，在合理的处理时间内提高了分析精度。</p>
<p>– <a href="https://ieeexplore.ieee.org/iel7/4629386/4629387/07115942.pdf">Accelerated PSO swarm search feature selection for data stream mining big data</a></p>
<h3 id="2-1-9-分布式数据挖掘"><a href="#2-1-9-分布式数据挖掘" class="headerlink" title="2.1.9. 分布式数据挖掘"></a>2.1.9. 分布式数据挖掘</h3><p><strong>Le-Khac, Nhien-An</strong>提出了一个新的框架，开发新的和创新的数据挖掘技术，以处理非常大的分布式异构数据集在商业和学术应用。详细介绍了其中的主要组件及其接口，允许用户在Globus ToolKit、DGET等网格平台上高效地开发和实现其数据挖掘应用程序技术。</p>
<p> – <a href="https://arxiv.org/abs/1703.09756">ADMIRE framework: Distributed data mining on data grid platforms</a></p>
<p><strong>Janez Kranjc</strong>介绍了一种分布式计算平台，利用最新的软件技术和计算范式开发出了支持大数据挖掘的平台。这个平台称为ClowdFlows，它是一个基于云的web应用程序，具有图形用户界面，支持数据挖掘工作流的构建和执行，其中包括作为工作流组件使用的web服务。</p>
<p> – <a href="https://www.sciencedirect.com/science/article/pii/S0167739X16302709">ClowdFlows: Online workflows for distributed big data mining</a></p>
<h2 id="2-2-数据挖掘发展动向"><a href="#2-2-数据挖掘发展动向" class="headerlink" title="2.2. 数据挖掘发展动向"></a>2.2. 数据挖掘发展动向</h2><h3 id="2-2-1-与物联网相结合"><a href="#2-2-1-与物联网相结合" class="headerlink" title="2.2.1. 与物联网相结合"></a>2.2.1. 与物联网相结合</h3><p>对许多人来说，物联网生成或捕获的海量数据被认为具有非常有用和有价值的信息。数据挖掘无疑将在使这种系统足够智能以提供更方便的服务和环境方面发挥关键作用。<br><strong>Chun-Wei Tsai</strong>从物联网开始讨论，简要回顾了“物联网数据”和“物联网数据挖掘”的特点，最后，讨论了该领域的变化、潜力、开放问题和未来趋势。</p>
<p>– <a href="https://ieeexplore.ieee.org/iel7/9739/6734839/06674155.pdf">data mining for Internet of Things: A survey.</a></p>
<h3 id="2-2-2-基于云计算的数据挖掘更低成本"><a href="#2-2-2-基于云计算的数据挖掘更低成本" class="headerlink" title="2.2.2. 基于云计算的数据挖掘更低成本"></a>2.2.2. 基于云计算的数据挖掘更低成本</h3><p>数据挖掘技术和应用程序可以有效地用于云计算范式。云计算是一种能够支持广泛应用的通用技术。基于云计算的数据挖掘技术的实现将允许用户从几乎集成的数据仓库中检索有意义的信息，从而**降低基础设施和存储的成本，并且可以从云检索有用的和潜在的信息。</p>
<p>– <a href="http://ijrise.org/asset/archive/15SANKALP1.pdf">A review on data mining based cloud computing</a></p>
<h3 id="2-2-3-与统计与机器学习结合"><a href="#2-2-3-与统计与机器学习结合" class="headerlink" title="2.2.3. 与统计与机器学习结合"></a>2.2.3. 与统计与机器学习结合</h3><p>– <a href="https://books.google.com/books?hl=en&lr=&id=ETwuDwAAQBAJ&oi=fnd&pg=PR19&dq=data+mining+Development+trend&ots=2NWgjl2RLK&sig=sQBatbtbXqXyebsmDBRzPVYNL_8">Data mining for business analytics: concepts, techniques, and applications in R</a></p>
<h3 id="2-2-4-数据挖掘实现的集成库及平台化"><a href="#2-2-4-数据挖掘实现的集成库及平台化" class="headerlink" title="2.2.4. 数据挖掘实现的集成库及平台化"></a>2.2.4. 数据挖掘实现的集成库及平台化</h3><ul>
<li><strong>SPMF——一个开源数据挖掘库</strong> 2014</li>
</ul>
<p><strong>Fournier-Viger</strong>提供了一个用Java实现的跨平台库——<strong>SPMF</strong>，一个开源数据挖掘库**，提供了超过55种数据挖掘算法的实现。<br>SPMF专门用于发现事务和序列数据库中的模式，如频繁项目集、关联规则和顺序模式。<br>源代码可以集成到其他Java程序中。<br>此外，SPMF还提供了命令行界面和简单的图形界面来进行快速测试。</p>
<p>– <a href="http://www.jmlr.org/papers/volume15/fournierviger14a/fournierviger14a.pdf">SPMF: a Java open-source pattern mining library</a></p>
<ul>
<li><strong>SAMOA——一个挖掘大数据流的平台</strong> 2015</li>
</ul>
<p><strong>Morales GD</strong>提供了一个挖掘大数据流的平台——<strong>SAMOA</strong>。它提供了一组分布式流算法，用于最常见的数据挖掘和机器学习任务，如分类、聚类和回归，以及开发新算法的编程抽象。它具有一个可插入的体系结构，允许它在多个分布式流处理引擎(如Storm、S4和Samza)上运行。萨摩亚是用Java编写的，是开源的，可以在<a href="http://samoa-project.net的apache/">http://samoa-project.net的Apache</a> Software License version 2.0下访问。</p>
<p>– <a href="http://www.jmlr.org/papers/volume16/morales15a/morales15a.pdf">SAMOA: scalable advanced massive online analysis.</a></p>
<ul>
<li>与应用相结合 </li>
<li>研制和开发数据挖掘标准 </li>
<li>支持移动环境  </li>
</ul>
<h1 id="3-应用领域及行业应用"><a href="#3-应用领域及行业应用" class="headerlink" title="3. 应用领域及行业应用"></a>3. 应用领域及行业应用</h1><h2 id="3-1-应用领域"><a href="#3-1-应用领域" class="headerlink" title="3.1. 应用领域"></a>3.1. 应用领域</h2><p><strong>数据挖掘有许多成功的应用，如电子商务、Web搜索、生物信息学、卫生保健信息学、商务智能、金融、数字图书馆和政府等。</strong></p>
<h2 id="3-2-行业应用"><a href="#3-2-行业应用" class="headerlink" title="3.2. 行业应用"></a>3.2. 行业应用</h2><h3 id="3-2-1-动态资源的新闻识别"><a href="#3-2-1-动态资源的新闻识别" class="headerlink" title="3.2.1. 动态资源的新闻识别"></a>3.2.1. 动态资源的新闻识别</h3><p><strong>Kalmegh, Sushilkumar</strong>讨论了动态资源的新闻识别可以通过所提出的模型来完成，使用REPTree、Simple Cart和RandomTree三种分类器来分析数据集。结果表明，随机树算法在对新闻进行分类时表现最佳。REPTree和Simple Cart算法的整体性能是不可接受的，因为可以看出，这两种算法都只能正确地对政治新闻进行分类。</p>
<p>– <a href="https://pdfs.semanticscholar.org/26d6/73f140807942313545489b38241c1f0401d0.pdf">Analysis of WEKA data mining algorithm REPTree, Simple CART and RandomTree for classification of Indian news</a></p>
<h3 id="3-2-2-教育数据挖掘-EDM-领域"><a href="#3-2-2-教育数据挖掘-EDM-领域" class="headerlink" title="3.2.2. 教育数据挖掘(EDM)领域"></a>3.2.2. 教育数据挖掘(EDM)领域</h3><ul>
<li>教育数据挖掘和学习分析</li>
</ul>
<p><strong>Sin, Katrina</strong>近年来，学习管理系统在教育中的应用越来越多。学生们已经开始使用移动电话，主要是智能手机，它们已经成为他们日常生活的一部分，以获取在线内容。学生的在线活动产生了大量未使用的数据，由于传统的学习分析无法处理这些数据，这些数据被浪费了。这使得大数据技术和工具渗透到教育中，处理大量的数据。本研究探讨了大数据技术在教育领域的最新应用，并对教育数据挖掘和学习分析方面的文献进行了综述。</p>
<p>– <a href="http://www.academia.edu/download/51542496/APPLICATION_OF_BIG_DATA_IN_EDUCATION_DAT.pdf">APPLICATION OF BIG data IN EDUCATION data mining AND LEARNING ANALYTICS–A LITERATURE REVIEW.</a></p>
<ul>
<li>挖掘学生入学率、考勤记录以及他们的考试数据，使之有利于教育质量的改进与提高。</li>
</ul>
<p>–  <a href="https://ieeexplore.ieee.org/iel7/6287639/6514899/07820050.pdf">A systematic review on educational data mining</a></p>
<h3 id="3-2-3-地理信息科学和遥感方面"><a href="#3-2-3-地理信息科学和遥感方面" class="headerlink" title="3.2.3. 地理信息科学和遥感方面"></a>3.2.3. 地理信息科学和遥感方面</h3><ul>
<li>空间数据挖掘应用于<strong>地理信息科学和遥感方面</strong></li>
</ul>
<p><strong>Li, Deren</strong>提供了空间数据挖掘在地理信息科学和遥感方面的应用实例。实践项目包括用于维护公共安全的时空视频数据挖掘、用于评估叙利亚危机严重程度的夜间灯光序列图像挖掘、以及在政府“一带一路”项目中的应用。</p>
<p>– <a href="https://link.springer.com/content/pdf/10.1007/978-3-662-48538-5.pdf">Spatial data mining</a></p>
<h3 id="3-2-4-医疗大数据"><a href="#3-2-4-医疗大数据" class="headerlink" title="3.2.4. 医疗大数据"></a>3.2.4. 医疗大数据</h3><ul>
<li><p>医疗大数据创新路径包括三个阶段：疾病早期发现、诊断、治疗和预后阶段、生命健康促进阶段和护理阶段。</p>
</li>
<li><p>研究热点主要集中在三个维度：疾病维度(如流行病学、乳腺癌、肥胖、糖尿病)、技术维度(如数据挖掘、机器学习)、健康服务维度(如定制服务、养老护理)</p>
</li>
<li><ul>
<li><a href="https://www.sciencedirect.com/science/article/pii/S1386505616302556">Visualizing the knowledge structure and evolution of big data research in healthcare informatics</a></li>
</ul>
</li>
<li><p>与云技术结合提供医疗服务</p>
</li>
</ul>
<p><strong>Zhang, Yin</strong>提出了一个基于云和大数据分析技术的以患者为中心的医疗应用和服务的网络物理系统，称为Health-CPS。该系统由具有统一标准的数据采集层、用于分布式存储和并行计算的数据管理层和面向数据的服务层组成。研究结果表明，云技术和大数据技术可以提高医疗系统的性能，使人们可以享受各种智能医疗应用和服务。</p>
<p> – <a href="https://ieeexplore.ieee.org/abstract/document/7219371/">Health-CPS: Healthcare cyber-physical system assisted by cloud and big data</a></p>
<ul>
<li>医学大数据研究的文献计量分析与可视化 –<a href="https://www.mdpi.com/2071-1050/10/1/166"><strong>A bibliometric analysis</strong> and <strong>visualization</strong> of <strong>medical big data research</strong></a></li>
<li>预测和解决乳腺癌生存率 –<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2994925">Data mining techniques: To predict and resolve breast cancer survivability</a></li>
</ul>
<h3 id="3-2-5-能源评估"><a href="#3-2-5-能源评估" class="headerlink" title="3.2.5. 能源评估"></a>3.2.5. 能源评估</h3><ul>
<li>全球水资源趋势和可持续发展的未来前景 –<a href="https://www.sciencedirect.com/science/article/pii/S0959652617321182">Global water <strong>trends</strong> and future scenarios for sustainable development: The case of Russia</a></li>
<li>对智能电网环境下用电量数据的数据质量分析 –<a href="https://www.sciencedirect.com/science/article/pii/S1364032116307109">data quality of electricity consumption data in a smart grid environment</a></li>
</ul>
<h3 id="3-2-6-业务运营和风险管理"><a href="#3-2-6-业务运营和风险管理" class="headerlink" title="3.2.6. 业务运营和风险管理"></a>3.2.6. 业务运营和风险管理</h3><ul>
<li>工业系统的可靠性和安全性以及它们的操作风险管理 –<a href="https://ieeexplore.ieee.org/abstract/document/7378465/">Recent development in big data analytics for business operations and risk management</a></li>
<li>业务分析的数据挖掘 –<a href="https://books.google.com/books?hl=en&lr=&id=ETwuDwAAQBAJ&oi=fnd&pg=PR19&dq=data+mining+Development+trend&ots=2NWgjl2RLK&sig=sQBatbtbXqXyebsmDBRzPVYNL_8">Data mining for business analytics: concepts, techniques, and applications in R</a></li>
</ul>
<h3 id="3-2-7-用于保险行业"><a href="#3-2-7-用于保险行业" class="headerlink" title="3.2.7. 用于保险行业"></a>3.2.7. 用于保险行业</h3><p>数据挖掘技术在人寿保险中的应用 –<a href="https://www.researchgate.net/institution/Chh_Shahu_Institute_of_Business_Education_Research/publications">Applications of Data mining techniques in life insurance</a></p>
<h3 id="3-2-8-用于政府机构"><a href="#3-2-8-用于政府机构" class="headerlink" title="3.2.8. 用于政府机构"></a>3.2.8. 用于政府机构</h3><ul>
<li>可持续自然资源管理评价污染防治 –<a href="https://www.sciencedirect.com/science/article/pii/S0959652616317115">How would big data support societal development and environmental sustainability? Insights and practices</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Kmeans算法——数据挖掘</title>
    <url>/2018/10/24/DataMining_Kmeans/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Kmeans.png" class="full-image" />

<h1 id="1-实现K-means算法对无噪声的waveform数据集进行分割"><a href="#1-实现K-means算法对无噪声的waveform数据集进行分割" class="headerlink" title="1. 实现K-means算法对无噪声的waveform数据集进行分割"></a>1. 实现K-means算法对无噪声的waveform数据集进行分割</h1><h2 id="1-1-K-means算法简介"><a href="#1-1-K-means算法简介" class="headerlink" title="1.1. K-means算法简介"></a>1.1. K-means算法简介</h2><ul>
<li>k均值聚类是一种矢量量化方法，最初来自信号处理，是数据挖掘中聚类分析的常用方法。</li>
<li>k均值聚类的目的是将n个观测值划分为k个聚类，其中每个观测值属于具有最近均值的聚类，作为聚类的原型。这导致数据空间划分为Voronoi单元。</li>
</ul>
<a id="more"></a>

<ul>
<li>这个问题在计算上很困难（NP难）；然而，有效的启发式算法快速收敛到局部最优。这些通常类似于通过k均值和高斯混合建模所采用的迭代细化方法的高斯分布混合的期望最大化算法。他们都使用集群中心来建模数据;然而，k均值聚类倾向于找到具有可比空间范围的聚类，而期望最大化机制允许聚类具有不同的形状。</li>
<li>该算法与k-最近邻分类器具有松散的关系，这是一种流行的分类机器学习技术，由于名称的原因常常与k-means混淆。应用1最近邻分类器，通过k均值获得的聚类中心将新数据分类到现有聚类中。这被称为最近的质心分类器或Rocchio算法。</li>
</ul>
<h2 id="1-2-Python编程实现K-means算法"><a href="#1-2-Python编程实现K-means算法" class="headerlink" title="1.2. Python编程实现K-means算法"></a>1.2. Python编程实现K-means算法</h2><p><strong>K-means算法主要分为以下步骤实现</strong>：</p>
<ul>
<li>S1. 随机生成 k 个 “种子”</li>
<li>S2. 依次求解当前(第i个)元素对k个’种子’的最小欧式距离，得到距当前(第i个)元素欧式距离最小的(‘种子’)集群</li>
<li>S3. 如果当前(第i个)元素的与k个‘种子’(集群)的最小欧式距离所对应的【种子编号】遇上一次记录不一致 ==&gt; (第i个)元素所属集群发生改变，更新所属集群</li>
<li>S4. 重新计算k个(‘种子’)集群的各属性值的平均值，得到新的k个(‘种子’)集群</li>
<li>S5. 若S2～S4的运行过程中，至少1个元素的所属‘种子’(集群)发生改变，则不断重复运行S2~S5过程,直至没有元素所属‘种子’(集群)发生改变视为聚类成功(也可限定最大迭代次数)跳转S6</li>
<li>S6. 结束迭代，返回k个集群的中心值centroids, 及每个集群所包含的元素数组clusterAssment</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># Pandas库：强大、灵活的数据分析和探索工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算欧式距离:</span></span><br><span class="line"><span class="comment"># 将&#x27;vector1&#x27;与&#x27;vector2&#x27;中所有对应属性值之差的平方求和，再求平方根</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caclEucDistance</span>(<span class="params">vector1, vector2</span>):</span></span><br><span class="line">    distance = np.sqrt(np.<span class="built_in">sum</span>(np.square(vector2 - vector1)))</span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成 k 个 “种子”</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span>(<span class="params">dataSet, k</span>):</span></span><br><span class="line">    numSamples, dim = dataSet.shape</span><br><span class="line">    centroids = np.zeros((k, dim)) <span class="comment">#创建大小为：&#x27;k x 元素属性列值&#x27; 的全0矩阵，用于存放k个‘种子’（集群）</span></span><br><span class="line">    <span class="comment"># 随机生成 k 个 “种子”</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        index = <span class="built_in">int</span>(random.uniform(<span class="number">0</span>, numSamples))</span><br><span class="line">        centroids[i, :] = dataSet[index, :] <span class="comment">#在数据集中取 k 个值</span></span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line"><span class="comment"># k-means 算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span>(<span class="params">dataSet, k</span>):</span></span><br><span class="line">    numSamples = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    clusterAssment = np.mat(np.zeros((numSamples, <span class="number">2</span>)))</span><br><span class="line">    <span class="comment"># clusterAssment &#x27;元素属性值行 x 2列矩阵&#x27;</span></span><br><span class="line">    <span class="comment"># 第一列：存储此示例所属的(&#x27;种子&#x27;)集群</span></span><br><span class="line">    <span class="comment"># 第二列：存储当前(第i个)元素与其所属的(&#x27;种子&#x27;)集群的欧式距离</span></span><br><span class="line">    clusterChanged = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># clusterChanged：在迭代时&#x27;种子&#x27;是否改变标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 随机生成 k 个 “种子”</span></span><br><span class="line">    centroids = initCentroids(dataSet, k)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 一直迭代直到没有1个&#x27;种子&#x27;的所属(&#x27;种子&#x27;)集群发生改变</span></span><br><span class="line">    <span class="keyword">while</span> clusterChanged:</span><br><span class="line">   </span><br><span class="line">        <span class="comment"># 迭代前为&#x27;种子&#x27;是否改变标志赋初值(False:未改变，如果执行完循环体后仍未False,视作迭代完成，退出迭代)</span></span><br><span class="line">        clusterChanged = <span class="literal">False</span> </span><br><span class="line">                </span><br><span class="line">        <span class="comment">## 依次求解每个元素对k个&#x27;种子&#x27;的最小距离</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numSamples):</span><br><span class="line">            minDist = <span class="number">100000.0</span></span><br><span class="line">            minIndex = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#比较当前(第i个)元素 对应 k个&#x27;种子&#x27; 的欧式距离，求出最小（存于minDist），并记录对应种子编号（存于minIndex）</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                distance = caclEucDistance(centroids[j, :], dataSet[i, :])</span><br><span class="line">                <span class="keyword">if</span> distance &lt; minDist:</span><br><span class="line">                    minDist = distance</span><br><span class="line">                    minIndex = j</span><br><span class="line"></span><br><span class="line">            <span class="comment">## 如果当前(第i个)元素的与k个‘种子’(集群)的最小欧式距离所对应的【种子编号】遇上一次记录不一致 ==&gt; (第i个)元素所属集群发生改变</span></span><br><span class="line">            <span class="keyword">if</span> clusterAssment[i, <span class="number">0</span>] != minIndex:</span><br><span class="line">            	<span class="comment"># 该变标志置&#x27;True&#x27; , 更新当前(第i个)元素的所属集群编号</span></span><br><span class="line">                clusterChanged = <span class="literal">True</span></span><br><span class="line">                clusterAssment[i, :] = minIndex, minDist ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## 重新计算各个集群的中心点，并更新</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            pointsInCluster = dataSet[np.nonzero(clusterAssment[:, <span class="number">0</span>].A == j)[<span class="number">0</span>]]</span><br><span class="line">            centroids[j, :] = np.mean(pointsInCluster, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处表示退出迭代 ==&gt; 聚类成功</span></span><br><span class="line">    print(<span class="string">&#x27;Congratulations, cluster complete!&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> centroids, clusterAssment</span><br></pre></td></tr></table></figure>

<h2 id="1-3-编写Python程序实现K-means算法对UCI的waveform数据集的3个类中每类数据取100个的分割"><a href="#1-3-编写Python程序实现K-means算法对UCI的waveform数据集的3个类中每类数据取100个的分割" class="headerlink" title="1.3. 编写Python程序实现K-means算法对UCI的waveform数据集的3个类中每类数据取100个的分割"></a>1.3. 编写Python程序实现K-means算法对UCI的waveform数据集的3个类中每类数据取100个的分割</h2><p>从UCI获取<a href="http://archive.ics.uci.edu/ml/datasets/waveform+database+generator+(version+2)">Waveform Database Generator (Version 2) Data Set</a>数据集。由网页介绍可知该数据集中，数据量为：5000，属性数为：40(实际21列), waves数据的类为：3。</p>
<h3 id="1-3-1-程序加载waveform-data数据"><a href="#1-3-1-程序加载waveform-data数据" class="headerlink" title="1.3.1. 程序加载waveform.data数据"></a>1.3.1. 程序加载waveform.data数据</h3><p>通过以下代码读取Waveform Database Generator (Version 2) Data Set中’waveform.data’文件内的所有数据，可看到数据的最后一列为类属性的标识号，由网页介绍可知，waves数据共有3类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line">print(<span class="string">&#x27;数据加载...\n&#x27;</span>)</span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;waveform.data&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, header=<span class="literal">None</span>, skiprows=<span class="number">0</span>, names=<span class="literal">None</span>) <span class="comment"># waveform.data</span></span><br><span class="line">print(data[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-在第0-2类中，每类提取100个数据"><a href="#1-3-2-在第0-2类中，每类提取100个数据" class="headerlink" title="1.3.2. 在第0~2类中，每类提取100个数据"></a>1.3.2. 在第0~2类中，每类提取100个数据</h3><p>在3类中每类取100个数据使用上一步实现的K-means算法的进行聚类,其中每类取100个样本，并将这300个样本拼接到一个列表，将这个操作封装成函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在data中，第0~2类，每获取100个数据并简单拼接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geteveryClass3Data100Samples</span>(<span class="params">data</span>):</span></span><br><span class="line">    data_class0 = data[data[<span class="number">21</span>]==<span class="number">0</span>].head(<span class="number">100</span>) <span class="comment">#取第0类数据前100个</span></span><br><span class="line">    data_class1 = data[data[<span class="number">21</span>]==<span class="number">1</span>].head(<span class="number">100</span>) <span class="comment">#取第1类数据前100个</span></span><br><span class="line">    data_class2 = data[data[<span class="number">21</span>]==<span class="number">2</span>].head(<span class="number">100</span>) <span class="comment">#取第2类数据前100个</span></span><br><span class="line">    data_3x100 = pd.concat([data_class0, data_class1, data_class2]) <span class="comment">#简单拼接到一起</span></span><br><span class="line">    data_3x100 = data_3x100.sort_index() <span class="comment">#将这300个样本，按原文件的索引从小到大排序(打乱第0~2类的数据)</span></span><br><span class="line">    data_3x100 = data_3x100.reset_index(drop=<span class="literal">True</span>) <span class="comment">#重新建立索引</span></span><br><span class="line">    <span class="keyword">return</span> data_3x100</span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-用K-means算法对UCI的waveform数据集中筛选出的300个样本进行分割"><a href="#1-3-3-用K-means算法对UCI的waveform数据集中筛选出的300个样本进行分割" class="headerlink" title="1.3.3. 用K-means算法对UCI的waveform数据集中筛选出的300个样本进行分割"></a>1.3.3. 用K-means算法对UCI的waveform数据集中筛选出的300个样本进行分割</h3><p>设置’种子’(集群)个数为:5, 运行k-means算法进行迭代分割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_3x100 = np.mat(data_3x100)</span><br><span class="line">k = <span class="number">5</span></span><br><span class="line">centroids, clusterAssment = kmeans(data_3x100, k)</span><br></pre></td></tr></table></figure>
<p>设置分割’种子’(集群)个数为:5时，k-means分割（集群中心点）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">centroids:</span><br><span class="line">[[-<span class="number">0.07813559</span>  <span class="number">0.40762712</span> -<span class="number">0.00067797</span>  <span class="number">0.27966102</span>  <span class="number">0.30101695</span>  <span class="number">0.99237288</span></span><br><span class="line">   <span class="number">2.17169492</span>  <span class="number">2.86677966</span>  <span class="number">3.79711864</span>  <span class="number">4.43864407</span>  <span class="number">5.55898305</span>  <span class="number">4.80983051</span></span><br><span class="line">   <span class="number">3.42457627</span>  <span class="number">3.19677966</span>  <span class="number">2.29627119</span>  <span class="number">1.22847458</span>  <span class="number">0.41711864</span>  <span class="number">0.37355932</span></span><br><span class="line">   <span class="number">0.1579661</span>   <span class="number">0.04322034</span>  <span class="number">0.28288136</span>  <span class="number">1.54237288</span>]</span><br><span class="line"> [-<span class="number">0.09621622</span>  <span class="number">0.93040541</span>  <span class="number">1.7172973</span>   <span class="number">2.41486486</span>  <span class="number">3.45162162</span>  <span class="number">4.06337838</span></span><br><span class="line">   <span class="number">5.0372973</span>   <span class="number">4.08067568</span>  <span class="number">3.61054054</span>  <span class="number">2.96756757</span>  <span class="number">2.16027027</span>  <span class="number">1.42175676</span></span><br><span class="line">   <span class="number">0.93310811</span>  <span class="number">0.84135135</span>  <span class="number">0.76283784</span>  <span class="number">0.67040541</span>  <span class="number">0.5422973</span>   <span class="number">0.45581081</span></span><br><span class="line">   <span class="number">0.01040541</span>  <span class="number">0.13513514</span>  <span class="number">0.15216216</span>  <span class="number">0.43243243</span>]</span><br><span class="line"> [-<span class="number">0.0027027</span>   <span class="number">0.50324324</span>  <span class="number">0.90378378</span>  <span class="number">1.23</span>        <span class="number">1.77783784</span>  <span class="number">1.97189189</span></span><br><span class="line">   <span class="number">2.92</span>        <span class="number">2.16405405</span>  <span class="number">1.71540541</span>  <span class="number">1.70378378</span>  <span class="number">1.92513514</span>  <span class="number">2.20432432</span></span><br><span class="line">   <span class="number">2.42216216</span>  <span class="number">2.71108108</span>  <span class="number">3.4572973</span>   <span class="number">2.60216216</span>  <span class="number">2.22405405</span>  <span class="number">1.64891892</span></span><br><span class="line">   <span class="number">1.4772973</span>   <span class="number">0.91378378</span> -<span class="number">0.10621622</span>  <span class="number">0.</span>        ]</span><br><span class="line"> [ <span class="number">0.11701149</span> -<span class="number">0.04942529</span>  <span class="number">0.15103448</span>  <span class="number">0.2254023</span>   <span class="number">0.02505747</span>  <span class="number">0.53701149</span></span><br><span class="line">   <span class="number">0.52448276</span>  <span class="number">0.95298851</span>  <span class="number">1.39574713</span>  <span class="number">2.04942529</span>  <span class="number">2.98126437</span>  <span class="number">3.51758621</span></span><br><span class="line">   <span class="number">3.88402299</span>  <span class="number">4.27816092</span>  <span class="number">4.94563218</span>  <span class="number">3.90206897</span>  <span class="number">2.75586207</span>  <span class="number">2.2708046</span></span><br><span class="line">   <span class="number">1.31091954</span>  <span class="number">0.7808046</span>  -<span class="number">0.05574713</span>  <span class="number">1.56321839</span>]</span><br><span class="line"> [ <span class="number">0.16418605</span>  <span class="number">0.40674419</span>  <span class="number">0.60651163</span>  <span class="number">1.61302326</span>  <span class="number">1.84697674</span>  <span class="number">2.77744186</span></span><br><span class="line">   <span class="number">4.06790698</span>  <span class="number">3.94511628</span>  <span class="number">4.00023256</span>  <span class="number">4.18767442</span>  <span class="number">4.25465116</span>  <span class="number">3.05651163</span></span><br><span class="line">   <span class="number">2.0372093</span>   <span class="number">1.23186047</span>  <span class="number">0.92744186</span>  <span class="number">0.74837209</span> -<span class="number">0.07837209</span> -<span class="number">0.14767442</span></span><br><span class="line">   <span class="number">0.1255814</span>  -<span class="number">0.0727907</span>  -<span class="number">0.06697674</span>  <span class="number">0.95348837</span>]]</span><br></pre></td></tr></table></figure>
<p>设置分割’种子’(集群)个数为:10时，k-means分割（集群中心点）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">centroids:</span><br><span class="line"> [[ <span class="number">0.05916667</span>  <span class="number">0.48</span>        <span class="number">0.4125</span>      <span class="number">1.08</span>        <span class="number">1.20388889</span>  <span class="number">2.09888889</span></span><br><span class="line">   <span class="number">3.15527778</span>  <span class="number">3.62388889</span>  <span class="number">4.28333333</span>  <span class="number">4.35555556</span>  <span class="number">5.08</span>        <span class="number">3.77861111</span></span><br><span class="line">   <span class="number">2.64166667</span>  <span class="number">1.89805556</span>  <span class="number">1.35138889</span>  <span class="number">0.85166667</span> -<span class="number">0.05416667</span>  <span class="number">0.03388889</span></span><br><span class="line">   <span class="number">0.08083333</span>  <span class="number">0.07666667</span>  <span class="number">0.16888889</span>  <span class="number">1.</span>        ]</span><br><span class="line"> [-<span class="number">0.48290323</span>  <span class="number">0.64677419</span>  <span class="number">1.51258065</span>  <span class="number">2.13935484</span>  <span class="number">3.30935484</span>  <span class="number">3.56096774</span></span><br><span class="line">   <span class="number">4.61419355</span>  <span class="number">3.29774194</span>  <span class="number">3.21</span>        <span class="number">2.65354839</span>  <span class="number">1.97225806</span>  <span class="number">1.4</span></span><br><span class="line">   <span class="number">1.31290323</span>  <span class="number">1.58870968</span>  <span class="number">1.15967742</span>  <span class="number">1.19612903</span>  <span class="number">1.1016129</span>   <span class="number">0.96290323</span></span><br><span class="line">   <span class="number">0.39032258</span>  <span class="number">0.47419355</span>  <span class="number">0.21322581</span>  <span class="number">0.16129032</span>]</span><br><span class="line"> [-<span class="number">0.57913043</span>  <span class="number">0.70695652</span>  <span class="number">0.55217391</span>  <span class="number">0.59521739</span>  <span class="number">1.11130435</span>  <span class="number">0.91608696</span></span><br><span class="line">   <span class="number">1.8326087</span>   <span class="number">0.71521739</span>  <span class="number">1.23130435</span>  <span class="number">1.29086957</span>  <span class="number">1.73695652</span>  <span class="number">3.23869565</span></span><br><span class="line">   <span class="number">3.33608696</span>  <span class="number">3.50521739</span>  <span class="number">4.50695652</span>  <span class="number">3.38652174</span>  <span class="number">2.71173913</span>  <span class="number">1.58913043</span></span><br><span class="line">   <span class="number">1.32434783</span>  <span class="number">1.0573913</span>   <span class="number">0.06608696</span>  <span class="number">0.52173913</span>]</span><br><span class="line"> [ <span class="number">0.56333333</span>  <span class="number">0.22777778</span>  <span class="number">1.39777778</span>  <span class="number">1.62666667</span>  <span class="number">1.97166667</span>  <span class="number">2.52888889</span></span><br><span class="line">   <span class="number">3.37111111</span>  <span class="number">2.64666667</span>  <span class="number">2.01611111</span>  <span class="number">1.95</span>        <span class="number">1.60555556</span>  <span class="number">1.56888889</span></span><br><span class="line">   <span class="number">2.40555556</span>  <span class="number">2.01555556</span>  <span class="number">2.97277778</span>  <span class="number">2.33055556</span>  <span class="number">2.20944444</span>  <span class="number">1.59333333</span></span><br><span class="line">   <span class="number">1.20611111</span>  <span class="number">0.66777778</span>  <span class="number">0.08222222</span>  <span class="number">0.</span>        ]</span><br><span class="line"> [-<span class="number">0.35111111</span>  <span class="number">0.43777778</span>  <span class="number">0.35111111</span>  <span class="number">0.60111111</span>  <span class="number">1.68888889</span>  <span class="number">1.59</span></span><br><span class="line">   <span class="number">2.60777778</span>  <span class="number">2.73111111</span>  <span class="number">1.46444444</span>  <span class="number">1.9</span>         <span class="number">2.70111111</span>  <span class="number">2.50222222</span></span><br><span class="line">   <span class="number">1.77888889</span>  <span class="number">2.82777778</span>  <span class="number">3.32111111</span>  <span class="number">2.25111111</span>  <span class="number">1.80444444</span>  <span class="number">1.69111111</span></span><br><span class="line">   <span class="number">1.83777778</span>  <span class="number">1.02333333</span> -<span class="number">0.81777778</span>  <span class="number">0.</span>        ]</span><br><span class="line"> [ <span class="number">0.13974359</span>  <span class="number">0.03769231</span> -<span class="number">0.19538462</span> -<span class="number">0.03897436</span>  <span class="number">0.06948718</span>  <span class="number">0.30487179</span></span><br><span class="line">   <span class="number">0.94025641</span>  <span class="number">1.81025641</span>  <span class="number">2.21564103</span>  <span class="number">2.92897436</span>  <span class="number">4.26564103</span>  <span class="number">4.30051282</span></span><br><span class="line">   <span class="number">3.85358974</span>  <span class="number">3.62333333</span>  <span class="number">3.78410256</span>  <span class="number">2.80692308</span>  <span class="number">1.69282051</span>  <span class="number">1.52538462</span></span><br><span class="line">   <span class="number">1.12794872</span>  <span class="number">0.55102564</span> -<span class="number">0.08230769</span>  <span class="number">2.</span>        ]</span><br><span class="line"> [ <span class="number">0.27111111</span> -<span class="number">0.21111111</span>  <span class="number">0.24088889</span>  <span class="number">0.47222222</span> -<span class="number">0.22355556</span>  <span class="number">0.66466667</span></span><br><span class="line">   <span class="number">0.25977778</span>  <span class="number">0.54777778</span>  <span class="number">1.01555556</span>  <span class="number">1.72822222</span>  <span class="number">2.55888889</span>  <span class="number">3.07777778</span></span><br><span class="line">   <span class="number">3.85911111</span>  <span class="number">4.78444444</span>  <span class="number">5.672</span>       <span class="number">4.64822222</span>  <span class="number">3.32355556</span>  <span class="number">2.85711111</span></span><br><span class="line">   <span class="number">1.46044444</span>  <span class="number">0.83622222</span>  <span class="number">0.00777778</span>  <span class="number">1.42222222</span>]</span><br><span class="line"> [ <span class="number">0.38176471</span>  <span class="number">0.59882353</span>  <span class="number">0.895</span>       <span class="number">2.25941176</span>  <span class="number">2.44352941</span>  <span class="number">3.32911765</span></span><br><span class="line">   <span class="number">4.81647059</span>  <span class="number">4.02794118</span>  <span class="number">3.63352941</span>  <span class="number">3.83470588</span>  <span class="number">3.34117647</span>  <span class="number">2.41088235</span></span><br><span class="line">   <span class="number">1.30147059</span>  <span class="number">0.83588235</span>  <span class="number">0.90970588</span>  <span class="number">0.585</span>       <span class="number">0.13470588</span> -<span class="number">0.05617647</span></span><br><span class="line">   <span class="number">0.10294118</span> -<span class="number">0.23382353</span> -<span class="number">0.06294118</span>  <span class="number">0.82352941</span>]</span><br><span class="line"> [-<span class="number">0.084</span>       <span class="number">1.168</span>       <span class="number">2.10333333</span>  <span class="number">2.54066667</span>  <span class="number">3.858</span>       <span class="number">4.87866667</span></span><br><span class="line">   <span class="number">5.49433333</span>  <span class="number">4.91</span>        <span class="number">4.08633333</span>  <span class="number">3.16633333</span>  <span class="number">2.175</span>       <span class="number">1.17433333</span></span><br><span class="line">   <span class="number">0.554</span>       <span class="number">0.12933333</span>  <span class="number">0.15466667</span>  <span class="number">0.12266667</span>  <span class="number">0.01733333</span>  <span class="number">0.14733333</span></span><br><span class="line">  -<span class="number">0.47633333</span>  <span class="number">0.00633333</span>  <span class="number">0.173</span>       <span class="number">0.63333333</span>]</span><br><span class="line"> [-<span class="number">0.10057143</span>  <span class="number">0.44885714</span>  <span class="number">0.00542857</span>  <span class="number">0.09514286</span>  <span class="number">0.19742857</span>  <span class="number">0.86142857</span></span><br><span class="line">   <span class="number">1.98857143</span>  <span class="number">2.93914286</span>  <span class="number">3.95371429</span>  <span class="number">4.702</span>       <span class="number">5.82428571</span>  <span class="number">5.14028571</span></span><br><span class="line">   <span class="number">3.702</span>       <span class="number">3.64314286</span>  <span class="number">2.28428571</span>  <span class="number">1.14228571</span>  <span class="number">0.34742857</span>  <span class="number">0.16857143</span></span><br><span class="line">   <span class="number">0.04457143</span> -<span class="number">0.09171429</span>  <span class="number">0.222</span>       <span class="number">1.65714286</span>]]</span><br></pre></td></tr></table></figure>

<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待处理文件</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/waveform.data">waveform.data</a><br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/kmeans.py">kmeans.py</a></p>
</div>


<h1 id="2-K-means算法对一副无噪图像进行分割"><a href="#2-K-means算法对一副无噪图像进行分割" class="headerlink" title="2. K-means算法对一副无噪图像进行分割"></a>2. K-means算法对一副无噪图像进行分割</h1><p><strong>加载图片数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取图片的rgb列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImageRGB</span>(<span class="params">file</span>):</span></span><br><span class="line">    image = img.imread(file)</span><br><span class="line">    width, height, x = image.shape</span><br><span class="line">    <span class="comment"># 创建与照片像素规模同大小rgb列表，存rgb数据</span></span><br><span class="line">    rgb = np.zeros((width, height, x))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            rgb[i][j] = image[i, j]</span><br><span class="line">    <span class="keyword">return</span> rgb</span><br></pre></td></tr></table></figure>
<p><strong>修改k个随机种子生成函数，使返回k个随机像素点坐标</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机生成k个种子，返回k个随机像素点坐标</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span>(<span class="params">imageRGB, k</span>):</span></span><br><span class="line">    center = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        x, y = random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">0</span>]), random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">1</span>])</span><br><span class="line">        center += [[x, y]]</span><br><span class="line">    <span class="keyword">return</span> center</span><br></pre></td></tr></table></figure>
<p><strong>修改欧式距离的计算公式，按对第一步随机产生的k个变量的欧式距离分簇</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caclEucDistance</span>(<span class="params">imageRGB, centers</span>):</span></span><br><span class="line">    region = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">0</span>]): <span class="comment">#行</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">1</span>]): <span class="comment">#列</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centers)): <span class="comment">#计算k个像素点与k个中心点的欧式距离</span></span><br><span class="line">                dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(imageRGB[i, j] - imageRGB[centers[k][<span class="number">0</span>], centers[k][<span class="number">1</span>]])))</span><br><span class="line">                temp += [dist] <span class="comment">#添加到temp临时数组中</span></span><br><span class="line">            x.append(np.argmin(temp)) <span class="comment">#距离最小的集群的下标，按距离分簇</span></span><br><span class="line">        region.append(x)</span><br><span class="line">    <span class="keyword">return</span> region <span class="comment">#返回与数组同大小的 像素与簇对应关系</span></span><br></pre></td></tr></table></figure>
<p><strong>迭代循环中计算每个像素点与k个簇平均值的欧式距离，并分簇</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loopCaclEucDistance</span>(<span class="params">imageRGB, CalCentercolor</span>):</span></span><br><span class="line">    region = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">0</span>]): <span class="comment">#行</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">1</span>]): <span class="comment">#列</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(CalCentercolor)): <span class="comment">#计算k个像素点与k个中心点的欧式距离</span></span><br><span class="line">                dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(imageRGB[i, j] - CalCentercolor[k])))</span><br><span class="line">                temp += [dist] <span class="comment">#添加到temp临时数组中</span></span><br><span class="line">            x.append(np.argmin(temp))  <span class="comment">#距离最小的集群的下标，按距离分簇</span></span><br><span class="line">        region.append(x)</span><br><span class="line">    <span class="keyword">return</span> region <span class="comment">#返回与数组同大小的 像素与簇对应关系</span></span><br></pre></td></tr></table></figure>
<p><strong>计算集群内所有样本的平均值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calNewCenter</span>(<span class="params">features, imageRGB, k</span>):</span></span><br><span class="line">    temp = [] <span class="comment">#一位数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> features:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            temp.append(j)</span><br><span class="line">    centercolor = [<span class="number">0</span>] * k</span><br><span class="line">    <span class="comment"># 累加 每个集群中所包含的 像素点的RGB值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features)): <span class="comment">#Rows</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features[i])): <span class="comment">#Columns</span></span><br><span class="line">            centercolor[features[i][j]] += imageRGB[i, j]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centercolor)):</span><br><span class="line">        centercolor[i] /= temp.count(i) <span class="comment">#求每个集群的RGB 均值</span></span><br><span class="line">        <span class="comment"># 将求得的均值[取整]</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centercolor[i])):  <span class="comment">#Columns</span></span><br><span class="line">            centercolor[i][j] = <span class="built_in">int</span>(centercolor[i][j])</span><br><span class="line">    <span class="keyword">return</span> centercolor</span><br></pre></td></tr></table></figure>
<p><strong>显示分割前后对比图程序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showImage</span>(<span class="params">imageRGB, centercolor, features, k, iteration</span>):</span></span><br><span class="line">    NewImage = np.empty((<span class="built_in">len</span>(features), <span class="built_in">len</span>(features[<span class="number">0</span>]), <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features[i])):</span><br><span class="line">            NewImage[i, j] = centercolor[features[i][j]]</span><br><span class="line">    <span class="comment"># 绘制图片</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&#x27;k=&#x27;</span>+<span class="built_in">str</span>(k)+<span class="string">&#x27;, iteration=&#x27;</span>+<span class="built_in">str</span>(iteration), fontsize=<span class="number">12</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    fig.gca().xaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">    fig.gca().yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图1: 绘制原图</span></span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    ax1.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    ax1.imshow(imageRGB / <span class="number">255</span>)</span><br><span class="line">    ax1.set_title(<span class="string">&#x27;Original image&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图2: 绘制分割图</span></span><br><span class="line">    ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ax2.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    ax2.imshow(NewImage / <span class="number">255</span>)</span><br><span class="line">    ax2.set_title(<span class="string">&#x27;Split graph&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示绘制图像</span></span><br><span class="line">    pylab.show()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="2-1-使用K-means算法对一副无噪图像进行分割完整主程序"><a href="#2-1-使用K-means算法对一副无噪图像进行分割完整主程序" class="headerlink" title="2.1. 使用K-means算法对一副无噪图像进行分割完整主程序"></a>2.1. 使用K-means算法对一副无噪图像进行分割完整主程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">#加载图片数据</span></span><br><span class="line">    imageRGB = getImageRGB(<span class="string">&#x27;picture.jpg&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Finish load image RGB data...&#x27;</span>)</span><br><span class="line">    <span class="comment">#设置集群数：k=3</span></span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    <span class="comment"># 生成k个随机像素点坐标</span></span><br><span class="line">    InitialCenter = initCentroids(imageRGB, k)</span><br><span class="line">    <span class="comment"># 计算样本中每个像素点与k个中心点的欧式距离，并重新分类</span></span><br><span class="line">    features = caclEucDistance(imageRGB, InitialCenter)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置k-means算法执行的最大迭代次数：iteration = 20</span></span><br><span class="line">    iteration = <span class="number">20</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">&#x27;iteration = &#x27;</span>, i)</span><br><span class="line">        CalCentercolor = calNewCenter(features, imageRGB, k) <span class="comment"># 得到每个簇的均值</span></span><br><span class="line">        <span class="comment"># 根据簇中的新均值，并重新分簇</span></span><br><span class="line">        features = loopCaclEucDistance(imageRGB, CalCentercolor)</span><br><span class="line">        print(<span class="string">&#x27;\n&#x27;</span>+<span class="string">&#x27;Center[k] = &#x27;</span>, CalCentercolor, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#显示分割前后对比图</span></span><br><span class="line">    showImage(imageRGB, CalCentercolor, features, k, iteration)</span><br></pre></td></tr></table></figure>

<h2 id="2-2-K-means算法分割图片效果图"><a href="#2-2-K-means算法分割图片效果图" class="headerlink" title="2.2. K-means算法分割图片效果图"></a>2.2. K-means算法分割图片效果图</h2><h3 id="2-2-1-当最大迭代次数限制为20次时："><a href="#2-2-1-当最大迭代次数限制为20次时：" class="headerlink" title="2.2.1. 当最大迭代次数限制为20次时："></a>2.2.1. 当最大迭代次数限制为20次时：</h3><ul>
<li><p><strong>k=3时的效果图如下</strong>：<br>（只用“平均后”的3种颜色替代原图）<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Kmeans_result_k=3_iteration=20.png" alt="iteration=20,k=3时的效果图"></p>
</li>
<li><p><strong>k=8时的效果图如下</strong>：<br>（只用“平均后”的8种颜色替代原图）<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Kmeans_result_k=8_iteration=20.png" alt="iteration=20,k=8时的效果图"></p>
</li>
</ul>
<h3 id="2-2-2-当最大迭代次数限制为50次时："><a href="#2-2-2-当最大迭代次数限制为50次时：" class="headerlink" title="2.2.2. 当最大迭代次数限制为50次时："></a>2.2.2. 当最大迭代次数限制为50次时：</h3><ul>
<li><p><strong>k=3时的效果图如下</strong>：<br>（只用“平均后”的3种颜色替代原图）<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Kmeans_result_k=3_iteration=50.png" alt="iteration=50,k=3时的效果图"></p>
</li>
<li><p><strong>k=8时的效果图如下</strong>：<br>（只用“平均后”的8种颜色替代原图）<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Kmeans_result_k=8_iteration=50.png" alt="iteration=50,k=8时的效果图"></p>
</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>通过反复测试，得出在一定的迭代次数限制下，设置的种子数越多，图像分割越明显，细节越丰富；</li>
<li>在一定种子数范围内，最大迭代次数越多，图像分割效果并不一定更好。</li>
<li>并且程序的运行时间会随着集群k、最大迭代次数iteration的增加而增加。</li>
</ul>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>待聚类图片</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/KmeansTestPicture.jpg">KmeansTestPicture.jpg</a><br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/kmeansPicture.py">kmeansPicture.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>PAM算法——数据挖掘</title>
    <url>/2018/10/26/DataMining_PAM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_PAM.png" class="full-image" />

<h1 id="1-实现PAM算法对部分含有高斯噪声的waveform数据集进行聚类"><a href="#1-实现PAM算法对部分含有高斯噪声的waveform数据集进行聚类" class="headerlink" title="1. 实现PAM算法对部分含有高斯噪声的waveform数据集进行聚类"></a>1. 实现PAM算法对部分含有高斯噪声的waveform数据集进行聚类</h1><h2 id="1-1-PAM算法简介"><a href="#1-1-PAM算法简介" class="headerlink" title="1.1. PAM算法简介"></a>1.1. PAM算法简介</h2><ul>
<li>PAM方法于1987年提出，用于l1范数和其他距离的工作。 </li>
<li>k-medoid是一种经典的聚类分割技术，它将n个对象的数据集聚为k个聚类，假设聚类的数量k是先验的。如果未知，则可以使用诸如轮廓的方法来确定k。 与k均值相比，它对噪声和异常值更具鲁棒性，因为它最小化了成对差异的总和，而不是欧几里德距离的平方和。</li>
<li>可以将medoid定义为群集的对象，其与群集中的所有对象的平均差异最小。即，它是群集中位于最中心的点（迭代选取最中心的点，而非Kmeans的中心计算值，抗噪声能力更强）。</li>
</ul>
<a id="more"></a>

<h2 id="1-2-编写Python程序实现PAM算法"><a href="#1-2-编写Python程序实现PAM算法" class="headerlink" title="1.2. 编写Python程序实现PAM算法"></a>1.2. 编写Python程序实现PAM算法</h2><p><strong>PAM算法主要分为以下步骤实现</strong>：</p>
<ul>
<li>S1. 随机生成 k 个 “种子” 作为中心点</li>
<li>S2. 将其余的对象划分至距离这k个类别中的最近的一个簇</li>
<li>S3. 计算此时损失值cost。计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost0</li>
<li>S4. 随机选择一个非中心对象Oi分别临时试替换k个簇中心对象中的一个，重新分簇，计算得到一个损失值cost</li>
<li>S5. 如果这个损失值cost小于S3中得到的cost0，则将这个最小损失值计算时对应的非中心点和中心点交换，更新cost0</li>
<li>S6. 重复S4~S6步骤，重复迭代直至收敛</li>
</ul>
<h2 id="1-3-对部分含有高斯噪声的waveform数据集进行聚类"><a href="#1-3-对部分含有高斯噪声的waveform数据集进行聚类" class="headerlink" title="1.3. 对部分含有高斯噪声的waveform数据集进行聚类"></a>1.3. 对部分含有高斯噪声的waveform数据集进行聚类</h2><h3 id="1-3-1-加载’waveform-noise-data’文件中的含噪声的数据"><a href="#1-3-1-加载’waveform-noise-data’文件中的含噪声的数据" class="headerlink" title="1.3.1. 加载’waveform-+noise.data’文件中的含噪声的数据"></a>1.3.1. 加载’waveform-+noise.data’文件中的含噪声的数据</h3><p>通过以下代码读取Waveform Database Generator (Version 2) Data Set中’waveform-+noise.data’文件内的所有数据，可看到数据的最后一列为类属性的标识号，由网页介绍可知,noise waveform数据规模为：5000 x 41，取含噪声waveform数据集的前500个数据样本进行聚类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 含噪声数据加载</span></span><br><span class="line">print(<span class="string">&#x27;数据加载...\n&#x27;</span>)</span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;waveform.data&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, header=<span class="literal">None</span>, skiprows=<span class="number">0</span>, names=<span class="literal">None</span>) <span class="comment"># waveform.data</span></span><br><span class="line">print(data[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-PAM算法对waveform数据集进行聚类"><a href="#1-3-2-PAM算法对waveform数据集进行聚类" class="headerlink" title="1.3.2. PAM算法对waveform数据集进行聚类"></a>1.3.2. PAM算法对waveform数据集进行聚类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PAM算法实现</span></span><br><span class="line"><span class="comment"># iteration:最大迭代次数，k:&#x27;种子&#x27;集群个数，data:待聚类数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PAM</span>(<span class="params">iteration, k, data</span>):</span></span><br><span class="line">    data_numSamples, data_dim = data.shape</span><br><span class="line">    <span class="comment"># print(data_numSamples, &#x27; &#x27;, data_dim)</span></span><br><span class="line"></span><br><span class="line">    data_new = copy.deepcopy(data)  <span class="comment"># 前40列存放数据，不可变。最后1列即第41列存放标签，标签列随着每次迭代而更新。</span></span><br><span class="line">    data_now = copy.deepcopy(data)  <span class="comment"># data_now用于存放中间过程的数据</span></span><br><span class="line"></span><br><span class="line">    center_point = np.random.choice(data_numSamples, k, replace=<span class="literal">False</span>)</span><br><span class="line">    center = data_new[center_point, :(data_dim-<span class="number">2</span>)]  <span class="comment"># 随机形成的k个中心，维度为（3，40）</span></span><br><span class="line"></span><br><span class="line">    distance = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    distance_now = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]  <span class="comment"># distance_now用于存放中间过程的距离</span></span><br><span class="line">    lost = np.ones([data_numSamples, k]) * <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 初始lost为维度为（numSamples，3）的无穷大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):  <span class="comment"># 首先完成第一次划分，即第一次根据距离划分所有点到k个类别中</span></span><br><span class="line">        distance[j] = np.sqrt(np.<span class="built_in">sum</span>(np.square(data_new[:, :(data_dim-<span class="number">2</span>)] - np.array(center[j])), axis=<span class="number">1</span>))</span><br><span class="line">    data_new[:, data_dim-<span class="number">1</span>] = np.argmin(np.array(distance), axis=<span class="number">0</span>)  <span class="comment"># data_new 的最后一列，即标签列随之改变，变为距离某中心点最近的标签，例如与第0个中心点最近，则为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration):  <span class="comment"># 假设迭代n次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(k):  <span class="comment"># 每一次都要分别替换k=k个中心点，所以循环k次。这层循环结束即算出利用所有点分别替代k个中心点后产生的i个lost值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(data_numSamples):  <span class="comment"># 替换某个中心点时都要利用全部点进行替换，所以循环numSamples次。这层循环结束即算出利用所有点分别替换1个中心点后产生的numSamples个lost值</span></span><br><span class="line"></span><br><span class="line">                center_now = copy.deepcopy(center)  <span class="comment"># center_now用于存放中间过程的中心点</span></span><br><span class="line">                center_now[m] = data_now[l, :(data_dim-<span class="number">2</span>)]  <span class="comment"># 用第l个点替换第m个中心点</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):  <span class="comment"># 计算暂时替换1个中心点后的距离值</span></span><br><span class="line">                    distance_now[j] = np.sqrt(np.<span class="built_in">sum</span>(np.square(data_now[:, :(data_dim-<span class="number">2</span>)] - np.array(center_now[j])), axis=<span class="number">1</span>))</span><br><span class="line">                data_now[:, (data_dim-<span class="number">1</span>)] = np.argmin(np.array(distance),</span><br><span class="line">                                            axis=<span class="number">0</span>)  <span class="comment"># data_now的标签列更新，注意data_now时中间过程，所以这里不能选择更新data_new的标签列</span></span><br><span class="line"></span><br><span class="line">                lost[l, m] = (caclEucDistance(data_now[:, :(data_dim-<span class="number">2</span>)], center_now[data_now[:, (data_dim-<span class="number">1</span>)].astype(<span class="built_in">int</span>)]) \</span><br><span class="line">                              - caclEucDistance(data_now[:, :(data_dim-<span class="number">2</span>)], center[data_new[:, (data_dim-<span class="number">1</span>)].astype(</span><br><span class="line">                            <span class="built_in">int</span>)])).<span class="built_in">sum</span>()  <span class="comment"># 这里很好理解lost的维度为什么为numSamples*3了。lost[l,m]的值代表用第l个点替换第m个中心点的损失值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">min</span>(lost) &lt; <span class="number">0</span>:  <span class="comment"># lost意味替换代价，选择代价最小的来完成替换</span></span><br><span class="line">            index = np.where(np.<span class="built_in">min</span>(lost) == lost)  <span class="comment"># 即找到min(lost)对应的替换组合</span></span><br><span class="line">            index_l = index[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># index_l指将要替代某个中心点的候选点</span></span><br><span class="line">            index_m = index[<span class="number">1</span>][<span class="number">0</span>]  <span class="comment"># index_m指将要被替代的某个中心点，即用index_l来替代index_m</span></span><br><span class="line"></span><br><span class="line">        center[index_m] = data_now[index_l, :data_dim-<span class="number">2</span>]  <span class="comment"># 更新聚类中心</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            distance[j] = np.sqrt(np.<span class="built_in">sum</span>(np.square(data_now[:, :(data_dim-<span class="number">2</span>)] - np.array(center[j])), axis=<span class="number">1</span>))</span><br><span class="line">        data_new[:, (data_dim-<span class="number">1</span>)] = np.argmin(np.array(distance), axis=<span class="number">0</span>)  <span class="comment"># 更新参考矩阵,至此data_new的标签列得以更新，即完成了一次迭代</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> center ,data_new  <span class="comment"># 最后返回center：集群中心对象，data_new：其最后一列即为最终聚好的标签</span></span><br></pre></td></tr></table></figure>
<p>设置最大迭代次数teration = 10, ‘种子’集群个数k = 3,对提取的500个含有高斯噪声的waveform数据集分类结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">center</span><br><span class="line"> [[ <span class="number">1.24</span>  <span class="number">1.75</span>  <span class="number">3.09</span>  <span class="number">3.08</span>  <span class="number">3.39</span>  <span class="number">3.22</span>  <span class="number">5.38</span>  <span class="number">4.55</span>  <span class="number">3.24</span>  <span class="number">2.52</span>  <span class="number">2.66</span>  <span class="number">1.15</span></span><br><span class="line">   <span class="number">0.69</span>  <span class="number">0.43</span>  <span class="number">0.84</span>  <span class="number">0.11</span>  <span class="number">1.25</span>  <span class="number">0.64</span> -<span class="number">0.14</span>  <span class="number">0.78</span> -<span class="number">0.75</span> -<span class="number">0.02</span>  <span class="number">0.14</span>  <span class="number">0.97</span></span><br><span class="line">   <span class="number">0.95</span>  <span class="number">0.91</span>  <span class="number">0.06</span>  <span class="number">0.78</span>  <span class="number">0.27</span> -<span class="number">2.38</span> -<span class="number">0.38</span> -<span class="number">0.04</span> -<span class="number">1.44</span>  <span class="number">0.89</span> -<span class="number">1.91</span>  <span class="number">0.04</span></span><br><span class="line">   <span class="number">0.66</span> -<span class="number">0.05</span>  <span class="number">0.74</span>]</span><br><span class="line"> [ <span class="number">1.24</span>  <span class="number">0.32</span>  <span class="number">0.19</span>  <span class="number">1.38</span>  <span class="number">0.16</span>  <span class="number">3.28</span>  <span class="number">4.65</span>  <span class="number">4.72</span>  <span class="number">2.97</span>  <span class="number">5.05</span>  <span class="number">4.05</span>  <span class="number">3.99</span></span><br><span class="line">   <span class="number">3.17</span>  <span class="number">1.06</span>  <span class="number">0.36</span> -<span class="number">0.23</span> -<span class="number">0.22</span>  <span class="number">1.4</span>   <span class="number">1.33</span>  <span class="number">0.72</span>  <span class="number">0.63</span> -<span class="number">0.05</span>  <span class="number">0.45</span>  <span class="number">0.68</span></span><br><span class="line">  -<span class="number">0.19</span> -<span class="number">1.13</span> -<span class="number">0.76</span> -<span class="number">0.01</span>  <span class="number">0.81</span>  <span class="number">0.3</span>   <span class="number">1.81</span>  <span class="number">0.15</span>  <span class="number">0.89</span>  <span class="number">0.31</span>  <span class="number">1.11</span> -<span class="number">0.51</span></span><br><span class="line">   <span class="number">0.42</span>  <span class="number">0.52</span> -<span class="number">0.01</span>]</span><br><span class="line"> [ <span class="number">0.05</span>  <span class="number">0.27</span>  <span class="number">1.3</span>  -<span class="number">0.72</span> -<span class="number">0.6</span>   <span class="number">1.16</span>  <span class="number">1.29</span>  <span class="number">1.59</span>  <span class="number">0.54</span>  <span class="number">2.19</span>  <span class="number">3.77</span>  <span class="number">3.77</span></span><br><span class="line">   <span class="number">3.76</span>  <span class="number">4.55</span>  <span class="number">4.48</span>  <span class="number">3.07</span>  <span class="number">2.65</span>  <span class="number">1.12</span>  <span class="number">1.09</span>  <span class="number">0.47</span>  <span class="number">1.47</span>  <span class="number">0.72</span> -<span class="number">0.02</span>  <span class="number">1.14</span></span><br><span class="line">  -<span class="number">1.04</span>  <span class="number">1.16</span>  <span class="number">0.81</span>  <span class="number">1.63</span> -<span class="number">0.57</span>  <span class="number">0.33</span> -<span class="number">0.2</span>  -<span class="number">0.18</span>  <span class="number">0.2</span>  -<span class="number">0.22</span> -<span class="number">0.77</span>  <span class="number">0.05</span></span><br><span class="line">   <span class="number">0.03</span> -<span class="number">0.36</span>  <span class="number">0.96</span>]]</span><br><span class="line">[<span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span></span><br><span class="line"> <span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">0.</span>]</span><br></pre></td></tr></table></figure>

<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>含高斯噪声文件</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/waveform-+noise.data">waveform-+noise.data</a><br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/pam.py">pam.py</a></p>
</div>

<h1 id="2-编写Python程序实现PAM算法并对一副噪声图像进行分割"><a href="#2-编写Python程序实现PAM算法并对一副噪声图像进行分割" class="headerlink" title="2. 编写Python程序实现PAM算法并对一副噪声图像进行分割"></a>2. 编写Python程序实现PAM算法并对一副噪声图像进行分割</h1><h2 id="2-1-加载含高斯噪声的图片的rgb数据"><a href="#2-1-加载含高斯噪声的图片的rgb数据" class="headerlink" title="2.1. 加载含高斯噪声的图片的rgb数据"></a>2.1. 加载含高斯噪声的图片的rgb数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImageRGB</span>(<span class="params">file</span>):</span></span><br><span class="line">    image = img.imread(file)</span><br><span class="line">    width, height, x = image.shape</span><br><span class="line">    <span class="comment"># 创建与照片像素规模同大小rgb列表，存rgb数据</span></span><br><span class="line">    rgb = np.zeros((width, height, x))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            rgb[i][j] = image[i, j]</span><br><span class="line">    <span class="keyword">return</span> rgb</span><br></pre></td></tr></table></figure>
<h2 id="2-2-随机生成k个种子，返回k个随机像素点坐标"><a href="#2-2-随机生成k个种子，返回k个随机像素点坐标" class="headerlink" title="2.2. 随机生成k个种子，返回k个随机像素点坐标"></a>2.2. 随机生成k个种子，返回k个随机像素点坐标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span>(<span class="params">imageRGB, k</span>):</span></span><br><span class="line">    center = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        x, y = random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">0</span>]), random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">1</span>])</span><br><span class="line">        center += [[x, y]]</span><br><span class="line">    <span class="keyword">return</span> center</span><br></pre></td></tr></table></figure>
<h2 id="2-3-随机选择一个非中心点Oi"><a href="#2-3-随机选择一个非中心点Oi" class="headerlink" title="2.3. 随机选择一个非中心点Oi"></a>2.3. 随机选择一个非中心点Oi</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseOneNoCenterSample</span>(<span class="params">imageRGB, centers</span>):</span></span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    isChooseACenterSampleFlag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span>(isChooseACenterSampleFlag):</span><br><span class="line">        isExist = <span class="literal">False</span></span><br><span class="line">        x, y = random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">0</span>]), random.randint(<span class="number">0</span>, imageRGB.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 判断与k个中心 是否有重复样本,</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centers)):</span><br><span class="line">            <span class="keyword">if</span>(x==centers[k][<span class="number">0</span>] <span class="keyword">and</span> y==centers[k][<span class="number">1</span>]):</span><br><span class="line">                isExist = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">#若无重复，则退出while,并返回[x,y]</span></span><br><span class="line">        <span class="keyword">if</span>( isExist == <span class="literal">False</span> ):</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">#若重复则继续while</span></span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br></pre></td></tr></table></figure>
<h2 id="2-4-计算变量中每个像素点与k个中心点的欧式距离，并分簇"><a href="#2-4-计算变量中每个像素点与k个中心点的欧式距离，并分簇" class="headerlink" title="2.4. 计算变量中每个像素点与k个中心点的欧式距离，并分簇"></a>2.4. 计算变量中每个像素点与k个中心点的欧式距离，并分簇</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caclEucDistance</span>(<span class="params">imageRGB, centers</span>):</span></span><br><span class="line">    region = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">0</span>]): <span class="comment">#行</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">1</span>]): <span class="comment">#列</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centers)): <span class="comment">#计算k个像素点与k个中心点的欧式距离</span></span><br><span class="line">                dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(imageRGB[i, j] - imageRGB[centers[k][<span class="number">0</span>], centers[k][<span class="number">1</span>]])))</span><br><span class="line">                temp += [dist] <span class="comment">#添加到temp临时数组中</span></span><br><span class="line">            x.append(np.argmin(temp)) <span class="comment">#添加[i,j]像素距离k个‘种子’最小的距离于region</span></span><br><span class="line">        region.append(x)</span><br><span class="line">    <span class="keyword">return</span> region <span class="comment">#返回与数组同大小的最小欧式距离数组</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost"><a href="#2-5-计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost" class="headerlink" title="2.5. 计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost"></a>2.5. 计算所有对象与其簇中中心点的距离值，将其全部累加得到损失值，记为cost</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcCost</span>(<span class="params">imageRGB, features, centers</span>):</span></span><br><span class="line">    cost = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">0</span>]): <span class="comment">#行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(imageRGB.shape[<span class="number">1</span>]): <span class="comment">#列</span></span><br><span class="line">            dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(imageRGB[i, j] - imageRGB[centers[features[i][j]][<span class="number">0</span>], centers[features[i][j]][<span class="number">1</span>]])))</span><br><span class="line">            cost = cost + dist</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>
<h2 id="2-6-显示分割前后对比图程序"><a href="#2-6-显示分割前后对比图程序" class="headerlink" title="2.6. 显示分割前后对比图程序"></a>2.6. 显示分割前后对比图程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showImage</span>(<span class="params">imageRGB, centercolor, features, k, iteration</span>):</span></span><br><span class="line">    NewImage = np.empty((<span class="built_in">len</span>(features), <span class="built_in">len</span>(features[<span class="number">0</span>]), <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features[i])):</span><br><span class="line">            NewImage[i, j] = centercolor[features[i][j]]</span><br><span class="line">    <span class="comment"># 绘制图片</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&#x27;k=&#x27;</span>+<span class="built_in">str</span>(k)+<span class="string">&#x27;, iteration=&#x27;</span>+<span class="built_in">str</span>(iteration), fontsize=<span class="number">12</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    fig.gca().xaxis.set_major_locator(plt.NullLocator())</span><br><span class="line">    fig.gca().yaxis.set_major_locator(plt.NullLocator())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图1: 绘制原图</span></span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    ax1.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    ax1.imshow(imageRGB / <span class="number">255</span>)</span><br><span class="line">    ax1.set_title(<span class="string">&#x27;Original image&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子图2: 绘制分割图</span></span><br><span class="line">    ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ax2.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    ax2.imshow(NewImage / <span class="number">255</span>)</span><br><span class="line">    ax2.set_title(<span class="string">&#x27;Split graph&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示绘制图像</span></span><br><span class="line">    pylab.show()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="2-7-PAM算法对图片数据聚类实现"><a href="#2-7-PAM算法对图片数据聚类实现" class="headerlink" title="2.7. PAM算法对图片数据聚类实现"></a>2.7. PAM算法对图片数据聚类实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PAM</span>(<span class="params">imageRGB, features, centers</span>):</span></span><br><span class="line">    <span class="comment"># 计算初始cost0</span></span><br><span class="line">    cost0 = calcCost(imageRGB, features, centers)</span><br><span class="line">    <span class="comment"># print(&#x27;cost0=&#x27;, cost0)</span></span><br><span class="line">    <span class="comment"># 随机选择一个非中心点Oi</span></span><br><span class="line">    aNoCenterSample = chooseOneNoCenterSample(imageRGB, centers)</span><br><span class="line">    <span class="comment"># print(&#x27;Center = &#x27;, centers)</span></span><br><span class="line">    <span class="comment"># print(&#x27;aNoCenterSample = &#x27;, aNoCenterSample)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 替换该随机对象所属的第k个中心对象</span></span><br><span class="line">    belongsK = features[aNoCenterSample[<span class="number">0</span>]][aNoCenterSample[<span class="number">1</span>]]</span><br><span class="line">    TempCenters = centers</span><br><span class="line">    TempCenters[belongsK][<span class="number">0</span>] = aNoCenterSample[<span class="number">0</span>]  <span class="comment"># Rows下标</span></span><br><span class="line">    TempCenters[belongsK][<span class="number">1</span>] = aNoCenterSample[<span class="number">1</span>]  <span class="comment"># Columns下标</span></span><br><span class="line">    <span class="comment"># 重新分簇</span></span><br><span class="line">    TempFeatures = caclEucDistance(imageRGB, TempCenters)</span><br><span class="line">    <span class="comment"># 计算代价cost</span></span><br><span class="line">    Tempcost = calcCost(imageRGB, TempFeatures, TempCenters)</span><br><span class="line">    <span class="comment"># 比较替换后的 cost</span></span><br><span class="line">    <span class="keyword">if</span> (Tempcost &lt; cost0):</span><br><span class="line">        <span class="comment"># 若比最初损失值cost0小，则确认替换</span></span><br><span class="line">        centers = TempCenters</span><br><span class="line">        features = TempFeatures</span><br><span class="line">        cost0 = Tempcost</span><br><span class="line">    <span class="keyword">return</span> features, centers</span><br></pre></td></tr></table></figure>

<h2 id="2-8-使用PAM算法对一副有噪图像进行分割完整主程序"><a href="#2-8-使用PAM算法对一副有噪图像进行分割完整主程序" class="headerlink" title="2.8. 使用PAM算法对一副有噪图像进行分割完整主程序"></a>2.8. 使用PAM算法对一副有噪图像进行分割完整主程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">#加载图片数据</span></span><br><span class="line">    imageRGB = getImageRGB(<span class="string">&#x27;picture.jpg&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Finish load image RGB data...\n&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置集群数：k=3</span></span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    <span class="comment">#设置k-means算法执行的最大迭代次数：iteration = 20</span></span><br><span class="line">    iteration = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成k个随机像素点坐标，作为中心点</span></span><br><span class="line">    centers = initCentroids(imageRGB, k)</span><br><span class="line">    <span class="comment"># 计算样本中每个像素点与k个中心点的欧式距离，并根据距离分到最近簇</span></span><br><span class="line">    features = caclEucDistance(imageRGB, centers)</span><br><span class="line">    print(<span class="string">&#x27;PAM start...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iteration, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">&#x27;iteration = &#x27;</span>, i)</span><br><span class="line">        features, centers = PAM(imageRGB, features, centers) <span class="comment">#PAM迭代</span></span><br><span class="line">        print(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;Centers = &#x27;</span>, centers, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    centercolor = getCenterColor(imageRGB, centers, k)</span><br><span class="line">    <span class="comment">#显示分割前后对比图</span></span><br><span class="line">    print(<span class="string">&#x27;Show the Comparison images...&#x27;</span>)</span><br><span class="line">    showImage(imageRGB, centercolor, features, k, iteration)</span><br></pre></td></tr></table></figure>

<h2 id="2-9-PAM算法分割图片效果图"><a href="#2-9-PAM算法分割图片效果图" class="headerlink" title="2.9. PAM算法分割图片效果图"></a>2.9. PAM算法分割图片效果图</h2><h3 id="2-9-1-当最大迭代次数限制为10次时："><a href="#2-9-1-当最大迭代次数限制为10次时：" class="headerlink" title="2.9.1. 当最大迭代次数限制为10次时："></a>2.9.1. 当最大迭代次数限制为10次时：</h3><p><strong>k=3时的效果图如下</strong>：<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Pam_result_k=3_iteration=10.png" alt="PAMiteration=10,k=3时的效果图"><br><strong>k=8时的效果图如下</strong>：<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Pam_result_k=8_iteration=10.png" alt="PAMiteration=10,k=8时的效果图"></p>
<h3 id="2-9-2-当最大迭代次数限制为30次时："><a href="#2-9-2-当最大迭代次数限制为30次时：" class="headerlink" title="2.9.2. 当最大迭代次数限制为30次时："></a>2.9.2. 当最大迭代次数限制为30次时：</h3><p><strong>k=3时的效果图如下</strong>：<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Pam_result_k=3_iteration=30.png" alt="PAMiteration=30,k=3时的效果图"><br><strong>k=8时的效果图如下</strong>：<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DataMining_Pam_result_k=8_iteration=30.png" alt="PAMiteration=30,k=8时的效果图"><br>通过反复运行测试，得出的结论基本与K-mean算法一致：在一定的迭代次数限制下，设置的种子数越多，图像分割越明显，细节越丰富；在一定种子数范围内，最大迭代次数越多，图像分割效果并不一定更好。并且程序的运行时间会随着集群k、最大迭代次数iteration的增加而增加。</p>
<h1 id="3-对比PAM算法与Kmeans算法"><a href="#3-对比PAM算法与Kmeans算法" class="headerlink" title="3. 对比PAM算法与Kmeans算法"></a>3. 对比PAM算法与Kmeans算法</h1><p>虽然经过反复测试运行代码，PAM与Kmeans算法对图片的分割效果与集群数k和最大迭代次数iteration的关系结论基本一致，总的来说PAM算法运行时间较长，复杂度也较高。但相比与K-means算法，PAM算法又有一定优势。由于选择的是中心对象而非平均值，所以如结果所示，受样本中的噪声的影响相对较小。</p>
<div class="note success"><p><strong>备注</strong><br><strong>运行平台</strong>：Arch Linux<br><strong>运行环境</strong>：Intellij IDEA<br><strong>含噪声图片</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/PamTestPicture.jpg">PamTestPicture.jpg</a><br><strong>源代码</strong>：<a href="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/pamPicture.py">pamPicture.py</a></p>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装及简单应用</title>
    <url>/2018/11/19/DockerSimpleUsing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DockerSimpleUsing.png" class="full-image" />

<h1 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h1><h2 id="1-1-一键安装Docker"><a href="#1-1-一键安装Docker" class="headerlink" title="1.1. 一键安装Docker"></a>1.1. 一键安装Docker</h2><p>Manjaro系统下pacman命令一键安装Docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S docker</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="1-2-配置镜像加速器"><a href="#1-2-配置镜像加速器" class="headerlink" title="1.2. 配置镜像加速器"></a>1.2. 配置镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如:</p>
<ul>
<li>Docker 官方提供的中国 registry mirror <a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li>
<li>七牛云加速器 <a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com/</a></li>
</ul>
<h3 id="1-2-1-新建-etc-docker-daemon-json-文件"><a href="#1-2-1-新建-etc-docker-daemon-json-文件" class="headerlink" title="1.2.1. 新建 /etc/docker/daemon.json 文件"></a>1.2.1. 新建 /etc/docker/daemon.json 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">sudo vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-在文件中添加如下命令"><a href="#1-2-2-在文件中添加如下命令" class="headerlink" title="1.2.2. 在文件中添加如下命令"></a>1.2.2. 在文件中添加如下命令</h3><figure class="highlight plain"><figcaption><span>文件位置：/etc/docker/daemon.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-重新启动服务"><a href="#1-2-3-重新启动服务" class="headerlink" title="1.2.3. 重新启动服务"></a>1.2.3. 重新启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-检查加速器是否生效"><a href="#1-2-4-检查加速器是否生效" class="headerlink" title="1.2.4. 检查加速器是否生效"></a>1.2.4. 检查加速器是否生效</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>
<p>若最后有如下信息，则国内镜像服务（加速器）已生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure>

<h1 id="2-Docker简单应用"><a href="#2-Docker简单应用" class="headerlink" title="2. Docker简单应用"></a>2. Docker简单应用</h1><h2 id="2-1-运行hello-word小例子"><a href="#2-1-运行hello-word小例子" class="headerlink" title="2.1. 运行hello-word小例子"></a>2.1. 运行hello-word小例子</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>运行hello-world容器，尽管此时没有hello-world镜像，docker会自动拉取hello-world的镜像，然后运行hello-world容器。</p>
<h2 id="2-2-获取镜像"><a href="#2-2-获取镜像" class="headerlink" title="2.2. 获取镜像"></a>2.2. 获取镜像</h2><p>在 <a href="https://store.docker.com/">Docker Store</a> 上有非常多的高质量的官方镜像</p>
<h3 id="2-2-1-拉取Python镜像"><a href="#2-2-1-拉取Python镜像" class="headerlink" title="2.2.1. 拉取Python镜像"></a>2.2.1. 拉取Python镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull python:3.5</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-拉取Ubuntu16-04镜像"><a href="#2-2-2-拉取Ubuntu16-04镜像" class="headerlink" title="2.2.2. 拉取Ubuntu16.04镜像"></a>2.2.2. 拉取Ubuntu16.04镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-列出已经下载下来的镜像"><a href="#2-2-3-列出已经下载下来的镜像" class="headerlink" title="2.2.3. 列出已经下载下来的镜像"></a>2.2.3. 列出已经下载下来的镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image ls</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-删除镜像"><a href="#2-2-4-删除镜像" class="headerlink" title="2.2.4. 删除镜像"></a>2.2.4. 删除镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image rm [镜像名/镜像ID]</span><br></pre></td></tr></table></figure>

<h1 id="3-使用python镜像"><a href="#3-使用python镜像" class="headerlink" title="3. 使用python镜像"></a>3. 使用python镜像</h1><h2 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1. 准备工作"></a>3.1. 准备工作</h2><p>在宿主操作系统～目录下新建文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p DockerTest/Pythonapp <span class="comment">#新建Pythonapp文件夹</span></span><br><span class="line">touch helloworld.py <span class="comment">#创建 python程序文件</span></span><br></pre></td></tr></table></figure>
<p>helloworld.py 文件，代码如下：</p>
<figure class="highlight plain"><figcaption><span>文件位置：~/DockerTest/Pythonapp/helloworld.py</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    print(i， &#39; hello world!&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="3-2-运行容器"><a href="#3-2-运行容器" class="headerlink" title="3.2. 运行容器"></a>3.2. 运行容器</h2><p>跳转到上一目录~/DockerTest，并执行以下命令运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -v <span class="variable">$PWD</span>/Pythonapp:/usr/src/Pythonapp -w /usr/src/Pythonapp python:3.5 python helloworld.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令说明：</span></span><br><span class="line"></span><br><span class="line">-v <span class="variable">$PWD</span>/Pythonapp:/usr/src/Pythonapp <span class="comment">#将主机中当前目录下的Pythonapp挂载到容器的/usr/src/Pythonapp</span></span><br><span class="line">-w /usr/src/Pythonapp <span class="comment">#指定容器的/usr/src/Pythonapp目录为工作目录</span></span><br><span class="line">python helloworld.py <span class="comment">#使用容器的python命令来执行工作目录中的helloworld.py文件</span></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> hello world!</span><br><span class="line"><span class="number">1</span> hello world!</span><br><span class="line"><span class="number">2</span> hello world!</span><br><span class="line"><span class="number">3</span> hello world!</span><br><span class="line"><span class="number">4</span> hello world!</span><br></pre></td></tr></table></figure>

<h1 id="4-使用Ubuntu16-04镜像"><a href="#4-使用Ubuntu16-04镜像" class="headerlink" title="4. 使用Ubuntu16.04镜像"></a>4. 使用Ubuntu16.04镜像</h1><h2 id="4-1-容器与宿主机对比"><a href="#4-1-容器与宿主机对比" class="headerlink" title="4.1. 容器与宿主机对比"></a>4.1. 容器与宿主机对比</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个Ubuntu16.04容器并在内运行bash</span></span><br><span class="line">sudo docker run -t -i ubuntu:16.04 /bin/bash</span><br><span class="line"><span class="comment"># 显示当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment"># 显示正在使用的内核版本</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="comment"># 显示Docker的进程</span></span><br><span class="line">ps a | grep docker</span><br></pre></td></tr></table></figure>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/DockerContainerAndHostComparison.png" alt="Docker容器&amp;宿主机对比"></p>
<p><strong>左图</strong>为Docker运行的Ubuntu16.04容器； <strong>右图</strong>为宿主操作系统</p>
<p><strong>分析</strong>：执行<strong>pwd</strong> (#显示当前目录)<strong>命令</strong>时可看到容器的当前目录为<code>/</code>，而非运行容器的宿主目录<code>~</code>；均跳转到根目录<code>/</code>后运行<code>ls</code>命令可看到容器与宿主操作系统有两套不同的文件系统。正如前面介绍的那样，Docker会虚拟一整套文件系统。</p>
<p><strong>分析</strong>：两边执行<code><strong>uname -r</strong></code>&gt;            # 显示正在使用的内核版本<strong>命令</strong>，两边内核版本一致，正如前面介绍的那样，Docker无模拟硬件，无内核。</p>
<h2 id="4-2-创建一个Ubuntu16-04容器并在内运行bash小程序"><a href="#4-2-创建一个Ubuntu16-04容器并在内运行bash小程序" class="headerlink" title="4.2. 创建一个Ubuntu16.04容器并在内运行bash小程序"></a>4.2. 创建一个Ubuntu16.04容器并在内运行bash小程序</h2><p>小程序功能：每隔一秒输出一次hello world</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run ubuntu:16.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>按 Ctrl + C 可退出小程序循环</p>
</div>

<h2 id="4-3-显示当前容器"><a href="#4-3-显示当前容器" class="headerlink" title="4.3. 显示当前容器"></a>4.3. 显示当前容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container ls <span class="comment">#显示当前正在运行的容器</span></span><br><span class="line">sudo docker container ls -a <span class="comment">#显示所有容器，包括终止状态的容器</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-清理所有处于终止状态的容器"><a href="#4-4-清理所有处于终止状态的容器" class="headerlink" title="4.4. 清理所有处于终止状态的容器"></a>4.4. 清理所有处于终止状态的容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container prune</span><br></pre></td></tr></table></figure>

<h1 id="5-Docker镜像、容器常用命令"><a href="#5-Docker镜像、容器常用命令" class="headerlink" title="5. Docker镜像、容器常用命令"></a>5. Docker镜像、容器常用命令</h1><h2 id="5-1-每次启动docker-重新启动服务"><a href="#5-1-每次启动docker-重新启动服务" class="headerlink" title="5.1. 每次启动docker 重新启动服务"></a>5.1. 每次启动docker 重新启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>##（容器对比）linux命令：<br>显示当前目录:                 pwd<br>显示正在使用的内核版本:        uname -r<br>显示Docker的进程：            ps a | grep docker</p>
<h2 id="5-2-从-Docker-镜像仓库获取镜像："><a href="#5-2-从-Docker-镜像仓库获取镜像：" class="headerlink" title="5.2. 从 Docker 镜像仓库获取镜像："></a>5.2. 从 Docker 镜像仓库获取镜像：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure>

<h2 id="5-3-列出本地镜像："><a href="#5-3-列出本地镜像：" class="headerlink" title="5.3. 列出本地镜像："></a>5.3. 列出本地镜像：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image ls</span><br></pre></td></tr></table></figure>

<h2 id="5-4-删除本地镜像："><a href="#5-4-删除本地镜像：" class="headerlink" title="5.4. 删除本地镜像："></a>5.4. 删除本地镜像：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>

<h1 id="6-容器-常用命令"><a href="#6-容器-常用命令" class="headerlink" title="6. 容器 常用命令"></a>6. 容器 常用命令</h1><h2 id="6-1-显示当前容器："><a href="#6-1-显示当前容器：" class="headerlink" title="6.1. 显示当前容器："></a>6.1. 显示当前容器：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container ls <span class="comment">#显示当前正在运行的容器</span></span><br><span class="line">sudo docker container ls -a <span class="comment">#显示所有状态的容器（包括终止状态的容器）</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-新建并启动"><a href="#6-2-新建并启动" class="headerlink" title="6.2. 新建并启动:"></a>6.2. 新建并启动:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -t -i ubuntu:16.04 /bin/bash <span class="comment"># 创建一个Ubuntu16.04容器并在内运行bash</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-后台运行容器-d-参数："><a href="#6-3-后台运行容器-d-参数：" class="headerlink" title="6.3. 后台运行容器 -d 参数："></a>6.3. 后台运行容器 -d 参数：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -d ubuntu:16.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span>    <span class="comment">#容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比缺少 -d 参数的运行容器</span></span><br><span class="line">sudo docker run ubuntu:16.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span>    <span class="comment">#容器会把输出的结果 (STDOUT) 打印到宿主机上面</span></span><br></pre></td></tr></table></figure>

<h2 id="6-4-终止容器："><a href="#6-4-终止容器：" class="headerlink" title="6.4. 终止容器："></a>6.4. 终止容器：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container stop [容器名/容器ID]</span><br></pre></td></tr></table></figure>
<p>例如对于上面中只启动了一个ubuntu:16.04终端的容器，用户通过 exit 命令或Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<h2 id="6-5-删除容器"><a href="#6-5-删除容器" class="headerlink" title="6.5. 删除容器"></a>6.5. 删除容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container rm [容器名/容器ID] <span class="comment">#删除一个处于终止状态的容器</span></span><br><span class="line">sudo docker container rm -f [容器名/容器ID] <span class="comment">#删除一个运行中的容器</span></span><br><span class="line">sudo docker container prune <span class="comment">#清理所有处于终止状态的容器</span></span><br></pre></td></tr></table></figure>

<h2 id="6-6-进入容器"><a href="#6-6-进入容器" class="headerlink" title="6.6. 进入容器"></a>6.6. 进入容器</h2><p>在使用 -d 参数时，容器启动后会进入后台。<br>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker attach [容器名/容器ID]</span><br><span class="line">sudo docker <span class="built_in">exec</span> -it [容器名/容器ID] bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#eg.</span></span><br><span class="line">sudo docker run -d ubuntu:16.04 <span class="comment">#后台运行ubuntu:16.04容器</span></span><br><span class="line">sudo docker container ls -a <span class="comment">#显示所有状态的容器（包括终止状态的容器）</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it [容器名/容器ID] bash <span class="comment">#进入ubuntu:16.04容器，并执行bash</span></span><br></pre></td></tr></table></figure>

<h2 id="6-7-导出和导入容器"><a href="#6-7-导出和导入容器" class="headerlink" title="6.7. 导出和导入容器"></a>6.7. 导出和导入容器</h2><h3 id="6-7-1-导出容器"><a href="#6-7-1-导出容器" class="headerlink" title="6.7.1. 导出容器"></a>6.7.1. 导出容器</h3><p>如果要导出本地某个容器，可以使用 docker export 命令，将导出容器快照到本地文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker container ls -a <span class="comment">#显示所有状态的容器（包括终止状态的容器）</span></span><br><span class="line">sudo docker <span class="built_in">export</span> [容器名/容器ID] &gt; FileName.tar</span><br></pre></td></tr></table></figure>

<h3 id="6-7-2-导入容器快照"><a href="#6-7-2-导入容器快照" class="headerlink" title="6.7.2. 导入容器快照"></a>6.7.2. 导入容器快照</h3><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cat FileName.tar | docker import - <span class="built_in">test</span>/FileName:v1.0</span><br><span class="line">sudo docker image ls</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>高效地阅读文献--《文献检索与论文写作》</title>
    <url>/2017/03/25/Efficient-reading-of-the-literature/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Efficient-reading-of-the-literature.jpg" class="full-image" />

<p>你是否时常苦于获取不到精确且优质的信息？据统计科研人员花费在文献阅读的时间占比总科研时间超过一半。在信息时代，如何从海量的数据中快速筛选出有用的信息已成为当代人的一项重要技能，博主收集了几项对高效地阅读文献、提升检索信息效率有积极作用的方法，或将提升信息检索的效率。</p>
<a id="more"></a>

<h1 id="1-勤加练习，养成习惯"><a href="#1-勤加练习，养成习惯" class="headerlink" title="1. 勤加练习，养成习惯"></a>1. <strong>勤加练习，养成习惯</strong></h1><p>据美国科学基金会统计，一个科研人员花费在*查找和消化科技资料上的时间需占全部科研时间的51%*，计划思考占8%，实验研究占32%,书面益结占9%,由这些统计数字可以看出，科研人员花费在科技文献出版物上的时间为全部科研时间的60%。作为科研工作者及相关高校师生，随时了解外界信息十分必要。在当前的信息时代，获取信息的途径和手段正在变得越来越容易，如何从海量的数据中查找、获取到与研究课题相关度高的文献，并高效地阅读文献、消化文献也变得越来越重要。</p>
<p>科研人员需要通过勤加练习，逐渐把阅读文献培养成一种习惯。阅读文献非常重要，从文献中可以看到前人的研究成果，站得高看得远；从文献中可以学习别人的工作，启迪思维，抛砖引玉。同时，阅读文献也是一个烦琐的工作，应日复一日，年复一年地阅读，不断积累自已研究领域所需要的阅读量以及形成新的研究点子，以促进科学研究的顺利进展。</p>
<h1 id="2-集中时间，研究经典"><a href="#2-集中时间，研究经典" class="headerlink" title="2. 集中时间，研究经典"></a>2. <strong>集中时间，研究经典</strong></h1><p>由于科学研究都有周期时间，阅读文献要集中时间，主要阅读与论文主题相关的文献。一个有用的<code>小技巧是：首先找出研究领域中那些最经典和研究前沿的文献</code>。例如：可以通过万方数据库，就某个研究领域进行知识脉络分析。根据其检索出来的图示结果，可以看出以论文发表情况为代表的本领域历年来的研究趋势情况，本领域的经典文献和研究前沿文献，以及相关学者的情况(发文数、被引、H指数等）。另外，还可以参考一些有用的书目，例如导师推荐的阅读书目列表、相关专业课程表等，这些可以让科研人员对研究领域有一个初步的印象。如果对自己研究的某个子领域感兴趣，则可以向该领域的前辈或专家请教本领域最重要的几篇论文是什么，如果允许的话，可以向其要求获取相关的文献。回顾最近几年的出版物，将那些非常感兴趣的复制下来。这不仅是由于其中很多都是意义重大的论文，对于研究工作进展也是很重要的。定期到学校的图书馆，翻阅其他院校出版的以及自己相关领域的技术报告，并选出自己感兴趣的仔细加以阅读，并注意归纳、整理资料与数据。</p>
<h1 id="3-阅读分析，注重技巧"><a href="#3-阅读分析，注重技巧" class="headerlink" title="3. 阅读分析，注重技巧"></a>3. <strong>阅读分析，注重技巧</strong></h1><p>一般来说，<code><strong>核心及重要期刊</strong></code>上的论文会<code>有比较多的创新、创意</code>。因此，虽然阅读起来比较累，但收获较多而深入，值得花心思去阅读分析。在阅读文献的第一阶段，总是习惯于从头到尾地阅读文献，看论文中是否有感兴趣的东西，这样的做法浪费时间而且看多了会迷失了当初的阅读目标。大多数论文完全可以通过查看题目和摘要来判断这篇论文和自己的研究有没有直接的关联，由此决定是否要把论文全部读完整。如果研究人员有能力只根据<strong>摘要和题目</strong>就能締选出其中最密切相关的几篇论文，其学术研究及做事的效率就会比其他人高出好几倍。再者，论文主要内容也不需要完全看懂。除了其中两三个关键公式以外，其他公式都可以看不懂。公式之间的推导工程也可以完全忽略。如果要看公式，重点是要看明白公式推导过程中引人的假设条件，而不是恒等式的转换。甚至有些论文通篇都可以粗略地跳跃式阅读，阅读时只要把觉得有需要的部分看明白，其他不需要的部分只要了解它的主要点子就可以了。</p>
<p>在看了大约30〜40篇文献后，将进入到下一个阶段—-<code>找出论文真正有价值的部分</code>。也就是把文献读薄的过程，不少二十多更的论文可以重新整理后形成一页左右的篇幅。从文献中找出那些真正对研究有作用的地方。论文作者从其工作中所发现的感兴趣的地方，未必是你感兴趣的，反之亦然。当然，如果觉得该论文确实有价值，则需要通篇甚至反复精读，务必理解论文。理解论文得到了什么结论并不等同于理解了该论文。理解论文，就要了解论义的目的，作者所做的选择，假设和形式化是否可行，论文指出了怎样的方向，论文所涉及领域都有哪些问题，作者的研究中持续出现的难点模式是什么，论文所丧达的策略观点是什么，诸如此类。当阅读文献达到了对本研究领域的主要内容、主要方法、文献之间的关系等相肖熟练之后，就表示已经基本掌握了本领域主要的论文。</p>
<h1 id="4-科研利器，助力科研"><a href="#4-科研利器，助力科研" class="headerlink" title="4. 科研利器，助力科研"></a>4. <strong>科研利器，助力科研</strong></h1><p>主要指在科研选题、思路整理、文献管理、论文撰写过程中比较好用的相关软件。</p>
<h2 id="4-1-思路整理或知识管理的工具软件"><a href="#4-1-思路整理或知识管理的工具软件" class="headerlink" title="4.1. 思路整理或知识管理的工具软件"></a>4.1. 思路整理或知识管理的工具软件</h2><p>代表性工具软件包括：<code>EverNote</code>、<code>有道云笔记</code>、<code>one Note</code>、<code>为知笔记</code>等。这几款软件各有千秋，用户可以按个人使用巧惯来选择使用。</p>
<ul>
<li><code><strong>EverNote</strong></code>就是Logo是一个大象标志的印象笔记，是目前较为火热的笔记软件之一，除了可以处理常规的文字信息外，还可以记录语音、阁片等，好处就在于一处编辑，多平台之间可以同步，还有网页剪辑功能，让科研人员可以随时随地记录并收藏好的idea</li>
<li><code><strong>有道云笔记</strong></code>功能与其类似，是网易旗下的有道推出的产品，使用时所占内存会比EverNote小一些，而且重要的是上手快，操作起来更贴近中国人习惯，可随手记录下Idea。也支持多平台同步，可以实现实时增量式同步。缺点在于需要定期整理，否则存储内容会过于杂乱</li>
<li><code>one Note</code>作为一款收集笔记和信息的软件，功能强大。它提供了一种灵活的方式，将文本、图片、数字手写墨迹、录音和录像等信息全部收集并组织到计算机上的一个数字笔记本中。但是one Note不少扩展功能是要收费的，同时由于对系统内存的占用比较大，还可能会出现运行速度慢等现象</li>
</ul>
<h2 id="4-2-文献生产和管理工具软件"><a href="#4-2-文献生产和管理工具软件" class="headerlink" title="4.2. 文献生产和管理工具软件"></a>4.2. <strong>文献</strong>生产和管理工具软件</h2><p>代表性工具软件包括：<code>NoteExpress</code>、<code>NoteFirst</code>、<code>EndNote</code>等。这几款软件各有千秋，用户可以按个人使用习惯来选择使用。</p>
<ul>
<li><code><strong>NoteExpress</strong></code>是国内主流的文献管理软件，其核心功能包括知识采集、管理、应用、挖掘等知识管理的几乎所有的环节，可以有效推进学术研究，知识管理</li>
<li><code><strong>NoteFirst</strong></code>于2009年年底正式发布，是国内唯一的网络版文献管理软件。针对个人用户，它集成了文献收集与管理，论文参考文献的自动生成，参考文献自动校对等功能，支持多种其他软件的文件格式；针对学术性困队，它推出了团队科研协作的功能，帮助科研团队收集和管理知识，实现科研文献管理和开放存取、科研资源交流共享相结合，由此更好地管理团队以及促进团队成长</li>
<li><code><strong>EndNote</strong></code>支持国际期刊的参考文献格式有3776 种，写作模板几百种，涵盖各个领域的杂志，可以方便地使用这些格式和模板。还具有管理文献、在线搜索文献、建立文献库和图片库、定制文稿、引文编排等主要功能</li>
</ul>
<h1 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h1><ul>
<li>《文献检索与论文写作》</li>
</ul>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进程执行Shell命令问题总结</title>
    <url>/2020/06/15/ExecShellCMD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/execShellCMD.jpg" class="full-image" />

<p>在大部分Java开发过程中需要调用一些Shell脚本命令来实现某些功能，如：文本处理过程中调脚本使开发更便捷、其他组件只提供了Shell脚本调用方式或调脚本与系统直接交互等场景。<br>博主总结了一些Java进程执行Shell命令的常见问题及解决方法，或能在大家开发过程中避坑有积极作用。</p>
<p>关键词: Java调Shell、问题总结</p>
<a id="more"></a>

<h1 id="1-“No-such-file-or-directory”问题的原因分析及解决方法"><a href="#1-“No-such-file-or-directory”问题的原因分析及解决方法" class="headerlink" title="1. “No such file or directory”问题的原因分析及解决方法"></a>1. “No such file or directory”问题的原因分析及解决方法</h1><h2 id="1-1-若执行的是Shell脚本文件，可能是由于执行脚本的换行符不正确导致的"><a href="#1-1-若执行的是Shell脚本文件，可能是由于执行脚本的换行符不正确导致的" class="headerlink" title="1.1. 若执行的是Shell脚本文件，可能是由于执行脚本的换行符不正确导致的"></a>1.1. 若执行的是Shell脚本文件，可能是由于执行脚本的换行符不正确导致的</h2><p><strong>原因分析：</strong>文件明明存在但Java仍然报“No such file or directory”，可能由于Linux与Windows系统字符差异（主要是换行符\n,\r\n）导致的，即待执行脚本文件的换行符为\r\n，导致win下编写的脚本文件无法被在Linux环境中Java执行，而报“No such file or directory”IO异常。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li><p>重新在Windows上用文本编辑器改好格式后上传到Linux服务器再执行（简单直观）<br>在Windows上用文本编辑器(eg.VS code、Notepad++)打开脚本，更改右下角的行位序列: CRLF –&gt; LF，保存。将改好的脚本文件Sftp上传到Linux后重新执行。</p>
</li>
<li><p>若觉得从Windows到Linux上传太折腾，也可通过vim更改字符格式（dos -&gt; unix），在Linux环境上用vim去掉多出的’\r’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim查看文本格式，确定脚本文档格式（dos(Windows)--\r\n; unix(Linux)--\n）</span></span><br><span class="line">:set ff</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim查看不可见字符，确认脚本结尾字符问题</span></span><br><span class="line">:set invlist</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式1：命令行模式<span class="built_in">set</span> fileformat(推荐)</span></span><br><span class="line">:set fileformat=unix</span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式2：删除多的\r字符（下方替换命令没写错，用/r）</span></span><br><span class="line">:%s//r//g</span><br></pre></td></tr></table></figure>
</li>
<li><p>若需要修改多个脚本文件格式，也可通过dos2unix命令批量修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo find YourScriptsDir/ -name &quot;*.sh&quot; | xargs dos2unix</span><br><span class="line">可选参数备注：</span><br><span class="line">-k：保持输出文件的日期不变 </span><br><span class="line">-q：安静模式，不提示任何警告信息</span><br><span class="line">-V：查看版本</span><br><span class="line">-c：转换模式，模式有：ASCII, 7bit, ISO, Mac, 默认是：ASCII</span><br><span class="line">-o：写入到源文件</span><br><span class="line">-n：写入到新文件</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-2-手动在bash中能够执行，但Java中调用Shell却报“No-such-file-or-directory”"><a href="#1-2-手动在bash中能够执行，但Java中调用Shell却报“No-such-file-or-directory”" class="headerlink" title="1.2. 手动在bash中能够执行，但Java中调用Shell却报“No such file or directory”"></a>1.2. 手动在bash中能够执行，但Java中调用Shell却报“No such file or directory”</h2><p><strong>原因分析：</strong>Java在调用Shell的时候，默认是用在系统的/bin/目录下的指令（不加载环境变量），可能是找不到命令的路径。如：要用Java执行Shell命令为”node helloworld.js”，可能是不能识别”node”这个命令。<br><strong>解决方法：</strong>在/bin/目录下创所调用命令软链接 或 用命令全路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建所调用命令软链接到/bin/目录</span></span><br><span class="line">ln -s /home/admin/node/bin/node node;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  或调用时用node的绝对地址</span></span><br><span class="line">/home/admin/node/bin/node helloworld.js</span><br></pre></td></tr></table></figure>

<h2 id="1-3-若脚本文件换行符正确、有脚本执行权限，无命令识别问题，却依然无法执行shell"><a href="#1-3-若脚本文件换行符正确、有脚本执行权限，无命令识别问题，却依然无法执行shell" class="headerlink" title="1.3. 若脚本文件换行符正确、有脚本执行权限，无命令识别问题，却依然无法执行shell"></a>1.3. 若脚本文件换行符正确、有脚本执行权限，无命令识别问题，却依然无法执行shell</h2><p><strong>原因分析：</strong>推测可能是在调用Runtime.getRuntime().exec(“CMD”)时，传递Shell命令字符串的某个实现环节出了问题。<br><strong>解决方法：</strong>实例化一个数据输出流，通过dataoutputstream对象的写字节方法往process写待执行的Shell命令字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line">Process process = <span class="keyword">null</span>;</span><br><span class="line">DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime().exec(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">    dataOutputStream = <span class="keyword">new</span> DataOutputStream(process.getOutputStream());</span><br><span class="line">    dataOutputStream.writeBytes(command + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    dataOutputStream.writeBytes(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">    dataOutputStream.flush();</span><br><span class="line">    readStdStream(process);</span><br><span class="line">    resultValue = process.waitFor();</span><br><span class="line">    System.out.println(<span class="string">&quot;resultValue = &quot;</span> + resultValue);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        process.destroy();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-脚本无执行权限问题及解决方法"><a href="#2-脚本无执行权限问题及解决方法" class="headerlink" title="2. 脚本无执行权限问题及解决方法"></a>2. 脚本无执行权限问题及解决方法</h1><p><strong>原因分析：</strong>Java执行某些程序解压的脚本，因没及时赋权限导致无法执行<br><strong>解决方法：</strong>Java中调用shell命令赋权</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(<span class="string">&quot;/bin/chmod&quot;</span>, <span class="string">&quot;a+x&quot;</span>, shFile.getPath());</span><br><span class="line">Process process = processBuilder.start();</span><br><span class="line"><span class="keyword">int</span> exitValue = process.waitFor();</span><br></pre></td></tr></table></figure>

<h1 id="3-Java进程阻塞-一直等待Shell返回-问题及解决方法"><a href="#3-Java进程阻塞-一直等待Shell返回-问题及解决方法" class="headerlink" title="3. Java进程阻塞(一直等待Shell返回)问题及解决方法"></a>3. Java进程阻塞(一直等待Shell返回)问题及解决方法</h1><p><strong>原因分析：</strong>调用Shell命令后Java业务进程阻塞，根因是在执行的Shell脚本中含print或echo输出，未能读取缓存区导致缓存区用尽。<br><strong>解决方法：</strong>及时将标准输出流和错误流读取出来，也方便后续问题定位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String readLine;</span><br><span class="line">BufferedReader stdInput = <span class="keyword">null</span>;</span><br><span class="line">BufferedReader stdError = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取Shell进程标准输出流</span></span><br><span class="line">    stdInput = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">    <span class="keyword">while</span> ((readLine = stdInput.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[stdInputStream]:&quot;</span> + readLine);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取Shell进程标准错误流</span></span><br><span class="line">    stdError = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">    <span class="keyword">while</span> ((readLine = stdError.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[stdErrorStream]:&quot;</span> + readLine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stdInput.close();</span><br><span class="line">        stdError.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-附录：简易的Java执行Shell命令类"><a href="#4-附录：简易的Java执行Shell命令类" class="headerlink" title="4. 附录：简易的Java执行Shell命令类"></a>4. 附录：简易的Java执行Shell命令类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecShellCMD</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java执行shell命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">execShellCommand</span><span class="params">(<span class="keyword">final</span> String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line">        Process process = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process = Runtime.getRuntime().exec(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">            dataOutputStream = <span class="keyword">new</span> DataOutputStream(process.getOutputStream());</span><br><span class="line">            dataOutputStream.writeBytes(command + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            dataOutputStream.writeBytes(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">            dataOutputStream.flush();</span><br><span class="line">            readStdStream(process);</span><br><span class="line">            resultValue = process.waitFor();</span><br><span class="line">            System.out.println(<span class="string">&quot;resultValue = &quot;</span> + resultValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalMonitorStateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">                process.destroy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取Shell进程标准输出流和错误流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> process</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readStdStream</span><span class="params">(<span class="keyword">final</span> Process process)</span> </span>&#123;</span><br><span class="line">        String readLine;</span><br><span class="line">        BufferedReader stdInput = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader stdError = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取Shell进程标准输出流</span></span><br><span class="line">            stdInput = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> ((readLine = stdInput.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;[stdInputStream]:&quot;</span> + readLine);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 读取Shell进程标准错误流</span></span><br><span class="line">            stdError = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">            <span class="keyword">while</span> ((readLine = stdError.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;[stdErrorStream]:&quot;</span> + readLine);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;close std stream&quot;</span>);</span><br><span class="line">                stdInput.close();</span><br><span class="line">                stdError.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java exec shell command running...&quot;</span>);</span><br><span class="line">        String command = <span class="string">&quot;/home/admin/node/bin/node helloworld.js&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (times &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                times = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;\nNo.&quot;</span> + (++times) + <span class="string">&quot; times to exec shell command...&quot;</span>);</span><br><span class="line">            execShellCommand(command);</span><br><span class="line">            <span class="comment">// 进程等待10s</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git实用命令记录</title>
    <url>/2021/07/25/GitUsefullCmd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/gitRevert.jpg" style="zoom:45%;"  />

<a id="more"></a>

<h1 id="1-Git常用基础命令"><a href="#1-Git常用基础命令" class="headerlink" title="1. Git常用基础命令"></a>1. Git常用基础命令</h1><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/gitUsuallyUseCmd.png" style="zoom:35%;" />

<h1 id="2-Git实用操作命令"><a href="#2-Git实用操作命令" class="headerlink" title="2. Git实用操作命令"></a>2. Git实用操作命令</h1><h2 id="2-1-对比指定文件在本地分支与远端分支的差异"><a href="#2-1-对比指定文件在本地分支与远端分支的差异" class="headerlink" title="2.1. 对比指定文件在本地分支与远端分支的差异"></a>2.1. 对比指定文件在本地分支与远端分支的差异</h2><p><b><font color="#7E3D76" style="">1. 对比指定【单个文件】在【本地分支与远端】分支的差异</font></b></p>
<p>可以识别到暂存区中未提交的修改（其他跨分支的比较均无法识别暂存区中未提交的修改）。</p>
<p>前置条件：本地当前分支在远端有相对应分支。</p>
<p>示例代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat -- src/file1.cpp src/file1.cpp</span><br></pre></td></tr></table></figure>

<p>–stat参数作用：显示简要信息（精度到文件），默认diff会显示精度到行的差异信息</p>
<p>只需填写需对比的文件路径分别在本地和远端分支各自的地址即可，第一个路径为本地文件地址，第二个路径为远端仓库文件地址（此示例两文件路径相同）</p>
<p><b><font color="#7E3D76" style="">2. 对比指定的多个文件在两分支间的差异</font></b></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat master dev  -- file1.md src/file2.java</span><br></pre></td></tr></table></figure>

<h2 id="2-2-对比俩分支文件差异"><a href="#2-2-对比俩分支文件差异" class="headerlink" title="2.2. 对比俩分支文件差异"></a>2.2. 对比俩分支文件差异</h2><p><b><font color="#7E3D76" style="">1. 对比【本地两分支】差异</font></b></p>
<p>比较本地master和dev分支所有文件的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat master dev</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">2. 对比【本地两分支】差异（限定文件）</font></b></p>
<p>只比较关注的指定文件，在本地master和dev分支的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat master dev -- filepath1 filepath2 filepath3</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">3. 对比【本地分支与远端分支】差异</font></b></p>
<p>比较本地dev分支和远端master分支所有文件的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat dev origin/master</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">4. 对比【本地分支与远端分支】差异（限定文件）</font></b></p>
<p>比较指定文件，在本地dev分支和远端master分支的差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --stat dev origin/master -- filepath1 filepath2 filepath3</span><br></pre></td></tr></table></figure>

<h2 id="2-3-对比两分支commit差异"><a href="#2-3-对比两分支commit差异" class="headerlink" title="2.3. 对比两分支commit差异"></a>2.3. 对比两分支commit差异</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --left-right --stat master...dev</span><br></pre></td></tr></table></figure>

<h2 id="2-4-在远端仓库新建一个分支"><a href="#2-4-在远端仓库新建一个分支" class="headerlink" title="2.4. 在远端仓库新建一个分支"></a>2.4. 在远端仓库新建一个分支</h2><p>实现方式：本地建分支后同步到远端仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b newBranch origin/master</span><br><span class="line">git push --set-upstream origin newBranch</span><br></pre></td></tr></table></figure>

<h2 id="2-5-删除远端分支"><a href="#2-5-删除远端分支" class="headerlink" title="2.5. 删除远端分支"></a>2.5. 删除远端分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -r -d origin/newBranch</span><br></pre></td></tr></table></figure>

<h2 id="2-6-本地分支与远端分支关联"><a href="#2-6-本地分支与远端分支关联" class="headerlink" title="2.6. 本地分支与远端分支关联"></a>2.6. 本地分支与远端分支关联</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout --track origin/branchName</span><br></pre></td></tr></table></figure>

<h1 id="3-Git命令进阶用法"><a href="#3-Git命令进阶用法" class="headerlink" title="3. Git命令进阶用法"></a>3. Git命令进阶用法</h1><h2 id="3-1-reset-回滚"><a href="#3-1-reset-回滚" class="headerlink" title="3.1. reset 回滚"></a>3.1. reset 回滚</h2><p>reset参数说明：</p>
<ul>
<li>–hard：重置时清空工作目录的所有改动</li>
<li>–soft：重置时保留工作目录和暂存区的内容；</li>
<li>–mixed（默认）：重置时保留工作目录的内容，并清空暂存区。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^          # 方式1：回滚到上一次提交</span><br><span class="line">git reset --hard $&#123;commitID&#125;    # 方式2：回滚到指定commit处，丢弃其后所有commit</span><br><span class="line">git reflog                      # 方式3：撤销历史操作（如撤销上一次回滚操作）</span><br><span class="line">git reset --hard $&#123;历史操作ID&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-amend-修复上次提交的操作"><a href="#3-2-amend-修复上次提交的操作" class="headerlink" title="3.2. amend 修复上次提交的操作"></a>3.2. amend 修复上次提交的操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add $&#123;changeFiles&#125;  # s1.将修复错误的文件添加到提交</span><br><span class="line">git commit --amend      # s2.修复上次提交，注意amend只适用于还处于评审中的CR。</span><br></pre></td></tr></table></figure>

<h2 id="3-3-rebase-变基的操作步骤"><a href="#3-3-rebase-变基的操作步骤" class="headerlink" title="3.3. rebase 变基的操作步骤"></a>3.3. rebase 变基的操作步骤</h2><p>前置条件：dev分支拉取自master（eg.dev分支拉取时间：20210715），且在之后（eg.20210720）master又有新提交（或合入），且现在（eg.20210730）dev分支需要在引入该新提交（或合入）后再开发。</p>
<p>变基操作成功执行后，dev分支相当于是从变基操作时（eg.20210730）新拉取的分支，且(20210715 ~ 20210730)之间的提交和修改仍保留。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev        # s1.切换到待变基分支dev</span><br><span class="line">git rebase master       # s2.将分支的起点移动到想要合并的分支的HEAD上</span><br><span class="line"></span><br><span class="line">git checkout master     # s3.切换到主分支（本地）</span><br><span class="line">git merge dev           # s4.移到最新的提交</span><br></pre></td></tr></table></figure>

<h2 id="3-4-rebase-修改完善之前某次提交的操作步骤"><a href="#3-4-rebase-修改完善之前某次提交的操作步骤" class="headerlink" title="3.4. rebase 修改完善之前某次提交的操作步骤"></a>3.4. rebase 修改完善之前某次提交的操作步骤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> s1.触发git修改弹窗，将对应commit标记为edit。</span></span><br><span class="line">git rebase -i $&#123;commitID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s2.修改完善某次提交的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s3.添加已修改的文件</span></span><br><span class="line">git add changedFiles</span><br><span class="line"><span class="meta">#</span><span class="bash"> s4.将修正应用到当前最新的 commit</span></span><br><span class="line">git commit --amend</span><br><span class="line"><span class="meta">#</span><span class="bash"> s5.继续rebase过程。</span></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<h2 id="3-5-rebase-撤销过往提交命令的两种方式"><a href="#3-5-rebase-撤销过往提交命令的两种方式" class="headerlink" title="3.5. rebase 撤销过往提交命令的两种方式"></a>3.5. rebase 撤销过往提交命令的两种方式</h2><p><b><font color="#7E3D76" style="">1. 方式1——触发git修改并在弹出git编辑界面中删除想撤销的commits</font></b><br>实现原理：在触发的git编辑界面中添加drop ${待删除commitID}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> s1. 触发rebase编辑界面</span></span><br><span class="line">git rebase -i $&#123;待删除的前一条commitID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s2. 在修改文件中pick commitId.. 下方将pick命令改为丢弃命令</span></span><br><span class="line">pick $&#123;待删除commitID&#125;  ==》  drop $&#123;待删除commitID&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s3. 手动解决<span class="variable">$&#123;冲突files&#125;</span>的冲突</span></span><br><span class="line">vi $&#123;冲突files&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s4. 添加已修改的文件</span></span><br><span class="line">git add $&#123;冲突files&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s5. 继续rebase过程</span></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p><b><font color="#7E3D76" style="">2. 方式2——将修正应用到当前最新的commit</font></b></p>
<p>实现原理：对本地当前分支，将左开右闭区间 (commitID_B, commitID_C] 的提交覆盖到 commitID_A 之后。相当于原左开右闭区间(commitID_A, commitID_B]的提交被删除了。</p>
<p>示例代码：</p>
<p>当前分支提交记录顺序为：commitID_A, … , commitID_B , … , commitID_C。现要删除左开右闭区间(commitID_A, commitID_B]的提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> s1. 触发rebase</span></span><br><span class="line">git rebase --onto $&#123;目标commitID_A&#125; $&#123;起点commitID_B&#125; $&#123;终点commitID_C&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s2. 手动解决<span class="variable">$&#123;冲突files&#125;</span>的冲突</span></span><br><span class="line">vi $&#123;冲突files&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s3. 添加已修改的文件</span></span><br><span class="line">git add $&#123;冲突files&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> s4. 继续rebase过程</span></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<h2 id="3-6-根据操作历史回退"><a href="#3-6-根据操作历史回退" class="headerlink" title="3.6. 根据操作历史回退"></a>3.6. 根据操作历史回退</h2><p>根据git操作历史记录回退，eg.撤销上一步git reset –hard操作，以恢复到执行该操作前的状态（需确保git全局配置中core.logallrefupdates已打开true）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> s1.查询git操作命令历史记录对应的<span class="variable">$&#123;上一步操作ID&#125;</span></span></span><br><span class="line">git reflog</span><br><span class="line"><span class="meta">#</span><span class="bash"> s2.恢复到执行该操作的前一个操作状态</span></span><br><span class="line">git reset --hard $&#123;上一步操作ID&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/zhaoyingjie/p/10259715.html">Git 合并多次 commit 、 删除某次 commit</a></li>
<li><a href="https://blog.csdn.net/weixin_34268843/article/details/92032933">git diff 比较本地文件记录和远程文件记录的修改项</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>曾国藩的“六戒五勤”（深度好文）</title>
    <url>/2017/11/12/GuofanZeng-six-rings/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/GuofanZeng-six-rings.jpg" class="full-image" />

<blockquote class="blockquote-center">
<p>一勤天下无难事<br>– by 曾国藩</p>

</blockquote>

<a id="more"></a>
<div class="note success"><p><a href="http://www.cnki.com.cn/Article/CJFDTotal-WSYK201406021.htm">来源：《文史月刊》2014年06期 曾国藩的“五勤”之道 – 作者:罗日荣</a></p>
</div>

<h1 id="1-六戒"><a href="#1-六戒" class="headerlink" title="1. 六戒"></a>1. 六戒</h1><ul>
<li>第一戒：久利之事勿为，众争之地勿往</li>
<li>第二戒：勿以小恶弃人大美，勿以小怨忘人大恩</li>
<li>第三戒：说人之短乃护己之短，夸己之长乃忌人之长</li>
<li>第四戒：利可共而不可独，谋可寡而不可众</li>
<li>第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败</li>
<li>第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半</li>
</ul>
<h2 id="1-1-第一戒：久利之事勿为，众争之地勿往"><a href="#1-1-第一戒：久利之事勿为，众争之地勿往" class="headerlink" title="1.1. 第一戒：久利之事勿为，众争之地勿往"></a>1.1. 第一戒：久利之事勿为，众争之地勿往</h2><p>一直都能获利的事不要做，所有人都想得到的地方不要前去。危城莫入！所有人都向往渴求的，可能有有害。</p>
<p>前半句说：不可贪求过多！日中则移，月满则亏，物盛则衰。世界上没有一劳永逸的事情，也不可能有长久获利的事情，如果有这种能够一直获利的事情，那只能说这种事是表面现象或者骗局，这时候一定要保持头脑清。</p>
<p>后半句是说的安全，众人争执、争斗的地方你不要去，容易惹麻烦或者招致祸患。《论语》上说，“危邦不入，乱邦不居”就是这个意思。当然，这句话里的争，也可以理解为，争利。意思是说，大家都去争抢的利益，你就不要去争抢了，因为那肯定是薄利。</p>
<h2 id="1-2-第二戒：勿以小恶弃人大美，勿以小怨忘人大恩"><a href="#1-2-第二戒：勿以小恶弃人大美，勿以小怨忘人大恩" class="headerlink" title="1.2. 第二戒：勿以小恶弃人大美，勿以小怨忘人大恩"></a>1.2. 第二戒：勿以小恶弃人大美，勿以小怨忘人大恩</h2><p>不要因为别人小的缺点就忽视他的优点，不要因为小小的恩怨就忽略了别人的大恩。</p>
<p>人只要做事就会犯错，这两句话都是告诉我们，不要因为别人的一点小过失，一点道德上的小瑕疵，一点小恩怨，就全盘否定别人的好，忘记别人的恩情。</p>
<p>《礼记》上说， “好而知其恶，恶而知其美者，天下鲜矣。”意思是喜爱一个人而知道其缺点，厌恶而知道其优点。这就是告诫我们，在待人接物的时候，一定不要太感情用事，一定要客观、公正地看待别人的缺点和不足。</p>
<h2 id="1-3-第三戒：说人之短乃护己之短，夸己之长乃忌人之长"><a href="#1-3-第三戒：说人之短乃护己之短，夸己之长乃忌人之长" class="headerlink" title="1.3. 第三戒：说人之短乃护己之短，夸己之长乃忌人之长"></a>1.3. 第三戒：说人之短乃护己之短，夸己之长乃忌人之长</h2><p>经常说别人短处的人，经常夸耀自己长处的人，可以说是“存心不厚，识量太狭。”俗话说，“打人不打脸，揭人不揭短。”经常谈论别人的短处，夸耀自己的长处，不仅是情商低的表现，也必然给自己招来怨恨，埋下祸乱的种子。</p>
<p>汉高祖刘邦曾经随便和韩信讨论各位将领的才能。刘邦问道：“像我自己，能带多少士兵？”韩信说：“陛下不过能带十万人。”刘邦说：“那对你来说呢？”韩信回答：“像我，越多越好。”韩信后来被杀，不能说与他这种性格无关。</p>
<p>曾国藩这句话的意思，入目三分地画出了可这种人的精神肖像。那种经常谈论别人缺点的人，内心其实是借此在掩饰自己的缺点；经常夸耀自己长处的人，内心其实是嫉妒或者想掩盖别人的长处罢了。</p>
<h2 id="1-4-第四戒：利可共而不可独，谋可寡而不可众"><a href="#1-4-第四戒：利可共而不可独，谋可寡而不可众" class="headerlink" title="1.4. 第四戒：利可共而不可独，谋可寡而不可众"></a>1.4. 第四戒：利可共而不可独，谋可寡而不可众</h2><p>利益，往往是众人都渴望得到的，如果谁独占了利益而不与大家分享，那么一定会招致怨恨，甚至成为众矢之的。刘邦攻破咸阳，却不敢占据其地；曹操能够“挟天子以令诸侯”，却终其一生不敢篡汉自立，他们都是怕成为众矢之的。所以，面对利益，一定要权衡取舍之道。</p>
<p>谋划事情，一定要跟有主见的几个人一起，而不要与众人一起谋划事情。正如《战国策》上说，“论至德者不和于俗，成大功者不谋于众。”通俗地说，就是谋求特别重大的事情，不必与众人商量。因为谋求大事的人，自己必定有非同一般的眼光、心胸与气度，自己看准了，去做就是了，如果和别人商量，反倒麻烦。如果别人见识低下，心胸狭小，气度平凡，必定不理解你的想法。七嘴八舌，会动摇你的意志，也会破坏你的信心和情绪。</p>
<h2 id="1-5-第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败"><a href="#1-5-第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败" class="headerlink" title="1.5. 第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败"></a>1.5. 第五戒：天下古今之庸人，皆以一惰字致败；天下古今之才人，皆以一傲字致败</h2><p>庸人，就是普通人，一般的人。对于一般的人来说，没有什么才气，只有勤奋工作才能成就事业，所以最忌讳一个“懒”字。而那些有才的人呢，虽然可凭才气走捷径，更容易成功，但也容易孤傲自大，故步自封，不肯向别人学习，这也是容易失败的。</p>
<p>曾国藩是勤劳的好例子，他其实并不聪明，但是却能以“勤”成就大学问和大事业，可以说正是普通人的榜样。而如项羽、李自成等，占尽天时地利，却因为骄傲而败亡。</p>
<h2 id="1-6-第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半"><a href="#1-6-第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半" class="headerlink" title="1.6. 第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半"></a>1.6. 第六戒：凡办大事，以识为主，以才为辅；凡成大事，人谋居半，天意居半</h2><p>凡是办大事，首先需要有深厚的阅历和识见，并以才能作为辅助；凡是要成就大事的，一半在于人的谋划，另一半就要看天意了，看时机会不会来到。所谓谋事在人，成事在天。</p>
<p>曾国藩明确告诉我们，办大事要以“识”为主，才气、才能不过是辅助罢了。所以恃才傲物的人，往往难以成就大事。当然这里的“识”，不单单指知识，更指的是经验和见识。</p>
<p>而“人谋居半，天意居半。”则是说，我们无论做什么事情，都要抱着“尽人事以听天命”的态度。不要因为有自己不能左右的的因素就不去努力，更不能因为自己努力了，最终却失败了而去怨天尤人。</p>
<h1 id="2-五勤"><a href="#2-五勤" class="headerlink" title="2. 五勤"></a>2. 五勤</h1><p>曾国藩说为官者当有五勤：</p>
<ul>
<li>一曰身勤：险远之路，身往验之；艰苦之境，身亲尝之。</li>
<li>二曰眼勤：遇一人，必详细察看；接一文，必反复审阅。</li>
<li>三曰手勤：易弃之物，随手收拾；易忘之事，随笔记载。</li>
<li>四曰口勤：待同僚，则互相规劝；待下属，则再三训导。</li>
<li>五曰心勤：精诚所至，金石亦开；苦思所积，鬼神迹通。<br>曾国藩的“五勤”之道虽是为官之道，同时也是为人处世之道。</li>
</ul>
<h2 id="2-1-一曰身勤："><a href="#2-1-一曰身勤：" class="headerlink" title="2.1. 一曰身勤："></a>2.1. 一曰身勤：</h2><p>身体力行、以身作则<br>曾国藩曾说“余谓天子或可不亲细事，为大臣者则断不可不亲”。</p>
<p>曾国藩是这么说的，也是这么做的。曾国藩在军中要求自己早起，不论是什么样的天气，不论是什么样的环境，他一定“闻鸡起舞”，练兵督训，办理各项事务。曾国藩对军中将士说：“练兵之道，必须官弁昼夜从事，乃可渐几于熟。如鸡孵卵，如炉炼丹，未可须臾稍离。”《论语》有曰：“其身正，不令而行；其身不正，虽令不从。”</p>
<p>言传不如身教，曾国藩就是这样影响手下的幕僚、将领的。不管是个人修行还是管理团队，这一点至关重要，要给周围的人和下属做一个好榜样。</p>
<h2 id="2-2-二曰眼勤："><a href="#2-2-二曰眼勤：" class="headerlink" title="2.2. 二曰眼勤："></a>2.2. 二曰眼勤：</h2><p>从细微之处识人</p>
<p>曾国藩指派李鸿章训练淮军时，李鸿章带了三个人求见，请曾国藩分配职务给他们。不巧曾刚好饭后出外散步，李命三人在室外等候，自己则进入室内。等到曾散步回来，李请曾传见三人。</p>
<p>曾说不用再召见了，并对李说：“站在右边的是个忠厚可靠的人，可委派后勤补给工作；站在中间的是个阳奉险违之人，只能给他无足轻重的工作；站在左边的人是个上上之材，应予重用。”</p>
<p>李惊问道：“您是如何看出来的呢？”</p>
<p>曾笑道：“刚才我散步回来，走过三人的面前时，右边那人垂首不敢仰视，可见他恭谨厚重，故可委派补给工作。中间那人表面上必恭必敬，但我一走过，立刻左顾右盼，可见他阳奉阴违，故不可用。左边那人始终挺直站立，双目正视，不亢不卑，乃大将之材。”</p>
<p>曾国藩所指左边那位“大将之材”，就是后来担任台湾巡抚鼎鼎有名的刘铭传。</p>
<p>曾国藩从细微之处识人，练就了他的一双慧眼，曾府幕僚鼎盛一时，幕僚在曾国藩平定太平军的过程中出谋划策，立下了赫赫功勋。</p>
<h2 id="2-3-三曰手勤："><a href="#2-3-三曰手勤：" class="headerlink" title="2.3. 三曰手勤："></a>2.3. 三曰手勤：</h2><p>其实就是要养成一个好习惯<br>曾国藩一生养成了三个好习惯：</p>
<ul>
<li>一是反省的习惯：曾国藩每一天都写日记，曾国藩说：“吾人只有进德、修业两事靠得住。进德，则孝弟仁义是也；修业，则诗文作字是也。此二者由我作主，得尺则我之尺也，得寸则我之寸也。今日进一分德，便算积了一升谷；明日修一分业，又算馀了一文钱；德业并增，则家私日起。至于功名富贵，悉由命走，丝毫不能自主。”曾国藩通过写日记进行修身，反思自己在为人处世等方面存在的不足，通过这样的反省，不断修炼自己。</li>
<li>第二个好习惯就是读书习惯，他规定自己每一天必须坚持看历史不下十页，饭后写字不下半小时。曾国藩说“人之气质，由于天生，很难改变，唯读书则可以变其气质。古之精于相法者，并言读书可以变换骨相。”通过坚持读书，曾国藩不仅改变了气质，更磨练了他持之以恒的精神，同时也增长了他的才干，懂得不少为人处世的道理，也让他成了一代大儒。</li>
<li>第三个好习惯就是写家书，据说曾国藩仅在1861年就写了不下253封家书，通过写家书不断训导教育弟弟和子女，在曾国藩的言传身教之下，曾家后人人才辈出。</li>
</ul>
<p>正所谓习惯决定性格，性格决定命运。曾国藩养成很好的习惯，不仅成就了曾国藩自己，也影响了曾家后人。</p>
<h2 id="2-4-四曰口勤："><a href="#2-4-四曰口勤：" class="headerlink" title="2.4. 四曰口勤："></a>2.4. 四曰口勤：</h2><p>他与人的相处之道<br>曾国藩认为同僚相处“两虎相斗，胜者也哀”。</p>
<p>据说曾国藩开始同湖南巡抚骆秉章的关系并不好，咸丰三年，曾国藩在长沙初办团练时，骆秉章压根儿就没把曾国藩放在眼里，对曾国藩的工作也不是十分支持。当绿营与团练闹矛盾时，他总是把偏向着绿营。</p>
<p>让曾国藩特别愤愤不平的是，在靖港兵败，湘军退驻长沙城郊的水陆洲时，骆秉章来到离曾国藩座船仅数十米之遥的码头送客，曾国藩以为他是特意来看望和安慰自己的，内心正十分感激，谁知他送完客人之后竟然转身便走，就当没有看到曾国藩！并且还同长沙官员一起对曾国藩的兵败百般讥讽。</p>
<p>尽管如此，曾国藩并没有逞口舌之争，而是采取曲意忍让的态度，在他为父守孝后第二次出山之时，他特意拜访了骆秉章，态度十分谦恭又十分热情，之前的那点事就当没发生一样。这让骆秉章大感意外，当场表态，以后湘军有什么困难，我们湖南当倾力相助。</p>
<p>“己预立而立人，己欲达而达人”，曾国藩口勤不仅仅是对同僚和上级，对下属也会耐心地训导，曾国藩秉持的这种为人处世之道，不仅让他成就了自己，也成就了如李鸿章、左宗棠、张之洞、刘铭传、胡林翼等名臣，实现了清末短暂的中兴。</p>
<h2 id="2-5-五曰心勤："><a href="#2-5-五曰心勤：" class="headerlink" title="2.5. 五曰心勤："></a>2.5. 五曰心勤：</h2><p>坚定的意志品质</p>
<p>曾国藩不管是从科考还是在平定太平军时“屡败屡战”，都有一种精诚所至的信念在支撑他。从各方面下足工夫，功到自然成。</p>
<p>曾国藩说“天下古今之庸人，皆以一惰字致败。”以勤治惰，以勤治庸，不管是修身自律，还是为人处世，一勤天下无难事。</p>
<p>摘抄于此，与君共勉！</p>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>深度好文</tag>
      </tags>
  </entry>
  <entry>
    <title>基于C++的B树的数据结构设计与编码实现</title>
    <url>/2020/12/04/ImplementationOfBTreeBasedOnCpp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BTreeNodeStruct1.png" class="full-image" />

<h1 id="1-B树的原理及性能"><a href="#1-B树的原理及性能" class="headerlink" title="1. B树的原理及性能"></a>1. B树的原理及性能</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1. 定义"></a>1.1. 定义</h2><p>1970年，R.Bayer和E.mccreight提出了一种适用于外查找的树，它是一种平衡的多叉树，称为<a href="https://baike.baidu.com/item/B%E6%A0%91/5411672?fr=aladdin">B树</a>。</p>
<a id="more"></a>

<p>一棵m阶B树是一棵平衡的m路搜索树。当m取2时，就是我们常见的二叉搜索树。它或者是空树，或者是满足下列性质的树：</p>
<ul>
<li>根结点至少有两个子女；</li>
<li>每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；（┌，向上取整）</li>
<li>除根结点以外的所有非叶子结点的度数正好是关键字总数加1；故<strong>内部子树</strong>个数 k 满足：┌m/2┐ &lt;= k &lt;= m ；</li>
<li>所有叶子节点都位于同一层</li>
</ul>
<p>备注：</p>
<ul>
<li>每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划</li>
<li><strong>叶子结点</strong>的数目正好等于树中所包含的<strong>关键字</strong>总个数加1</li>
<li>B-树中的一个包含n个<strong>关键字</strong>，n+1个<strong>指针</strong>的结点的一般形式为： （n,P0,K1,P1,K2,P2,…,Kn,Pn）</li>
</ul>
<h2 id="1-2-B树的查询性能"><a href="#1-2-B树的查询性能" class="headerlink" title="1.2. B树的查询性能"></a>1.2. B树的查询性能</h2><p>设B树包含N个关键字，有N+1个叶子节点。B树高为：1 +  log┌m/2┐((N+1)/2 )，（叶子节点层不在计算内），每次查询只需要┌m/2┐的对数时间，当m&gt;2时查询效率优于二叉搜索树，故B树数据结构具备较高的查询性能。</p>
<h1 id="2-基于C-实现B树能带来哪些优势？"><a href="#2-基于C-实现B树能带来哪些优势？" class="headerlink" title="2. 基于C++实现B树能带来哪些优势？"></a>2. 基于C++实现B树能带来哪些优势？</h1><ul>
<li>设计数据结构时，可采用面向对象设计思路，可根据数据特征灵活自定义每个 BTree 对象的阶数 m</li>
<li>可利用C++的模板类进行设计，可在实例化时自定义 &lt;KEY_TYPE, VALUE_TYPE&gt; 的具体类型</li>
<li>具备面向对象设计的传统优势：易维护、质量高、效率高、易扩展</li>
</ul>
<h1 id="3-B树的数据结构设计"><a href="#3-B树的数据结构设计" class="headerlink" title="3. B树的数据结构设计"></a>3. B树的数据结构设计</h1><p>由B树的定义可知它是一种多叉树的结构，而组成多叉树的基本单位为节点（中间节点、叶子节点），故实现B数的数据结构设计的关键点在于对B树节点的设计</p>
<h2 id="3-1-B树节点的数据结构设计"><a href="#3-1-B树节点的数据结构设计" class="headerlink" title="3.1. B树节点的数据结构设计"></a>3.1. B树节点的数据结构设计</h2><h3 id="3-1-1-最大m-1个关键字及m个关键字对应值的存放"><a href="#3-1-1-最大m-1个关键字及m个关键字对应值的存放" class="headerlink" title="3.1.1. 最大m-1个关键字及m个关键字对应值的存放"></a>3.1.1. 最大m-1个关键字及m个关键字对应值的存放</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BTreeNodeStruct1.png" alt="myBtree"></p>
<ul>
<li><p>在一个m阶的B树（多叉树）中，每个节点最多包含m-1个关键字及m个关键字指向的值。其中关键字指向的值可能非值的地址（依然为中间节点的地址），则该关键字对应的值采取逐层下放到下一节点Ptr0所指向的值（可能依然为中间节点），直至叶子节点Ptr0指向的值；同理，其他关键字：Key0 ~ Key(m-2)对应的值为：Ptr1 ~ Ptr(m-1)，若非叶子节点则逐层下放直至叶子节点的Ptr0所指向的值。</p>
</li>
<li><p>考虑到不是每个节点都存满m-1个关键字，故还需要一个变量记录当前节点已有关键字数。尽管可以通过遍历Ptrs1~Ptr(m-1)，统计为NULL的个数cnt，从而得到已有关键字数：m - 1 - cnt，但当m阶数过大(实际应用阶数m一般大于100)时，浪费很多不必要的CPU资源计算现有关键字数，故采用4字节int直接记录当前节点所包含关键字数</p>
</li>
<li><p>对于中间节点，其Ptrs指针指向的子节点可能为：叶子节点或中间节点，故还需要一个bool值来记录当前节点指向的是叶子节点还是中间节点</p>
</li>
<li><p>分析至此可知，只需对叶子节点类定义：包含关键字数变量和两成员数组变量: 关键字数组KEY_TYPE[m - 1]、值指针数组VALUE_TYPE[m]；中间节点类定义：指向的下一节点是否是叶子节点、包含关键字数变量和两成员数组变量：关键字数组KEY_TYPE[m - 1]、子节点指针数组BTreeNode*[m]</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 叶子节点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeLeafNode</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> keyNum;<span class="comment">// 当前节点所含关键字个数</span></span><br><span class="line">    KEY_TYPE* keys;<span class="comment">// 关键字数组</span></span><br><span class="line">    VALUE_TYPE* valuePtrs;<span class="comment">// 指向value的指针数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间节点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeMiddleNode</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isChildLeafNode;<span class="comment">// 指向的子节点是否是叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> keyNum;<span class="comment">// 当前节点所含关键字个数</span></span><br><span class="line">    KEY_TYPE* keys;<span class="comment">// 关键字数组</span></span><br><span class="line">    <span class="keyword">void</span>* childPtrs;<span class="comment">// isChildLeafNode(true)--强转为(BTreeLeafNode*);isChildLeafNode(false)--强转为(BTreeMiddleNode*);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-优化：融合叶子节点类和中间节点类"><a href="#3-1-2-优化：融合叶子节点类和中间节点类" class="headerlink" title="3.1.2. 优化：融合叶子节点类和中间节点类"></a>3.1.2. 优化：融合叶子节点类和中间节点类</h3><ul>
<li><p>比较叶子节点类与中间节点类易知，其大多数成员变量相同，为简化后续管理节点类管理及后续中间节点与叶子节点相互转换，尝试将叶子节点类与中间节点类融合。采用一个bool值(isLeaf)记录当前节点是否是叶子节点，则中间节点类的指向子节点类型(原: isChildLeafNode)可通过判断子节点的isLeaf的bool值判断。</p>
</li>
<li><p>进一步优化。叶子节点类的指向value的指针数组VALUE_TYPE*[m]与中间节点的指向下一节点子节点指针数组BTreeNode*[m]所占内存一致，且互斥不可能在融合类中同时使用这两个数组，故采用union使这两个数组复用同一块内存以节省内存开销。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isLeaf;<span class="comment">// 是否是叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> keyNum;<span class="comment">// 当前节点所含关键字个数</span></span><br><span class="line">    KEY_TYPE* keys;<span class="comment">// 关键字数组</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VALUE_TYPE* valuePtrs;<span class="comment">// 若为叶子节点，指向value的指针数组</span></span><br><span class="line">        BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;** childPtrs;<span class="comment">// 子节点指针数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>至此，存储节点信息已基本完成。但由于后续分裂节点，维持节点平衡需要用到该节点的父节点信息，若从根节点开始向下遍历较浪费CPU资源和时间开销，故在每个节点增加记录其父节点地址的指针变量parent，最终B树节点类的数据结构如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BTree</span>&lt;</span>KEY_TYPE, VALUE_TYPE&gt;;<span class="comment">// 申明友元类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isLeaf;<span class="comment">// 是否是叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> keyNum;<span class="comment">// 当前节点所含关键字个数</span></span><br><span class="line">    BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;* parent;<span class="comment">// 父指针</span></span><br><span class="line">    KEY_TYPE* keys;<span class="comment">// 关键字数组</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        VALUE_TYPE* valuePtrs;<span class="comment">// 若为叶子节点，指向value的指针数组</span></span><br><span class="line">        BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;** childPtrs;<span class="comment">// 子节点指针数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-B树管理类的数据结构设计"><a href="#3-2-B树管理类的数据结构设计" class="headerlink" title="3.2. B树管理类的数据结构设计"></a>3.2. B树管理类的数据结构设计</h2><p>相比于B树节点类，B数管理类的数据结构则相对简单：维护3个变量分别记录该实例的阶数(m)，最少关键字数(minKeyNum)，最多关键字个数(maxKeyNum)以及根节点(root)便可，其数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m; <span class="comment">// m阶，┌m/2┐ - 1 &lt;= j &lt;= m - 1</span></span><br><span class="line">    <span class="keyword">int</span> maxKeyNum; <span class="comment">// 最多关键字个数 =  m - 1;</span></span><br><span class="line">    <span class="keyword">int</span> minKeyNum; <span class="comment">// 最少关键字个数 = ┌m/2┐ - 1 = (m - 1) / 2 == maxKeyNum / 2</span></span><br><span class="line">    BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;* root; <span class="comment">// 根节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-B树支持的操作及编码实现"><a href="#4-B树支持的操作及编码实现" class="headerlink" title="4. B树支持的操作及编码实现"></a>4. B树支持的操作及编码实现</h1><h2 id="4-1-实例化一个m阶的B树实例"><a href="#4-1-实例化一个m阶的B树实例" class="headerlink" title="4.1. 实例化一个m阶的B树实例"></a>4.1. 实例化一个m阶的B树实例</h2><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/newBTree.png" alt="myBtree"></p>
<ol>
<li>实例化BTree，申请BTree类所需内存，根据输入的阶数m初始化成员变量: 阶数(m)，最少关键字数(minKeyNum)，最多关键字个数(maxKeyNum)</li>
<li>实例化一个B树节点BTreeNode作为根节点(根节点为叶子节点)，初始化BTreeNode成员变量，并根据此实例化B树的阶数申请关键字数组keys 和 指向value的指针数组valuePtrs所需内存。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B树管理类，构造函数</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line">BTree(<span class="keyword">int</span> m = <span class="number">3</span>) : m(m), maxKeyNum(m - <span class="number">1</span>), minKeyNum((m - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例化空树根节点（也是叶子节点）</span></span><br><span class="line">    root = <span class="keyword">new</span> BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;(maxKeyNum);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create a BTree, which max Key num = &quot;</span> &lt;&lt; maxKeyNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B树节点类，构造函数</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> * @param maxKeyNum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line">BTreeNode(<span class="keyword">int</span> maxKeyNum, <span class="keyword">bool</span> isLeaf = <span class="literal">true</span>) : isLeaf(isLeaf), keyNum(<span class="number">0</span>), parent(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    keys = <span class="keyword">new</span> KEY_TYPE[maxKeyNum];</span><br><span class="line">    <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">        valuePtrs = <span class="keyword">new</span> VALUE_TYPE[maxKeyNum + <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        childPtrs = <span class="keyword">new</span> BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;*[maxKeyNum + <span class="number">1</span>]&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-释放一个m阶的B树实例"><a href="#4-2-释放一个m阶的B树实例" class="headerlink" title="4.2. 释放一个m阶的B树实例"></a>4.2. 释放一个m阶的B树实例</h2><ol>
<li><p>释放BTree实例，会调用BTree类的析构函数释放普通类型的成员变量和B树节点BTreeNode指针(root)指向的内存。</p>
</li>
<li><p>释放BTreeNode实例(eg. root)，会调用BTreeNode类的析构函数释放普通类型的成员变量，手动申请的关键字数组keys，会根据当前节点是否是叶子节点遍历释放申请的value的指针数组或遍历并递归释放中间节点的子节点指针数组指向的内存。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B树管理类，析构函数</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line">~BTree() &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B树节点类，析构函数</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line">~BTreeNode() &#123;</span><br><span class="line">    <span class="keyword">delete</span> []keys;</span><br><span class="line">    <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">        <span class="keyword">delete</span> []valuePtrs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清理释放子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyNum + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (childPtrs[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> childPtrs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> []childPtrs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-二分法查询关键字"><a href="#4-3-二分法查询关键字" class="headerlink" title="4.3. 二分法查询关键字"></a>4.3. 二分法查询关键字</h2><p>在一个m阶的B树（多叉树）中，每个节点最多包含m-1个关键字（实际使用为减少层高，一般m会较大eg. m &gt; 100），且这些关键字严格递增。从根节点开始查询某key时，若只是采用从左至右线性遍历节点的关键字数组将浪费较多的Cpu资源：O(m)，且没有利用好严格递增的特性，故在查询关键字时，一般采用二分法以减少每个节点检索关键字时间：O(log(m))。</p>
<p>由于B树满足二叉搜索树特性（值：右 &lt; 根 &lt; 左），在从根节点开始查询关键字时，若无法在本节点找到关键字 k，则k有可能在以本节点**不超过k关键字**指向节点为根的子树中（此节点非叶节点），故搜索关键字可简化为：对当前节点，返回keys[i] &gt;= key对应的子节点可能所在下标 i，外层判断keys[i] 的值与key，直至找到key，或下降至叶子节点都未找到。</p>
<h3 id="4-3-1-对每个节点，二分法返回第一个-keys-i-gt-key-的下标-i"><a href="#4-3-1-对每个节点，二分法返回第一个-keys-i-gt-key-的下标-i" class="headerlink" title="4.3.1. 对每个节点，二分法返回第一个 keys[i]  &gt;=  key 的下标 i"></a>4.3.1. 对每个节点，二分法返回第一个 keys[i]  &gt;=  key 的下标 i</h3><p>其中，返回当前节点第一个 keys[i]  &gt;=  key 对应的子节点可能所在下标 i 伪代码如下：</p>
<ul>
<li>若本节点若无关键字且非叶子节点，则返回下标0</li>
<li>二分法找到不超过 key 值所对应的下标 i<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查询关键字数组中，第一个keys[i] &gt;= key对应的子节点可能所在下标 i</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> * @tparam VALUE_TYPE</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @return i -- 可能的子节点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;::binarySearchKey(KEY_TYPE key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (keyNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = keyNum - <span class="number">1</span>, mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right &amp;&amp; keys[mid] != key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys[mid] &gt; key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key &gt; keys[mid] ? mid + <span class="number">1</span> : mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-3-2-外层二分查询关键字key"><a href="#4-3-2-外层二分查询关键字key" class="headerlink" title="4.3.2. 外层二分查询关键字key"></a>4.3.2. 外层二分查询关键字key</h3><p>外层判断keys[i] 的值与key，若keys[i] 不等于 key，若非叶子节点，则将查找任务下降为子节点childPtrs[i]查找key，若直至叶子节点都未找到，则返回nullptr；若 keys[i] 等于 key，但此时节点非叶子节点，则依次下降遍历子节点的第0个指针数组指向的子节点，直至叶子节点ptr-&gt;valuePtrs[0]即为 key 对应值的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询以当前节点为根的BTree子树中，是否已经存在 Key，若存在返回其value指针</span></span><br><span class="line"><span class="comment"> * @tparam KEY_TYPE</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @return nullptr -- 未找到key; others -- 其value指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title">VALUE_TYPE</span>&gt;</span></span><br><span class="line">VALUE_TYPE BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;::getValue(KEY_TYPE key) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = binarySearchKey(key);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; keyNum &amp;&amp; keys[i] == key) &#123;</span><br><span class="line">        <span class="comment">// 若是叶子节点，则返回value指针，否则继续下落到叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">            <span class="keyword">return</span> valuePtrs[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        BTreeNode&lt;KEY_TYPE, VALUE_TYPE&gt;* ptr = childPtrs[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (!ptr-&gt;isLeaf) &#123;</span><br><span class="line">            ptr = ptr-&gt;childPtrs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;valuePtrs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是叶子节点（未找到），返回nullptr；若非叶子节点，继续向下寻找</span></span><br><span class="line">    <span class="keyword">return</span> isLeaf ? <span class="literal">nullptr</span> : childPtrs[i]-&gt;getValue(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-插入-lt-key-value-gt-键值对"><a href="#4-4-插入-lt-key-value-gt-键值对" class="headerlink" title="4.4. 插入&lt;key, value&gt;键值对"></a>4.4. 插入&lt;key, value&gt;键值对</h2><p>由于m阶的B树（多叉树）中，每个节点最多包含m-1个关键字（有限），故插入&lt;key, value&gt;键值对前，需判断待插入节点的关键字剩余容量后操作：若非零（未满插入），直接填充&lt;key, value&gt;到已有的keys数组尾部即可；若为零（已满插入），需要对节点进行分裂操作，为加速插入过程，博主实现时将节点分裂和插入融合为一个操作<strong>分裂插入</strong>。</p>
<h3 id="4-4-1-先找到要插入该key的节点"><a href="#4-4-1-先找到要插入该key的节点" class="headerlink" title="4.4.1. 先找到要插入该key的节点"></a>4.4.1. 先找到要插入该key的节点</h3><ul>
<li>从根节点开始，查找key</li>
<li>若key已存在，则只需下降到叶节点，将其value指针指向新value地址即可</li>
<li>若向下搜索到叶节点都未找到key，则该叶子节点即为我们要插入&lt;key, value&gt;键值对的节点</li>
</ul>
<h3 id="4-4-2-未满节点插入-lt-key-value-gt-键值对"><a href="#4-4-2-未满节点插入-lt-key-value-gt-键值对" class="headerlink" title="4.4.2. 未满节点插入&lt;key, value&gt;键值对"></a>4.4.2. 未满节点插入&lt;key, value&gt;键值对</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BTreeNotFullInsert.png" alt="BTreeNotFullInsert"></p>
<p>对于节点关键字节点未满插入，只需将新的&lt;key, value&gt;键值对对应插入尾部即可。</p>
<h3 id="4-4-3-已满节点插入-lt-key-value-gt-键值对"><a href="#4-4-3-已满节点插入-lt-key-value-gt-键值对" class="headerlink" title="4.4.3. 已满节点插入&lt;key, value&gt;键值对"></a>4.4.3. 已满节点插入&lt;key, value&gt;键值对</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BTreeSplitInsert.png" alt="BTreeSplitInsert"><br>对于关键字已满的节点，需新增右兄弟节点，将原已满节点的后半部分挪到右兄弟节点（“<strong>分裂</strong>”），会上升一个key到其父节点作为新增右兄弟节点对应的key（若无则创建新父节点），再插入新节点。博主这里将这两步操作(分裂 + 插入)合为一步以提高效率：</p>
<ul>
<li>新增右兄弟节点 rightBrotherPtr</li>
<li>下标变换以模拟过载1插入该key后的数组分裂</li>
<li>记录模拟过载1后的数组对应 midKey，作为新增右兄弟节点在父节点的key值&lt;midKey, rightBrotherPtr&gt;</li>
<li>将 midKey 之后的后半部分key及其对应valuePtr挪到右兄弟节点</li>
<li>刷新分裂后两兄弟节点的关键字容量 keyNum 的数值</li>
<li>最后将新增的右兄弟节点和其对应的Key值: &lt;rightBrotherKey, rightBrotherPtr&gt;，插入共同的父节点（无父节点则需新增父节点/root节点）</li>
</ul>
<h2 id="4-5-删除-lt-key-value-gt-键值对"><a href="#4-5-删除-lt-key-value-gt-键值对" class="headerlink" title="4.5. 删除&lt;key, value&gt;键值对"></a>4.5. 删除&lt;key, value&gt;键值对</h2><ul>
<li>对于&lt;key, value&gt;键值对的删除，若B树中查无该key，则不多讨论直接返回false。由于所有的记录valuePtr的指针数组都在叶子节点层，若在叶子节点查到该key，则还好，若在中间节点查到该key，意味着该key对应的value的地址记录在其子树下降直至叶子节点层的第0个元素内，对该key删除后，若子树非空，还需在最初找到该key的位置补充一个key作为新子树的key。</li>
<li>B树作为一颗m阶搜索树，存在搜索树的缺陷——退化为链表的，另一方面为了降低层高，B树还要求了每个节点的最少关键字数(m/2, m阶)，以保证查询效率，若删除键值对后发现关键字数小于m/2，还需进行一系列平衡操作。</li>
</ul>
<h3 id="4-5-1-删除-lt-key-value-gt-键值对-假设删除后-keyNum-gt-m-2，无需考虑平衡"><a href="#4-5-1-删除-lt-key-value-gt-键值对-假设删除后-keyNum-gt-m-2，无需考虑平衡" class="headerlink" title="4.5.1. 删除&lt;key, value&gt;键值对 (假设删除后 keyNum &gt; m/2，无需考虑平衡)"></a>4.5.1. 删除&lt;key, value&gt;键值对 (假设删除后 keyNum &gt; m/2，无需考虑平衡)</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BTreeRemoveWithoutBalance.png" alt="BTreeRemoveWithoutBalance"></p>
<ul>
<li>若此节点非叶子节点，记录该key地址recordKey，继续下落到叶子节点执行删除（若子树非空，需更新整个子树的key，若子树为空，还需递归上层删除）</li>
<li>若下落的到叶子节点，关键字数为0，释放该叶子节点，并执行递归向上删除</li>
<li>若下落到叶子节点，关键字数非0，则截取下一个key以更新recordKey，删除叶子节点对应的valuePtr值，其他key及对应记录的value地址前挪。</li>
</ul>
<h2 id="4-6-删除-lt-key-value-gt-键值对后的平衡操作"><a href="#4-6-删除-lt-key-value-gt-键值对后的平衡操作" class="headerlink" title="4.6. 删除&lt;key, value&gt;键值对后的平衡操作"></a>4.6. 删除&lt;key, value&gt;键值对后的平衡操作</h2><h3 id="4-6-1-尝试从左、右兄弟节点挪借关键字"><a href="#4-6-1-尝试从左、右兄弟节点挪借关键字" class="headerlink" title="4.6.1. 尝试从左、右兄弟节点挪借关键字"></a>4.6.1. 尝试从左、右兄弟节点挪借关键字</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BTreeBalanceBrowFromBro.png" alt="BTreeBalanceBrowFromBro"></p>
<ul>
<li>若无左（或右）兄弟节点，或左右节点无法提供可挪借关键字，则挪借失败</li>
<li>若存在左（或右）兄弟节点 且 左（或右）兄弟节点关键字字数大于 minKeyNum，则可从左（或右）兄弟挪借关键字</li>
<li>若左、右兄弟节点均可挪借关键字数，从平衡角度选择可挪借关键字数较多的一方挪借</li>
</ul>
<h3 id="4-6-2-尝试与左或右兄弟节点合并"><a href="#4-6-2-尝试与左或右兄弟节点合并" class="headerlink" title="4.6.2. 尝试与左或右兄弟节点合并"></a>4.6.2. 尝试与左或右兄弟节点合并</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BTreeBalanceMergeWithBro.png" alt="BTreeBalanceMergeWithBro"></p>
<ul>
<li>若存在左兄弟节点，且左兄弟节点关键字 + 本节点关键字 + 1 &lt;= 最大关键字数，则可与左兄弟节点合并</li>
<li>若存在右兄弟节点，且右兄弟节点关键字 + 本节点关键字 + 1 &lt;= 最大关键字数，则可与右兄弟节点合并</li>
<li>若左、右兄弟节点均不可合并，则返回合并失败</li>
<li>若均可合并，选取左右兄弟节点中，从平衡角度选择关键字数较少的一方合并</li>
</ul>
<h3 id="4-6-3-若节点的关键词数为0，且非叶子节点（降层）"><a href="#4-6-3-若节点的关键词数为0，且非叶子节点（降层）" class="headerlink" title="4.6.3. 若节点的关键词数为0，且非叶子节点（降层）"></a>4.6.3. 若节点的关键词数为0，且非叶子节点（降层）</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/BTreeBalanceReduceLevel.png" alt="BTreeBalanceReduceLevel"></p>
<ul>
<li>若当前节点关键字数大于0，或为叶子节点，不进行降层</li>
<li>若其兄弟节点与其node-&gt;childPtrs[0] 是否是叶子节点属性不同，则不降层</li>
<li>降层处理，将其父节点指向其的childPtrs[i]指针，指向其node-&gt;childPtrs[0]指向的值，后释放node节点</li>
<li>若该节点为根节点，则将root指针指向node-&gt;childPtrs[0]（更新root节点），清除父节点指向node指针的值后释放node节点</li>
</ul>
<h2 id="4-7-更多详细的实现细节，请阅读我上传到Git的源码吧"><a href="#4-7-更多详细的实现细节，请阅读我上传到Git的源码吧" class="headerlink" title="4.7. 更多详细的实现细节，请阅读我上传到Git的源码吧:)"></a>4.7. 更多详细的实现细节，请阅读我上传到Git的源码吧:)</h2><div class="note success"><p> 博主基于C++的B树的数据结构设计与编码实现源码详见：<br><a href="https://github.com/EisenHao/Cpp_Learning/blob/master/myBTree.h">https://github.com/EisenHao/Cpp_Learning/blob/master/myBTree.h</a></p>
</div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2019/04/05/JavaStudyNote/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/JavaStudyNote.png" class="full-image" />

<h1 id="1-Java基础知识"><a href="#1-Java基础知识" class="headerlink" title="1. Java基础知识"></a>1. Java基础知识</h1><h2 id="1-1-引用-amp-对象"><a href="#1-1-引用-amp-对象" class="headerlink" title="1.1. 引用 &amp; 对象"></a>1.1. 引用 &amp; 对象</h2><ul>
<li><strong>对象</strong>：类的实例化，实质为运行时堆内为类内各属性值顺序分配的一组内存空间。<br>类变量(static)只在堆内分配一次，类内方法只在代码段内存一次。<a id="more"></a></li>
<li><strong>引用</strong>：传递消息的入口（通过引用访问与之关联的对象的各属性值或调用对象的方法，类似方法调用），引用可不指向对象单独存在（但仅声明无意义）</li>
</ul>
<p>备注：Java中除基本类型外，其他类型都是类<strong>class</strong>，都能实例化为对象，eg. String</p>
<h3 id="1-1-1-Java引用与C-C-指针的区别"><a href="#1-1-1-Java引用与C-C-指针的区别" class="headerlink" title="1.1.1. Java引用与C/C++指针的区别"></a>1.1.1. Java引用与C/C++指针的区别</h3><ul>
<li><p>相同点：<br>Java中的引用和C/C++中的指针本质上都是通过一个别名，找到要操作的目标（变量对象等），方便在程序里操作</p>
</li>
<li><p>不同点：</p>
<ul>
<li>指针可以改变所指向的对象；引用一旦绑定某个对象后总是指向该对象不可改变。原因：在编译时，<ul>
<li>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。</li>
<li>符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的地址值可以改），而引用对象不能改。</li>
</ul>
</li>
<li>指针在32位系统中占4字节（64位系统中占8字节）；引用为被Java封装后的所指向对象的实际地址</li>
<li>指针声明时不会占内存，用到时才会分配内存；引用（编译时被确定为对象的实际地址）没有实体不占空间</li>
<li>指针可能产生越界访问；引用通过’.’访问所属类的属性值，有边界控制，不会出现越界</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-equals-的引用和对象区别（忽视将会造成重大问题）"><a href="#1-1-2-equals-的引用和对象区别（忽视将会造成重大问题）" class="headerlink" title="1.1.2. equals()的引用和对象区别（忽视将会造成重大问题）"></a>1.1.2. equals()的引用和对象区别（忽视将会造成重大问题）</h3><ul>
<li>equals()默认行为是比较引用（而非对象的内容），如自定义类调用</li>
<li>大多数Java类库实现了equals()可比较对象的内容<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test t1 = <span class="keyword">new</span> Test(<span class="number">10</span>);</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test(<span class="number">10</span>);</span><br><span class="line">System.out.println(t1.equals(t2));<span class="comment">//输出false，equals()默认行为是比较引用</span></span><br><span class="line"></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">//输出true，Java的String类库实现了equals()比较对象的内容</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-2-String-用法小记"><a href="#1-2-String-用法小记" class="headerlink" title="1.2. String 用法小记"></a>1.2. String 用法小记</h2><h3 id="1-2-1-String-当作对象处理需要new"><a href="#1-2-1-String-当作对象处理需要new" class="headerlink" title="1.2.1. String 当作对象处理需要new"></a>1.2.1. String 当作对象处理需要new</h3><p>Java将String视为一个对象，而非C/C++中的数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String();</span><br><span class="line">String str2;<span class="comment">//只是声明引用，但未与对象关联</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-初始化字符串的其他方法"><a href="#1-2-2-初始化字符串的其他方法" class="headerlink" title="1.2.2. 初始化字符串的其他方法"></a>1.2.2. 初始化字符串的其他方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello World&quot;</span>;<span class="comment">//静态初始化</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//创建对象初始化</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="keyword">char</span> Array[]);<span class="comment">//将字符数组转化为字符串</span></span><br><span class="line">String str = <span class="keyword">new</span> String(str1 + str2);</span><br><span class="line">String str = str1;<span class="comment">//实测也是可以的，是根据str1重新分配内存并复制值，并非引用str1</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-访问字符串指定下标的字符"><a href="#1-2-3-访问字符串指定下标的字符" class="headerlink" title="1.2.3. 访问字符串指定下标的字符"></a>1.2.3. 访问字符串指定下标的字符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.charAt(<span class="number">1</span>);<span class="comment">//访问索引为1的字符（返回&quot;Hello&quot;中的&#x27;e&#x27;）</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-判断两个字符串是否相等"><a href="#1-2-4-判断两个字符串是否相等" class="headerlink" title="1.2.4. 判断两个字符串是否相等"></a>1.2.4. 判断两个字符串是否相等</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str1.equals(str2);<span class="comment">//严格区分大小写</span></span><br><span class="line">str1.equalsIgnoreCase(str2);<span class="comment">//不区分大小写</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-5-比较两个字符串"><a href="#1-2-5-比较两个字符串" class="headerlink" title="1.2.5. 比较两个字符串"></a>1.2.5. 比较两个字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str1.compareTo(str2);<span class="comment">//只有当str1与str2完全相等时才返回0, 否则返回按次序比较第一个不同字符的计算差值 eg:  &quot;aB&quot;.compareTo(&quot;aC&quot;);//会返回&#x27;B&#x27;-&#x27;C&#x27;的值-1</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-6-分割字符串"><a href="#1-2-6-分割字符串" class="headerlink" title="1.2.6. 分割字符串"></a>1.2.6. 分割字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello world xiao ming&quot;</span>;</span><br><span class="line">String[] strArray = str.split(<span class="string">&quot; &quot;</span>);<span class="comment">//用空格字符串将上述字符串分割</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">    System.out.println(strArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果：</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">xiao</span></span><br><span class="line"><span class="comment">ming</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String str = <span class="string">&quot;Hello world xiao ming&quot;</span>;</span><br><span class="line">String[] strArray = str.split(<span class="string">&quot; &quot;</span>, <span class="number">3</span>);<span class="comment">//用空格字符串将上述字符串分割, 最多分3个子串（按空格正常分前两个，最后一个为剩余字符子串）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">    System.out.println(strArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果：</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">xiao ming</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-7-查找子串"><a href="#1-2-7-查找子串" class="headerlink" title="1.2.7. 查找子串"></a>1.2.7. 查找子串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.indexOf(String s);<span class="comment">//返回子串s第一次出现的下标</span></span><br><span class="line">str.lastIndexOf(String s);<span class="comment">//返回子串s最后出现的下标</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-8-返回字符串去除前后空格的子串的副本"><a href="#1-2-8-返回字符串去除前后空格的子串的副本" class="headerlink" title="1.2.8. 返回字符串去除前后空格的子串的副本"></a>1.2.8. 返回字符串去除前后空格的子串的副本</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = str.trim();<span class="comment">//忽略字符串前后空格字符</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-9-替换子串"><a href="#1-2-9-替换子串" class="headerlink" title="1.2.9. 替换子串"></a>1.2.9. 替换子串</h3><p>将字符串内的部分子串替换为另外子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String newStr = str.replace(<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;abc&quot;</span>);<span class="comment">//将字符串str内所有“ABC”子串全部替换为“abc”</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-10-判断字符串是否以目标子串开始或结束"><a href="#1-2-10-判断字符串是否以目标子串开始或结束" class="headerlink" title="1.2.10. 判断字符串是否以目标子串开始或结束"></a>1.2.10. 判断字符串是否以目标子串开始或结束</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> a = str.startsWith(<span class="string">&quot;He&quot;</span>);<span class="comment">//字符串是否以子串“He”开头，返回true</span></span><br><span class="line"><span class="keyword">boolean</span> b = str.endsWith(<span class="string">&quot;llo&quot;</span>);<span class="comment">//字符串是否以子串“llo”结尾，返回true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-11-转换大小写字符"><a href="#1-2-11-转换大小写字符" class="headerlink" title="1.2.11. 转换大小写字符"></a>1.2.11. 转换大小写字符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = str.toLowerCase();<span class="comment">//将字符串内所有大写字符全转换为对应小写字符</span></span><br><span class="line">str = str.toUpperCase();<span class="comment">//将字符串内所有小写字符全转换为对应大写字符</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-数组用法小记"><a href="#1-3-数组用法小记" class="headerlink" title="1.3. 数组用法小记"></a>1.3. 数组用法小记</h2><h3 id="1-3-1-声明初始化二维数组"><a href="#1-3-1-声明初始化二维数组" class="headerlink" title="1.3.1. 声明初始化二维数组"></a>1.3.1. 声明初始化二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array1[][] = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> array2[<span class="number">3</span>][];</span><br><span class="line">array2[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">array2[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">array2[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-填充数组"><a href="#1-3-2-填充数组" class="headerlink" title="1.3.2. 填充数组"></a>1.3.2. 填充数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(array, <span class="number">8</span>);<span class="comment">//将array1数组的所有元素值更改为8</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-排序数组"><a href="#1-3-3-排序数组" class="headerlink" title="1.3.3. 排序数组"></a>1.3.3. 排序数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(array);<span class="comment">//用Java自带的(快排算法)对array1进行排序，默认从小到大</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-复制数组"><a href="#1-3-4-复制数组" class="headerlink" title="1.3.4. 复制数组"></a>1.3.4. 复制数组</h3><h4 id="1-3-4-1-copyOf-int-a-int-length"><a href="#1-3-4-1-copyOf-int-a-int-length" class="headerlink" title="1.3.4.1. copyOf(int a[], int length);"></a>1.3.4.1. copyOf(int a[], int length);</h4><ul>
<li>若length小于a.length，创建length大小的数组，然后复制a的前length长度的元素</li>
<li>若length大于a.length，创建length大小的数组，复制整个数组a，其后部分默认值0填充<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newArray[] = Arrays.copyOf(array, <span class="number">5</span>);<span class="comment">//复制array前5个元素组成一个新数组</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-3-4-2-copyOfRange-int-a-int-fromIndex-int-toIndex"><a href="#1-3-4-2-copyOfRange-int-a-int-fromIndex-int-toIndex" class="headerlink" title="1.3.4.2. copyOfRange(int a[], int fromIndex, int toIndex);"></a>1.3.4.2. copyOfRange(int a[], int fromIndex, int toIndex);</h4><p>创建toIndex-fromIndex大小的数组（可大于原始数组，其后用0填充），复制数组a从下标fromIndex到下标toIndex-1的元素<br><strong>备注</strong>：</p>
<ul>
<li>若toIndex-1 &gt; a.length-1，只复制到a[a.length-1]且其后填0</li>
<li>fromIndex 必须在取值范围[0, a.length-1]内，否则报错</li>
</ul>
<h4 id="1-3-4-3-特殊用法，给已固定数组扩容"><a href="#1-3-4-3-特殊用法，给已固定数组扩容" class="headerlink" title="1.3.4.3. 特殊用法，给已固定数组扩容"></a>1.3.4.3. 特殊用法，给已固定数组扩容</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array = Arrays.copyOf(array, array.length*<span class="number">2</span>);<span class="comment">//扩容array一倍，其后扩容的元素默认值为0</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-产生随机数小记"><a href="#1-4-产生随机数小记" class="headerlink" title="1.4. 产生随机数小记"></a>1.4. 产生随机数小记</h2><p>Java产生随机数的方式有两种：调用Math类的random()方法、调用Random类</p>
<h3 id="1-4-1-调用Math类的random-方法"><a href="#1-4-1-调用Math类的random-方法" class="headerlink" title="1.4.1. 调用Math类的random()方法"></a>1.4.1. 调用Math类的random()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> num = Math.random();<span class="comment">//产生 [0, 1.0) 之间的随机数</span></span><br><span class="line"><span class="keyword">double</span> num2 = a + Math.random() * (b - a);<span class="comment">//产生 [a, b) 之间的随机数</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-调用Random类"><a href="#1-4-2-调用Random类" class="headerlink" title="1.4.2. 调用Random类"></a>1.4.2. 调用Random类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();<span class="comment">//Java运行时JVM以当前系统时间为随机数生成器的种子</span></span><br><span class="line">Random r2 = <span class="keyword">new</span> Random(SeedValue);<span class="comment">//手动设置种子数值</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();<span class="comment">//Java运行时JVM以当前系统时间为随机数生成器的种子</span></span><br><span class="line"><span class="keyword">int</span> b = r.nextInt(<span class="number">100</span>);<span class="comment">//产生一个在 [0, 100)范围内的整数</span></span><br><span class="line"><span class="keyword">boolean</span> c = r.nextBoolean();<span class="comment">//产生一个随机布尔值</span></span><br><span class="line"><span class="keyword">float</span> d = r.nextFloat();<span class="comment">//产生一个随机单精度浮点数</span></span><br><span class="line"><span class="keyword">double</span> e = r.nextDouble();<span class="comment">//产生一个随机双精度浮点数</span></span><br><span class="line"><span class="keyword">double</span> f = r.nextGaussian();<span class="comment">//产生一个概率密度为高斯分布的随机双精度浮点数（连续调用一组）</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：两次函数调用的时间间隔过小，可能返回相同的随机数。</p>
<h1 id="2-Java核心技术"><a href="#2-Java核心技术" class="headerlink" title="2. Java核心技术"></a>2. Java核心技术</h1><h2 id="2-1-Java类的继承小记"><a href="#2-1-Java类的继承小记" class="headerlink" title="2.1. Java类的继承小记"></a>2.1. Java类的继承小记</h2><p>用代码更亲切地展示继承相关细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//爷爷类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandParents</span> </span>&#123;</span><br><span class="line">    GrandParents()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用爷爷类的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;<span class="comment">//无特殊要求非必须，Java垃圾回收机制会自动回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;销毁爷爷类实例&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.finalize();<span class="comment">//爷爷类的父类是Object类，Java每个类都直接或间接继承于java.lang.Object类，爷爷类定义等价于class GrandParents extends Object &#123;...&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类（继承于爷爷类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parents</span> <span class="keyword">extends</span> <span class="title">GrandParents</span> </span>&#123;</span><br><span class="line">    Parents(String name)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用父类:&quot;</span>+name+<span class="string">&quot;的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;<span class="comment">//无特殊要求非必须，Java垃圾回收机制会自动回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;销毁父类实例&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类（继承于父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Childron</span> <span class="keyword">extends</span> <span class="title">Parents</span> </span>&#123;</span><br><span class="line">    Childron()&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;Parents&quot;</span>);<span class="comment">//父类构造函数有参数时，不能自动调用，只能通过super显示调用父类构造函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用子类的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//重写父类doSomething函数，但修改权限只能不变或放大，不能缩小（若改为private会报错）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;<span class="comment">//【方法的重载】参数类型不同、参数个数不同、参数顺序不同均可构成重载(仅返回值不同不能构成重载)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span>... a)</span> </span>&#123;<span class="comment">//定义不定长方法</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            sum += a[i];<span class="comment">//当作数组来操作参数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;<span class="comment">//无特殊要求非必须，Java垃圾回收机制会自动回收</span></span><br><span class="line">        System.out.println(<span class="string">&quot;销毁子类实例&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Childron c = <span class="keyword">new</span> Childron();</span><br><span class="line">        System.out.println(c.doSomething(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.finalize();<span class="comment">//手动调用finalize销毁子类实例</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先实例化父类对象，再实例化子类对象；销毁时先销毁子类再逐级销毁父类实例</span></span><br><span class="line"><span class="comment">/* 运行结果：</span></span><br><span class="line"><span class="comment">调用爷爷类的构造函数</span></span><br><span class="line"><span class="comment">调用父类:Parents的构造函数</span></span><br><span class="line"><span class="comment">调用子类的构造函数</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">销毁子类实例</span></span><br><span class="line"><span class="comment">销毁父类实例</span></span><br><span class="line"><span class="comment">销毁爷爷类实例</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Object类"><a href="#2-2-Object类" class="headerlink" title="2.2. Object类"></a>2.2. Object类</h2><p>Java每个类都直接或间接继承于java.lang.Object类。在Object类中主要包括: clone(), finalize(), equals(), toString()等可重写的方法，及getClass(), notify(), notifyAll(), wait()等不可重写方法（Object中被定义为final类型）</p>
<h3 id="2-2-1-getClass-方法"><a href="#2-2-1-getClass-方法" class="headerlink" title="2.2.1. getClass()方法"></a>2.2.1. getClass()方法</h3><p>返回对象执行时的Class实例，一般于获取类的名称getName()方法连用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = c.getClass().getName();<span class="comment">//将返回实例c的类名“Childron”</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-Java-接口小记"><a href="#2-3-Java-接口小记" class="headerlink" title="2.3. Java 接口小记"></a>2.3. Java 接口小记</h2><p>接口是抽象类的延伸，可以将它看作是纯粹的抽象类，接口中的所有方法都没有方法体。接口的可以在子类中更灵活地选择方法功能，一个子类可以选择多个接口，然后每个接口类的方法都在该子类中有具体实现，不需要的方法直接不用接口就行，相比于在父类定义虚函数造成代码冗余和不能多继承，接口的出现更方便在子类中按需添加自定义方法。</p>
<h3 id="2-3-1-对比接口与抽象父类"><a href="#2-3-1-对比接口与抽象父类" class="headerlink" title="2.3.1. 对比接口与抽象父类"></a>2.3.1. 对比接口与抽象父类</h3><h4 id="2-3-1-1-1-先定义抽象父类实现子类不同方法的需求"><a href="#2-3-1-1-1-先定义抽象父类实现子类不同方法的需求" class="headerlink" title="2.3.1.1. 1.先定义抽象父类实现子类不同方法的需求"></a>2.3.1.1. 1.先定义抽象父类实现子类不同方法的需求</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义抽象四边形类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Quadrangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//声明抽象draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span></span>;<span class="comment">//声明抽象ba方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个平行四边形类（假设需要draw方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rhomboid</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//重写draw方法以满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//虽然不需要ba方法，但却不得不重写ba，否则报错，造成极大代码冗余</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个正方形类（假设需要draw方法和ba方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//重写draw方法以满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//重写ba方法以满足要求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个长方形类（不需要其他方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//虽然不需要draw方法，但却不得不重写draw，否则报错，造成极大代码冗余</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//虽然不需要ba方法，但却不得不重写ba，否则报错，造成极大代码冗余</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-2-抽象父类缺点："><a href="#2-3-1-2-抽象父类缺点：" class="headerlink" title="2.3.1.2. 抽象父类缺点："></a>2.3.1.2. 抽象父类缺点：</h4><ul>
<li>造成极大代码冗余</li>
<li>引发逻辑问题，不需要某些方法的子类必须重写抽象父类的所有虚函数，与逻辑不符</li>
</ul>
<h4 id="2-3-1-3-2-定义接口，子类灵活选择接口即可"><a href="#2-3-1-3-2-定义接口，子类灵活选择接口即可" class="headerlink" title="2.3.1.3. 2.定义接口，子类灵活选择接口即可"></a>2.3.1.3. 2.定义接口，子类灵活选择接口即可</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口 1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">drwaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//接口内的方法（类型只能是public或abstract）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义接口 2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">bala</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义四边形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quadrangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个平行四边形类（假设需要draw方法），并实现 drwaTest 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rhomboid</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span> <span class="keyword">implements</span> <span class="title">drwaTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制平行四边形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个正方形类（假设需要draw方法和ba方法），并实现drwaTest接口与bala接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span> <span class="keyword">implements</span> <span class="title">drwaTest</span>, <span class="title">bala</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制正方形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ba</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;balabala&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个长方形类（不需要其他方法，单纯继承四边形类即可）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-4-接口优点："><a href="#2-3-1-4-接口优点：" class="headerlink" title="2.3.1.4. 接口优点："></a>2.3.1.4. 接口优点：</h4><ul>
<li>逻辑清晰，随意加减接口，灵活实现</li>
<li>精简代码，只需将子类所需的接口中的方法重写即可</li>
<li>子类不能继承多个抽象父类（不能多重继承），但子类却可添加多个接口</li>
</ul>
<h2 id="2-4-异常"><a href="#2-4-异常" class="headerlink" title="2.4. 异常"></a>2.4. 异常</h2><p>常见异常：空指针，数组溢出，被除数为0，……，自定义异常等。</p>
<h3 id="2-4-1-自定义异常"><a href="#2-4-1-自定义异常" class="headerlink" title="2.4.1. 自定义异常"></a>2.4.1. 自定义异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMessage);<span class="comment">//调用父类构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.message = errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-捕获异常"><a href="#2-4-2-捕获异常" class="headerlink" title="2.4.2. 捕获异常"></a>2.4.2. 捕获异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义可能会抛出异常的方法，在方法中抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 &lt; <span class="number">0</span> || num2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;数字不能为负&quot;</span>);<span class="comment">//若条件为真执行到throw，在throw抛出异常后，此函数后续部分都不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1 &gt; <span class="number">100</span> || num2 &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;数字不能超过100&quot;</span>);<span class="comment">//若条件为真执行到throw，在throw抛出异常后，此函数后续部分都不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (num1 + num2) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">102</span>, y=<span class="number">5</span>, z=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isExceptionFlag = <span class="keyword">true</span>;<span class="comment">//是否发生异常标志</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            z = average(x, y);<span class="comment">//可能抛出异常的代码，放在try&#123;&#125;内执行，若异常发生就不会执行try&#123;&#125;内的下方代码</span></span><br><span class="line">            z += x / y;<span class="comment">//可能会抛出除数为0异常</span></span><br><span class="line">            isExceptionFlag = <span class="keyword">false</span>;<span class="comment">//当执行到此处，说明上方函数未发生异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            <span class="comment">// 若捕获到抛出的自定义异常，会执行下面代码</span></span><br><span class="line">            System.out.println(e.getMessage());<span class="comment">//输出异常携带的消息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获异常类型2（除数为0异常），异常处理代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//无论是否抛出异常，都会执行此块内代码</span></span><br><span class="line">            <span class="keyword">if</span> (isExceptionFlag)</span><br><span class="line">                System.out.println(<span class="string">&quot;发生异常&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;未发生异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1）当x=102, y=5时，运行结果：</span></span><br><span class="line"><span class="comment">数字不能超过100</span></span><br><span class="line"><span class="comment">发生异常</span></span><br><span class="line"><span class="comment">2）当x=10，y=0时，运行结果：</span></span><br><span class="line"><span class="comment">除数不能为0</span></span><br><span class="line"><span class="comment">发生异常</span></span><br><span class="line"><span class="comment">3）当x=10，y=5时，运行结果：</span></span><br><span class="line"><span class="comment">未发生异常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-Swing程序设计（跳过）"><a href="#2-5-Swing程序设计（跳过）" class="headerlink" title="2.5. Swing程序设计（跳过）"></a>2.5. Swing程序设计（跳过）</h2><h2 id="2-6-集合类"><a href="#2-6-集合类" class="headerlink" title="2.6. 集合类"></a>2.6. 集合类</h2><p>集合类，又称容器。常见的集合类有：List集合, Set集合, Map集合，其中List与Set继承了Collection接口。<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Inheritance-relationship-of-common-collection-classes.jpg" alt="常见集合类的继承关系"><br><strong>与数组区别</strong>：</p>
<ul>
<li>数组的长度固定，而集合的长度可变；</li>
<li>数组存放基本类型的数据，集合存放对象的引用。</li>
</ul>
<h3 id="2-6-1-List集合"><a href="#2-6-1-List集合" class="headerlink" title="2.6.1. List集合"></a>2.6.1. List集合</h3><p>List的接口常用的实现类有：<strong>ArrayList</strong>与<strong>LinkedList</strong>。<br><strong>ArrayList</strong>：实现了可变长数组，允许保存所有元素，包括null，可根据索引快速访问数组内元素，但插入或删除元素时间较长。<br><strong>LinkedList</strong>：采用链表结构存储元素（数组元素上限仅受可用内存限制），类似链表，插入删除元素较快，但随机访问都会从头结点开始顺序向下遍历，故随机访问较慢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list1.add(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//添加元素&#x27;a&#x27;，List元素下标与数组一样从0开始</span></span><br><span class="line">list1.add(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//添加元素&#x27;b&#x27;</span></span><br><span class="line">list1.remove(<span class="number">1</span>);<span class="comment">//删除索引为1的元素</span></span><br><span class="line">System.out.println(list1);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-Set接口"><a href="#2-6-2-Set接口" class="headerlink" title="2.6.2. Set接口"></a>2.6.2. Set接口</h3><p>Set接口的常用实现类有：<strong>HashSet</strong>与<strong>TreeSet</strong><br><strong>HashSet</strong>：由哈希表支持（实际上是一个HashMap实例），不保证Set的迭代顺序（不稳定），允许使用null元素<br><strong>TreeSet</strong>：TreeSet实现的Set集合在遍历集合时按照自然顺序递增排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">tree.add(<span class="string">&quot;ZhangSan&quot;</span>);</span><br><span class="line">tree.add(<span class="string">&quot;LiSi&quot;</span>);</span><br><span class="line">tree.add(<span class="string">&quot;WangWu&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = tree.iterator();<span class="comment">//Set集合中的所有对象的迭代器</span></span><br><span class="line"><span class="comment">//遍历Set集合</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">  String tmp = (String)it.next();</span><br><span class="line">  System.out.println(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果（与插入顺序无关，自然递增）</span></span><br><span class="line"><span class="comment">LiSi</span></span><br><span class="line"><span class="comment">WangWu</span></span><br><span class="line"><span class="comment">ZhangSan</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-List集合-vs-Set集合"><a href="#2-6-3-List集合-vs-Set集合" class="headerlink" title="2.6.3. List集合 vs Set集合"></a>2.6.3. List集合 vs Set集合</h3><ul>
<li>List集合允许元素重复，而Set集合<strong>不能包含重复对象</strong></li>
<li>List集合元素顺序为插入顺序（类似数组），而Set集合不保证顺序</li>
<li>List访问指定索引的元素<code>get(int index)</code>或<code>set<int index, Object obj></code>，而Set集合不能访问指定索引元素</li>
</ul>
<h3 id="2-6-4-Map集合"><a href="#2-6-4-Map集合" class="headerlink" title="2.6.4. Map集合"></a>2.6.4. Map集合</h3><p>Map接口的常用实现类有<strong>HashMap</strong>(无序，允许null值)和<strong>TreeMap</strong>(升序，不允许null值)。<br> Map提供key到value的映射，Map中不能包含相同的key，每个key只能映射一个value。Key还决定了存储对象在映射中的存储位置，但不是由key本身决定的，而是由key根据”散列技术”产生的散列码整数值（作为偏移量）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;ZhangSan&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;LiSi&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;WangWu&quot;</span>);</span><br><span class="line"><span class="comment">//遍历Map的Key值集合</span></span><br><span class="line">Set&lt;Integer&gt; s = map.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = s.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历Map的Value值集合</span></span><br><span class="line">Collection&lt;String&gt; c = map.values();</span><br><span class="line">Iterator&lt;String&gt; it2 = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (it2.hasNext())&#123;</span><br><span class="line">    System.out.println(it2.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">ZhangSan</span></span><br><span class="line"><span class="comment">LiSi</span></span><br><span class="line"><span class="comment">WangWu</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-文件File"><a href="#2-7-文件File" class="headerlink" title="2.7. 文件File"></a>2.7. 文件File</h2><h3 id="2-7-1-文件的创建与删除"><a href="#2-7-1-文件的创建与删除" class="headerlink" title="2.7.1. 文件的创建与删除"></a>2.7.1. 文件的创建与删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/eisenhao/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中）,绝对路径</span></span><br><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;/Users/eisenhao/Test/&quot;</span>, <span class="string">&quot;test2.txt&quot;</span>);<span class="comment">//在目录下 创建文件对象（于内存中）,绝对路径</span></span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">    file.delete();<span class="comment">//删除文件</span></span><br><span class="line">    System.out.println(file.getName() + <span class="string">&quot;文件已存在, 故删除&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();<span class="comment">//创建该文件（于磁盘中）</span></span><br><span class="line">        System.out.println(file.getName() + <span class="string">&quot;文件不存在，故创建&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-File文件的常用方法"><a href="#2-7-2-File文件的常用方法" class="headerlink" title="2.7.2. File文件的常用方法"></a>2.7.2. File文件的常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String FileName = file.getName();<span class="comment">//获取文件名</span></span><br><span class="line"><span class="keyword">boolean</span> isReadable = file.canRead();<span class="comment">//返回文件是否可读</span></span><br><span class="line"><span class="keyword">boolean</span> isWriteable = file.canWrite();<span class="comment">//返回文件是否可写</span></span><br><span class="line"><span class="keyword">boolean</span> isFileExisted = file.exists();<span class="comment">//返回文件是否在该目录（File类型记录路径）存在</span></span><br><span class="line"><span class="keyword">long</span> FileLength = file.length();<span class="comment">//文件的大小（单位：字节）</span></span><br><span class="line">String FileAbsolutePath = file.getAbsolutePath();<span class="comment">//文件的绝对路径</span></span><br><span class="line">String FileParentPath = file.getParent();<span class="comment">//获取文件所在目录</span></span><br><span class="line"><span class="keyword">boolean</span> isAFile = file.isFile();<span class="comment">//是否为普通文件（而非目录文件，或链接文件）</span></span><br><span class="line"><span class="keyword">boolean</span> isADirectory = file.isDirectory();<span class="comment">//是否为一个目录文件</span></span><br><span class="line"><span class="keyword">boolean</span> isHiddened = file.isHidden();<span class="comment">//判断文件是否为隐藏文件</span></span><br><span class="line"><span class="keyword">long</span> lastChangeTime = file.lastModified();<span class="comment">//文件最后修改时间</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;lastChangeTime = &quot;</span> + lastChangeTime);</span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(file.getName() + <span class="string">&quot;文件的最近修改时间为：&quot;</span> + dateFormat.format(<span class="keyword">new</span> Date(lastChangeTime)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">lastChangeTime = 1555158024000</span></span><br><span class="line"><span class="comment">test.txt文件的最近修改时间为：2019-04-13 20:20:24</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-3-文件输入输出流"><a href="#2-7-3-文件输入输出流" class="headerlink" title="2.7.3. 文件输入输出流"></a>2.7.3. 文件输入输出流</h3><h4 id="2-7-3-1-FileInputStream与FileOutputStream类"><a href="#2-7-3-1-FileInputStream与FileOutputStream类" class="headerlink" title="2.7.3.1. FileInputStream与FileOutputStream类"></a>2.7.3.1. FileInputStream与FileOutputStream类</h4><p>操作磁盘文件，可满足简单的文件读写需求。但由于读写操作以字节或字节数组为单位，由于汉字占两个字节，若读取readBuff[]容量设置为单字节，或正好错开一字节会导致汉字乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/eisenhao/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中）,绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件测试</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileOutputStream简单文件输出流对象</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    <span class="comment">//创建byte数组</span></span><br><span class="line">    <span class="keyword">byte</span> writeBuff[] = <span class="string">&quot;写入如下字符串以测试简单文件输出流功能。&quot;</span>.getBytes();</span><br><span class="line">    out.write(writeBuff);<span class="comment">//将数组中内容写入磁盘</span></span><br><span class="line">    out.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件测试</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileOutputStream简单文件读取流对象</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    <span class="keyword">byte</span> readBuff[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">//创建大小为1KB的读取缓存</span></span><br><span class="line">    <span class="keyword">int</span> len = in.read(readBuff);<span class="comment">//从文件中读取内容到readBuff数组，并返回读取的内容大小（单位：字节）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取到的内容如下：\n&quot;</span> + <span class="keyword">new</span> String(readBuff, <span class="number">0</span>, len) + <span class="string">&quot;&lt;END&gt;&quot;</span>);<span class="comment">//将读到的readBuff数组内Byte类型数据转换为String输出</span></span><br><span class="line">    in.close();<span class="comment">//关闭读取流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">读取到的内容如下：</span></span><br><span class="line"><span class="comment">写入如下字符串以测试简单文件输出流功能。</span></span><br><span class="line"><span class="comment">&lt;END&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-2-FileReader与FileWriter类"><a href="#2-7-3-2-FileReader与FileWriter类" class="headerlink" title="2.7.3.2. FileReader与FileWriter类"></a>2.7.3.2. FileReader与FileWriter类</h4><p>能够避免FileInputStream与FileOutputStream类可能出现的汉字读写乱码现象。FileReader流顺序地读取文件，只要不关闭流，每次调用read()方法就顺序地读取源中的内容，直到源的末尾或流被关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/eisenhao/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中）,绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileWriter文件输出流对象</span></span><br><span class="line">    FileWriter out = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">    String writerStr = <span class="string">&quot;尝试写入如下字符串以测试FileWriter文件输入流功能。\n&quot;</span>;</span><br><span class="line">    out.write(writerStr);<span class="comment">//将writerStr内容写入磁盘文件中(会清空原文件所有内容)</span></span><br><span class="line">    out.close();<span class="comment">//关闭写文件流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileReader文件读取流对象</span></span><br><span class="line">    FileReader in = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="keyword">char</span> readBuff[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>]; <span class="comment">//创建char类型读取内容数组</span></span><br><span class="line">    <span class="keyword">int</span> len = in.read(readBuff);<span class="comment">//从文件中读取内容到readBuff数组，并返回读取的内容char数组长度</span></span><br><span class="line">    in.close();<span class="comment">//关闭读文件流</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取到的内容如下：\n&quot;</span> + <span class="keyword">new</span> String(readBuff, <span class="number">0</span>, len) + <span class="string">&quot;&lt;END&gt;&quot;</span>);<span class="comment">//将读到的readBuff数组内数据转换为String输出</span></span><br><span class="line">    in.close();<span class="comment">//关闭读取流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">读取到的内容如下：</span></span><br><span class="line"><span class="comment">尝试写入如下字符串以测试FileWriter文件输入流功能。</span></span><br><span class="line"><span class="comment">&lt;END&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-3-带缓存的输入-输出流"><a href="#2-7-3-3-带缓存的输入-输出流" class="headerlink" title="2.7.3.3. 带缓存的输入/输出流"></a>2.7.3.3. 带缓存的输入/输出流</h4><p><strong>BufferedInputStream</strong>与<strong>BufferedOutputStream</strong>类。BufferedInputStream类可以对所有的InputStream类进行带缓存区的包装以达到性能的优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedInputStream(InputStream in);<span class="comment">//创建一个带有32个字节的缓存流</span></span><br><span class="line">BufferedInputStream(InputStream in, <span class="keyword">int</span> size);<span class="comment">//创建一个自定义大小的读取流缓存区</span></span><br></pre></td></tr></table></figure>
<p>BufferedOutputStream类有一个flush()方法可以将缓存区内的数据强制输出到磁盘（无论缓存区满否）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedOutputStream(OutputStream out);<span class="comment">//创建一个带有32字节的缓存区</span></span><br><span class="line">BufferedOutputStream(OutputStream out, <span class="keyword">int</span> size);<span class="comment">//创建一个自定义大小的写出流缓存区</span></span><br></pre></td></tr></table></figure>
<p><strong>BufferedReader</strong>与<strong>BufferedWriter</strong>类<br>BufferedReader与BufferedWriter类分别继承Reader类与Writer类。这两个类同样具有内部缓存机制，并可以以行为为单位进行输入输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/eisenhao/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中）,绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带缓存写文件操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileWriter文件输出流对象</span></span><br><span class="line">    FileWriter fileWriter = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">    <span class="comment">//创建带缓存区的输出流</span></span><br><span class="line">    BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(fileWriter);</span><br><span class="line">    String writerStr = <span class="string">&quot;尝试写入如下字符串以测试带缓存区的输出流功能。&quot;</span>;</span><br><span class="line">    bufferedWriter.write(writerStr);<span class="comment">//将writerStr内容写入缓存区（自动控制，缓存区满自动写入磁盘，避免频繁读写磁盘）</span></span><br><span class="line">    bufferedWriter.newLine();<span class="comment">//将换行符写入文件</span></span><br><span class="line">    bufferedWriter.close();<span class="comment">//关闭写缓存区流</span></span><br><span class="line">    fileWriter.close();<span class="comment">//关闭输出流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带缓存区读文件操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileReader文件读取流对象</span></span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="comment">//创建带缓存区的读取流</span></span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">    String readStr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果文件的文本行不为null，则进入循环</span></span><br><span class="line">    <span class="keyword">while</span>((readStr = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        row++;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取到第&quot;</span>+ row + <span class="string">&quot;行的内容为：&quot;</span> + readStr);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&lt;END&gt;&quot;</span>);</span><br><span class="line">    bufferedReader.close();<span class="comment">//关闭读缓存区流</span></span><br><span class="line">    fileReader.close();<span class="comment">//关闭读取流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">读取到第1行的内容为：尝试写入如下字符串以测试带缓存区的输出流功能。</span></span><br><span class="line"><span class="comment">&lt;END&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>BufferedReader</strong>类的常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = bufferedReader.read();<span class="comment">//读取单个字符(unicode两字节)</span></span><br><span class="line">System.out.println(<span class="string">&quot;ch = &quot;</span> + (<span class="keyword">char</span>)ch);<span class="comment">//输出结果为：尝</span></span><br><span class="line">String readStr = bufferedReader.readLine();<span class="comment">//读取一行</span></span><br></pre></td></tr></table></figure>
<p><strong>BufferedWriter</strong>类的常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bufferedWriter.write(writerStr, <span class="number">0</span>, writerStr.length());<span class="comment">//写入字符串的某一索引区间内容（此处为全部写入）</span></span><br><span class="line">bufferedWriter.flush();<span class="comment">//强制将缓存区的内容写入到磁盘（不管缓存区满否）</span></span><br><span class="line">bufferedWriter.newLine();<span class="comment">//将换行符写入文件</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-4-数据输入输出流"><a href="#2-7-3-4-数据输入输出流" class="headerlink" title="2.7.3.4. 数据输入输出流"></a>2.7.3.4. 数据输入输出流</h4><p><strong>DataInputStream</strong>与<strong>DataOutputStream</strong>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/eisenhao/Test/test.txt&quot;</span>);<span class="comment">//创建文件对象（于内存中），绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试数据输出流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(fileOutputStream);</span><br><span class="line">    <span class="comment">//dataOutputStream.writeBytes(&quot;尝试以Byte格式写入内容。&quot;);</span></span><br><span class="line">    <span class="comment">//dataOutputStream.writeChars(&quot;尝试以Char格式写入内容。&quot;);</span></span><br><span class="line">    dataOutputStream.writeUTF(<span class="string">&quot;尝试以UTF格式写入内容。&quot;</span>);</span><br><span class="line">    dataOutputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试数据输入流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(fileInputStream);</span><br><span class="line">    String readStr = dataInputStream.readUTF();<span class="comment">//尝试以UTF格式读取文件内容</span></span><br><span class="line">    System.out.println(<span class="string">&quot;以UTF格式读取的内容为: &quot;</span> + readStr + <span class="string">&quot;&lt;END&gt;&quot;</span>);</span><br><span class="line">    dataInputStream.close();<span class="comment">//关闭数据输入流</span></span><br><span class="line">    fileInputStream.close();<span class="comment">//关闭文件写入流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">以UTF格式读取的内容为: 尝试以UTF格式写入内容。&lt;END&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-5-ZIP压缩输入-输出流（压缩-解压文件）"><a href="#2-7-3-5-ZIP压缩输入-输出流（压缩-解压文件）" class="headerlink" title="2.7.3.5. ZIP压缩输入/输出流（压缩/解压文件）"></a>2.7.3.5. ZIP压缩输入/输出流（压缩/解压文件）</h4><p>ZIP压缩管理文件（Zip archive）是一种十分典型的文件压缩形式。常用<strong>ZipOutputStream</strong>与<strong>ZipInputStream</strong>类来实现文件的<strong>压缩</strong>/<strong>解压缩</strong>。</p>
<h5 id="2-7-3-5-1-压缩文件（ZipOutputStream类）"><a href="#2-7-3-5-1-压缩文件（ZipOutputStream类）" class="headerlink" title="2.7.3.5.1. 压缩文件（ZipOutputStream类）"></a>2.7.3.5.1. <strong>压缩文件（ZipOutputStream类）</strong></h5><p>若要将某个文件添加到ZIP压缩管理文件内，必须先写入待添加文件的目录进入点（待添加文件在ZIP文件内的位置），并且把待添加文件内容的位置移到此进入点说指的位置，然后再写入文件内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 压缩文件类</span></span><br><span class="line"><span class="comment"> * coder:eisenhao</span></span><br><span class="line"><span class="comment"> * Java</span></span><br><span class="line"><span class="comment"> * 20190414*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加壳压缩文件函数</span></span><br><span class="line"><span class="comment">     * 输入参数：zipFileName -- 压缩后的文件名，inputFile -- 待压缩文件</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String zipFileName, File inputFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File unzipFile = <span class="keyword">new</span> File(zipFileName);<span class="comment">//获取待压缩文件 对象</span></span><br><span class="line">        String Base = inputFile.getName();<span class="comment">//得到待压缩文件名</span></span><br><span class="line">        ZipOutputStream out = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(zipFileName));<span class="comment">//新建ZipOutputStream对象</span></span><br><span class="line">        zip(out, inputFile, Base); <span class="comment">//相对目录进入点为空</span></span><br><span class="line">        out.close();<span class="comment">//关闭压缩流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩文件核心函数</span></span><br><span class="line"><span class="comment">     * 输入参数：zipout - 压缩流、file - 待压缩文件、base - 目录进入点</span></span><br><span class="line"><span class="comment">     * 若为单个文件 - 直接拷贝压缩，若为目录文件 - 递归调用自身</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zip</span><span class="params">(ZipOutputStream zipout, File file, String base)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//判断文件是否为目录文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">//若问文件夹，列出待压缩文件夹内所有文件</span></span><br><span class="line">            File[] fl = file.listFiles();<span class="comment">//获取路径数组</span></span><br><span class="line">            <span class="comment">//循环遍历待压缩文件夹内的所有文件(可能存在多级文件夹)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fl.length; i++) &#123;</span><br><span class="line">                String tmpBase = base + <span class="string">&quot;/&quot;</span> + fl[i].getName();<span class="comment">//路径写入点为</span></span><br><span class="line">                zip(zipout, fl[i], tmpBase);<span class="comment">//递归调</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若为单个文件，直接拷贝压缩</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            zipout.putNextEntry(<span class="keyword">new</span> ZipEntry(base));<span class="comment">//创建新的进入点</span></span><br><span class="line">            <span class="comment">//创建FileInputStream写出流对象</span></span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            System.out.println(<span class="string">&quot;压缩 &quot;</span> + base + <span class="string">&quot; 位置的 &quot;</span> + file.getName() + <span class="string">&quot; 文件 ...&quot;</span>);<span class="comment">//打印当前目录进入点</span></span><br><span class="line">            <span class="comment">//逐一字节拷贝压缩</span></span><br><span class="line">            <span class="keyword">while</span> ((ch = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                zipout.write(ch);<span class="comment">//将字节写入当前ZIP条目</span></span><br><span class="line">            &#125;</span><br><span class="line">            in.close();<span class="comment">//关闭读取流</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZipTest zipTest = <span class="keyword">new</span> ZipTest();</span><br><span class="line">        <span class="comment">//尝试压缩</span></span><br><span class="line">        String zipFileName = <span class="string">&quot;/Users/eisenhao/Downloads/Test.zip&quot;</span>;<span class="comment">//压缩后得到的文件名</span></span><br><span class="line">        String inputFile = <span class="string">&quot;/Users/eisenhao/Test/&quot;</span>;<span class="comment">//待压缩文件（可谓普通文件 或 目录文件）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;尝试压缩 &quot;</span> + inputFile + <span class="string">&quot; 到 &quot;</span> + zipFileName + <span class="string">&quot; ...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zipTest.zipFile(zipFileName, <span class="keyword">new</span> File(inputFile));<span class="comment">//调用加壳压缩文件函数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;压缩完成:)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">尝试压缩 /Users/eisenhao/Test/ 到 /Users/eisenhao/Downloads/Test.zip ...</span></span><br><span class="line"><span class="comment">压缩 Test/test2.txt 位置的 test2.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/Second/test3.txt 位置的 test3.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/Second/Third/test4.txt 位置的 test4.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/Second/test3的副本.txt 位置的 test3的副本.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/test2的副本.txt 位置的 test2的副本.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩 Test/test.txt 位置的 test.txt 文件 ...</span></span><br><span class="line"><span class="comment">压缩完成:)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="2-7-3-5-2-解压缩文件（ZipInputStream类）"><a href="#2-7-3-5-2-解压缩文件（ZipInputStream类）" class="headerlink" title="2.7.3.5.2. 解压缩文件（ZipInputStream类）"></a>2.7.3.5.2. <strong>解压缩文件（ZipInputStream类）</strong></h5><p>若要从ZIP压缩管理文件内提取某个文件，要先找到待提取文件的目录进入点（该文件在ZIP文件内的位置），才能读取这个文件的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipFile;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 解压缩类</span></span><br><span class="line"><span class="comment"> * coder:eisenhao</span></span><br><span class="line"><span class="comment"> * Java</span></span><br><span class="line"><span class="comment"> * 20190414*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnzipTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压缩文件方法，解压到当前目录</span></span><br><span class="line"><span class="comment">     * 参数：unZipFileName -- 待解压缩文件名（含路径）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Unzip</span><span class="params">(String unZipFileName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File unzipFile = <span class="keyword">new</span> File(unZipFileName);<span class="comment">//获取待压缩文件 对象</span></span><br><span class="line">        String finalPath = unzipFile.getParentFile() + <span class="string">&quot;/&quot;</span>;<span class="comment">//得到待解压缩文件的绝对路径</span></span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(unzipFile);<span class="comment">//创建Zip压缩文件 对象</span></span><br><span class="line">        ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(unzipFile));<span class="comment">//实例化解压缩ZipInputStream对象</span></span><br><span class="line">        ZipEntry entry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代解压缩所有目录树上的文件（包括目录文件）</span></span><br><span class="line">        <span class="keyword">while</span> ((entry=zipInputStream.getNextEntry())!=<span class="keyword">null</span> &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">            File tmp = <span class="keyword">new</span> File(finalPath + entry.getName());<span class="comment">//解压出的文件路径</span></span><br><span class="line">            <span class="comment">//如果文件不存在</span></span><br><span class="line">            <span class="keyword">if</span> (!tmp.exists()) &#123;</span><br><span class="line">                tmp.getParentFile().mkdirs();<span class="comment">//创建父类文件夹路径</span></span><br><span class="line">                OutputStream writeStream = <span class="keyword">new</span> FileOutputStream(tmp);<span class="comment">//将文件目录中的文件放入输出流</span></span><br><span class="line">                System.out.println(<span class="string">&quot;解压缩 &quot;</span> + tmp.getAbsolutePath() + <span class="string">&quot; 文件 ...&quot;</span>);</span><br><span class="line">                <span class="comment">//用输入流读取压缩文件中制定目录中的文件</span></span><br><span class="line">                InputStream readStream = zipFile.getInputStream(entry);</span><br><span class="line">                <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((ch = readStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    writeStream.write(ch);</span><br><span class="line">                &#125;</span><br><span class="line">                writeStream.close();<span class="comment">//关闭写文件流</span></span><br><span class="line">                readStream.close();<span class="comment">//关闭读文件流</span></span><br><span class="line">            &#125;</span><br><span class="line">            zipInputStream.closeEntry();<span class="comment">//关闭当前Entry</span></span><br><span class="line">        &#125;</span><br><span class="line">        zipInputStream.close();<span class="comment">//关闭解压缩流</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解压缩已完成:)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnzipTest unzipTest = <span class="keyword">new</span> UnzipTest();</span><br><span class="line">        String unzipFileName = <span class="string">&quot;/Users/eisenhao/Downloads/Test.zip&quot;</span>;<span class="comment">//待解压缩文件名（含路径）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unzipTest.Unzip(unzipFileName);<span class="comment">//尝试解压缩</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">解压缩 /Users/eisenhao/Downloads/Test/test2.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/eisenhao/Downloads/Test/Second/test3.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/eisenhao/Downloads/Test/Second/Third/test4.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/eisenhao/Downloads/Test/Second/test3的副本.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/eisenhao/Downloads/Test/test2的副本.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩 /Users/eisenhao/Downloads/Test/test.txt 文件 ...</span></span><br><span class="line"><span class="comment">解压缩已完成:)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-多线程"><a href="#2-8-多线程" class="headerlink" title="2.8. 多线程"></a>2.8. 多线程</h2><p>在Java中可通过继承java.lang.Thread类与实现java.lang.Runnable接口两种方式。</p>
<h3 id="2-8-1-Theard类与Runnable类实现线程区别"><a href="#2-8-1-Theard类与Runnable类实现线程区别" class="headerlink" title="2.8.1. Theard类与Runnable类实现线程区别"></a>2.8.1. Theard类与Runnable类实现线程区别</h3><p>Thread实现必须继承Thread类，而继承Runnable接口则更方便</p>
<h3 id="2-8-2-继承Thread类"><a href="#2-8-2-继承Thread类" class="headerlink" title="2.8.2. 继承Thread类"></a>2.8.2. 继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);<span class="comment">//调用父类Thread构造函数，给线程命名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写run()方法实现线程执行的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (++i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">            <span class="comment">//延时方式1：</span></span><br><span class="line"><span class="comment">//            for (long k=0; k&lt;100000000; k++);//阻塞式延时，不推荐（占CPU）</span></span><br><span class="line">            <span class="comment">//延时方式2：</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//线程休眠1秒，推荐（让出CPU）</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Thread test1 = <span class="keyword">new</span> TestThread(<span class="string">&quot;A&quot;</span>);<span class="comment">//定义线程&quot;A&quot;</span></span><br><span class="line">        Thread test2 = <span class="keyword">new</span> TestThread(<span class="string">&quot;BBB&quot;</span>);<span class="comment">//定义线程&quot;BBB&quot;</span></span><br><span class="line">        test1.start();<span class="comment">//启动线程&quot;A&quot;</span></span><br><span class="line">        test2.start();<span class="comment">//启动线程&quot;BBB&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//主线程在while死循环内</span></span><br><span class="line">            System.out.println((i++) + <span class="string">&quot;:Main&quot;</span>);<span class="comment">//Main主线程执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">600</span>);<span class="comment">//主线程延时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">1:A</span></span><br><span class="line"><span class="comment">1:BBB</span></span><br><span class="line"><span class="comment">0:Main</span></span><br><span class="line"><span class="comment">1:Main</span></span><br><span class="line"><span class="comment">2:BBB</span></span><br><span class="line"><span class="comment">2:A</span></span><br><span class="line"><span class="comment">2:Main</span></span><br><span class="line"><span class="comment">3:Main</span></span><br><span class="line"><span class="comment">3:A</span></span><br><span class="line"><span class="comment">3:BBB</span></span><br><span class="line"><span class="comment">4:Main</span></span><br><span class="line"><span class="comment">4:A</span></span><br><span class="line"><span class="comment">4:BBB</span></span><br><span class="line"><span class="comment">5:Main</span></span><br><span class="line"><span class="comment">6:Main</span></span><br><span class="line"><span class="comment">7:Main</span></span><br><span class="line"><span class="comment">...(主函数仍在while循环)...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>由此可知同一进程内的子线程，它们的运行先后顺序是随机的。</p>
<h3 id="2-8-3-实现Runnable接口"><a href="#2-8-3-实现Runnable接口" class="headerlink" title="2.8.3. 实现Runnable接口"></a>2.8.3. 实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runnable;</span><br><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dosomething</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Dosomething</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重写run()方法实现线程执行的操作</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">                System.out.println(i+ <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">//线程休眠1秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序：测试Runnable多线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dosomething t1 = <span class="keyword">new</span> Dosomething(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Dosomething t2 = <span class="keyword">new</span> Dosomething(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        Thread test1 = <span class="keyword">new</span> Thread(t1);<span class="comment">//创建Thread对象，并与继承了Runnable接口的对象关联</span></span><br><span class="line">        Thread test2 = <span class="keyword">new</span> Thread(t2);</span><br><span class="line">        test1.start();<span class="comment">//启动线程1（关联的对象“A”）</span></span><br><span class="line">        test2.start();<span class="comment">//启动线程2（关联的对象“BBB”）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">1:A</span></span><br><span class="line"><span class="comment">1:BBB</span></span><br><span class="line"><span class="comment">2:A</span></span><br><span class="line"><span class="comment">2:BBB</span></span><br><span class="line"><span class="comment">3:A</span></span><br><span class="line"><span class="comment">3:BBB</span></span><br><span class="line"><span class="comment">4:BBB</span></span><br><span class="line"><span class="comment">4:A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-8-4-操作线程的方法"><a href="#2-8-4-操作线程的方法" class="headerlink" title="2.8.4. 操作线程的方法"></a>2.8.4. 操作线程的方法</h3><h4 id="2-8-4-1-线程休眠"><a href="#2-8-4-1-线程休眠" class="headerlink" title="2.8.4.1. 线程休眠"></a>2.8.4.1. 线程休眠</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">//线程休眠1秒</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep()方法通常在run()方法内循环使用，因sleep()方法的执行有可能抛出InterruptedException异常，所以需放在try-catch块中，该线程在1秒休眠结束后会进入<strong>就绪态</strong>（不一定是<strong>运行态</strong>）。</p>
<h4 id="2-8-4-2-线程的加入（join-方法）"><a href="#2-8-4-2-线程的加入（join-方法）" class="headerlink" title="2.8.4.2. 线程的加入（join()方法）"></a>2.8.4.2. 线程的加入（join()方法）</h4><p>在当前线程A新建一个线程B，线程B调用join()方法，当线程A放弃CPU使用后执行线程B，只有线程B执行完毕后，才继续执行线程A。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runnable;</span><br><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line">    Thread threadA;<span class="comment">//声明线程A</span></span><br><span class="line">    Thread threadB;<span class="comment">//声明线程B</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestJoin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">//使用匿名内部类型形式初始化Thread实例</span></span><br><span class="line">        threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">int</span> countA = <span class="number">0</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;A: &quot;</span> + countA);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);   <span class="comment">// 线程A休眠0.1秒</span></span><br><span class="line">                        threadB.join();      <span class="comment">// 线程B调用join()方法</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++countA &gt; <span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();                     <span class="comment">// 启动线程A</span></span><br><span class="line"></span><br><span class="line">        threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">int</span> countB = <span class="number">0</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B: &quot;</span> + countB);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>); <span class="comment">//线程B休眠0.1秒</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++countB &gt; <span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadB.start();                   <span class="comment">// 启动线程B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestJoin t = <span class="keyword">new</span> TestJoin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">A: 0</span></span><br><span class="line"><span class="comment">B: 0</span></span><br><span class="line"><span class="comment">B: 1</span></span><br><span class="line"><span class="comment">B: 2</span></span><br><span class="line"><span class="comment">B: 3</span></span><br><span class="line"><span class="comment">B: 4</span></span><br><span class="line"><span class="comment">B: 5</span></span><br><span class="line"><span class="comment">A: 1</span></span><br><span class="line"><span class="comment">A: 2</span></span><br><span class="line"><span class="comment">A: 3</span></span><br><span class="line"><span class="comment">A: 4</span></span><br><span class="line"><span class="comment">A: 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>线程的中断</strong><br>提倡在线程run()方法中使用无限循环的形式，用一个布尔型标记控制循环的停止。（而不是JDK已废除的stop()方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStop = <span class="keyword">false</span>;<span class="comment">//设置一个标记变量（默认值为false）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStop) <span class="keyword">break</span>;<span class="comment">//当isStop为true时，停止线程</span></span><br><span class="line">            <span class="comment">/** Do something **/</span></span><br><span class="line">            System.out.println((++count) + <span class="string">&quot;. Hello...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义设置停止线程标志位的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isStop = <span class="keyword">true</span>;<span class="comment">//设置isStop为true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InterruptedTest interruptedTest = <span class="keyword">new</span> InterruptedTest();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(interruptedTest);</span><br><span class="line">        t.start();<span class="comment">//启动线程t</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">1500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        interruptedTest.setStop();<span class="comment">//设置停止线程的标志位（停止线程t）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">1. Hello...</span></span><br><span class="line"><span class="comment">2. Hello...</span></span><br><span class="line"><span class="comment">3. Hello...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-8-5-线程的优先级"><a href="#2-8-5-线程的优先级" class="headerlink" title="2.8.5. 线程的优先级"></a>2.8.5. 线程的优先级</h3><p>每个线程都具有各自的优先级，系统会从多个处于<strong>就绪状态</strong>选择优先级最高的线程进入运行状态（优先级较低的线程也有机会运行）。可用setPriority()方法调整线程优先级（优先级范围：1～10，设置需在线程执行start()前）</p>
<h3 id="2-8-6-线程同步"><a href="#2-8-6-线程同步" class="headerlink" title="2.8.6. 线程同步"></a>2.8.6. 线程同步</h3><h4 id="2-8-6-1-线程安全"><a href="#2-8-6-1-线程安全" class="headerlink" title="2.8.6.1. 线程安全"></a>2.8.6.1. 线程安全</h4><p>线程安全问题源于：多个线程同时存取单一对象的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试线程不安全实例</span></span><br><span class="line"><span class="comment"> * -- 多个线程同时读写单一对象数据时，可能引发的安全问题</span></span><br><span class="line"><span class="comment"> * eg. 未考虑线程安全的对线程买票（不安全）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadUnsafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftNum = <span class="number">5</span>;<span class="comment">//设置剩余票数</span></span><br><span class="line">    <span class="keyword">int</span> purchaseTime = <span class="number">0</span>;<span class="comment">//统计买票次数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readValue;<span class="comment">//定义读取值</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((readValue = leftNum) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);<span class="comment">//线程休眠0.1秒, 模仿买票操作用时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;ReadLeftNum = &quot;</span> + readValue + <span class="string">&quot;, After Purchase leftNum = &quot;</span> + --leftNum);<span class="comment">//购票，将剩余票数减一</span></span><br><span class="line">                purchaseTime++;<span class="comment">//统计已购买票次数变量 +1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadUnsafe testThreadUnsafe = <span class="keyword">new</span> TestThreadUnsafe();<span class="comment">//实例化类对象</span></span><br><span class="line">        <span class="comment">//以下实例化四个子线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(testThreadUnsafe);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(testThreadUnsafe);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(testThreadUnsafe);</span><br><span class="line">        Thread threadD = <span class="keyword">new</span> Thread(testThreadUnsafe);</span><br><span class="line">        System.out.println(<span class="string">&quot;不安全的多线程演示：\n总票数：&quot;</span> + testThreadUnsafe.leftNum);</span><br><span class="line">        <span class="comment">//启动四个子线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">        threadD.start();</span><br><span class="line">        <span class="comment">//主线程休眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">//主线程休眠3秒(足够这四个子线程买票)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总共买票次数：&quot;</span> + testThreadUnsafe.purchaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">不安全的多线程演示：</span></span><br><span class="line"><span class="comment">总票数：5</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 4</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 3</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 2</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 1</span></span><br><span class="line"><span class="comment">ReadLeftNum = 4, After Purchase leftNum = 0</span></span><br><span class="line"><span class="comment">ReadLeftNum = 3, After Purchase leftNum = -1</span></span><br><span class="line"><span class="comment">ReadLeftNum = 1, After Purchase leftNum = -2</span></span><br><span class="line"><span class="comment">ReadLeftNum = 1, After Purchase leftNum = -3</span></span><br><span class="line"><span class="comment">总共买票次数：8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从运行结果可看出最后打印的剩余票数值为负值，这时因为有两个线程读取值的时候leftNum值时为1（满足leftNum&gt;0）的时刻，已有其他线程进入”购票操作”只不过还未修改值，这就导致当最终这两个线程此时读到还有票，但等到其他线程完成修改值后（票数已为负），仍然执行-1操作导致票数为负。</p>
<h4 id="2-8-6-2-线程同步机制"><a href="#2-8-6-2-线程同步机制" class="headerlink" title="2.8.6.2. 线程同步机制"></a>2.8.6.2. 线程同步机制</h4><h5 id="2-8-6-2-1-synchronized-“”-同步块"><a href="#2-8-6-2-1-synchronized-“”-同步块" class="headerlink" title="2.8.6.2.1. synchronized (“”){}同步块"></a>2.8.6.2.1. synchronized (“”){}同步块</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;同步锁</span><br><span class="line">synchronized (Object)&#123;</span><br><span class="line">    &#x2F;&#x2F;Do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑线程同步机制的多线程买票程序实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试线程安全-1</span></span><br><span class="line"><span class="comment"> * -- 多个线程同时读写单一对象数据时(加同步锁)，避免引发安全问题</span></span><br><span class="line"><span class="comment"> * eg. 对于多线程买票问题，考虑线程同步机制（安全）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadSafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftNum = <span class="number">5</span>;<span class="comment">//设置剩余票数</span></span><br><span class="line">    <span class="keyword">int</span> purchaseTime = <span class="number">0</span>;<span class="comment">//统计买票次数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readValue;<span class="comment">//定义读取值</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((readValue = leftNum) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);<span class="comment">//线程休眠0.1秒, 模仿买票操作用时</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;ReadLeftNum = &quot;</span> + readValue + <span class="string">&quot;, After Purchase leftNum = &quot;</span> + --leftNum);<span class="comment">//购票，将剩余票数减一</span></span><br><span class="line">                    purchaseTime++;<span class="comment">//统计已购买票次数变量 +1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadSafe testThreadSafe = <span class="keyword">new</span> TestThreadSafe();<span class="comment">//实例化类对象</span></span><br><span class="line">        <span class="comment">//以下实例化四个子线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadD = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        System.out.println(<span class="string">&quot;安全的有线程同步机制的多线程演示：\n总票数：&quot;</span> + testThreadSafe.leftNum);</span><br><span class="line">        <span class="comment">//启动四个子线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">        threadD.start();</span><br><span class="line">        <span class="comment">//主线程休眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">//主线程休眠3秒(足够这四个子线程买票)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总共买票次数：&quot;</span> + testThreadSafe.purchaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">安全的有线程同步机制的多线程演示：</span></span><br><span class="line"><span class="comment">总票数：5</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 4</span></span><br><span class="line"><span class="comment">ReadLeftNum = 4, After Purchase leftNum = 3</span></span><br><span class="line"><span class="comment">ReadLeftNum = 3, After Purchase leftNum = 2</span></span><br><span class="line"><span class="comment">ReadLeftNum = 2, After Purchase leftNum = 1</span></span><br><span class="line"><span class="comment">ReadLeftNum = 1, After Purchase leftNum = 0</span></span><br><span class="line"><span class="comment">总共买票次数：5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>相比于上一个未考虑线程同步的例子来说，这个考虑线程同步只是将线程对关键的单一对象数据的存取操作放在了synchronized (“”){}同步块内，Java的同步机制会保证单位时刻最多只有一个线程在执行同步块内的操作，所以能达到线程同步效果避免不安全。<br>synchronized关键字修饰的同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> ElementType <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑线程同步机制的多线程买票程序实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试线程安全-2</span></span><br><span class="line"><span class="comment"> * -- 多个线程同时读写单一对象数据时(加同步锁)，避免引发安全问题</span></span><br><span class="line"><span class="comment"> * eg. 对于多线程买票问题，考虑线程同步机制（安全）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadSafe2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftNum = <span class="number">5</span>;<span class="comment">//设置剩余票数</span></span><br><span class="line">    <span class="keyword">int</span> purchaseTime = <span class="number">0</span>;<span class="comment">//统计买票次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//synchronized关键字修饰的&quot;买一张票&quot;的同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">purchaseAticket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readValue;<span class="comment">//定义读取值</span></span><br><span class="line">        <span class="keyword">if</span>((readValue = leftNum) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);<span class="comment">//线程休眠0.1秒, 模仿买票操作用时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReadLeftNum = &quot;</span> + readValue + <span class="string">&quot;, After Purchase leftNum = &quot;</span> + --leftNum);<span class="comment">//购票，将剩余票数减一</span></span><br><span class="line">            purchaseTime++;<span class="comment">//统计已购买票次数变量 +1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//成功买票，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//买票失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(purchaseAticket());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadSafe2 testThreadSafe = <span class="keyword">new</span> TestThreadSafe2();<span class="comment">//实例化类对象</span></span><br><span class="line">        <span class="comment">//以下实例化四个子线程</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        Thread threadD = <span class="keyword">new</span> Thread(testThreadSafe);</span><br><span class="line">        System.out.println(<span class="string">&quot;安全的有线程同步机制的多线程演示：\n总票数：&quot;</span> + testThreadSafe.leftNum);</span><br><span class="line">        <span class="comment">//启动四个子线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">        threadD.start();</span><br><span class="line">        <span class="comment">//主线程休眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">//主线程休眠3秒(足够这四个子线程买票)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总共买票次数：&quot;</span> + testThreadSafe.purchaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">安全的有线程同步机制的多线程演示：</span></span><br><span class="line"><span class="comment">总票数：5</span></span><br><span class="line"><span class="comment">ReadLeftNum = 5, After Purchase leftNum = 4</span></span><br><span class="line"><span class="comment">ReadLeftNum = 4, After Purchase leftNum = 3</span></span><br><span class="line"><span class="comment">ReadLeftNum = 3, After Purchase leftNum = 2</span></span><br><span class="line"><span class="comment">ReadLeftNum = 2, After Purchase leftNum = 1</span></span><br><span class="line"><span class="comment">ReadLeftNum = 1, After Purchase leftNum = 0</span></span><br><span class="line"><span class="comment">总共买票次数：5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>与第二种用<strong>synchronized (“”){}**同步块用修饰不同之处在于，这种是通过</strong>synchronized**关键字修饰的同步方法，单位时间内，最多只有一个线程执行该方法purchaseAticket()，所以能达到线程同步效果避免不安全。</p>
<h2 id="2-9-网络通信"><a href="#2-9-网络通信" class="headerlink" title="2.9. 网络通信"></a>2.9. 网络通信</h2><h3 id="2-9-1-网络协议"><a href="#2-9-1-网络协议" class="headerlink" title="2.9.1. 网络协议"></a>2.9.1. 网络协议</h3><h4 id="2-9-1-1-IP协议"><a href="#2-9-1-1-IP协议" class="headerlink" title="2.9.1.1. IP协议"></a>2.9.1.1. IP协议</h4><p>IP是Internet Protocol的简称，它是一种网络协议。Internet采用的协议是TCP/IP协议。</p>
<h4 id="2-9-1-2-TCP传输控制协议-Transmission-Control-Protocol"><a href="#2-9-1-2-TCP传输控制协议-Transmission-Control-Protocol" class="headerlink" title="2.9.1.2. TCP传输控制协议(Transmission Control Protocol)"></a>2.9.1.2. TCP传输控制协议(Transmission Control Protocol)</h4><p>TCP协议是一种 以固接线为基础的协议，它提供两台计算机间可靠的数据传送。</p>
<p>特征：</p>
<ul>
<li>保证数据能够确实送达</li>
<li>抵达的数据排列顺序与送出时的顺序相同</li>
</ul>
<p>因此，TCP协议适合可靠性要求较高的场合（HTTP、FTP和Telnet等都需要使用可靠的通信频道）</p>
<h4 id="2-9-1-3-UDP用户数据协议-User-Datagram-Protocol"><a href="#2-9-1-3-UDP用户数据协议-User-Datagram-Protocol" class="headerlink" title="2.9.1.3. UDP用户数据协议(User Datagram Protocol)"></a>2.9.1.3. UDP用户数据协议(User Datagram Protocol)</h4><p>UDP是无线连接通信协议，不保证可靠数据的传输。</p>
<p>特征：</p>
<ul>
<li>能够向若干个目标发送数据</li>
<li>能够接收发自若干个源的数据</li>
<li>接收多个数据包时不保证接收数据包的顺序与源发送顺序相同</li>
</ul>
<p>因此 ，UDP协议适合一些对数据准确性要求不高，对传输速度和时效要求非常高但允许小部分数据包丢失或传送顺序有所不同也不会严重损害需求的场合(如：网络聊天室、在线影片等)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>龙应台与儿子对话--“读书的理解”</title>
    <url>/2017/11/12/Meanning-reading/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Meanning-reading.jpg" class="full-image" />

<p>孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利。选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。</p>
<a id="more"></a>

<p>你说：“妈，你要清楚接受一个事实，就是你有一个极其平庸的儿子。我觉得你将来的事业一定比不上你，也比不上爸爸–你们俩都有博士学位，我可能会变成一个很普通的人，有很普通的学历，很普通的职业，不太有钱，也没有名。一个最最平庸的人。”</p>
<p>我可以现在告诉你：我真的不在乎你是否有成就。对我最重要的，不是你有否成就，而是你是否快乐。假如横在你眼前的选择是到华尔街做银行经理或者到动物园做照顾狮子河马的管理员，而你是一个喜欢动物研究的人，我就完全不认为银行经理比较有成就，或者狮子河马的管理员“平庸”。每天为钱的数字起伏而紧张而斗争，很可能不如每天给大象洗澡，给河马刷牙。</p>
<p>那么，在什么情况下我们才会与别人比名利？</p>
<p>最好的答案是：在我们内心无处寄托的情况之下。</p>
<p>怎么才能让我们的心灵有一个寄托，要么你经历过很多很多的事，要么你读过很多很多的书。水木然认为，作为年轻的一代，我们虽然无法像上一代那么淡定，因为经历是无法安装的，但是我们却可以的很多很多的书，让自己变的淡定而优雅。</p>
<p>再换一个角度来看：我们活在这个世界上，最划算的上就是读书，因为那都是前人智慧的积累，很多东西经历的几百年才成为真理，变成白纸黑字流传下来，而我们只需要几天时间就消化成自己的知识、见识，变成智慧储存起来，何乐而不为？</p>
<blockquote class="blockquote-center">
<p>阅读，才是这个世界上收益最高的买卖！<br>很多有成就的人，也都是因为站在了巨人的肩膀上，吸纳了前人的大智慧。</p>

</blockquote>

<div align = right>----龙应台</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>深度好文</tag>
      </tags>
  </entry>
  <entry>
    <title>最小堆与最大堆</title>
    <url>/2018/10/16/MinHeapAndMaxHeap/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/MinHeapAndMaxHeap.jpg" class="full-image" />

<ul>
<li>堆是一种经过排序的完全二叉树，对其中任一非终端节点，其数据值不大于（或不小于）其左右子节点的值。</li>
<li>最小堆(最大堆)堆能保证堆顶元素最小(最大)，相比于用数组存放数据，如果要查找所有数据中最小(最大)的数据时，数组的时间复杂度为O(n)，而最小堆(最大堆)的时间复杂度为O(1)。</li>
<li>而数据增删数据时，需要保证最小堆(最大堆)的动态可维护性仅需O(logN)。因此在特定的需求环境，最小堆(最大堆)这种数据结构非常高效。</li>
</ul>
<a id="more"></a>

<h1 id="1-最小堆"><a href="#1-最小堆" class="headerlink" title="1. 最小堆"></a>1. 最小堆</h1><h2 id="1-1-最小堆概念"><a href="#1-1-最小堆概念" class="headerlink" title="1.1. 最小堆概念"></a>1.1. 最小堆概念</h2><p>最小堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节点的值。堆内的所有数据中最小的元素始终在堆顶，而增删一个元素而动态维护最小堆性质的时间复杂度仅为O(logN)</p>
<h2 id="1-2-最小堆实现思路"><a href="#1-2-最小堆实现思路" class="headerlink" title="1.2. 最小堆实现思路"></a>1.2. 最小堆实现思路</h2><p>将最小堆二叉树存储到数组内，非根节点元素的父节点下标为(i-1)/2，若子节点存在则下标为2*i+1。</p>
<ul>
<li><strong>插入操作</strong>：每当插入一个元素，将元素插入到容器（数组）尾部，然后执行迭代的上升操作，将插入的元素与其父节点比较，若比父节点小则交换，然后再与交换后节点的父节点相互比较交换，直到放置到合适位置。（最坏递归到根节点终止迭代）</li>
<li><strong>取出操作</strong>：弹出最小值（即数组首地址元素a[0]）。先交换交换堆顶与堆末，再弹出堆末（最小值），然后再将现堆顶元素执行迭代的下降操作，若其子节点存在与其子节点比较，若比子节点小则交换，然后再与交换后的子节点相互比较交换，直到放置在合适位置。（最坏递归到叶子节点）</li>
</ul>
<h2 id="1-3-最小堆C-实现完整代码"><a href="#1-3-最小堆C-实现完整代码" class="headerlink" title="1.3. 最小堆C++实现完整代码"></a>1.3. 最小堆C++实现完整代码</h2><h3 id="1-3-1-最小堆-h文件"><a href="#1-3-1-最小堆-h文件" class="headerlink" title="1.3.1. 最小堆.h文件"></a>1.3.1. 最小堆.h文件</h3><figure class="highlight c++"><figcaption><span>文件名：MinHeap.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MINHEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINHEAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造小顶堆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ElementType&gt; a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造小顶堆</span></span><br><span class="line">    MinHeap(ElementType elements[], <span class="keyword">int</span> number)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.push_back(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=a.size()/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            down(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换i,j下标对应元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ElementType temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上升操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa =(i<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//f表示父节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; a[i]&lt;a[fa])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(i, fa);</span><br><span class="line">            up(fa);<span class="comment">//如果一直比父节点小，递归到根节点(下标0)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(ElementType p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a.push_back(p);</span><br><span class="line">        up(a.size()<span class="number">-1</span>);<span class="comment">//上升操作 直到合适位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下降操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> son = <span class="number">2</span>*i+<span class="number">1</span>;<span class="comment">//son表示子节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (son &lt; a.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (son+<span class="number">1</span> &lt; a.size() &amp;&amp; a[son] &gt; a[son+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                son++; <span class="comment">//取值两个子节点 值更小的节点下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若子节点小，交换</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[son])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(i, son);</span><br><span class="line">            &#125;</span><br><span class="line">            down(son);<span class="comment">//递归调用，直到叶子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出堆顶节点（最小）</span></span><br><span class="line">    <span class="function">ElementType <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ElementType result = a[<span class="number">0</span>];</span><br><span class="line">        swap(<span class="number">0</span>, a.size()<span class="number">-1</span>);<span class="comment">//交换堆顶与堆末</span></span><br><span class="line">        a.pop_back();<span class="comment">//弹出</span></span><br><span class="line">        down(<span class="number">0</span>);<span class="comment">//再将原来的最末元素（现在的堆顶元素）下降操作，使之到合适位置</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出堆(顺序输出)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-最小堆-cpp范例代码"><a href="#1-3-2-最小堆-cpp范例代码" class="headerlink" title="1.3.2. 最小堆.cpp范例代码"></a>1.3.2. 最小堆.cpp范例代码</h3><figure class="highlight c++"><figcaption><span>文件名：MinHeap.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">13</span>, <span class="number">43</span>, <span class="number">84</span>, <span class="number">96</span>, <span class="number">22</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">47</span>&#125;;</span><br><span class="line">    MinHeap* m = <span class="keyword">new</span> MinHeap(a, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;显示当前最小堆:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m-&gt;show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;弹出最小堆顶的元素:&quot;</span> &lt;&lt; m-&gt;pop() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;显示当前最小堆:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m-&gt;show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入一个节点30:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m-&gt;push(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;显示当前最小堆:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-最大堆"><a href="#2-最大堆" class="headerlink" title="2. 最大堆"></a>2. 最大堆</h1><h2 id="2-1-最大堆概念"><a href="#2-1-最大堆概念" class="headerlink" title="2.1. 最大堆概念"></a>2.1. 最大堆概念</h2><p>最大堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不小于其左子节点和右子节点的值。</p>
<h2 id="2-2-最大堆实现思路"><a href="#2-2-最大堆实现思路" class="headerlink" title="2.2. 最大堆实现思路"></a>2.2. 最大堆实现思路</h2><p>将最大堆二叉树存储到数组内，非根节点元素的父节点下标为(i-1)/2，若子节点存在则下标为2*i+1。</p>
<ul>
<li><strong>插入操作</strong>：每当插入一个元素，将元素插入到容器（数组）尾部，然后执行迭代的上升操作，将插入的元素与其父节点比较，若比父节点大则交换，然后再与交换后节点的父节点相互比较交换，直到放置到合适位置。（最坏递归到根节点终止迭代）</li>
<li><strong>取出操作</strong>：弹出最大值（即数组首地址元素a[0]）。先交换交换堆顶与堆末，再弹出堆末（最大值），然后再将现堆顶元素执行迭代的下降操作，若其子节点存在与其子节点比较，若比子节点小则交换，然后再与交换后的子节点相互比较交换，直到放置在合适位置。（最坏递归到叶子节点）</li>
</ul>
<h2 id="2-3-最大堆C-实现完整代码"><a href="#2-3-最大堆C-实现完整代码" class="headerlink" title="2.3. 最大堆C++实现完整代码"></a>2.3. 最大堆C++实现完整代码</h2><h3 id="2-3-1-最大堆-h代码"><a href="#2-3-1-最大堆-h代码" class="headerlink" title="2.3.1. 最大堆.h代码"></a>2.3.1. 最大堆.h代码</h3><figure class="highlight c++"><figcaption><span>文件名：MaxHeap.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAXHEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXHEAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造大顶堆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ElementType&gt; a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造大顶堆</span></span><br><span class="line">    MaxHeap(ElementType elements[], <span class="keyword">int</span> number)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.push_back(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=a.size()/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            down(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换i,j下标对应元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ElementType temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上升操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = (i<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//f表示父节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; a[i] &gt; a[fa])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(i, fa);</span><br><span class="line">            up(fa);<span class="comment">//如果一直比父节点大，递归到根节点(下标0)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(ElementType p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a.push_back(p);</span><br><span class="line">        up(a.size()<span class="number">-1</span>);<span class="comment">//上升操作 直到合适位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下降操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> son = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//son表示子节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (son &lt; a.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (son+<span class="number">1</span> &lt; a.size() &amp;&amp; a[son] &lt; a[son+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                son++; <span class="comment">//取值两个子节点 值更大的节点下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若子节点大，交换</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[son])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(i, son);</span><br><span class="line">            &#125;</span><br><span class="line">            down(son);<span class="comment">//递归调用，直到叶子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出堆顶节点（最大）</span></span><br><span class="line">    <span class="function">ElementType <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ElementType result = a[<span class="number">0</span>];</span><br><span class="line">        swap(<span class="number">0</span>, a.size()<span class="number">-1</span>);<span class="comment">//交换堆顶与堆末</span></span><br><span class="line">        a.pop_back();<span class="comment">//弹出</span></span><br><span class="line">        down(<span class="number">0</span>);<span class="comment">//再将原来的最末元素（现在的堆顶元素）下降操作，使之到合适位置</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出堆(顺序输出)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-最大堆-cpp范例代码"><a href="#2-3-2-最大堆-cpp范例代码" class="headerlink" title="2.3.2. 最大堆.cpp范例代码"></a>2.3.2. 最大堆.cpp范例代码</h3><figure class="highlight c++"><figcaption><span>文件名：MaxHeap.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MaxHeap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">13</span>,<span class="number">43</span>,<span class="number">84</span>,<span class="number">96</span>,<span class="number">22</span>,<span class="number">65</span>,<span class="number">70</span>,<span class="number">47</span>&#125;;</span><br><span class="line">    MaxHeap* m = <span class="keyword">new</span> MaxHeap(a, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;显示当前最大堆:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m-&gt;show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;弹出最大堆顶的元素:&quot;</span> &lt;&lt; m-&gt;pop() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;显示当前最大堆:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m-&gt;show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入一个节点90:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m-&gt;push(<span class="number">90</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;显示当前最大堆:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>停车场仿真系统</title>
    <url>/2019/01/23/ParkingSimulationSystem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/ParkingSimulationSystem.jpg" class="full-image" />

<h1 id="1-停车场仿真系统"><a href="#1-停车场仿真系统" class="headerlink" title="1. 停车场仿真系统"></a>1. 停车场仿真系统</h1><p>Project：用面向对象方法和面向对象程序设计语言，设计并实现停车场仿真程序。<br>Platform：基于QT5.9.1开发，程序语言C++<br>coder：eisenhao<br>Time: 20190123</p>
<a id="more"></a>

<div class="note success"><p>完整源码详见:<a href="https://github.com/EisenHao/ParkingSimulationSystem">我的Git🥰</a></p>
</div>
<p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/showFunction.gif" alt="parkingSimulationSystemUMLMainWindowDiagram"></p>
<h2 id="1-1-设计说明"><a href="#1-1-设计说明" class="headerlink" title="1.1. 设计说明"></a>1.1. 设计说明</h2><p>某企业欲为其内部停车场建设一套信息系统，已经调查到的需求如下：</p>
<ul>
<li>企业为每位员工均发放一张感应式IC卡，卡上记录员工号。该卡由专门的卡管理系统 M 制作和维护，本系统需通过 M 来验证卡的有效性。</li>
<li>在停车场的入口和出口处分别安装一个自动栏杆、一台感应式IC卡读卡器和一个车辆通过传感器。</li>
<li>入口处安装一个显示屏，显示当前空闲车位数量。若停车场当前没有空闲车位，则不允许汽车入场，只许场内的汽车出场。</li>
<li>当一辆入场汽车到达入口时，用读卡器读出驾驶员的卡上信息，系统根据读出内容检查该卡的合法性：若该卡有效（需问M）&amp;&amp; 未被记录于当前场内卡号集合(即其车在场内的员工集合)中，即为合法卡。若为合法卡，系统命令栏杆抬起；汽车通过入口后，入口传感器通知系统发出命令，栏杆放下，系统遂将该卡卡号记录于当前场内卡号集合中；若为非法卡，则系统不发出栏杆抬起的命令，并发出告警信号。</li>
<li>当一辆出场汽车到达出口时，用读入器读出驾驶员的卡上信息，系统根据读出内容检查该卡是否已经被记录在当前场内卡号集合中。若已被记录，系统命令栏杆抬起；汽车通过出口后，出口传感器通知系统发出命令，栏杆放下，系统遂将该卡从当前场内卡号集合中删除；若未被记录，系统不发出栏杆抬起的命令而发出告警信号，交由出口值班人员处理。</li>
</ul>
<h2 id="1-2-设计要求"><a href="#1-2-设计要求" class="headerlink" title="1.2. 设计要求"></a>1.2. 设计要求</h2><ul>
<li>程序开始时，停车场车位全空。此后随机产生要进场的汽车，并按上述描述进行入场仿真。</li>
<li>汽车在停车场中的停留时间随机产生（为仿真的方便，可限定在5分钟之内，并在入场后立即设置）。到达停车时间后汽车即按上述描述进行出场仿真。</li>
<li><strong>定时报告</strong>（为方便，每分钟报告一次），应至少包括：当前时刻（包括时、分、秒）、当前场内车数、到目前为止的本次仿真“累计入场车数”、本次仿真“累计出场车数”、“本次仿真汽车的平均停车时间”。</li>
<li>应将上条报告的每条信息均写入指定的运行<strong>记录文件</strong>。文件名格式为“仿真日期-仿真起始时间.TXT”。 其中&lt;仿真日期&gt;为yyyyMMdd格式，&lt;仿真起始时间&gt;为hhmmss格式。</li>
<li>先按E=2<em>N进行上述仿真。达到预期目标后，再分别按E &lt; 2*N和E &gt; 2</em>N进行仿真。因此，要求E和N从命令行、或配置文件、或从界面上读入，不能写死在程序中。</li>
<li>为检验系统的<strong>控制功能</strong>，应<strong>随机</strong>产生以下三类<strong>事件</strong>，并将这些事件的细节记录到上述的运行记录文件。a)前文的两类争道冲突；b)非本单位员工汽车要求入场的情况；c)需按限定条件（8）处理的情况。</li>
</ul>
<h2 id="1-3-限定条件"><a href="#1-3-限定条件" class="headerlink" title="1.3. 限定条件"></a>1.3. 限定条件</h2><ul>
<li><p>该企业的员工总人数为E人，员工号为1~E。</p>
</li>
<li><p>该停车场可容纳2*N辆汽车；入口到出口的距离=N+2个车位的宽度。</p>
</li>
<li><p>汽车入场、出场时的读卡均需1秒钟，栏杆抬起、放下均需2秒钟，汽车的长度为2个车位宽度，汽车的行驶速度为每秒1个车位宽度。</p>
</li>
<li><p>入场的汽车尾端通过入口传感器后，该传感器通知系统放下入口栏杆。出场的汽车尾端通过出口传感器后，该传感器通知系统放下出口栏杆。</p>
</li>
<li><p> 汽车进入停车场后，总是选择离入口最近的一个<strong>空</strong>车位停车。</p>
</li>
<li><p>汽车入场到达停车位后，需再用2秒从行车道停到车位上。汽车出场时先用2秒从车位到达行车道，然后向出口行进。</p>
</li>
<li><p>行车道上不允许汽车并行。a)若有进场车与出场车争道冲突，让出场车先行；b)若有出场车争道冲突，让离出口较远者先行；若与出口距离相同，随机决定让其中一辆车先行。</p>
</li>
<li><p>出口值班人员处理不允许出场的汽车时，令该车返回原车位。若原车位已被占用，返回离出口最近的一个空车位。</p>
</li>
</ul>
<p>在整个仿真过程中不考虑驾驶员走入或走出停车场。</p>
<h2 id="1-4-设计模型说明"><a href="#1-4-设计模型说明" class="headerlink" title="1.4. 设计模型说明"></a>1.4. 设计模型说明</h2><h3 id="1-4-1-类图"><a href="#1-4-1-类图" class="headerlink" title="1.4.1. 类图"></a>1.4.1. 类图</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/parkingSimulationSystemUMLClassDiagram.png" alt="parkingSimulationSystemUMLClassDiagram"></p>
<p>主要有：停车场类、汽车类、后台管理M系统类、IC读卡器类、栏杆类、传感器类。与栏杆类、传感器类是整体与部分关系。</p>
<h3 id="1-4-2-用例图"><a href="#1-4-2-用例图" class="headerlink" title="1.4.2. 用例图"></a>1.4.2. 用例图</h3><p><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/parkingSimulationSystemUMLUseCaseDiagram.png" alt="parkingSimulationSystemUMLUseCaseDiagram"></p>
<p>主要描述了汽车与系统与后台管理系统M、读卡器、传感器、栏杆等参与者的关系。</p>
<h2 id="1-5-仿真流程（运行流程）简介"><a href="#1-5-仿真流程（运行流程）简介" class="headerlink" title="1.5. 仿真流程（运行流程）简介"></a>1.5. 仿真流程（运行流程）简介</h2><p>操作简单。涉及用户的人机交互操作仅有：设定员工人数、设定总车位数(/2)、“开始仿真”、“结束仿真”、“生成汽车”按钮。</p>
<h3 id="1-5-1-设定员工人数、设定总车位数-2-参数"><a href="#1-5-1-设定员工人数、设定总车位数-2-参数" class="headerlink" title="1.5.1. 设定员工人数、设定总车位数(/2)参数"></a>1.5.1. 设定员工人数、设定总车位数(/2)参数</h3><p>设定员工人数、设定总车位数(/2) 或维持默认（10, 5）。</p>
<h3 id="1-5-2-点击“开始仿真”"><a href="#1-5-2-点击“开始仿真”" class="headerlink" title="1.5.2. 点击“开始仿真”"></a>1.5.2. 点击“开始仿真”</h3><p>点击“开始仿真”按钮。</p>
<h3 id="1-5-3-点击“生成汽车”"><a href="#1-5-3-点击“生成汽车”" class="headerlink" title="1.5.3. 点击“生成汽车”"></a>1.5.3. 点击“生成汽车”</h3><p>点击“生成汽车”按钮，此时在相对坐标(0,0)处生成汽车，添加该实例到MainWindow类的生成汽车容器中（QVector&lt;carClass*&gt; creatCarList），并进行各种行为控制。</p>
<h3 id="1-5-4-系统内部每1s中断响应函数"><a href="#1-5-4-系统内部每1s中断响应函数" class="headerlink" title="1.5.4. 系统内部每1s中断响应函数"></a>1.5.4. 系统内部每1s中断响应函数</h3><p>执行：获取时间并更新界面左侧显示窗口信息，仿真控制所有生成车的运动的函数，检测下1秒有无争道并处理(让弱势方延时1秒)，自动关前门，自动关后门</p>
<h3 id="1-5-5-点击“结束仿真”"><a href="#1-5-5-点击“结束仿真”" class="headerlink" title="1.5.5. 点击“结束仿真”"></a>1.5.5. 点击“结束仿真”</h3><p>点击“结束仿真”按钮，关闭右侧动画框，保存系统日志文件。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的四种多态</title>
    <url>/2018/10/14/PolymorphismTest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/PolymorphismTest.jpg" class="full-image" />

<h1 id="1-多态的意义"><a href="#1-多态的意义" class="headerlink" title="1. 多态的意义"></a>1. 多态的意义</h1><ul>
<li>使程序中的数学运算符合常规的数学运算规则，使程序提供更强的表达能力;</li>
<li>使得对不同类型的数据有同样的操作语义(程序的重用);</li>
<li>重用标识的资源，提高程序的可读性和可理解性。<a id="more"></a>

</li>
</ul>
<h1 id="2-多态的种类"><a href="#2-多态的种类" class="headerlink" title="2. 多态的种类"></a>2. 多态的种类</h1><p>在程序中多态分为：通用的多态(universal)及特定的多态。</p>
<ul>
<li>其中通用多态包含：参数多态(parametric)和包含多态(inclusion)，特点是对数据类型不加限制;允许对不同类型的值执行相同的代码。</li>
<li>特定的多态包含：过载多态(overloading)和强制多态(coercion)，特点是只对有限数量的类型有效、对不同类型的值可能要执行不同的代码。</li>
</ul>
<h2 id="2-1-参数多态-Parametric-polymorphism"><a href="#2-1-参数多态-Parametric-polymorphism" class="headerlink" title="2.1. 参数多态(Parametric polymorphism)"></a>2.1. 参数多态(Parametric polymorphism)</h2><ul>
<li>概念：采用参数化模板，通过给出不同的类型实参，使得一个程序结构有多种类型。</li>
<li>例如：Ada中的generic(类属)、C++中的template(模板)，二者均支持数据类型和函数的参数多态。</li>
<li>从C++的template 结构可以看出：<ul>
<li>对实参所取的类型不加限制，不同的实参执行的是相同的代码。所以参数多态是一种通用多态。</li>
<li>模板的特点有：<ul>
<li>在一个抽象结构中允许以参数形式来表示可变部分–包括：类型、函数、常数;</li>
<li>在编译时(静态)才进行实例化，结果是一个具体的结构(类型、函数等)。</li>
<li>类型的实例化(类型→变量)可以静态进行，也可以动态进行，但结果都是一个值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如以下代码，在.h文件中定义模板类shape时，将类中的变量类型暂时用”T”代替</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后在.cpp文件中实例化该shape类时再指定变量的类型。如以下代码实例化该shape时分别指定类中的成员变量bottomLength、height的类型为int、double</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="function">shape&lt;<span class="keyword">int</span>&gt; <span class="title">shape1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">shape&lt;<span class="keyword">double</span> &gt; <span class="title">shape2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-包含多态-inclusion-polymorphism"><a href="#2-2-包含多态-inclusion-polymorphism" class="headerlink" title="2.2. 包含多态(inclusion polymorphism)"></a>2.2. 包含多态(inclusion polymorphism)</h2><ul>
<li>概念：同样的操作可用于一个(基)类型及其派生类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//求图形面积</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (bottomLength * height);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：平行四边形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parallelogram</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态，可直接调用基类的getArea()方法**/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：矩形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态，可直接调用基类的getArea()方法**/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-重置"><a href="#2-3-重置" class="headerlink" title="2.3. 重置"></a>2.3. 重置</h2><p>类比与之相似的“重置”。如C++中在基类定义的virsual方法，在派生类中再进行不同实现。如以下代码，在.h文件中从基类shape派生了两个子类：Triangle和Rectangle，两个子类中对父类的同一方法getArea()进行了两种不同的再实现，此为C++中的另一种形式的多态（重置）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//求图形面积</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (bottomLength * height);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：三角形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态**/</span></span><br><span class="line">        <span class="function">T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;bottomLength * <span class="keyword">this</span>-&gt;height / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：矩形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态**/</span></span><br><span class="line">        <span class="function">T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;bottomLength * <span class="keyword">this</span>-&gt;height);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-过载多态-overloading-polymorphism"><a href="#2-4-过载多态-overloading-polymorphism" class="headerlink" title="2.4. 过载多态(overloading polymorphism)"></a>2.4. 过载多态(overloading polymorphism)</h2><ul>
<li>概念：同一个表示操作的名字(如操作符、函数名)在不同的上下文中有不同的类型。(相同抽象，不同细节)。</li>
<li>程序设计语言中基本类型的多数操作符都是过载多态的。如：一个过载多态的操作符或函数名，它通常对应多个不同的实现。</li>
</ul>
<p>如以下代码在定义shape类中，有两个shape()构造函数，仅形参不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**过载多态：不带参数**/</span></span><br><span class="line">        shape()</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = <span class="number">0</span>;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**过载多态：带2个参数**/</span></span><br><span class="line">        shape(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = value1;</span><br><span class="line">            height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-强制多态-coercion"><a href="#2-5-强制多态-coercion" class="headerlink" title="2.5. 强制多态(coercion)"></a>2.5. 强制多态(coercion)</h2><ul>
<li>概念：通过语义操作，把操作数的类型强行加以变换，以符合操作符或函数的要求。</li>
<li>程序设计语言中基本类型的大多数操作符，在发生不同类型的数据进行混合运算时，编译程序一般都会进行强制类型转换(强制多态)。这种强制转换通常是隐式的，但程序员也可以显式地进行强制多态的操作(Casting)。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**强制多态**/</span></span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>， b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    c = a + b; <span class="comment">//隐式强制多态 将int类型的a，b转换为double</span></span><br></pre></td></tr></table></figure>

<h1 id="3-尝试构建一个同时包含四种多态的范例"><a href="#3-尝试构建一个同时包含四种多态的范例" class="headerlink" title="3. 尝试构建一个同时包含四种多态的范例"></a>3. 尝试构建一个同时包含四种多态的范例</h1><p>构造了一个基于C++的包含参数多态、包含多态、过载多态和强制多态的范例， 其中参数多态用模板展现。</p>
<h2 id="3-1-h文件完整代码如下："><a href="#3-1-h文件完整代码如下：" class="headerlink" title="3.1. .h文件完整代码如下："></a>3.1. .h文件完整代码如下：</h2><figure class="highlight c++"><figcaption><span>文件名: PolymorphismTest.h</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POLYMORPHISMTEST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLYMORPHISMTEST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//基类：图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        T bottomLength; <span class="comment">//底边长</span></span><br><span class="line">        T height; <span class="comment">//高</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**过载多态：不带参数**/</span></span><br><span class="line">        shape()</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = <span class="number">0</span>;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**过载多态：带1个参数**/</span></span><br><span class="line">        shape(T value)</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = value;</span><br><span class="line">            height = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**过载多态：带2个参数**/</span></span><br><span class="line">        shape(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">            bottomLength = value1;</span><br><span class="line">            height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求图形面积</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (bottomLength * height);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：三角形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**重置**/</span></span><br><span class="line">        <span class="function">T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;bottomLength * <span class="keyword">this</span>-&gt;height / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Triangle(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bottomLength = value1;</span><br><span class="line">            <span class="keyword">this</span>-&gt;height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：平行四边形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parallelogram</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**包含多态，可直接调用基类的getArea()方法**/</span></span><br><span class="line">        Parallelogram(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">this</span>-&gt;bottomLength = value1;</span><br><span class="line">            <span class="keyword">this</span>-&gt;height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**参数多态**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//派生：矩形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> shape&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**重置**/</span></span><br><span class="line">        <span class="function">T <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;bottomLength * <span class="keyword">this</span>-&gt;height);</span><br><span class="line">        &#125;</span><br><span class="line">        Rectangle(T value1， T value2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bottomLength = value1;</span><br><span class="line">            <span class="keyword">this</span>-&gt;height = value2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-2-cpp文件完整代码如下："><a href="#3-2-cpp文件完整代码如下：" class="headerlink" title="3.2. .cpp文件完整代码如下："></a>3.2. .cpp文件完整代码如下：</h2><figure class="highlight c++"><figcaption><span>文件名: PolymorphismTest.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PolymorphismTest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**参数多态**/</span></span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">int</span>&gt; <span class="title">shape1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">double</span> &gt; <span class="title">shape2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**过载多态**/</span></span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">double</span>&gt; <span class="title">shape3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">double</span>&gt; <span class="title">shape4</span><span class="params">(<span class="number">3.2</span>， <span class="number">5.7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**包含多态**/</span></span><br><span class="line">    <span class="function">shape&lt;<span class="keyword">double</span>&gt; <span class="title">shape5</span><span class="params">(<span class="number">4</span>， <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Parallelogram&lt;<span class="keyword">double</span>&gt; <span class="title">parallelogram</span><span class="params">(<span class="number">4</span>， <span class="number">5</span>)</span></span>;</span><br><span class="line">    shape5.getArea();</span><br><span class="line">    parallelogram.getArea();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**重置**/</span></span><br><span class="line">    <span class="keyword">int</span> a， b;</span><br><span class="line">    <span class="function">Rectangle&lt;<span class="keyword">int</span>&gt; <span class="title">rectangle1</span><span class="params">(<span class="number">4</span>， <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Triangle&lt;<span class="keyword">int</span>&gt; <span class="title">triangle1</span><span class="params">(<span class="number">4</span>， <span class="number">4</span>)</span></span>;</span><br><span class="line">    a = rectangle1.getArea();</span><br><span class="line">    b = triangle1.getArea();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**强制多态**/</span></span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    c = a + b; <span class="comment">//隐式强制多态 将int类型a，b转换为double</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QuickSort</title>
    <url>/2018/10/23/QuickSort/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/QuickSort.jpg" class="full-image" />

<h1 id="1-快速排序概念"><a href="#1-快速排序概念" class="headerlink" title="1. 快速排序概念"></a>1. 快速排序概念</h1><p>快速排序（Quick Sort）由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br>快速排序是不稳定的算法，时间复杂度在最坏情况下是O(N^2)，平均的时间复杂度是O(N*lgN)。</p>
<a id="more"></a>
<h2 id="1-1-Quick-Sort-实现思想"><a href="#1-1-Quick-Sort-实现思想" class="headerlink" title="1.1. Quick Sort 实现思想"></a>1.1. Quick Sort 实现思想</h2><p>快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：</p>
<ul>
<li>1、从数列中取出一个数作为基准数（枢轴，pivot）。 </li>
<li>2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。</li>
<li>3、再对左右的子区间重复第2步的划分操作，直至每个子区间的元素个数不超过Cutoff（阈值）。</li>
<li>4、每个子区间内的元素执行插入排序（实践经验小于一定数量后插入排序快于快速排序），然后返回上一调用堆栈。</li>
</ul>
<h2 id="1-2-快速排序-h完整代码"><a href="#1-2-快速排序-h完整代码" class="headerlink" title="1.2. 快速排序.h完整代码"></a>1.2. 快速排序.h完整代码</h2><figure class="highlight c++"><figcaption><span>文件名：QuickSort.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUICKSORT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKSORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序（从小到大）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">(ElementType* PtrA, <span class="keyword">long</span> <span class="keyword">int</span> Number)</span></span>&#123;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//认为A[0]已经插入了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">int</span> P = <span class="number">1</span>; P &lt; Number; P++)&#123;</span><br><span class="line">        temp = *(PtrA + P);<span class="comment">//取待插入排序元素到temp</span></span><br><span class="line">        <span class="keyword">for</span>(i = P; i &gt; <span class="number">0</span> &amp;&amp; *(PtrA + i - <span class="number">1</span>) &gt; temp; i--)&#123;</span><br><span class="line">            <span class="comment">//从后往前循环，大的元素往后挪，直到不小于temp处退出循环</span></span><br><span class="line">            <span class="comment">//A[i] = A[i-1];</span></span><br><span class="line">            *(PtrA + i) = *(PtrA + i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(PtrA + i) = temp;<span class="comment">//此是i为不大于temp的下标，插入temp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swap two elements of the Array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(ElementType *A, ElementType *B)</span></span>&#123;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    <span class="comment">//三部曲</span></span><br><span class="line">    temp = *A; <span class="comment">// 存A</span></span><br><span class="line">    *A = *B; <span class="comment">//换A</span></span><br><span class="line">    *B = temp; <span class="comment">//换B</span></span><br><span class="line">    <span class="comment">//或利用异或性质原地交换</span></span><br><span class="line">    <span class="comment">//*B ^= *A;</span></span><br><span class="line">    <span class="comment">//*A ^= *B;</span></span><br><span class="line">    <span class="comment">//*B ^= *A;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序中生成pivot</span></span><br><span class="line"><span class="function">ElementType <span class="title">Median3</span><span class="params">(<span class="built_in">vector</span>&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Left, <span class="keyword">long</span> <span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> Center = (Left + Right)/ <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span>(A[Left] &gt; A[Center])&#123;</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Center]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[Left] &gt; A[Right])&#123;</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[Center] &gt; A[Right])&#123;</span><br><span class="line">        Swap(&amp;A[Center], &amp;A[Right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在，左、中、右三个已经有序</span></span><br><span class="line">    Swap(&amp;A[Center], &amp;A[Right<span class="number">-1</span>]);</span><br><span class="line">    <span class="comment">//现在只需考虑　Left+1 ~ Right-2</span></span><br><span class="line">    <span class="keyword">return</span> A[Right<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序算法实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cutoff 5 <span class="comment">//定义快速排序（递归）阈值，数组元素小于Cutoff直接插入排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Left, <span class="keyword">long</span> <span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    ElementType pivot;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否进行快速排序，阈值判断</span></span><br><span class="line">    <span class="keyword">if</span>((Right - Left)&gt;= Cutoff)&#123;</span><br><span class="line">        <span class="comment">//选主元pivot，藏于A[Right-1]</span></span><br><span class="line">        pivot = Median3(A, Left, Right);</span><br><span class="line">        i = Left ;</span><br><span class="line">        j = Right - <span class="number">1</span> ;</span><br><span class="line">        <span class="comment">//子集划分(pivot左边全小于pivot；pivot右边全大于pivot)</span></span><br><span class="line">        <span class="keyword">for</span>(; ;)&#123;</span><br><span class="line">            <span class="keyword">while</span>(A[++i] &lt; pivot)&#123;&#125; <span class="comment">//找到A[i] &gt; pivot, 跳出</span></span><br><span class="line">            <span class="keyword">while</span>(A[--j] &gt; pivot)&#123;&#125; <span class="comment">//找到A[j] &lt; pivot, 跳出</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="comment">//说明A[i]与A[j]之间还有其他元素，可交换</span></span><br><span class="line">                Swap(&amp;A[i], &amp;A[j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Swap(&amp;A[i], &amp;A[Right<span class="number">-1</span>]); <span class="comment">//将pivot 放到中间，即i下标处</span></span><br><span class="line">        Quicksort(A, Left, i<span class="number">-1</span>);<span class="comment">//递归处理左边</span></span><br><span class="line">        Quicksort(A, i+<span class="number">1</span>, Right);<span class="comment">//递归处理右边</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//低于阈值，直接调用插入排序</span></span><br><span class="line">        <span class="comment">//递归到最小一层用插入排序(每段的插入排序地址为：&amp;A + Left(即：绝对地址A 加相对地址Left)</span></span><br><span class="line">        <span class="comment">//最小一层插入排序元素个数Number = Right-Left+1</span></span><br><span class="line">        Insertion_Sort( &amp;A[Left], Right-Left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序（统一接口，加壳）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Number)</span></span>&#123;</span><br><span class="line">    Quicksort(A, <span class="number">0</span>, Number<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Prlong int the Array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Array</span><span class="params">(<span class="built_in">vector</span>&lt;ElementType&gt; &amp;A, <span class="keyword">long</span> <span class="keyword">int</span> Number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> NumberOfPreRows = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Number; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; A[i];</span><br><span class="line">        <span class="keyword">if</span>(i%NumberOfPreRows == (NumberOfPreRows<span class="number">-1</span>))&#123;</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-快速排序-cpp范例代码"><a href="#1-3-快速排序-cpp范例代码" class="headerlink" title="1.3. 快速排序.cpp范例代码"></a>1.3. 快速排序.cpp范例代码</h2><figure class="highlight c++"><figcaption><span>文件名：QuickSort.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QuickSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(x)(rand()%x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> Number = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//构造Number + 1大小的容器</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ElementType&gt; <span class="title">A</span><span class="params">(Number + <span class="number">1</span>)</span></span>; <span class="comment">//build a vector to</span></span><br><span class="line">    <span class="comment">//产生Number个随机数并赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Number; i++)</span><br><span class="line">        A[i] = random(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//Print A</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creat 100 random Num:&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Print_Array(A, Number);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Execute Quick Sort&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Quick_Sort(A, Number);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result:&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//Print A</span></span><br><span class="line">    Print_Array(A, Number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-延伸思考："><a href="#1-4-延伸思考：" class="headerlink" title="1.4. 延伸思考："></a>1.4. 延伸思考：</h2><p>假设待排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？</p>
<p>最多需要遍历N次，至少需要遍历lg(N+1)次。</p>
<ul>
<li>(1).为什么最少是lg(N+1)次？<br>快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。</li>
<li>(2).为什么最多是N次？<br>将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>钱穆：读书与做人</title>
    <url>/2021/01/28/ReadingAndBeingAMan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/QianMu.jpg" class="full-image" />

<div class="note success"><p>钱穆（1895年7月30日-1990年8月30日），字宾四，笔名公沙，江苏省无锡人，中国现代历史学家。<br>其毕生弘扬中国传统文化，高举现代新儒家的旗帜，创办了新亚书院，与吕思勉、陈垣、陈寅恪并称为“史学四大家”，代表著作有《钱宾四先生全集》等。</p>
</div>

<p>本文转自钱穆先生在二十世纪六十年代应邀在复兴中国文化会第十次学术会议中发表的演讲《读书与做人》。原文如下，妄自在钱穆先生演讲中加上小标题以便网页快速定位，还望包涵！</p>
<a id="more"></a>

<h1 id="1-（引言）"><a href="#1-（引言）" class="headerlink" title="1. （引言）"></a>1. （引言）</h1><p>今天在这讲堂里有年青的同学，有中年人，更有老年人；真是一次很有价值、很有意义的盛会。如按年岁来排，便可分三班；所以讲话就比较难。因为所讲如是年青人比较喜欢的，可能年长的不大爱听；反之亦然。现在我准备所讲将以年长人为主，因为年青人将来还得做大人；但年老了，却不能复为青年人。并且年幼的都当敬重年老的，这将好让将来的青年人也敬重你们。至于年老的人，都抱着羡慕你们年青人的心情，自然已值得年青人骄傲了。</p>
<h1 id="2-（至死学做一个高标准的人）"><a href="#2-（至死学做一个高标准的人）" class="headerlink" title="2. （至死学做一个高标准的人）"></a>2. （至死学做一个高标准的人）</h1><p>我今天的讲题是“读书与做人”，实在对年青人也有关。婴孩一出世，就是一个人，但还不是我们理想中要做的一个人。我们也不能因为日渐长大成人了，就认为满足；人仍该要自己做。所谓做人，是要做一个理想标准高的人。这须自年幼时即学做；即使已届垂暮之年，仍当继续勉学、努力做。所谓“学到老，做到老”，做人工夫无止境。学生在学校读书，有毕业时期；但做人却永不毕业——临终一息尚存，他仍是一人，即仍该做；所以做人须至死才已。</p>
<h1 id="3-（读书与做人的关系）"><a href="#3-（读书与做人的关系）" class="headerlink" title="3. （读书与做人的关系）"></a>3. （读书与做人的关系）</h1><p>现在讲到读书。因为只有在书上可以告诉我们如何去做一个有理想高标准的人；诸位在学校读书，主要就是要学做人；即如做教师的亦然。固然做教师可当是一职业；但我们千万不要以为职业仅是为谋生，当知职业也在做人道理中。做人理当有职业，以此贡献于社会。人生不能无职业，这是从古到今皆然的。但做一职业，并不即是做人之全体，而只是其一部分。学生在校求学，为的是为他将来职业作准备。然而除在课堂以外；如在宿舍中，或是在运动场上，也都是在做人，亦当学。在课堂读书求学，那只是学做人的一部分；将来出了学校，有了职业，还得要做人。做人圈子大，职业圈子小。做人当有理想，有志愿。这种理想与志愿，藏在各人内心，别人不能见，只有他自己才知道。因此，读书先要有志；其次，当能养成习惯，离开了学校还能自己不断读书。读书亦就是做人之一部分，因从读书可懂得做人的道理，可使自己人格上进。</p>
<h1 id="4-（狭义读书与业余读书）"><a href="#4-（狭义读书与业余读书）" class="headerlink" title="4. （狭义读书与业余读书）"></a>4. （狭义读书与业余读书）</h1><p>惟在离开了学校以后的读书，实与在学校里读书有不同。在学校里读书，由学校课程硬性规定，要笔记、要考试，战战兢兢，担心不及格，不能升级、不能毕业，好像在为老师而读书，没有自己的自由；至于离了学校，有了职业，此时再也没有讲堂，也没有老师了，此时再读书，全是自由的，各人尽可读各人自己喜欢的书。当知：在学校中读书，只是为离学校求职业作准备。这种读书并不算真读书。如果想做一位专门学者，这是他想以读书为职业；当知此种读书，亦是做人中一小圈子。我们并不希望，而且亦不大可能要人人尽成为学者。我此所讲，乃指我们离开学校后，不论任何职业、任何环境而读书，这是一种业余读书，这种读书，始是属于人生的大圈子中尽人应有之一事；必需的，但又是自由的。今问此种读书应如何读法？下面我想提出两个最大的理想、最共同的目标来：</p>
<h1 id="5-（业余读书的最大理想与追求？）"><a href="#5-（业余读书的最大理想与追求？）" class="headerlink" title="5. （业余读书的最大理想与追求？）"></a>5. （业余读书的最大理想与追求？）</h1><h2 id="5-1-（培养情趣）"><a href="#5-1-（培养情趣）" class="headerlink" title="5.1. （培养情趣）"></a>5.1. （培养情趣）</h2><p>一是培养情趣。人生要过得愉快、有趣味，这需用工夫去培养。社会上甚至有很多人怕做人了，他觉得人生乏味，对人生发生厌倦，甚至于感到痛苦。譬如：我们当教师，有人觉得当教师是不得已，只是为谋生，只是枯燥沉闷，挨着过日子。但当知：这非教师做不得，只是他失了人生的情趣了。今试问：要如何才能扭转这心理，使他觉得人生还是有意义有价值？这便得先培养他对人生的情趣；而这一种培养人生情趣的工夫，莫如好读书。</p>
<h2 id="5-2-（提高境界）"><a href="#5-2-（提高境界）" class="headerlink" title="5.2. （提高境界）"></a>5.2. （提高境界）</h2><p>二是提高境界。所谓境界者，例如这讲堂，在调景岭村中，所处地势，既高又宽敞，背山面海；如此刻晴空万里，海面归帆遥驶，或海鸥三五，飞翔碧波之上；如开窗远眺，便觉眼前呈露的，乃是一片优美境界，令人心旷神怡。即或朗日已匿，阴雨晦冥，大雾迷蒙，亦仍别有一番好景。若说是风景好，当知亦从境界中得来；若换一境界，此种风景也便不可得。居住有境界，人生亦有境界；此两种境界并不同。并非住高楼美屋的便一定有高的、好的人生境界，住陋室茅舍的便没有。也许住高楼华屋，居住境界好，但他的人生境界并不好。或许住陋室茅舍，他的居住环境不好，而他的人生境界却尽好。要知人生境界别有存在。这一层，或许对青年人讲，一时不会领会，要待年纪大了、经验多、读书多才能体会到此。我们不是总喜欢过舒服快乐的日子吗？当知人生有了好的高的境界，他做人自会多情趣，觉得快活舒适。若我们希望能到此境界，便该好好学做人；要学做人，便得要读书。</p>
<h1 id="6-（读书为何能提高境界？）"><a href="#6-（读书为何能提高境界？）" class="headerlink" title="6. （读书为何能提高境界？）"></a>6. （读书为何能提高境界？）</h1><p>为什么读书便能学得做一个高境界的人呢？因为在书中可碰到很多人，这些人的人生境界高、情味深，好做你的榜样。目前在香港固然有三百几十万人之多，然而我们大家的做人境界却不一定能高，人生情味也不一定能深。我们都是普通人，但在书中遇见的人可不同；他们是由千百万人中选出，又经得起长时间的考验而保留以至于今日，像孔子，距今已有二千六百年，试问中国能有几个孔子呢？又如耶稣，也快达二千年；他如释迦牟尼、穆罕默德等人。为什么我们敬仰崇拜他们呢？便是由于他们的做人。当然，历史上有不少人物，他们都因做人有独到处，所以为后世人所记忆，而流传下来了。世间决没有中了一张马票，成为百万富翁而能流传后世的。即使做大总统或皇帝，亦没有很多人能流传让人记忆，令人向往。中国历代不是有很多皇帝吗？但其中大多数，全不为人所记忆，只是历史上有他一名字而已。哪里有读书专来记人姓名的呢？做皇帝亦尚无价值，其余可知。中马票固是不足道；一心想去外国留学、得学位，那又价值何在、意义何在呀？当知论做人，应别有其重要之所在。假如我们诚心想做一人，“培养情趣，提髙境界”，只此八个字，便可一生受用不尽；只要我们肯读书，能遵循此八个字来读，便可获得一种新情趣，进入一个新境界。各位如能在各自业余每天不断读书，持之以恒，那么长则十年二十年，短或三年五年，便能培养出人生情趣，提高了人生境界。那即是人生之最大幸福与最高享受了。</p>
<h1 id="7-（读书的选择？）"><a href="#7-（读书的选择？）" class="headerlink" title="7. （读书的选择？）"></a>7. （读书的选择？）</h1><p>说到此，我们当再进一层来谈一谈读书的选择。究竟当读哪些书好？我认为：业余读书，大致当分下列数类：</p>
<h2 id="7-1-（修养类的书）"><a href="#7-1-（修养类的书）" class="headerlink" title="7.1. （修养类的书）"></a>7.1. （修养类的书）</h2><p>一是修养类的书。所谓修养，犹如我们栽种一盆花，需要时常修剪枝叶，又得施肥浇水；如果偶有三五天不当心照顾，便决不会开出好花来，甚至根本不开花，或竟至枯死了。栽花尚然，何况做人！当然更须加倍修养。<br>中国有关人生修养的几部书是人人必读的。首先是论语。切不可以为我从前读过了，现在毋须再读。正如天天吃饭一样，不能说今天吃了，明天便不吃；好书也该时时读。再次是孟子。孔孟这两部书，最简单，但也最宝贵。如能把此两书经常放在身边，一天读一二条，不过化上三五分钟，但可得益无穷。此时的读书，是各人自愿的，不必硬求记得，也不为应考试，亦不是为着要做学问专家或是写博士论文；这是极轻松自由的，只如孔子所言“默而识之”便得。只这样一天天读下，不要以为没有什么用；如像诸位毎天吃下许多食品，不必也不能时时去计算在里面含有多少维他命，多少卡路里，只吃了便有益；读书也是一样。这只是我们一种私生活，同时却是一种高尚享受。</p>
<p>孟子曾说过：“君子有三乐，而王天下不与存焉。”连做皇帝王天下都不算乐事；那么，看电影、中马票，又算得什么？但究竟孟子所说的那三件乐事是什么？我们不妨翻读一下孟子，把他的话仔细想一想，那实在是有意义的。人生欲望是永远不会满足的；有人以为月入二百元能加至二百五十元就会有快乐；哪知等到你如愿以偿，你始觉得仍然不快乐——即使王天下，也一样会不快乐。我们试读历史，便知很多帝王比普通人活得更不快乐。做人确会有不快乐，但我们不能就此便罢，我们仍想寻求快乐。人生的真快乐，我劝诸位能从书本中去找；只化三两块钱到书店中去，便可买到论语孟子；即使一天读一条，久之也有无上享受。</p>
<p>还有一部老子，全书只五千字。一部庄子，篇幅较巨，文字较深，读来比较难；但我说的是业余读书，尽可不必求全懂。要知：即是一大学者，他读书也会有不懂的；何况我们是业余读书；等于放眼看窗外风景，或坐在巴士轮渡中欣赏四周景物，随你高兴看什么都好，不一定要全把外景看尽了，而且是谁也看不尽。还有一部佛教禅宗的六祖坛经，是用语体文写的，内中故事极生动，道理极深邃，化几小时就可一口气读完，但也可时常精读。其次，还有朱子的近思录与阳明先生的传习录。这两部书，篇幅均不多，而且均可一条条分开读。爱读几条便几条。我常劝国人能常读上述七部书。中国传统所讲修养精义，已尽在其内。而且此七书不论你做何职业，生活如何忙，都可读。今天在座年幼的同学们，只盼你们记住这几部书名，亦可准备将来长大了读。如果大家都能毎天抽出些时间来，有恒地去读这七部书，准可叫我们脱胎换骨，走上新人生的大道去。</p>
<h2 id="7-2-（欣赏类的书）"><a href="#7-2-（欣赏类的书）" class="headerlink" title="7.2. （欣赏类的书）"></a>7.2. （欣赏类的书）</h2><p>其次便是欣赏类的书。风景可以欣赏，电影也可以欣赏，甚至品茶喝咖啡，都可有一种欣赏。我们对人生本身也需要欣赏，而且需要能从高处去欣赏。最有效的莫如读文学作品，尤要在读诗。这并非要求大家都做一个文学家；只要能欣赏。谚语有云：“熟读唐诗三百首，不会做诗也会吟。”诗中境界，包罗万象；不论是自然部分，不论是人生部分，中国诗里可谓无所不包；一年四季，天时节令，一切气候景物，乃至飞潜动植，一枝柳，一瓣花，甚至一条村狗或一只令人讨厌的老鼠，都进入诗境，经过诗人笔下晕染，都显出一番甚深情意，趣味无穷；进入人生所遇喜怒哀乐，全在诗家作品中。当我们读诗时，便可培养我们欣赏自然，欣赏人生，把诗中境界成为我们心灵欣赏的境界。如能将我们的人生投放沉浸在诗中，那真趣味无穷。<br>如陶渊明诗：</p>
<blockquote class="blockquote-center">
<p><strong>犬吠深巷中，鸡鸣桑树巅。</strong></p>

</blockquote>
<p>这十个字，岂非我们在穷乡僻壤随时随地可遇到！但我们却忽略了其中情趣。经陶诗一描写，却把一幅富有风味的乡村闲逸景象活在我们眼前了。我们能读陶诗，尽在农村中过活，却可把我们带进人生最高境界中去，使你如在诗境中过活，那不好吗？</p>
<p>又如王维诗：</p>
<blockquote class="blockquote-center">
<p><strong>雨中山果落，灯下草虫鸣。</strong></p>

</blockquote>
<p>诸位此刻住山中，或许也会接触到这种光景：下雨了，宅旁果树上，一个个熟透了的果子掉下来，可以听到“扑”“扑”的声音；草堆里小青虫经着雨潜进窗户来了，在灯下唧唧地鸣叫着。这是一个萧瑟幽静的山中雨夜，但这诗中有人。上面所引陶诗，背后也有人。只是一在山中，一在村中；一在白天，一在晚上。诸位多读诗，不论在任何境遇中，都可唤起一种文学境界，使你像生活在诗中，这不好吗？</p>
<p>纵使我们也有不能亲历其境的，但也可以移情神游，于诗中得到一番另外境界，如唐诗：</p>
<blockquote class="blockquote-center">
<p><strong>松下问童子，言师采药去；只在此山中，云深不知处。</strong></p>

</blockquote>
<p>那不是一幅活的人生画像吗？那不是画的人，却是画的人生。那一幅人生画像，活映在我们眼前，让我们去欣赏。在我想，欣赏一首诗，应比欣赏一张电影片有味，因其更可使我们长日神游，无尽玩味。不仅诗如此，即中国散文亦然。诸位纵使只读一本唐诗三百首、只读一本古文观止也好；当知我们学文学，并不为自己要做文学家。因此，不懂诗韵平仄，仍可读诗。读散文更自由。学文学乃为自己人生享受之用，在享受中仍有提髙自己人生之收获，那真是人生一秘诀。</p>
<h2 id="7-3-（博闻类的书）"><a href="#7-3-（博闻类的书）" class="headerlink" title="7.3. （博闻类的书）"></a>7.3. （博闻类的书）</h2><p>第三是博闻类。这类书也没有硬性规定；只求自己爱读，史传也好，游记也好，科学也好，哲学也好，性之所近，自会乐读不倦，增加学识，广博见闻，年代一久，自不寻常。</p>
<h2 id="7-4-（新知类的书）"><a href="#7-4-（新知类的书）" class="headerlink" title="7.4. （新知类的书）"></a>7.4. （新知类的书）</h2><p>第四是新知类。我们生在这时代，应该随时在这时代中求新知。这类知识，可从现代出版的期刊杂志上，乃至报章上找到。这一类更不必详说了。</p>
<h2 id="7-5-（消遣类的书）"><a href="#7-5-（消遣类的书）" class="headerlink" title="7.5. （消遣类的书）"></a>7.5. （消遣类的书）</h2><p>第五是消遣类。其实广义说来，上面所提，均可作为消遣；因为这根本就是业余读书，也可说即是业余消遣。但就狭义说之，如小说、剧本、传奇等，这些书便属这一类。如诸位读水浒传、三国演义、红楼梦，可作是消遣。</p>
<h1 id="8-（何时读书？）"><a href="#8-（何时读书？）" class="headerlink" title="8. （何时读书？）"></a>8. （何时读书？）</h1><p>上面已大致分类说了业余所当读的书。但诸位或说生活忙迫，能在什么时读呢？其实人生忙，也是应该的；只在能利用空闲，如欧阳修的三上，即：枕上、厕上和马上。上床了，可有十分一刻钟睡不着；上洗手间，也可顺便带本书看看；今人不骑骡马，但在舟车上读书，实比在马上更舒适。古人又说三余：冬者岁之余，夜者日之余，阴者晴之余。现在我们生活和古人不同；但每人必有很多零碎时间，如：清晨早餐前，傍晚天黑前，又如临睡前；一天便有三段零碎时间了。恰如一块布，裁一套衣服以后，余下的零头，大可派作别的用场。另外，还有周末礼拜天，乃及节日和假期；尤其是做教师的还有寒暑假。这些都可充分利用，作为业余读书时间的。假如毎日能节约一小时，十年便可有三千六百个小时。又如一个人自三十岁就业算起，到七十岁，便可节余一万四千四百个小时，这不是一笔了不得的大数目吗？现在并不是叫你去吃苦做学问，只是以读书为娱乐和消遣，亦像打麻雀、看电影，哪会说没有时间的！如果我们读书也如打麻雀、看电影般有兴趣、有习惯，在任何环境任何情况下都可读书。这样，便有高的享受，有好的娱乐，岂非人生一大佳事！读书只要有恒心，自能培养出兴趣，自能养成为习惯，从此可以提髙人生境界。这是任何数量的金钱所买不到的。</p>
<h1 id="9-（倡导读书）"><a href="#9-（倡导读书）" class="headerlink" title="9. （倡导读书）"></a>9. （倡导读书）</h1><p>今日香港社会读书空气实在太不够，中年以上的人，有了职业，便不再想到要进修，也不再想到业余还可再读书。我希望诸位能看重此事，也不妨大家合作，有书不妨交换读，有意见可以互相倾谈。如此，更易培养出兴趣。只消一年时间，习惯也可养成。我希望中年以上有职业的人能如此，在校的青年们他日离了学校亦当能如此，那真是无上大佳事。循此以往，自然人生境界都会高，人生情味都会厚。人人如此，社会也自成为一好社会。我今天所讲，并不是一番空泛的理论，只是我个人的实际经验。今天贡献给各位，愿与大家都分享这一份人生的无上宝贵乐趣。</p>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>深度好文</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork仓库同步官方源仓库的更新</title>
    <url>/2019/11/18/RefreshForkRepositorie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/RefreshForkRepositorie.png" class="full-image" />

<p>Fork仓库是对应官方源仓库的一份完全备份（类似快照，但却不能再接收到官方源仓库的更新内容），然而有时咱们需要Fork仓库涵盖官方源仓库的最新提交代码。</p>
<a id="more"></a>

<p>本文总结介绍了从官方源仓库同步更新内容到Fork仓库的方法，过程大致如下：</p>
<ul>
<li>向本地Fork仓库添加官方源仓库远端</li>
<li>再获取(fetch)官方源仓库的更新内容到本地仓库</li>
<li>然后合并官方源仓库的更新内容到本地Fork仓库</li>
<li>最后推送到远端Fork仓库。</li>
</ul>
<h1 id="1-步骤一、添加官方源仓库远端"><a href="#1-步骤一、添加官方源仓库远端" class="headerlink" title="1. 步骤一、添加官方源仓库远端"></a>1. 步骤一、添加官方源仓库远端</h1><h2 id="1-1-查看远端仓库"><a href="#1-1-查看远端仓库" class="headerlink" title="1.1. 查看远端仓库"></a>1.1. 查看远端仓库</h2><p>查看本地Fork仓库的远端信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>一般此时查询的结果只有一个Fork仓库远端（共两行fetch + push）eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin      ssh:&#x2F;&#x2F;git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git (fetch)</span><br><span class="line">origin      ssh:&#x2F;&#x2F;git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git (push)</span><br></pre></td></tr></table></figure>
<p>其中 “origin” （默认值）为本地设置的Fork远端仓库的远端别名， 而“ssh://git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git“ 对应为你的Fork仓库地址</p>
<h2 id="1-2-添加官方源仓库远端"><a href="#1-2-添加官方源仓库远端" class="headerlink" title="1.2. 添加官方源仓库远端"></a>1.2. 添加官方源仓库远端</h2><p>添加官方源仓库远端到本地Fork仓库，使具有两个远端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin_official https:&#x2F;&#x2F;oooooooooooooooooooooooooooooo.git</span><br></pre></td></tr></table></figure>
<p>其中 “origin_official” 为自定义官方源仓库在本地的远端别名， “<a href="https://oooooooooooooooooooooooooooooo.git&quot;/">https://oooooooooooooooooooooooooooooo.git&quot;</a> 为官方源仓库地址</p>
<h2 id="1-3-再次检查本地的远程信息"><a href="#1-3-再次检查本地的远程信息" class="headerlink" title="1.3. 再次检查本地的远程信息"></a>1.3. 再次检查本地的远程信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>此时查询本地Fork仓库应该有两个远端，一个Fork仓库远端和一个官方源仓库远端（共四行）eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin            ssh:&#x2F;&#x2F;git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git (fetch)</span><br><span class="line">origin            ssh:&#x2F;&#x2F;git@xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.git (push)</span><br><span class="line">origin_official   https:&#x2F;&#x2F;oooooooooooooooooooooooooooooo.git(fetch)</span><br><span class="line">origin_official   https:&#x2F;&#x2F;oooooooooooooooooooooooooooooo.git(push)</span><br></pre></td></tr></table></figure>

<h1 id="2-步骤二、获取远程官方源仓库的更新内容"><a href="#2-步骤二、获取远程官方源仓库的更新内容" class="headerlink" title="2. 步骤二、获取远程官方源仓库的更新内容"></a>2. 步骤二、获取远程官方源仓库的更新内容</h1><h2 id="2-1-通过fetch命令获得一份官方源仓库的更新内容到本地Fork仓库"><a href="#2-1-通过fetch命令获得一份官方源仓库的更新内容到本地Fork仓库" class="headerlink" title="2.1. 通过fetch命令获得一份官方源仓库的更新内容到本地Fork仓库"></a>2.1. 通过fetch命令获得一份官方源仓库的更新内容到本地Fork仓库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin_official</span><br></pre></td></tr></table></figure>

<h2 id="2-2-检查并切换到想同步更新的分支-一般为master分支"><a href="#2-2-检查并切换到想同步更新的分支-一般为master分支" class="headerlink" title="2.2. 检查并切换到想同步更新的分支(一般为master分支)"></a>2.2. 检查并切换到想同步更新的分支(一般为master分支)</h2><h3 id="2-2-1-检查当前分支"><a href="#2-2-1-检查当前分支" class="headerlink" title="2.2.1. 检查当前分支"></a>2.2.1. 检查当前分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>一般此时查询结果为origin/master分支（默认），其对应远端分支为Fork远端仓库的master分支。若当前本地Fork仓库有未提交的修改内容则需先推送修改内容到Fork仓库远端，否则可能为后面合并操作带来不必要的工作量。</p>
<h3 id="2-2-2-切换到非master分支（可选）"><a href="#2-2-2-切换到非master分支（可选）" class="headerlink" title="2.2.2. 切换到非master分支（可选）"></a>2.2.2. 切换到非master分支（可选）</h3><p>若待同步的源仓库更新内容不在master分支，则需手动切换到对应分支（如xxxxxx分支），否则可跳过此## 步骤。切换到待同步源仓库远端分支有更新内容对应的Fork仓库在本地仓库的分支（有点绕，如xxxxxx分支）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b xxxxxxFork origin&#x2F;master</span><br></pre></td></tr></table></figure>
<p>其中 “xxxxxxFork” 为自定义本地分支名，对应Fork仓库的xxxxxx分支， “origin” 对应Fork仓库远端别名</p>
<h1 id="3-步骤三、合并官方源仓库的更新内容到本地仓库"><a href="#3-步骤三、合并官方源仓库的更新内容到本地仓库" class="headerlink" title="3. 步骤三、合并官方源仓库的更新内容到本地仓库"></a>3. 步骤三、合并官方源仓库的更新内容到本地仓库</h1><p>合并官方源仓库的更新内容到本地仓库对应分支(一般为master分支)。如合并origin_official/master的更新内容到本地Fork仓库的master分支（默认分支），若为其他分支则替换为对应分支便可（如：替换master为xxxxxx）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge origin_official&#x2F;master</span><br></pre></td></tr></table></figure>
<ul>
<li>若当前的本地仓库包含未提交的内容，则会提示合并失败，此时需要先推送本地修改内容到Fork仓库远端，再执行该合并操作。</li>
<li>若更新内容与本地仓库内容区别较大git合并时报冲突也会提示合并失败，处理冲突后便可完成合并</li>
</ul>
<h1 id="4-步骤四、推送本地代码到远端Fork仓库"><a href="#4-步骤四、推送本地代码到远端Fork仓库" class="headerlink" title="4. 步骤四、推送本地代码到远端Fork仓库"></a>4. 步骤四、推送本地代码到远端Fork仓库</h1><p>此时本地Fork仓库的master分支已包含官方源仓库master分支的更新内容，再执行push操作将这些更新内容推送到自己的远端Fork仓库即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>至此，已完成同步官方源仓库mater分支的所有更新到Fork仓库。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>成长规划</title>
    <url>/2019/11/04/SelfgrowthPlanning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/SelfgrowthPlanning.jpg" class="full-image" />

<p>总结 Bilibili Up主 zettaranc 不断践行并获取成功的四点方法论：年轻人如何赚到自己的第一桶金，乍一看虽会觉得老生常谈，但粗略考虑却也是符合无数名人的成功和发展的大体趋势，而且zettaranc结合自身诸多“小目标”的成功实践也颇具说服力。践行强于妄想，不断培养自我成长的“内驱力”，记录以自勉👊</p>
<a id="more"></a>

<blockquote class="blockquote-center">
<p>心中醒，口中说，纸上作，不从身上习过，皆无用也。<br>– by 颜元</p>

</blockquote>

<h1 id="1-找到你最想干的事"><a href="#1-找到你最想干的事" class="headerlink" title="1. 找到你最想干的事"></a>1. 找到你最想干的事</h1><ul>
<li>不要企图用理想让这个世界上有谁理解你，你只有用做到后的事实让大家认可你！</li>
<li>越年轻，失败的成本越低，所以趁还年轻勇于尝试</li>
<li>一个人老后不会伤心曾经做过什么，因为已成既定事实，而是懊悔没有做过什么</li>
</ul>
<h1 id="2-找到擅长的领域，成长为专家"><a href="#2-找到擅长的领域，成长为专家" class="headerlink" title="2. 找到擅长的领域，成长为专家"></a>2. 找到擅长的领域，成长为专家</h1><ul>
<li>比别人思考更多的专业问题，学习更多的专业知识，投入更多的时间精力。因为必须至少成为某个领域额的专家，你才有资格在这个领域混口饭吃。</li>
</ul>
<h1 id="3-主动尝试，主动出击"><a href="#3-主动尝试，主动出击" class="headerlink" title="3. 主动尝试，主动出击"></a>3. 主动尝试，主动出击</h1><ul>
<li>这个世界人太多了，想要赚取“超额收益”比你想象中更难，总有人比你离机会更近，总有人比你想进入的领域钻研的时间更长，你只有巩固第一二项，不断的投入更多的时间于精力，才可能有更大概率获取期待的“超额收益”，否则仍难突破大众平庸。</li>
</ul>
<h1 id="4-想象力的正向循环激励"><a href="#4-想象力的正向循环激励" class="headerlink" title="4. 想象力的正向循环激励"></a>4. 想象力的正向循环激励</h1><ul>
<li>在前三项实践过程中，总会有各种挑战阻碍你，总会有各种诱惑纷扰你，总会有各种质疑诋毁你，让成功的憧憬成为你的正向循环自驱力。</li>
<li>注意区别幻想与想象力，前者是没有事实根据的，是虚无的，后者是建立在一步步阶段小目标实现后对未来几步的远瞻和预估。</li>
</ul>
<h1 id="5-zettaranc分享方法论的视频"><a href="#5-zettaranc分享方法论的视频" class="headerlink" title="5. zettaranc分享方法论的视频"></a>5. zettaranc分享方法论的视频</h1><iframe src="//player.bilibili.com/player.html?aid=61773370&cid=107417443&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>自驱</tag>
      </tags>
  </entry>
  <entry>
    <title>七次省视自己的灵魂--卡里·纪伯伦</title>
    <url>/2017/03/21/Save-your-soul-seven-times/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Save-your-soul-seven-times.jpg" class="full-image" />

<p>发现自己的缺点并直视才是真的勇士。我曾七次鄙视自己的灵魂：</p>
<a id="more"></a>

<blockquote class="blockquote-center">
<p><strong>第一次</strong>，当它本可进取时，却故作谦卑<br><strong>第二次</strong>，当它在空虚时，用爱欲来填充<br><strong>第三次</strong>，在困难和容易之间，它选择了容易<br><strong>第四次</strong>，它犯了错，却借由别人也会犯错来宽慰自己<br><strong>第五次</strong>，它自由软弱，却把它认为是生命的坚韧<br><strong>第六次</strong>，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副<br><strong>第七次</strong>，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾</p>
<div align = right>--卡里·纪伯伦</div>
</blockquote>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>人生观触动</tag>
      </tags>
  </entry>
  <entry>
    <title>对于阶级固化下人生追求的思考</title>
    <url>/2017/11/12/Social-stratification-and-personal-life-goals/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Social-stratification-and-personal-life-goals.jpg" class="full-image" />

<h1 id="1-《北京的无奈》引发的思考"><a href="#1-《北京的无奈》引发的思考" class="headerlink" title="1. 《北京的无奈》引发的思考"></a>1. 《北京的无奈》引发的思考</h1><p>《北京的无奈：海淀区拼娃是怎么拼的》——一篇字字扎心却又让你醍醐灌顶的文章。就连被广泛认同公平圣洁的教育，在精英家庭氛围、文化底蕴潜移默化的影响、优质且稀缺教育资源的倾斜等作用下还会公平么？</p>
<a id="more"></a>

<p>在看过余秀兰的文章《底层放弃教育，中产过度焦虑，上层不玩高考》后认识更为深刻，文中概述了诸多原因导致底层人们向上流动受阻，对教育绝望，而中产和上层阶层的家庭对教育的追逐却愈发疯狂。在这个连教育都要拼爹的时代，已无公平可言，但我们却不得不面对这残酷的现实和冰凉的<strong>马太效应</strong>——强者愈强，弱者愈弱，或许成功真的不是一代人的积累。</p>
<h1 id="2-社会即将分层，阶层正在固化，而你，能成为英雄吗？"><a href="#2-社会即将分层，阶层正在固化，而你，能成为英雄吗？" class="headerlink" title="2. 社会即将分层，阶层正在固化，而你，能成为英雄吗？"></a>2. 社会即将分层，阶层正在固化，而你，能成为英雄吗？</h1><p>世界上永远存在这样一类人，<strong>他能够超越自己的家庭、血缘、环境，他能够挣脱时代对他的束缚，让世界另眼相看</strong>，这一类人被称为<strong>英雄</strong>。</p>
<p>那么问题来了：</p>
<blockquote>
<p><strong>社会即将分层，阶层正在固化，而你，能成为英雄吗？</strong></p>
</blockquote>
<p>当前社会并未发展到，某网友看过《北京折叠》后慨叹“<strong>社会正在撕裂，阶层正在固化！这个社会上，绝大多数的人，刚一出生，就已经输了</strong>”那么极端的程度，我<strong>仍然相信机会永远都存在</strong>。与其无奈地吐槽“读书改变命运”在当下如何变味、仇视各种“二代”、万念俱灰地被生活压迫最终向宿命论妥协，不妨沉心静气地思考一下，<strong>在当下阶层逐渐固化的背景下，你除了努力还能拼什么？你有什么理由放弃努力？</strong></p>
<p>逆袭之路漫漫其修远兮，骚年要向屈公“上下求索”看齐，打破马太效应桎梏，<strong>但求精进</strong>！</p>
<h1 id="3-人生目标的思考"><a href="#3-人生目标的思考" class="headerlink" title="3. 人生目标的思考"></a>3. 人生目标的思考</h1><ul>
<li><strong>打破现有家庭环境，文化背景，思想瓶颈的束缚</strong></li>
<li><strong>不断地修正自己的人生最高目标，以使自己能够长期地、持续地获得内心最有意义的感受</strong></li>
<li><strong>追求更精致的生活，更深度的价值观念，更高的生命质量</strong></li>
</ul>
<p>望与君共勉！</p>
<h1 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h1><ul>
<li>《<a href="http://www.360doc.cn/mip/571643947.html">北京的无奈：海淀区拼娃是怎么拼的</a>》</li>
<li>《<a href="http://wemedia.ifeng.com/62150036/wemedia.shtml">余秀兰：底层放弃教育，中产过度焦虑，上层不玩高考</a>》</li>
</ul>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>人生观触动</tag>
      </tags>
  </entry>
  <entry>
    <title>经典排序算法的C++编码实现与性能对比</title>
    <url>/2019/11/17/SortFuncCompare/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/SortFuncComparePicture.png" class="full-image" />

<p>排序作为常用的解决实际问题的计算方法，被广泛应用于生活中的方方面面。而处理实际问题的数据规模常常十分庞大，同一个计算任务选用不同的算法，其执行效率可能相差几百倍，几千倍甚至更高，因此效率常被作入为评判一个算法优劣的重要指标。<br>博主对七种常见的排序算法进行编码实现，和以处理同规模数据所耗时长为指标进行了性能比较（冒泡、选择、插入、希尔、堆、归并和快排）。</p>
<a id="more"></a>

<h1 id="1-测试排序函数运行时间方法"><a href="#1-测试排序函数运行时间方法" class="headerlink" title="1. 测试排序函数运行时间方法"></a>1. 测试排序函数运行时间方法</h1><p>运行排序算法前后打点，取前后两次打点的差值，再除以打点的频率得到函数的运行时长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试排序函数运行时间</span></span><br><span class="line"><span class="comment"> * @param pFunction 排序函数的函数指针</span></span><br><span class="line"><span class="comment"> * @Return 运行时长（秒）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">SortFuncCompare::testRunTime</span><span class="params">(<span class="keyword">void</span> (*pFunction)(ElementType *))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, stop;</span><br><span class="line">    <span class="keyword">double</span> runTime;</span><br><span class="line">    start = clock();</span><br><span class="line">    (*pFunction)(m_array);</span><br><span class="line">    stop = clock();</span><br><span class="line">    runTime = ((<span class="keyword">double</span>)stop - (<span class="keyword">double</span>)start) / CLOCKS_PER_SEC;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;run time = &quot; &lt;&lt; runTime &lt;&lt; &quot; s&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> runTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-测试函数"><a href="#2-测试函数" class="headerlink" title="2. 测试函数"></a>2. 测试函数</h1><p>定义排序函数的函数指针数组，size为7，逐一将七种static函数地址赋值到函数指针数组，然后循环执行七种函数对相同规模的随机数组的排序操作，便可得到各排序算法在各规模数据下的运行时长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*func[NUM_OF_SORT_FUNC])(ElementType*);<span class="comment">// 定义函数指针数组</span></span><br><span class="line">func[<span class="number">0</span>] = Bubble_Sort;      <span class="comment">// 1.冒泡排序</span></span><br><span class="line">func[<span class="number">1</span>] = Selection_Sort;   <span class="comment">// 2.选择排序</span></span><br><span class="line">func[<span class="number">2</span>] = Insertion_Sort;   <span class="comment">// 3.插入排序</span></span><br><span class="line">func[<span class="number">3</span>] = Shell_Sort;       <span class="comment">// 4.希尔排序</span></span><br><span class="line">func[<span class="number">4</span>] = Heap_Sort;        <span class="comment">// 5.堆排序</span></span><br><span class="line">func[<span class="number">5</span>] = Merge_Sort;       <span class="comment">// 6.归并排序</span></span><br><span class="line">func[<span class="number">6</span>] = Quick_Sort;       <span class="comment">// 7.快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::testFuncRuntime</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> *runTime = <span class="keyword">new</span> <span class="keyword">double</span>[NUM_OF_SORT_FUNC];<span class="comment">// Record the running time</span></span><br><span class="line">    <span class="comment">// Size of random array:10 ～ 100,000</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> size = MIN_NUM_OF_RAND_ARRAY; size &lt;= MAX_NUM_OF_RAND_ARRAY; size *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_SORT_FUNC; ++i) &#123;</span><br><span class="line">            <span class="comment">// Generate a random array</span></span><br><span class="line">            refreshArray(size);</span><br><span class="line">            <span class="comment">// Execute and record the running time</span></span><br><span class="line">            *(runTime + i) = testRunTime(func[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Output time consuming</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Num of Array = &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;\t: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_OF_SORT_FUNC - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *(runTime + j) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *(runTime + NUM_OF_SORT_FUNC - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] runTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-七种经典排序算法的C-编码实现"><a href="#3-七种经典排序算法的C-编码实现" class="headerlink" title="3. 七种经典排序算法的C++编码实现"></a>3. 七种经典排序算法的C++编码实现</h1><h2 id="3-1-冒泡排序"><a href="#3-1-冒泡排序" class="headerlink" title="3.1. 冒泡排序"></a>3.1. 冒泡排序</h2><p>时间复杂度:O(N^2)，空间复杂度:O(1)，原地，稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Bubble_Sort</span><span class="params">(ElementType* pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Bubble Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">bool</span> swapFlag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m_uiSizeOfArray - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        swapFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(pArray + j) COMPARE *(pArray + j + <span class="number">1</span>)) &#123;</span><br><span class="line">                swapTwoNum(pArray + j, pArray + j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!swapFlag)</span><br><span class="line">                    swapFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!swapFlag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-选择排序"><a href="#3-2-选择排序" class="headerlink" title="3.2. 选择排序"></a>3.2. 选择排序</h2><p>时间复杂度:O(N^2)，空间复杂度:O(1)，原地，稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Selection_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Selection Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_uiSizeOfArray - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m_uiSizeOfArray; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(pArray + i) COMPARE *(pArray + j))</span><br><span class="line">                swapTwoNum(pArray + i, pArray + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-插入排序"><a href="#3-3-插入排序" class="headerlink" title="3.3. 插入排序"></a>3.3. 插入排序</h2><p>时间复杂度:O(N^2)，空间复杂度:O(1)，原地，稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Insertion_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Insert Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m_uiSizeOfArray; ++i) &#123;</span><br><span class="line">        tmp = *(pArray + i);</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; *(pArray + j - <span class="number">1</span>) COMPARE tmp; --j) &#123;</span><br><span class="line">            *(pArray + j) = *(pArray + j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(pArray + j) = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-希尔排序"><a href="#3-4-希尔排序" class="headerlink" title="3.4. 希尔排序"></a>3.4. 希尔排序</h2><p>时间复杂度:O(N^1.25 ～N^1.5)，空间复杂度:O(1)，原地，非稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Shell_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Shell Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> D = m_uiSizeOfArray / <span class="number">2</span>; D &gt; <span class="number">0</span>; D /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// like Insert sort whose step is D</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = D; i &lt; m_uiSizeOfArray; ++i) &#123;</span><br><span class="line">            tmp = *(pArray + i);</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= D &amp;&amp; *(pArray + j - D) COMPARE tmp; j -= D) &#123;</span><br><span class="line">                *(pArray + j) = *(pArray + j - D);</span><br><span class="line">            &#125;</span><br><span class="line">            *(pArray + j) = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-堆排序"><a href="#3-5-堆排序" class="headerlink" title="3.5. 堆排序"></a>3.5. 堆排序</h2><p>时间复杂度:O(NlogN)，空间复杂度:O(1)，原地，非稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Heap_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Heap Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// build big root heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m_uiSizeOfArray / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        heapDown(pArray, i, m_uiSizeOfArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// choose biggest to end--</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m_uiSizeOfArray - <span class="number">1</span>; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">        swapTwoNum(pArray, pArray + j);</span><br><span class="line">        heapDown(pArray, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::heapDown</span><span class="params">(ElementType *pArray, <span class="keyword">int</span> fatherIndex, <span class="keyword">int</span> maxIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sonIndex = <span class="number">2</span> * fatherIndex + <span class="number">1</span>;<span class="comment">// default left son</span></span><br><span class="line">    <span class="keyword">if</span> (sonIndex &lt; maxIndex) &#123;</span><br><span class="line">        <span class="comment">// choose the bigger son</span></span><br><span class="line">        <span class="keyword">if</span> (sonIndex + <span class="number">1</span> &lt; maxIndex &amp;&amp; *(pArray + sonIndex + <span class="number">1</span>) COMPARE *(pArray + sonIndex))</span><br><span class="line">            ++sonIndex;</span><br><span class="line">        <span class="comment">// if the bigger son is bigger than its father, then swap</span></span><br><span class="line">        <span class="keyword">if</span> (*(pArray + sonIndex) COMPARE *(pArray + fatherIndex))</span><br><span class="line">            swapTwoNum(pArray + sonIndex, pArray + fatherIndex);</span><br><span class="line">        heapDown(pArray, sonIndex, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-归并排序"><a href="#3-6-归并排序" class="headerlink" title="3.6. 归并排序"></a>3.6. 归并排序</h2><p>时间复杂度:O(NlogN), 空间复杂度:O(n)，非原地，非稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Merge_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    ElementType* tmpA = <span class="keyword">new</span> ElementType[m_uiSizeOfArray];</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != tmpA) &#123;</span><br><span class="line">        mergeSort(pArray, tmpA, <span class="number">0</span>, m_uiSizeOfArray - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">delete</span>[] tmpA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::mergeSort</span><span class="params">(ElementType *pArray, ElementType *tmpA, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">        <span class="keyword">int</span> middleIndex = (leftIndex + rightIndex) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(pArray, tmpA, leftIndex, middleIndex);</span><br><span class="line">        mergeSort(pArray, tmpA, middleIndex + <span class="number">1</span>, rightIndex);</span><br><span class="line">        merge(pArray, tmpA, leftIndex, middleIndex + <span class="number">1</span>, rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::merge</span><span class="params">(ElementType *pArray, ElementType *tmpA,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> middleIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftSubIndex = leftIndex;</span><br><span class="line">    <span class="keyword">int</span> rightSubIndex = middleIndex;</span><br><span class="line">    <span class="keyword">int</span> tmpIndex = leftIndex;</span><br><span class="line">    <span class="comment">// compare</span></span><br><span class="line">    <span class="keyword">while</span> (leftSubIndex &lt; middleIndex &amp;&amp; rightSubIndex &lt;= rightIndex) &#123;</span><br><span class="line">        *(tmpA + tmpIndex++) = (*(pArray + leftSubIndex) COMPARE *(pArray + rightSubIndex)) ?</span><br><span class="line">                               *(pArray + rightSubIndex++) : *(pArray + leftSubIndex++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy the left rest (if remain)</span></span><br><span class="line">    <span class="keyword">while</span> (leftSubIndex &lt; middleIndex) &#123;</span><br><span class="line">        *(tmpA + tmpIndex++) = *(pArray + leftSubIndex++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy the right rest (if remain)</span></span><br><span class="line">    <span class="keyword">while</span> (rightSubIndex &lt;= rightIndex) &#123;</span><br><span class="line">        *(tmpA + tmpIndex++) = *(pArray + rightSubIndex++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write the result from tmpA to pArray</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = leftIndex; i &lt;= rightIndex; ++i) &#123;</span><br><span class="line">        *(pArray + i) = *(tmpA + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-快速排序"><a href="#3-7-快速排序" class="headerlink" title="3.7. 快速排序"></a>3.7. 快速排序</h2><p>时间复杂度:O(NlogN ~ N^2)，空间复杂度:O(1)，原地，非稳定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::Quick_Sort</span><span class="params">(ElementType *pArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;Quick Sort&quot; &lt;&lt; endl;</span></span><br><span class="line">    quickSort(pArray, <span class="number">0</span>, m_uiSizeOfArray - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_NUM_OF_CUTOFF 32 <span class="comment">// when the length of subarray small than MIN_NUM_OF_CUTOFF, choose the insert sort</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortFuncCompare::quickSort</span><span class="params">(ElementType *pArray, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rightIndex - leftIndex &gt; MIN_NUM_OF_CUTOFF) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = leftIndex;</span><br><span class="line">        <span class="keyword">int</span> j = rightIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// choose middle pivot</span></span><br><span class="line">        ElementType middlePivot = choosePivot(pArray, leftIndex, rightIndex);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (middlePivot COMPARE *(pArray + ++i)) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span> (*(pArray + --j) COMPARE middlePivot) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                swapTwoNum(pArray + i, pArray + j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// put the middle pivot into the middle index</span></span><br><span class="line">        swapTwoNum(pArray + i, pArray + rightIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(pArray, leftIndex, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(pArray, i + <span class="number">1</span>, rightIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Insert sort</span></span><br><span class="line">        ElementType tmp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = leftIndex + <span class="number">1</span>; i &lt;= rightIndex; ++i) &#123;</span><br><span class="line">            tmp = *(pArray + i);</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; leftIndex &amp;&amp; *(pArray + j - <span class="number">1</span>) COMPARE tmp; --j) &#123;</span><br><span class="line">                *(pArray + j) = *(pArray + j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            *(pArray + j) = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">SortFuncCompare::choosePivot</span><span class="params">(ElementType *pArray, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> middleIndex = (leftIndex + rightIndex) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(pArray + leftIndex) COMPARE *(pArray + middleIndex)) &#123;</span><br><span class="line">        swapTwoNum(pArray + leftIndex, pArray + middleIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(pArray + leftIndex) COMPARE *(pArray + rightIndex)) &#123;</span><br><span class="line">        swapTwoNum(pArray + leftIndex, pArray + rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(pArray + middleIndex) COMPARE *(pArray + rightIndex)) &#123;</span><br><span class="line">        swapTwoNum(pArray + middleIndex, pArray + rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    swapTwoNum(pArray + middleIndex, pArray + rightIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// return the middle value</span></span><br><span class="line">    <span class="keyword">return</span> *(pArray + rightIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-时耗测试"><a href="#4-时耗测试" class="headerlink" title="4. 时耗测试"></a>4. 时耗测试</h1><p>各排序算法在各个数据规模下排序所耗时长（秒）。</p>
<table>
<thead>
<tr>
<th align="left">数据规模</th>
<th align="left">冒泡</th>
<th align="left">选择</th>
<th align="left">插入</th>
<th align="left">希尔</th>
<th align="left">堆</th>
<th align="left">归并</th>
<th align="left">快排</th>
</tr>
</thead>
<tbody><tr>
<td align="left">十</td>
<td align="left">2e-06</td>
<td align="left">1e-06</td>
<td align="left">1e-06</td>
<td align="left">1e-06</td>
<td align="left">2e-06</td>
<td align="left">1e-06</td>
<td align="left">1e-06</td>
</tr>
<tr>
<td align="left">百</td>
<td align="left">3.3e-05</td>
<td align="left">3.3e-05</td>
<td align="left">8e-06</td>
<td align="left">8e-06</td>
<td align="left">1.1e-05</td>
<td align="left">1e-05</td>
<td align="left">5e-06</td>
</tr>
<tr>
<td align="left">千</td>
<td align="left">0.003153</td>
<td align="left">0.003</td>
<td align="left">0.000627</td>
<td align="left">0.000164</td>
<td align="left">0.00016</td>
<td align="left">0.000118</td>
<td align="left">6.9e-05</td>
</tr>
<tr>
<td align="left">万</td>
<td align="left">0.365065</td>
<td align="left">0.387825</td>
<td align="left">0.060752</td>
<td align="left">0.001938</td>
<td align="left">0.002096</td>
<td align="left">0.001431</td>
<td align="left">0.00089</td>
</tr>
<tr>
<td align="left">十万</td>
<td align="left">38.2601</td>
<td align="left">35.2071</td>
<td align="left">7.63559</td>
<td align="left">0.034236</td>
<td align="left">0.031059</td>
<td align="left">0.019387</td>
<td align="left">0.01238</td>
</tr>
<tr>
<td align="left">百万</td>
<td align="left">9708.16</td>
<td align="left">3736.74</td>
<td align="left">1643.99</td>
<td align="left">0.93</td>
<td align="left">0.98</td>
<td align="left">0.5</td>
<td align="left">0.3</td>
</tr>
</tbody></table>
<h2 id="4-1-分析"><a href="#4-1-分析" class="headerlink" title="4.1. 分析"></a>4.1. 分析</h2><ul>
<li><p>数据规模不超过一百时</p>
<img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/SortFuncComparePicture_size100.png" class="full-image" />
当数据规模较小时，各排序算法所耗时长区别并不明显，但当数据规模为一百时已有明显区别，最快的排序算法与最满的排序算法效率相差一个数量级。
</li>
<li><p>数据规模为一千时</p>
<img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/SortFuncComparePicture_size1000.png" class="full-image" />
除了冒泡和选择排序耗时三十几毫秒，其他排序算法耗时均在一毫秒内，此时各排序算法最快与最满效率比值已达为四十多倍
</li>
<li><p>数据规模为十万时</p>
<img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/SortFuncComparePicture_size100000.png" class="full-image" />
当排序数据规模达到十万时，可以发现排序最快的算法是快排仅12毫秒，效率是最慢的冒泡排序(38秒)的三千多倍，性能差异已十分明显。
</li>
<li><p>数据规模为百万时<br>当排序数据规模达到百万时，可以发现排序最快的算法是快排仅0.3秒，效率是最慢的冒泡排序(9708.16秒，约2.7小时)的三万多倍，性能差异已非常巨大。而且已知快排的平均时间复杂度为O(N*logN)，可进一步推测当数据规模为千万级别时，快排算法在此平台下耗时仅需3秒多，而时间复杂度为O(N^2)的冒泡排序在此平台下预计耗时将达到11天，两种算法的效率显现出天壤之别。</p>
</li>
</ul>
<h2 id="4-2-此次实验收获"><a href="#4-2-此次实验收获" class="headerlink" title="4.2. 此次实验收获"></a>4.2. 此次实验收获</h2><ul>
<li>各种排序算法在数规模小于一百时还没有太大差距，此时选实现较简单的就好</li>
<li>当数据达到一定规模后，不同算法执行效率差异巨大，此时追求算法效率显得十分重要</li>
</ul>
<h1 id="5-附件"><a href="#5-附件" class="headerlink" title="5. 附件"></a>5. 附件</h1><p>本次实验源代码详见博主的个人git仓库:</p>
<ul>
<li><a href="https://github.com/EisenHao/Cpp_Learning/blob/master/SortFuncCompare.h">SortFuncCompare.h</a></li>
<li><a href="https://github.com/EisenHao/Cpp_Learning/blob/master/SortFuncCompare.cpp">SortFuncCompare.cpp</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Win10 和 IDEA 的 Spark 开发&amp;测试环境搭建</title>
    <url>/2020/06/25/SparkDevAndTestEnvInWin10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/SparkDevAndTestEnvInWin10.jpg" class="full-image" />

<p>试想一下，将精心编写的Spark业务代码Jar包上传到Spark集群环境，却出现了简单错误或预期之外的结果，势必会破坏一天的心情和积极性，这时一套桌面级的Spark开发&amp;测试环境的优势就展露无遗了。可以在本地开发Spark代码，并测试基础功能，让开发者可以不必担心上传jar包的代码逻辑正确性、代码质量等基础问题。接下来就跟随本文一起搭建一套Win10下的Spark开发&amp;测试环境吧！</p>
<a id="more"></a>

<div class="note success"><p>环境信息<br>Java            1.8.0_251<br>Scala sdk       2.11.12<br>Spark lib       2.4.5<br>IDEA Community  2020.1.2</p>
</div>

<h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="1-1-搭建Java环境"><a href="#1-1-搭建Java环境" class="headerlink" title="1.1. 搭建Java环境"></a>1.1. 搭建Java环境</h2><ul>
<li><a href="https://www.oracle.com/java/technologies/javase-jdk14-downloads.html">Oracle官网</a>下载所需要的JDK(eg.<a href="https://download.oracle.com/otn-pub/java/jdk/14.0.1+7/664493ef4a6946b186ff29eb326336a2/jdk-14.0.1_windows-x64_bin.exe">jdk-14.0.1_windows-x64_bin.exe</a>)</li>
<li>安装JDK</li>
<li>配置环境变量：此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建”JAVA_HOME”变量，其值为上一步JDK安装路径；新建”CLASSPATH”变量，其值为”.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”；最后编辑”Path”变量，追加字段”%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">新建环境变量</span><br><span class="line">JAVA_HOME       C:\Java\jdk1.8.0_251</span><br><span class="line">CLASSPATH       .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</span><br><span class="line">修改Path变量（追加）</span><br><span class="line">Path            %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</span><br></pre></td></tr></table></figure></li>
<li>在PowerShell输入 java -version 判断是否安装成功<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">PS C:\Windows\system32&gt; java -version</span><br><span class="line">java version &quot;1.8.0_251&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_251-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)</span><br><span class="line">PS C:\Windows\system32&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-2-搭建Scala环境"><a href="#1-2-搭建Scala环境" class="headerlink" title="1.2. 搭建Scala环境"></a>1.2. 搭建Scala环境</h2><p>注：Scala依赖Java 8 JDK (或 Java 11 JDK)以后的版本；目前最新版本为2.13.2，但若需要调试Spark强烈建议下载2.11.x版本，因为Spark主要适配的是2.11.x版本，最新Scala版本可能出现与Spark不兼容问题</p>
<ul>
<li><a href="https://www.scala-lang.org/download/">Scala官网</a>下载Scala可安装程序版<a href="https://downloads.lightbend.com/scala/2.11.12/scala-2.11.12.msi">msi安装包</a>(大小109 MB) 或 <a href="https://downloads.lightbend.com/scala/2.11.12/scala-2.11.12.zip">Zip版本</a>(大小27.8 MB，推荐)。msi版可直接安装，Zip版需解压。</li>
<li>配置环境变量：此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建”SCALA_HOME”变量，其值为上一步Zip版解压路径或msi版安装路径；最后编辑”Path”变量，追加字段”%SCALA_HOME%\bin;”<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">新建环境变量</span><br><span class="line">SCALA_HOME      C:\Scala\scala-2.11.12</span><br><span class="line">修改Path变量（追加）</span><br><span class="line">Path            %SCALA_HOME%\bin;</span><br></pre></td></tr></table></figure></li>
<li>在PowerShell输入 scala 判断是否安装成功<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">PS C:\Windows\system32&gt; scala</span><br><span class="line">Welcome to Scala 2.11.12 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_251).</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta">scala&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-3-搭建Hadoop环境"><a href="#1-3-搭建Hadoop环境" class="headerlink" title="1.3. 搭建Hadoop环境"></a>1.3. 搭建Hadoop环境</h2><p>注：此步未配置将会导致执行scala程序时因缺少Hadoop环境如“winutils.exe”文件而无法执行，抛IOException</p>
<ul>
<li>登录<a href="https://github.com/">GitHub</a>搜索”hadoop win”，下载Spark运行所需的Hadoop win环境（如：<a href="https://github.com/steveloughran/winutils">steveloughran/winutils</a>），否则将无法运行Spark工程，报”java.io.IOException: Could not locate executable null\bin\winutils.exe in the Hadoop binaries.”</li>
<li>解压相应Hadoop版本到指定文件夹</li>
<li>需确保bin下有如下两个文件：hadoop.dll、winutils.exe</li>
<li>配置环境变量：此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新建”HADOOP_HOME”变量，其值为上一步解压路径；最后编辑”Path”变量，追加字段”%HADOOP_HOME%\bin;”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">新建环境变量</span><br><span class="line">HADOOP_HOME     C:\hadoop-2.7.1</span><br><span class="line">修改Path变量（追加）</span><br><span class="line">Path            %HADOOP_HOME%\bin;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-下载-Spark-的-Jar-依赖包"><a href="#1-4-下载-Spark-的-Jar-依赖包" class="headerlink" title="1.4. 下载 Spark 的 Jar 依赖包"></a>1.4. 下载 Spark 的 Jar 依赖包</h2><p>Idea中Spark工程会用到Spark的jar依赖，故需下载spark的依赖包。</p>
<p>下载<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.5/spark-2.4.5-bin-hadoop2.7.tgz">spark-2.4.5-bin-hadoop2.7.tgz</a>后解压备用</p>
<h2 id="1-5-安装Intellij-IDEA-Community（社区免费版）"><a href="#1-5-安装Intellij-IDEA-Community（社区免费版）" class="headerlink" title="1.5. 安装Intellij IDEA Community（社区免费版）"></a>1.5. 安装Intellij IDEA Community（社区免费版）</h2><p><a href="https://www.jetbrains.com/idea/">官网</a>下载<a href="https://download.jetbrains.8686c.com/idea/ideaIC-2020.1.2.exe">Intellij IDEA Community（社区免费版）</a>，并安装</p>
<h2 id="1-6-IDEA-安装-Scala-插件"><a href="#1-6-IDEA-安装-Scala-插件" class="headerlink" title="1.6. IDEA 安装 Scala 插件"></a>1.6. IDEA 安装 Scala 插件</h2><p>有两种插件安装方式，即在线安装和离线安装，推荐网络不稳定的小伙伴选择后者（注意Scala插件版本应与IDEA版本匹配）</p>
<h3 id="1-6-1-在线安装-Scala-插件（超时、失败）"><a href="#1-6-1-在线安装-Scala-插件（超时、失败）" class="headerlink" title="1.6.1. 在线安装 Scala 插件（超时、失败）"></a>1.6.1. 在线安装 Scala 插件（超时、失败）</h3><p>IDEA -&gt; Settings -&gt; plugins -&gt; search plugins in marketplace(“scala”) -&gt; install -&gt; restart IDEA</p>
<h3 id="1-6-2-离线安装-Scala-插件"><a href="#1-6-2-离线安装-Scala-插件" class="headerlink" title="1.6.2. 离线安装 Scala 插件"></a>1.6.2. 离线安装 Scala 插件</h3><ul>
<li><p>浏览器访问 <a href="https://plugins.jetbrains.com/plugin/1347-scala">IDEA 离线插件库</a>，点击右上角”Get”按钮，并下载支持IDEA版本(2020.1.2)的 <a href="https://plugins.jetbrains.com/files/1347/89709/scala-intellij-bin-2020.1.39.zip?updateId=89709&pluginId=1347&family=INTELLIJ">Scala 插件</a>（支持2020.1 — 2020.1.2）</p>
</li>
<li><p>IDEA -&gt; Settings -&gt; plugins -&gt; 点击小齿轮 -&gt; Install plugin form disk -&gt; select package -&gt; restart IDEA</p>
</li>
</ul>
<div class="note success"><p>准备工作至此结束</p>
</div>

<h1 id="2-创建Scala项目"><a href="#2-创建Scala项目" class="headerlink" title="2. 创建Scala项目"></a>2. 创建Scala项目</h1><ul>
<li>新建Scala工程<br>Run IDEA -&gt; File -&gt; New -&gt; Project -&gt; Scala -&gt; IDEA -&gt; NEXT</li>
<li>填写工程基础信息</li>
</ul>
<p>指定工程的工程名、路径、Java JDK、Scala JDK。设置Scala JDK时点击右侧”Create”按钮会自动识别准备工作中安装的Scala JDK(2.11.12)</p>
<ul>
<li>添加Spark依赖的jar到此工程<br>也可直接将整个jars目录导入到Libraries</li>
</ul>
<p>File –&gt; Project Steuccture –&gt; Libraries –&gt; 点击”+”按钮 –&gt; Java –&gt; 选择准备工作中已解压备用的”spark-2.4.5-bin-hadoop2.7”文件夹里的”jars”目录 –&gt; OK</p>
<ul>
<li>新建一个object</li>
</ul>
<p>左侧工程结构中点击 src -&gt; new -&gt; scala clas -&gt; 输入文件名(“SparkPi.scala”) -&gt; 选择Object</p>
<ul>
<li>编写Spark简易程序：计算圆周率Pi</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.math.random</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spark 简易程序：计算圆周率 Pi</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 原理：随机落在与正方形相切的同心圆内的概率为：S圆 / S正 = Pi / 4</span></span><br><span class="line"><span class="comment"> * 注：根据大数定律，当随机抛点次数达到百万次时，据概率所计算出Pi才具有参考意义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SparkPi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">          .builder</span><br><span class="line">          .appName(<span class="string">&quot;Spark Pi&quot;</span>)</span><br><span class="line">          .getOrCreate()</span><br><span class="line">        <span class="keyword">val</span> slices = <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) args(<span class="number">0</span>).toInt <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> n = math.min(<span class="number">1000000</span>L * slices, <span class="type">Int</span>.<span class="type">MaxValue</span>).toInt <span class="comment">// avoid overflow</span></span><br><span class="line">        <span class="keyword">val</span> count = spark.sparkContext.parallelize(<span class="number">1</span> until n, slices).map &#123; i =&gt;</span><br><span class="line">            <span class="keyword">val</span> x = random * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> y = random * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt; <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        &#125;.reduce(_ + _)</span><br><span class="line">        println(<span class="string">&quot;Pi is roughly &quot;</span> + <span class="number">4.0</span> * count / (n - <span class="number">1</span>))</span><br><span class="line">        spark.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置启动参数</li>
</ul>
<p>注：未设置会报”SparkException: A master URL must be set in your configuration”异常</p>
<p>设置vm options：点击菜单栏Run -&gt; Edit Configurations -&gt; VM options -&gt; 填写如下启动参数，让Spark程序以local模式运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dspark.master=local</span><br></pre></td></tr></table></figure>

<ul>
<li>运行Spark程序</li>
</ul>
<p>点击”object SparkPi”旁的绿色小三角即可运行Spark程序（注意设置启动参数）</p>
<h1 id="3-参考博文"><a href="#3-参考博文" class="headerlink" title="3. 参考博文"></a>3. 参考博文</h1><ul>
<li><a href="https://www.cnblogs.com/zlslch/p/5880926.html">IntelliJ IDEA（Community版本）的下载、安装和WordCount的初步使用</a></li>
<li><a href="https://blog.csdn.net/LiangEdward/article/details/106845276">基于windows，IDEA配置hadoop运行环境遇到的问题和解决（null\bin\winutils.exe）</a></li>
<li><a href="https://blog.csdn.net/streamery/article/details/106752423">ERROR SparkContext: Error initializing SparkContext.</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>《千里千寻》中蕴含人生观触动的一段话</title>
    <url>/2017/02/24/Spirited-Away/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/Spirited-Away.jpg" class="full-image" />
<!-- 标签方式引用，要求版本在0.4.5或以上 -->

<blockquote class="blockquote-center">
<p>人生就是一列开往坟墓的列车，<br>路途上会有很多站口，<br>没有一个人可以至始至终陪着你走完，<br>你会看到来来往往、上上下下的人。</p>
<a id="more"></a>

<p>如果幸运，会有人陪你走过一段，<br>当这个人要下车的时候，即使不舍，<br>也该心存感激，然后挥手道别。<br>因为，说不定下一站，<br>会有另外一个人会陪你走得更远。</p>

</blockquote>

<div align = right>----千与千寻</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>人生观触动</tag>
      </tags>
  </entry>
  <entry>
    <title>抛开怯懦，勇于挑战</title>
    <url>/2017/09/17/challenge-yourself/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/challenge-yourself.jpg" class="full-image" />

<!-- 标签方式引用，要求版本在0.4.5或以上 -->
<blockquote class="blockquote-center">
<p> 你是否擅长去做某件事情，在你没有做之前是不知道的。人对于陌生的事情总是有点害怕和胆怯的。就像我们看到一条陌生的狗，你一般不太敢靠近，而自己家里养的狗就敢随便靠近。我们面对不擅长的陌生领域，就像遇到了一条陌生狗的状态。只要我们勇敢地迎着这条狗走过去，你会发现买际上大部分的狗是不敢咬你的。</p>
<div align = right>----俞敏洪</div>
</blockquote>

<a id="more"></a>

<p>切莫对陌生领域过于胆怯，<strong>勇敢地踏出舒适区，挑战自己</strong>。</p>
<p>望与君共勉！</p>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>自驱</tag>
      </tags>
  </entry>
  <entry>
    <title>函数指针 &amp; 指针函数</title>
    <url>/2018/10/09/functionPointerAndPointerfunction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/pointerFunction.jpg" class="full-image" />

<h1 id="1-指针函数"><a href="#1-指针函数" class="headerlink" title="1. 指针函数"></a>1. 指针函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;<span class="comment">//指针函数</span></span><br></pre></td></tr></table></figure>
<p>指针函数，即返回值为指针地址的函数。实质仍为函数，与普通函数的差异仅在于返回值比较特殊，为一个指针地址（当然需要告知编译器一个特定的类型处理数据类型）。</p>
<a id="more"></a>
<h2 id="1-1-指针函数实例1：-返回值为基本类型"><a href="#1-1-指针函数实例1：-返回值为基本类型" class="headerlink" title="1.1. 指针函数实例1： 返回值为基本类型"></a>1.1. 指针函数实例1： 返回值为基本类型</h2><p>函数实现：大小写互转。将传入字符串内所有小写字母转换为大写字母，所有大写字母转换为小写字母</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Cover</span> <span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Ptr )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p = Ptr;</span><br><span class="line">    <span class="keyword">char</span> ch = *p ;</span><br><span class="line">    <span class="keyword">while</span>( ch != <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span> ) &#123;</span><br><span class="line">            *p -= <span class="number">32</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span> ) &#123;</span><br><span class="line">            *p += <span class="number">32</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">        ch = *(++p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">15</span>] = &#123;<span class="string">&quot;Hello World!&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Previous: &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Aftet: &quot;</span> &lt;&lt; Cover(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-指针函数实例2：返回值为结构体"><a href="#1-2-指针函数实例2：返回值为结构体" class="headerlink" title="1.2. 指针函数实例2：返回值为结构体"></a>1.2. 指针函数实例2：返回值为结构体</h2><p>函数实现：获取并返回注册信息结构体。获取用户信息并返回包含用户名、用户密码的结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserMessage</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> userName;</span><br><span class="line">    <span class="built_in">string</span> userPassword;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showUser</span> <span class="params">( struct UserMessage* user )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( user == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error: register failed!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Success: register success:)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;User: &quot;</span> &lt;&lt; user-&gt;userName &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Psw: &quot;</span> &lt;&lt; user-&gt;userPassword &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct UserMessage* <span class="title">Register</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str0, str1, str2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Please input UserName:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str0;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Please input Password:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Please input Password again:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str2;</span><br><span class="line">    <span class="keyword">if</span> ( str1.compare(str2) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">//(string)(user-&gt;userName) = str0; //Doesn&#x27;t work</span></span><br><span class="line">        <span class="comment">//(string)(user-&gt;userPassword) = str1; //Doesn&#x27;t work</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UserMessage</span>* <span class="title">user</span> =</span> <span class="keyword">new</span> UserMessage;</span><br><span class="line">        *user = &#123; str0, str1 &#125;;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UserMessage</span>* <span class="title">Test</span> =</span> Register();</span><br><span class="line">    showUser(Test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/functionPointer.jpg" class="full-image" />
# 2. 函数指针
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fun)(<span class="keyword">char</span> ch);<span class="comment">//函数指针</span></span><br></pre></td></tr></table></figure>
函数指针，即指针地址指向一个函数入口地址的指针。实质任为指针。我们可以通过改变这个指针的不同地址调用同型的不同函数。

<h2 id="2-1-函数指针实例1：-通过一个指针调用同型的不同函数"><a href="#2-1-函数指针实例1：-通过一个指针调用同型的不同函数" class="headerlink" title="2.1. 函数指针实例1： 通过一个指针调用同型的不同函数"></a>2.1. 函数指针实例1： 通过一个指针调用同型的不同函数</h2><p>代码实现：通过改变一个指针地址的赋值，以调用同型的不同函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowOnce</span> <span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No.1 &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowTwice</span> <span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No.&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowThrice</span> <span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No.&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*fun)(<span class="built_in">string</span>);<span class="comment">//函数指针定义</span></span><br><span class="line">    fun = ShowOnce;</span><br><span class="line">    (*fun)(<span class="string">&quot;ShowOnce&quot;</span>);<span class="comment">//通过函数指针调用 函数1</span></span><br><span class="line"></span><br><span class="line">    fun = ShowTwice;</span><br><span class="line">    (*fun)(<span class="string">&quot;ShowTwice&quot;</span>);<span class="comment">//通过函数指针调用 函数2</span></span><br><span class="line"></span><br><span class="line">    fun = ShowThrice;</span><br><span class="line">    (*fun)(<span class="string">&quot;ShowThrice&quot;</span>);<span class="comment">//通过函数指针调用 函数3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-函数指针实例2：-通过一个指针调用同型的不同函数2"><a href="#2-2-函数指针实例2：-通过一个指针调用同型的不同函数2" class="headerlink" title="2.2. 函数指针实例2： 通过一个指针调用同型的不同函数2"></a>2.2. 函数指针实例2： 通过一个指针调用同型的不同函数2</h2><p>代码实现：通过改变一个指针地址的赋值，以调用同型的不同函数，与实例1区别在多个形参，需特别注意函数指针形参类型必须与调用的函数形参类型一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span> <span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;<span class="comment">//加</span></span><br><span class="line">    <span class="keyword">return</span> (num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Subtract</span> <span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;<span class="comment">//减</span></span><br><span class="line">    <span class="keyword">return</span> (num1 - num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Multiply</span> <span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;<span class="comment">//乘</span></span><br><span class="line">    <span class="keyword">return</span> (num1 * num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Divide</span> <span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;<span class="comment">//除</span></span><br><span class="line">    <span class="keyword">return</span> (num1 / num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> (*fun)(<span class="keyword">double</span>, <span class="keyword">double</span>);<span class="comment">//函数指针定义</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test (*fun)(5,3) :&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    fun = Add;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fun = Subtract;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Subtract: &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fun = Multiply;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Multiply: &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fun = Divide;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Divide: &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-函数指针高级应用：通过函数指针测试不同函数的运行时间（函数指针作为形参）"><a href="#2-3-函数指针高级应用：通过函数指针测试不同函数的运行时间（函数指针作为形参）" class="headerlink" title="2.3. 函数指针高级应用：通过函数指针测试不同函数的运行时间（函数指针作为形参）"></a>2.3. 函数指针高级应用：通过函数指针测试不同函数的运行时间（函数指针作为形参）</h2><p>代码实现：通过形参传入一个函数指针，可在函数体内调用该函数指针形参指向的函数，以测试不同函数的运行时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10   <span class="comment">//多项式最大项数(9阶)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fun_x 1.1 <span class="comment">//多项式x的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXK 1e3  <span class="comment">//被测函数最大重复调用次数</span></span></span><br><span class="line"><span class="keyword">double</span> a[MAXN];   <span class="comment">//多项式系数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFunctionUsingTime</span> <span class="params">(<span class="keyword">double</span> (*fun)(<span class="keyword">void</span>))</span></span>; <span class="comment">// *******函数指针作为形参 *******</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXN; i++) &#123; <span class="comment">//赋值项系数</span></span><br><span class="line">        a[i] = (<span class="keyword">double</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算Function1用时</span></span><br><span class="line">    showFunctionUsingTime(Function1);</span><br><span class="line">    <span class="comment">//计算Function2用时</span></span><br><span class="line">    showFunctionUsingTime(Function2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function1</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=(MAXN<span class="number">-1</span>); i++) &#123;</span><br><span class="line">        p += (a[i] * <span class="built_in">pow</span>(Fun_x, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function2</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p = a[MAXN<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=(MAXN<span class="number">-1</span>); i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        p = a[i<span class="number">-1</span>] + Fun_x * p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFunctionUsingTime</span> <span class="params">(<span class="keyword">double</span> (*fun)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, stop;</span><br><span class="line">    <span class="keyword">double</span> duration; <span class="comment">//运行时间　变量</span></span><br><span class="line">    <span class="comment">//计算Function1用时</span></span><br><span class="line">    start = clock();<span class="comment">//记录时钟此刻打点数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXK ;i++) &#123; <span class="comment">//重复调用多次函数</span></span><br><span class="line">        (*fun)();</span><br><span class="line">    &#125;</span><br><span class="line">    stop = clock();<span class="comment">//记录始终此时打点数</span></span><br><span class="line">    duration = ((<span class="keyword">double</span>)(stop - start))/CLOCKS_PER_SEC/MAXK;<span class="comment">//计算实际用时</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Ticks = &quot;</span> &lt;&lt; (<span class="keyword">double</span>)(stop - start) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Using time = &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot; s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>git撤销已push到远端仓库的提交</title>
    <url>/2019/10/26/gitRevert/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/gitRevert.jpg" class="full-image" />

<p>随着互联网时代的来临，代码项目多采用git仓库管理多人协同编码的方式。人非圣贤孰能无过，难免有时自己刚push到远端仓库的代码存在瑕疵需要修改，此时不必惊慌，我们可以利用git的强制覆盖远端仓库来实现撤销提交的目的。适用前提：待撤销的提交记录后暂无他人提交记录。</p>
<p>关键词: git、回退commit</p>
<a id="more"></a>
<blockquote class="blockquote-center">
<p>人谁无过？过而能改，善莫大焉<br>– 左丘明《晋灵公不君》</p>

</blockquote>
<p>记录以便查询，回退commit步骤如下。</p>
<h2 id="Step1-在本地其他路径重新克隆一份代码"><a href="#Step1-在本地其他路径重新克隆一份代码" class="headerlink" title="Step1. 在本地其他路径重新克隆一份代码"></a>Step1. 在本地其他路径重新克隆一份代码</h2><p>接下来的操作均在新克隆的路径执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远端代码仓库路径</span><br></pre></td></tr></table></figure>

<h2 id="Step2-切换到要撤销提交的分支"><a href="#Step2-切换到要撤销提交的分支" class="headerlink" title="Step2. 切换到要撤销提交的分支"></a>Step2. 切换到要撤销提交的分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b 自定义本地分支名 origin/对应远端分支名</span><br></pre></td></tr></table></figure>
<p>查看当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<h2 id="Step3-获取前一次的提交commit-id"><a href="#Step3-获取前一次的提交commit-id" class="headerlink" title="Step3. 获取前一次的提交commit id"></a>Step3. 获取前一次的提交commit id</h2><p>默认连续显示最近几次提交记录和对应的commit id，输入q退出。这步操作是为了获取待撤销提交的上一次正常提交的commit id。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="Step4-强制回退到上一次提交节点"><a href="#Step4-强制回退到上一次提交节点" class="headerlink" title="Step4. 强制回退到上一次提交节点"></a>Step4. 强制回退到上一次提交节点</h2><p>强制回退本地仓库代码到远端仓库上一次正常提交到的记录节点【注意：此时所有代码修改均会被删除，这也是为什么第一步选择在其他路径重新克隆代码和执行回退操作】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 【待撤销提交的前一次提交的commit id】</span><br></pre></td></tr></table></figure>

<h2 id="Step5-再次查询分支的提交记录"><a href="#Step5-再次查询分支的提交记录" class="headerlink" title="Step5. 再次查询分支的提交记录"></a>Step5. 再次查询分支的提交记录</h2><p>检验本地此路径仓库的提交记录是否不含待撤销的提交，输入q退出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="Step6-强制覆盖远端仓库"><a href="#Step6-强制覆盖远端仓库" class="headerlink" title="Step6. 强制覆盖远端仓库"></a>Step6. 强制覆盖远端仓库</h2><p>强制用不含待撤销记录的本地仓库完全覆盖远端仓库。【注意：此操作后远端仓库会与本地仓库完全一致，请确保在待撤销记录之后暂无他人提交代码】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin HEAD --force</span><br></pre></td></tr></table></figure>
<p>至此，git撤销已push到远端仓库的提交已完成，接下来跳转到工作仓库pull最新代码完善瑕疵吧！enjoy it :)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>高效软件推荐</title>
    <url>/2018/09/26/highValueApplicationSoftware/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/highValueApplicationSoftware.jpg" class="full-image" />

<h1 id="1-浏览器"><a href="#1-浏览器" class="headerlink" title="1. 浏览器"></a>1. <strong>浏览器</strong></h1><h2 id="1-1-chrome-Microsoft-Edge"><a href="#1-1-chrome-Microsoft-Edge" class="headerlink" title="1.1. chrome/Microsoft Edge"></a>1.1. chrome/Microsoft Edge</h2><p>第三方搜集的Google官方离线包，Google Chrome下载地址：<a href="https://api.shuax.com/tools/getchrome">https://api.shuax.com/tools/getchrome</a></p>
<a id="more"></a>

<p><strong>必备插件</strong>：</p>
<ul>
<li>Adblock Plus 屏蔽广告</li>
<li>SearchPreview 网页预览</li>
<li>Multi-highlight 网页关键字高亮</li>
<li>IDM Integration Module 使chrome支持IDM</li>
<li>Video Speed Controller 网页视频倍速播放</li>
<li>Cool Clock 网页时钟</li>
<li><strong>Proxy SwitchyOmega 智能选择梯子类似：PAC</strong><ul>
<li>Proxy SwitchyOmega插件官网：<a href="https://www.switchyomega.com/">https://www.switchyomega.com/</a></li>
<li>在chrome://extensions/ 中添加crx插件，注意先勾选Developer mode</li>
<li><strong>配合Shadowsockers使用，设置Proxy SwitchyOmega</strong></li>
<li><strong>VPN提供商服务器</strong>&lt;==443端口通讯==&gt;<strong>本地VPN软件</strong>&lt;==1080端口通讯==&gt;<strong>Proxy SwitchyOmega插件</strong>&lt;==其他未知通讯==&gt;<strong>chrome浏览器</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy:</span><br><span class="line">	SOCKS5--&gt;127.0.0.1--&gt;1080  #即Proxy SwitchyOmega插件监听本地1080端口</span><br><span class="line">auto switch:</span><br><span class="line">	Rule list rules--&gt;proxy</span><br><span class="line">	Default--&gt;Direct</span><br><span class="line">	Rule List Config--&gt;AutoProxy</span><br><span class="line">	Rule List URL--&gt;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gfwlist&#x2F;gfwlist&#x2F;master&#x2F;gfwlist.txt</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>常用Google链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Google：https:&#x2F;&#x2F;www.google.com&#x2F;ncr</span><br><span class="line">- Google学术搜索：https:&#x2F;&#x2F;scholar.google.com&#x2F;</span><br><span class="line">- Google翻译：http:&#x2F;&#x2F;translate.google.cn&#x2F;</span><br><span class="line">- GooGle香港：https:&#x2F;&#x2F;www.google.com.hk&#x2F;ncr </span><br><span class="line">- chrome同步状态Sync: chrome:&#x2F;&#x2F;sync-internals&#x2F;</span><br></pre></td></tr></table></figure>

<h1 id="2-云盘"><a href="#2-云盘" class="headerlink" title="2. 云盘"></a>2. 云盘</h1><ul>
<li>坚果云。文件容器：用于[重要且常用、不重要却常用]文件及时分享，使用。</li>
<li>oneDrive。文件仓库：用于[重要但不常用]文件长期存放。</li>
<li>百度云</li>
<li>Dropbox</li>
</ul>
<h1 id="3-云笔记"><a href="#3-云笔记" class="headerlink" title="3. 云笔记"></a>3. 云笔记</h1><ul>
<li>有道云笔记</li>
<li>EveryNote</li>
<li>oneNote</li>
</ul>
<h1 id="4-输入法"><a href="#4-输入法" class="headerlink" title="4. 输入法"></a>4. 输入法</h1><ul>
<li>Win：<strong>手心输入法</strong> #无广告无弹窗</li>
<li>Linux：<strong>ibus-pinyin</strong> #无广告无弹窗</li>
</ul>
<h1 id="5-梯子"><a href="#5-梯子" class="headerlink" title="5. 梯子"></a>5. 梯子</h1><h2 id="5-1-ShadowsocksR"><a href="#5-1-ShadowsocksR" class="headerlink" title="5.1. ShadowsocksR"></a>5.1. ShadowsocksR</h2><ul>
<li><a href="https://lolico.moe/tutorial/shadowsocksr.html">ShadowsocksR介绍</a></li>
<li>ss免费账号分享：<ul>
<li><a href="https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7">分享链接1</a></li>
<li><a href="https://gitlab.com/Alvin9999/free/wikis/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7">分享链接2</a></li>
<li><a href="https://github.com/gfw-breaker/ssr-accounts">分享链接3</a></li>
</ul>
</li>
</ul>
<h2 id="5-2-v2rayN"><a href="#5-2-v2rayN" class="headerlink" title="5.2. v2rayN"></a>5.2. v2rayN</h2><ul>
<li><a href="https://www.v2ray.com/">V2Ray官网</a></li>
<li><a href="https://v2raypro.top/"><strong>V2RayPro官网</strong></a>，<a href="https://myv2.us/">附链</a></li>
<li><a href="https://dl.v2raypro.us/">V2RayPro<strong>多平台客户端</strong>及说明</a></li>
</ul>
<h2 id="5-3-手动更改hosts文件"><a href="#5-3-手动更改hosts文件" class="headerlink" title="5.3. 手动更改hosts文件"></a>5.3. 手动更改hosts文件</h2><h3 id="5-3-1-查询hosts"><a href="#5-3-1-查询hosts" class="headerlink" title="5.3.1. 查询hosts"></a>5.3.1. 查询hosts</h3><p>推荐<a href="https://laod.cn/">老D博客</a>，长期更新hosts</p>
<h3 id="5-3-2-管理员修改hosts文件，hosts所在文件夹："><a href="#5-3-2-管理员修改hosts文件，hosts所在文件夹：" class="headerlink" title="5.3.2. 管理员修改hosts文件，hosts所在文件夹："></a>5.3.2. 管理员修改hosts文件，hosts所在文件夹：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows 系统hosts位于 C:\Windows\System32\drivers\etc\hosts</span><br><span class="line">Android（安卓）系统hosts位于 &#x2F;etc&#x2F;hosts</span><br><span class="line">Mac（苹果电脑）系统hosts位于 &#x2F;etc&#x2F;hosts</span><br><span class="line">iPhone（iOS）系统hosts位于 &#x2F;etc&#x2F;hosts</span><br><span class="line">Linux系统hosts位于 &#x2F;etc&#x2F;hosts</span><br><span class="line">绝大多数Unix系统都是在 &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>

<h3 id="5-3-3-使修改后的hosts生效"><a href="#5-3-3-使修改后的hosts生效" class="headerlink" title="5.3.3. 使修改后的hosts生效"></a>5.3.3. 使修改后的hosts生效</h3><p><strong>Windows</strong></p>
<p>开始 -&gt; 运行 -&gt; 输入cmd -&gt; 在CMD窗口输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig &#x2F;flushdns</span><br></pre></td></tr></table></figure>
<p><strong>Linux</strong></p>
<p>终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rcnscd restart</span><br></pre></td></tr></table></figure>
<p>对于systemd发行版，请使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager</span><br></pre></td></tr></table></figure>
<p><strong>Mac OS X</strong></p>
<p>终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>
<p><strong>Android</strong></p>
<p>开启飞行模式 -&gt; 关闭飞行模式</p>
<p><strong>通用方法</strong></p>
<p>拔网线(断网) -&gt; 插网线(重新连接网络)</p>
<p>如不行请清空浏览器缓存</p>
<h1 id="6-生产工具"><a href="#6-生产工具" class="headerlink" title="6. 生产工具"></a>6. 生产工具</h1><h2 id="6-1-代码编辑器"><a href="#6-1-代码编辑器" class="headerlink" title="6.1. 代码编辑器"></a>6.1. 代码编辑器</h2><ul>
<li>VIM</li>
<li>Notepad++</li>
</ul>
<h2 id="6-2-集成IDE开发环境"><a href="#6-2-集成IDE开发环境" class="headerlink" title="6.2. 集成IDE开发环境"></a>6.2. 集成IDE开发环境</h2><ul>
<li>CLion：C++集成IDE开发工具</li>
<li>CodeBlocks：C++集成IDE开发工具</li>
<li>IDEA：Java集成IDE开发工具</li>
<li>PyCharm：Python集成IDE开发工具</li>
</ul>
<h2 id="6-3-Markdown编辑器"><a href="#6-3-Markdown编辑器" class="headerlink" title="6.3. Markdown编辑器"></a>6.3. Markdown编辑器</h2><ul>
<li>Typora</li>
<li>VScode</li>
</ul>
<h2 id="6-4-思维导图"><a href="#6-4-思维导图" class="headerlink" title="6.4. 思维导图"></a>6.4. 思维导图</h2><ul>
<li>ManagerPortable</li>
<li>Mindmaster</li>
</ul>
<h2 id="6-5-辅助工具"><a href="#6-5-辅助工具" class="headerlink" title="6.5. 辅助工具"></a>6.5. 辅助工具</h2><ul>
<li>辅助计算工具：Matlab</li>
<li>数学公式编辑器：MathType</li>
</ul>
<h2 id="6-6-文献管理工具"><a href="#6-6-文献管理工具" class="headerlink" title="6.6. 文献管理工具"></a>6.6. 文献管理工具</h2><ul>
<li>EndNote</li>
</ul>
<h1 id="7-下载工具"><a href="#7-下载工具" class="headerlink" title="7. 下载工具"></a>7. 下载工具</h1><ul>
<li>IDM，IDM 6.25.11汉化破解版</li>
<li>迅雷，迅雷 精简版最后一版1.0.35.366</li>
<li>PanDownload，第三方提供百度云管家替代下载工具，PanDownload_v1.5.2</li>
</ul>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro系统安装.rpm或.deb软件</title>
    <url>/2018/09/30/howToConvert.rpmPackagesIntoArchPackages/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/howToConvert.rpmPackagesIntoArchPackages.jpg" class="full-image" />

<p>尽管AUR被称为这个星球上最大的软件资源库，但不可避免的，我们有时会遇到在AUR库中没有待装软件，而待装软件官网只提供.rpm或.deb软件包的情况。本文将介绍如何利用.rpm或.deb软件包资源创建一个Arch软件包，然后在Manjaro系统下安装这些软件。</p>
<a id="more"></a>

<h1 id="1-通过-deb包安装-推荐"><a href="#1-通过-deb包安装-推荐" class="headerlink" title="1. 通过.deb包安装(推荐)"></a>1. 通过.deb包安装(推荐)</h1><h2 id="1-1-deb包安装流程简述："><a href="#1-1-deb包安装流程简述：" class="headerlink" title="1.1. .deb包安装流程简述："></a>1.1. .deb包安装流程简述：</h2><ul>
<li>用一个叫“Debtap”的软件将.deb软件包转换成Arch软件包</li>
<li>用我们熟悉的<code>pacman</code>命令安装上一步创建的Arch软件包</li>
</ul>
<h2 id="1-2-准备工作："><a href="#1-2-准备工作：" class="headerlink" title="1.2. 准备工作："></a>1.2. 准备工作：</h2><ul>
<li>确保系统已安装<code>debtap</code>，可通过以下命令查询</li>
</ul>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">debtap -v #查询debtap安装的版本号</span><br></pre></td></tr></table></figure>
<p>若没安装也可通过（<code>pacaur</code>、<code>packer</code>、<code>yaourt</code>）三种方式下载debtap源码文件然后安装debtap，以下是通过<code>yaourt</code>安装debtap的示例。<code>yaourt -S debtap</code>命令会下载debtap源码文件压缩包及<code>PKGBUILD</code>配置文件，我们只需要在下载完成后编译并安装debtap即可:</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S yaourt #安装yaourt</span><br><span class="line">yaourt -S debtap</span><br><span class="line"></span><br><span class="line">#不用更改下载配置文件，一路No</span><br><span class="line">Edit PKGBUILD ? [Y&#x2F;n] --&gt; N</span><br><span class="line">Edit debtap.install ? --&gt; N</span><br><span class="line">Continue building debtap ? [Y&#x2F;n] --&gt; Y</span><br><span class="line"></span><br><span class="line">#安装过程中访问&#x2F;var目录会询问一次管理员密码</span><br><span class="line">Continue installing debtap ? [Y&#x2F;n] --&gt; Y</span><br><span class="line">Proceed with installation? [Y&#x2F;n] --&gt; Y</span><br><span class="line">debtap -v #查询debtap安装的版本号</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确保系统已安装<code>bash</code>, <code>binutils</code>, <code>pkgfile</code>和<code>fakeroot</code><br>一般情况均已安装。安装Debtap和所有上述依赖项后，运行以下命令来创建/更新pkgfile和debtap数据库（至少执行一次）。</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo debtap -u</span><br><span class="line"># 等待。。。创建&#x2F;更新pkgfile和debtap数据库。当看到下列信息时，表明debtap已安装完毕。</span><br><span class="line">&#x3D;&#x3D;&gt; Generating base group packages list...</span><br><span class="line">&#x3D;&#x3D;&gt; All steps successfully completed!</span><br></pre></td></tr></table></figure>
</li>
<li><p>去待安装软件官网下载与你系统相匹配的(64位或32位)<code>.deb</code>软件包，推荐下载到<code>~/Downloads</code>目录</p>
</li>
</ul>
<h2 id="1-3-实际操作及代码"><a href="#1-3-实际操作及代码" class="headerlink" title="1.3. 实际操作及代码"></a>1.3. 实际操作及代码</h2><ol>
<li><p>跳转到.deb软件包的下载目录：<br>如果准备工作中<code>.deb软件包</code>下载到<code>~/Downloads</code>目录的话</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Downloads</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>debtap</code>命令转换.deb软件包为arch软件包</p>
<figure class="highlight plain"><figcaption><span>执行命令目录：你下载的.deb文件目录 eg:~/Download</span></figcaption><table><tr><td class="code"><pre><span class="line">debtap EasyConnect_x64.deb</span><br><span class="line"></span><br><span class="line"># 如果您不想在程序包转换期间回答任何问题，可使用-q标志绕过所有问题</span><br><span class="line">debtap -q EasyConnect_x64.deb(建议)</span><br><span class="line"></span><br><span class="line"># 或使用-Q标志绕过所有问题（不建议使用）</span><br><span class="line">debtap -Q EasyConnect_x64.deb</span><br></pre></td></tr></table></figure>
<p>系统将要求您输入软件包维护者和许可证的名称。 只需输入它们并按ENTER键即可开始转换过程。软件包转换需要几秒钟到几分钟，具体取决于您的CPU速度。期间可以喝杯咖啡休息一下</p>
<figure class="highlight plain"><figcaption><span>若标志绕过所有问题，则不需要以下操作</span></figcaption><table><tr><td class="code"><pre><span class="line">:: Enter Packager name: --&gt; EasyConnect</span><br><span class="line">:: Enter package license: --&gt; 填&#39;GPL&#39;或&#39;unknow&#39;</span><br><span class="line">:: If you want to edit: --&gt; Enter(跳过编辑)</span><br></pre></td></tr></table></figure>
<p>转换完成后会在当前目录生成一个Arch软件包：<code>packagename.pkg.tar.xz</code>形式的文件(eg:<code>easyconnect-7.6.3.0.86415-1-x86_64.pkg.tar.xz</code>)</p>
</li>
<li><p>用熟悉的<code>pacman</code>命令安装刚创建的Arch软件包</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：刚刚转换Arch包的文件目录</span></figcaption><table><tr><td class="code"><pre><span class="line">#安装刚创建的Arch软件包</span><br><span class="line">sudo pacman -U easyconnect-7.6.3.0.86415-1-x86_64.pkg.tar.xz</span><br></pre></td></tr></table></figure>
<p>恭喜，至此已顺利安装软件。</p>
</li>
<li><p>若安装失败或想卸载该软件，执行以下命令即可</p>
</li>
</ol>
<figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -R easyconnect</span><br></pre></td></tr></table></figure>

<h1 id="2-通过-rpm软件包安装"><a href="#2-通过-rpm软件包安装" class="headerlink" title="2. 通过.rpm软件包安装"></a>2. 通过.rpm软件包安装</h1><h2 id="2-1-rpm安装流程简述："><a href="#2-1-rpm安装流程简述：" class="headerlink" title="2.1. .rpm安装流程简述："></a>2.1. .rpm安装流程简述：</h2><ul>
<li>新建一个文件夹作为软件安装目录，并将待安装软件<code>.rpm</code>软件包移动到该文件夹内</li>
<li>在安装文件夹内创建并配置<code>PKGBUILD</code>文件</li>
<li>在待装软件文件夹内运行<code>makepkg</code>，然后创建Arch软件包</li>
<li>用我们熟悉的<code>pacman</code>命令安装上一步创建的Arch软件包</li>
</ul>
<h2 id="2-2-准备工作："><a href="#2-2-准备工作：" class="headerlink" title="2.2. 准备工作："></a>2.2. 准备工作：</h2><ul>
<li>确保系统已安装<code>rpmextract</code><figure class="highlight plain"><figcaption><span>命令执行目录：~</span></figcaption><table><tr><td class="code"><pre><span class="line">sudo pacman -S rpmextract #安装rpmextract</span><br></pre></td></tr></table></figure></li>
<li>去待安装软件官网下载与你系统相匹配的(64位或32位)<code>.rpm</code>软件包</li>
</ul>
<h2 id="2-3-实际操作及代码："><a href="#2-3-实际操作及代码：" class="headerlink" title="2.3. 实际操作及代码："></a>2.3. 实际操作及代码：</h2><ol>
<li><p>新建一个软件的安装文件夹，并将待安装软件<code>.rpm</code>包移动到该文件夹内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir package #新建待安装软件文件夹，取名尽量具有可读性</span><br><span class="line">cd package #跳转到该文件夹</span><br><span class="line">#将待安装软件.rpm包复制到该文件夹内</span><br></pre></td></tr></table></figure>
</li>
<li><p>在待装软件文件夹内创建并配置<code>PKGBUILD</code>文件<br>这个<code>PKGBUILD</code>文件包含有关我们将要创建的包的所有配置信息，而Manjaro系统自带原生的<code>PKGBUILD</code>文件模板，所以直接复制到本目录再配置一下便可，可参考：<a href="https://jlk.fjfi.cvut.cz/arch/manpages/man/PKGBUILD.5">官方PKGBUILD文件配置说明</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;pacman&#x2F;PKGBUILD.proto PKGBUILD #复制系统自带的原生PKGBUILD文件模板到待安装软件目录</span><br><span class="line">gedit PKGBUILD #配置PKGBUILD文件</span><br></pre></td></tr></table></figure>
<p>我的<code>PKGBUILD</code>文件最终配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkgname&#x3D;google-musicmanager-beta</span><br><span class="line">pkgver&#x3D;current</span><br><span class="line">pkgrel&#x3D;1</span><br><span class="line">pkgdesc&#x3D;&quot;Add a simple disprection.&quot;</span><br><span class="line">arch&#x3D;(&#39;x86_64&#39;)</span><br><span class="line">url&#x3D;&quot;https:&#x2F;&#x2F;music.google.com&#x2F;&quot;</span><br><span class="line">license&#x3D;(&#39;unknown&#39;)</span><br><span class="line">depends&#x3D;(&#39;libidn&#39;)</span><br><span class="line">makedepends&#x3D;(&#39;rpmextract&#39;)</span><br><span class="line">options&#x3D;(&#39;emptydirs&#39;)</span><br><span class="line">source&#x3D;(&quot;http:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;direct&#x2F;google-musicmanager-beta_current_x86_64.rpm&quot;)</span><br><span class="line">md5sums&#x3D;(&#39;6c05f087f9cd77563b7d001584e3b2d8&#39;)</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">cd &quot;$pkgdir&quot;</span><br><span class="line">rpmextract.sh ..&#x2F;google-musicmanager-beta_current_x86_64.rpm</span><br><span class="line">&#125;</span><br><span class="line">package() &#123;</span><br><span class="line">cd $srcdir</span><br><span class="line">rsync -ruDq $srcdir $pkgdir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PKGBUILD</code>文件中代码说明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序名称（强制格式：小写，无空格等）</span><br><span class="line">版本（默认“current”吧）</span><br><span class="line">内部版本号，对于包的每次更改都应增加1</span><br><span class="line">简短描述（少于约80个字符）</span><br><span class="line">架构（i686，x86_64，两者任意一种，或都支持）</span><br><span class="line">包的官方网站的URL（可选）</span><br><span class="line">许可证（GPL，BSD，unknown等）</span><br><span class="line">程序可能具有的任何依赖项（若多个以空格分隔，而不是逗号）</span><br><span class="line">只需要构建但不运行程序的依赖关系(&#39;rpmextract optipng&#39;或&#39;rpmextract&#39;)</span><br><span class="line">任意选项（在这种情况下，提取后有一些空目录，我发现不必要，所以我使用了emptydirs选项）</span><br><span class="line">源文件列表（如果是URL，则会在安装时下载这些.rpm文件，但也可以直接将.rpm软件包放在与PKGBUILD文件相同的文件夹中）</span><br><span class="line">文件的md5sums列表（您可以通过在包含文件的文件夹中运行“makepkg -g”来获取这些文件的md5sums）。</span><br><span class="line">最后是构建脚本进行提取</span><br></pre></td></tr></table></figure>
</li>
<li><p>在待装软件文件夹内运行<code>makepkg</code>创建Arch软件包<br>首先，在待装软件文件夹内运行<code>makepkg -g</code>。其次，待下载PKGBUILD文件中指定文件并返回一行<code>md5sum</code>，并复制<code>md5sum</code>到PKGBUILD文件中 。再次，再根据提示安装依赖项。最后，用<code>makepkg</code>创建最终的Arch软件包(即：<code>pkgname.pkg.tar.xz</code>文件)</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：待装软件文件夹内</span></figcaption><table><tr><td class="code"><pre><span class="line">makepkg -g #该命令将下载PKGBUILD文件中指定文件并返回一md5sum行</span><br><span class="line">gedit PKGBUILD #再次编辑PKGBUILD文件，将返回的md5sums行复制到md5sums&#x3D;(&#39;&#39;)中</span><br><span class="line">makepkg #创建Arch包，可能会提示存在尚未安装的依赖项，按提示安装所需依赖项</span><br></pre></td></tr></table></figure>
</li>
<li><p>用熟悉的<code>pacman</code>命令安装刚创建的Arch软件包</p>
<figure class="highlight plain"><figcaption><span>命令执行目录：刚刚转换Arch包的文件目录</span></figcaption><table><tr><td class="code"><pre><span class="line">pacman -U pkgname.pkg.tar.xz</span><br></pre></td></tr></table></figure>
<p>恭喜，至此已顺利安装软件。</p>
</li>
<li><p><strong>若安装失败或想卸载该软件</strong>，执行以下命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -R pkgname #其中pkgname为PKGBUILD文件中配置的软件名</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="3-Linux每日一练"><a href="#3-Linux每日一练" class="headerlink" title="3. Linux每日一练"></a>3. Linux每日一练</h1><p>在Linux系统中搜索文件命令<code>find</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo find &#x2F; -name *example*.*</span><br><span class="line"></span><br><span class="line">#其中</span><br><span class="line">&#39;&#x2F;&#39;表示搜索路径为&#x2F;根目录，也可自定</span><br><span class="line">&#39;-name&#39;表示搜索条件为名称</span><br><span class="line">&#39;\*&#39; 表不确定内容，可搜索文件或文件夹</span><br></pre></td></tr></table></figure>

<h1 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h1><ul>
<li><a href="http://nemrod.se/guides/install-rpm-packages-on-arch-linux/">Install RPM packages on Arch Linux</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Creating_packages">Creating packages</a></li>
<li><a href="https://wiki.archlinux.org/index.php/PKGBUILD">PKGBUILD</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>简易随手记</title>
    <url>/2017/01/01/messageBoard/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/messageBoard.jpg" class="full-image" />
一个临时留言板，记录琐碎内容或抓住突发灵感，我的临时随手记！
藏这么深，我的小秘密应该没那么容易被发现吧😜2333
<a id="more"></a>
<blockquote class="blockquote-center">
<p>当夫运思落笔时，觉心手间勃勃欲发之势，便是机神初到之候。<br>– by 沈宗骞</p>

</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>基于Hexo的博文编写调试发布流程简介</title>
    <url>/2018/08/29/post-debugging-steps/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/post-debugging-steps.png" class="full-image" />

<h1 id="1-博客文章编写＆调试＆发布"><a href="#1-博客文章编写＆调试＆发布" class="headerlink" title="1. 博客文章编写＆调试＆发布"></a>1. 博客文章编写＆调试＆发布</h1><h2 id="1-1-进入Hexo根目录"><a href="#1-1-进入Hexo根目录" class="headerlink" title="1.1. 进入Hexo根目录"></a>1.1. 进入Hexo根目录</h2><ol>
<li>输入密码,进入root用户模式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo su</span><br></pre></td></tr></table></figure></li>
<li>进入Hexo站点根目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;eisenhao&#x2F;eisenhao.github.io</span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ol>
<h2 id="1-2-写文章"><a href="#1-2-写文章" class="headerlink" title="1.2. 写文章"></a>1.2. 写文章</h2><ol>
<li>进入发布文件夹<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;eisenhao&#x2F;eisenhao.github.io&#x2F;source&#x2F;_posts</span><br></pre></td></tr></table></figure></li>
<li>新建md文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch example.md</span><br></pre></td></tr></table></figure></li>
<li>编辑example.md文件，编写文章(用Markdown大肆发挥吧，可参考<a href="https://eisenhao.cn/2018/08/31/write-a-md-file/">Markdown文章语法</a>)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim example.md</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-3-本地调试"><a href="#1-3-本地调试" class="headerlink" title="1.3. 本地调试"></a>1.3. 本地调试</h2><ol>
<li>开启测试<figure class="highlight c"><figcaption><span>命令执行目录：~/你的博客站点根目录</span></figcaption><table><tr><td class="code"><pre><span class="line">$ sudo hexo s</span><br></pre></td></tr></table></figure></li>
<li>在浏览器中输入: <a href="http://localhost:4000/">http://localhost:4000/</a>以查看效果.</li>
</ol>
<h2 id="1-4-发布"><a href="#1-4-发布" class="headerlink" title="1.4. 发布"></a>1.4. 发布</h2><ol>
<li>测试没问题后，我们就生成静态网页文件发布至我们的Github pages 中。<figure class="highlight c"><figcaption><span>命令执行目录：~/你的博客站点根目录</span></figcaption><table><tr><td class="code"><pre><span class="line">$ cd /home/eisenhao/eisenhao.github.io</span><br><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
<li>可能会要求输入github账号密码</li>
<li>如果上传失败显示如下信息,可能是由于我们没有配置root环境中的GitHub账号global，按照提示配置一下GitHub的global账号即可.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="2-主题配置"><a href="#2-主题配置" class="headerlink" title="2. 主题配置"></a>2. 主题配置</h1><ol>
<li>主题配置文件在主题文件夹中,我们可以更改config.yml文件进行配置.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;eisenhao&#x2F;eisenhao.github.io&#x2F;themes&#x2F;next&#x2F;_config.yml</span><br></pre></td></tr></table></figure></li>
<li>用文本编辑器打开编辑主题配置文件,点击查看<a href="http://theme-next.iissnan.com/getting-started.html#theme-settings">设置详细介绍.</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim &#x2F;home&#x2F;eisenhao&#x2F;eisenhao.github.io&#x2F;themes&#x2F;next&#x2F;_config.yml</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="3-Linux-技巧每日一练"><a href="#3-Linux-技巧每日一练" class="headerlink" title="3. Linux 技巧每日一练"></a>3. Linux 技巧每日一练</h1><p>用管理员运行文档管理器. sudo nautilus 会打开root版的文档管理器，可在终端键入ctrl+c就会关闭这个文档管理器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo nautilus</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是真正的富人思维？</title>
    <url>/2017/01/07/rich-thinking-by-mba/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/rich-thinking-by-mba.jpg" class="full-image" />

<div class="note success"><p>全文摘自MBA中国网：<br><a href="http://www.mbachina.com/html/zhaopin/201701/101719.html">http://www.mbachina.com/html/zhaopin/201701/101719.html</a></p>
</div>

<h1 id="1-你渴望成为的那种有钱人，不是靠技能获取一份高工资的人"><a href="#1-你渴望成为的那种有钱人，不是靠技能获取一份高工资的人" class="headerlink" title="1. 你渴望成为的那种有钱人，不是靠技能获取一份高工资的人"></a>1. 你渴望成为的那种有钱人，不是靠技能获取一份高工资的人</h1><p>严格来说，即使在中国，凭借高超的技术领取高薪，最终取得财务自由也不是不可能的，只是难度极大，而且异常辛苦。没有过人的先天的条件和顶级的后天培养，大多数人所能习得的技能，都不是不可替代到让老板心甘情愿为你付一份远远超过市场平均水平的薪水的。只要你对中国绝大多数企业的收入获得方式稍加理解，就能明白技术骨干的收入是很难超过掌握客户的销售总监和组建团队和客户对接的项目主管的。</p>
<a id="more"></a>

<p>美国的一个著名的喜剧明星Chris Rock在一场脱口秀中讲过一个段子：黑人在美国最多也就rich，但不可能wealthy。奥尼尔年薪两千万美金，那只能叫rich;在奥尼尔工资支票上签字的那些白人老头们，才能算wealthy。事实上，我们身边最常见的有钱人都是后者，他们不是技能过人的人，而是整合资源的人，简称老板，也是这篇文章想探讨的重点。</p>
<p>值得一提的是，在现代的商业环境下，并非传统企业那种100%的公司拥有者才叫老板。项目投资人，企业的合伙人，装修队的工头，夜总会的妈咪，安排一队小弟在三里屯收二手iPhone自己坐在旁边抽烟的人… 但凡直接发起并促成商业活动的人，在我看来都是老板。</p>
<p>你真正渴望成为的那种有钱人，不是超凡技能的人，而是寻找资源并整合资源的人。这就是学校和父母从来不曾告诉你的秘密，当然了他们之所以不告诉你，很可能是因为自己也没这么想过。</p>
<h1 id="2-自我保护心理注定了穷人的宿命"><a href="#2-自我保护心理注定了穷人的宿命" class="headerlink" title="2. 自我保护心理注定了穷人的宿命"></a>2. 自我保护心理注定了穷人的宿命</h1><p>不信?可以看看你身边多少人热衷于分享 “盖茨的的书不会告诉你他母亲是IBM董事”，“还原聚美优品陈欧履历造假真相”，百度知道甚至有好几个问题都在研究“马化腾究竟是是不是富二代”。</p>
<p>我们的内心深处有一种与生俱来的强烈的自我保护机制，它会不停地暗示你，只有自己的想法和选择才是最好的最合理的。但凡当大脑扫描到有什么人和事会令自己的显得是如此的无知而无能的信息，这种保护机制就会迅速启动，收集一切线索去证明他们都是因为一些<em>客观因素而侥幸成功</em>，自己要是有同样的客观条件，只会比他们更好。</p>
<p>在<a href="http://wiki.mbalib.com/wiki/%E9%A6%96%E9%A1%B5">MBA智库百科</a>中，自我保护是指个体维护心理平衡的一种自发性行为，即是通过压抑、补偿、文饰和升华的手段改变对心理紧张的主观感受，掩饰不能接受的内在冲动和虚拟现实环境的危险，用以<em>减少痛苦</em>以及对痛苦的<em>意识</em>，达到心理平衡的行为反应。<small>(自欺欺人)</small></p>
<p>而且，万一这些成功人士是自己身边非常熟悉的人，内心的保护机制会更加强大。就像上学的时候，我们热衷于讨论学习好的人都是书呆子没出息，漂亮姑娘只喜欢开跑车的渣男一样;长大之后则变成了，同事升职了是因为会拍领导马屁，同学创业成功了因为家里给了巨额的启动资金。穷人的头脑(<em>穷人思维</em>)是如此的敏捷，如果上述原因都找不到，还有最后一招杀手锏。</p>
<p>是的，正是这种与生俱来的自我保护心理，维护了社会稳定，减少了自杀率，也让<small>极少</small>的一部分克服了这种心理的人，成为了有钱人。</p>
<blockquote>
<p>总结下来就是，穷人相信人和人之间的差距是<em>客观条件所决定的</em>，而富人相信这种差距的决定性因素是主观能动性。</p>
</blockquote>
<p><em>穷人的思维习惯</em>是：<em>他们做到了，是因为他们富二代/有关系/运气好，我没有这些，所以我做不到</em>（<em>将一切原因归咎于客观条件，掩饰自生的问题）。如果我有这些条件，我也可以做到</em>。富人的思维习惯是：他们做到了，我为什么没做到，我怎么才能做到?（正视自身薄弱点，充分发挥主观能动性，并积极地通过理性分析和寻找各种方式弥补差距）</p>
<p>可怜的穷人们，不打破这种自我保护的心里，是很难摆脱一事无成的宿命的。可惜，他们中的大多数一生都<del><em>沉浸在自我安慰中，从怀才不遇到壮志未酬，最终感慨平平淡淡才是真。</em></del></p>
<h1 id="3-有钱人的思维是整合资源，而不是拥有现成的资源"><a href="#3-有钱人的思维是整合资源，而不是拥有现成的资源" class="headerlink" title="3. 有钱人的思维是整合资源，而不是拥有现成的资源"></a>3. 有钱人的思维是整合资源，而不是拥有现成的资源</h1><p>如果这篇文章你只能看一段，那就是这一段，没准它就能改变个别人的人生轨迹。</p>
<p>其实很多穷人也不是甘心于一辈子领薪水的啊，他们只是在等机会，他们<small>永远在等机会</small>。</p>
<p>“我在美国留学的时候，惊人地发现原来每个留学生和他们的父母心里其实也都有一条走上人生巅峰的道路嘛。本科认真学习，积极参加课外活动，拓展社交网络，最终成绩优异简历丰富，找到一个大公司工作几年积累工作经验，继续名校MBA深造，出任跨国公司高级管理人员，最终调回国内担任中国区经理，甚至<del>时机成熟了</del>，凭借多年工作积累的经验和人脉，跳出来单飞最终创业成功。”</p>
<p>听起来如此酣畅淋漓的人生攻略，其实是最经典的穷人思维，穷人总以为有钱人的每一步都是<em>按部就班顺水推舟得来的，所以要等着一切时机都成熟了，一切资源都获取了，才能开始行动</em>。</p>
<p>他们无法理解的是，世界上还有另外一小撮人，和他们拥有类似的客观条件，但却把他们觉得遥不可及的事情做起来了。这一小撮人，没有本金，找朋友借钱找投资人投资甚至找银行贷款；没有技术，自己去现学或者找到懂技术的人帮自己来做；没有关系，找人介绍请人吃饭送礼屡败屡战；没有客户，一个一个冷拨电话登门拜访甚至办公室门口堵着。上面这种人，就是传说中的老板。（正视自身薄弱点，充分发挥主观能动性，并积极地通过理性分析和寻找各种方式弥补差距 。整合资源，而不是拥有现成的资源）</p>
<p>按照穷人的万事俱备才能行动的思维，聚美优品的创业过程应该是这样：</p>
<p>陈欧同学大学时期学习的是快消品营销，斯坦福MBA毕业后进入丝芙兰美国总部担任销售高管，工作五年之后跳槽到天猫国际任化妆品频道总监，在天猫又干了几年之后，掌握了大量供货商资源，打造了一个优秀的电商运营团队，在化妆品行业侵染了20多年后，终于在2026年成立了聚美优品。然后…</p>
<p>聚美优品的实际创业过程这里就不细表了，微博上已经写的太多了，可无论陈老板的之前经历作假也好，波士堂上装逼也罢，还是他家里多有钱真格基金给他提供了多少关系，他又如何运气好赶上了垂直化电商爆发的前夜，仅仅是他决定去做化妆品电商这一件事，勇气和魄力就远远超越了多少客观条件跟他相仿甚至更好的人。</p>
<p>其实，当你真正开始做一个整合资源的老板的时候就会发现，你之前自以为拥有的资源和人脉远没有你想的那么好用，任何一个商业活动从无到有，都必然要经历那些团队不整没有客户的阶段，滴滴打车两年前还在在北京机场T3一个一个拽着出租车司机下载App;以雷军在互联网圈二十多年的人脉，创立小米的时候光一个个登门挖人就挖了近一年，相比之下，你觉得自己能有的那些资源又能有多管用呢?切记，老板的实质是寻找资源然后整合资源的人，并不是拥有现成资源的人。</p>
<p>更进一步说，一切商业机会都包含了大量的未知因素，而鉴于人类对于一个未知事物的群体接受度的判断力是极其有限的，一个优秀的老板擅长的是边做根据形势快速调整自己的商业活动，而不是事先把一切事情都预料好了。你能想象亚马逊的创始人当年在网上卖书的时候，已经计划好了公司的业务要包括电子阅读器，电商，流媒体，云计算，无人机吗?</p>
<p>为什么穷人等待的机会永远不会到来?等你把一切都看的清清楚楚的时候，市场早已经被那些趁着一切并不明朗就冲进去的人瓜分干净了。真正的好机会，永远都存在与未知中。同样的道理并非只存在于商业世界，每个人生活中最好的机会，几乎都出现在那些你没有完全准备好的时候。</p>
<p>还记得刚去美国的时候，我听说高中的数学课代表去新东方做了托福老师，班里的同学谈起这件事，语气中大多充满了怀疑和嘲讽，因为大家都清楚他高中的时候学习好是因为数理化成绩优异，英语水平根本不行。他们想的一点没错，后来我才得知，这哥们当时连托福都没考过，但就是一咬牙硬着头皮上去应聘还成功了，结果最初过得心惊胆战，做梦都怕被学生从讲台上赶下来，于是每天疯狂的做题备课恶补英语，好不容易坚持了下来。</p>
<p>而两年之后，嘲讽他的人还是当年的样子，他已经成了新东方的托福名师，公开课出现在新东方官网上，学生遍布北美。后来我默默地在家里看了他的讲课视频，比起我当年崇拜的那些新东方名师毫不逊色。我忽然想起了罗永浩当年写给俞敏洪的求职信，试想如果罗老师当年认为要把英语练到王强老师一样才能敢去新东方应聘，现在可能也只是一个吉林延边的文艺老愤青罢。</p>
<p>你看，真正把事情做起来的人，考虑的问题的过程其实是这样的，这件事我一定要做，缺什么东西我去想办法去争取。而什么做不起来的人，永远在等待时机成熟。</p>
<p>只有在实践中摔打过才知道，牛逼的商业理论可以让企业从1发展到10000，可以让创业者在经营的路上少走很多弯路，可以帮其他成型的企业的做商业咨询分析，但是对于一个渴望无中生有开展一段成功的商业活动的人而言，寻找资源并整合资源的能力才是从0到1的根本，它和任何具体的知识都没有关系，而是源于突破舒适区的决心，不屈不挠解决问题的耐心，愿赌服输的魄力。简而言之，它是一股不安于现状，相信主观能动性可以超越客观条件的，比性欲还强烈的内心驱动力。</p>
<p>无论是工作还是生活，成功的人必然是有勇有谋，但勇又大于谋。相比之下，勤奋专注聪明简直只能算雕虫小技，唯有勇气才是一个人出类拔萃的核心竞争力。</p>
<h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h1><p>如果你的抽象思维能力实在有限，必须得看十分具体的例子去理解究竟什么才是寻找资源并整合资源，强烈推荐你上网看两个故事，一个是星巴克老板舒尔茨当年在西雅图开第一家咖啡店的始末，另一个是杨洁导演拍摄86版西游记的过程。</p>
<p>以上，就是我在读了这么多年书，看了那么多案例，和自己在残酷的实践中，能给出的关于“不是富二代，不是官二代，很想成功，是不是就会成功了”的最好答案。至于你觉得它是醍醐灌顶还是勾兑鸡汤，看你的了。</p>
<div class="note success"><p>全文摘自MBA中国网：<br><a href="http://www.mbachina.com/html/zhaopin/201701/101719.html">http://www.mbachina.com/html/zhaopin/201701/101719.html</a></p>
</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>深度好文</tag>
      </tags>
  </entry>
  <entry>
    <title>恋爱观</title>
    <url>/2018/04/24/talkAboutLoveCiteByAnonymousSenior/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/talkAboutLoveCiteByAnonymousSenior.jpg" class="full-image" />


<div class="note success"><p><a href="http://rs.xidian.edu.cn/forum.php?mod=viewthread&tid=935336">全文转自西电睿思学姐(内网)</a>详细成熟了如何树立正确的爱情观，约束而又不失个性，理性与感性并存，遂与大家分享。</p>
</div>

<a id="more"></a>

<div id="aplayer-MkYNHPFd" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
				<pre class="aplayer-lrc-content">[00:00.25]Kimberley(陈芳语) - 爱你[00:06.43]我闭上眼睛 贴着你心跳呼吸[00:13.42]而此刻地球 只剩我们而已[00:20.16]你微笑的唇型 总勾着我的心[00:26.73]每一秒初吻 我每一秒都想要吻你[00:36.11]就这样 爱你 爱你 爱你 随时都要一起[00:42.43]我喜欢 爱你 外套 味道 还有你的怀里[00:49.11]把我们 衣服 钮扣 互扣 那就不用分离[00:56.49]美好爱情 我就爱这样贴近 因为你[01:16.85]有时没生气 故意闹脾气[01:23.42]你的紧张在意 让我觉得安心[01:30.04]从你某个角度 我总看见自己[01:36.76]到底你懂我 或其时我本来就像你[01:46.17]就这样 爱你 爱你 爱你 随时都要一起[01:52.70]我喜欢 爱你 外套 味道 还有你的怀里[01:59.28]把我们 衣服 钮扣 互扣 那就不用分离[02:06.80]美好爱情 我就爱这样贴近 因为你[02:17.73]想变成你的氧气 溜进你身体里[02:31.49]好好看看在你心里 你有多麽宝贝 我爱你[02:44.44]就这样 爱你 爱你 爱你 随时都要一起 （爱你）[02:49.27]我喜欢 爱你 外套 味道 还有你的怀里[02:55.92]把我们 衣服 钮扣 互扣 那就不用分离[03:03.50]美好爱情 我就爱这样贴近 因为你[03:10.28]我们爱情 会一直没有距离 最美丽</pre>
			</div>
			<script>
				var ap = new APlayer({
					element: document.getElementById("aplayer-MkYNHPFd"),
					narrow: false,
					autoplay: false,
					showlrc: 2,
					music: {
						title: "爱你",
						author: "陈芳语",
						url: "https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/22852057.mp3",
						pic: "https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/loveYou.jpg",
					}
				});
				window.aplayers || (window.aplayers = []);
				window.aplayers.push(ap);
			</script>

<h1 id="1-恋爱观"><a href="#1-恋爱观" class="headerlink" title="1. 恋爱观"></a>1. 恋爱观</h1><p>我们要树立正确的恋爱观，在有热情的同时也要保持清醒理智。之前听陈果的一个分享很有意思，记录了笔记，拿出来和大家分享。<br>总共分为两个部分：</p>
<p><strong>第一部分是关于爱情的三个问题：</strong></p>
<ul>
<li>爱与被爱</li>
<li>爱的对象与能力</li>
<li>激情与爱情、性与爱；</li>
</ul>
<p><strong>第二部分是很喜欢的四句话：</strong></p>
<ul>
<li>每一个不曾起舞的日子都是对生命的辜负；</li>
<li>我自风情万种与世无争；</li>
<li>把有意思的事变得有意义，有意义的事变得有意思；</li>
<li>告诉他们我度过了幸福的一生。</li>
</ul>
<h2 id="1-1-关于爱情的三个问题"><a href="#1-1-关于爱情的三个问题" class="headerlink" title="1.1. 关于爱情的三个问题"></a>1.1. 关于爱情的三个问题</h2><blockquote class="blockquote-center">
<p><strong>爱与被爱</strong></p>

</blockquote>
<p>很多时候我们想要的是享受被爱的感觉，考虑的更多的是如何让自己爱的对象更爱自己或者让大家爱自己。但其实对于这个问题来说，我们首先要学会怎样去爱别人。比如爱自己的对象要考虑到怎样去爱他，他需要怎样的感情。如何为他提供更好的服务（爱和鼓励），在他失意的时候以自己对他的了解，给他给予支持和关怀。</p>
<p>但事实是，我们很少为别人提供服务，但需要别人为我们提供爱这种服务。对于男性来说，他们更多的是在意社会的评判，取得成就、更强、更有钱；对于女性来说，可能想要美丽、漂亮的仪容仪表。而对于男性和女性共同来说，就是需要优雅的谈吐、谦虚、诚实这些良好的品质。我们都在用优秀的要素来武装自己，来证明自己是一个优秀的人。</p>
<p>很多时候我们需要用别人的“我爱你”，来打消自己内心的疑惑，因为我们内心没有安全感。但很多东西如果需要被证实，那就说明自己本来就没有。在两个人相处的过程中应该相互信任，让信任播种出信任的种子。但很多人就是守护不住自己的感情，不知道两个人很好的爱情是需要细水长流的，是需要慢慢熬的。</p>
<p>很多时候给予比得到更让我们感到快乐。我们能够给予说明自己内心很富有，把自己身上的活力给别人。之前看到一个说穷人没有给予的乐趣。（这里所说的穷人是不愿意给予的人，而不是经济意义上的穷人。）</p>
<blockquote class="blockquote-center">
<p><strong>爱的对象和爱的能力的问题</strong></p>

</blockquote>
<p>首先我们要承认：爱是一种能力。如果说爱是一个对象的话，当这个对象出现的时候就会发现空间的转移，我们就会爱上这个对象。但是事实上，爱跟画画是一样的。我们画画首先需要打磨自己画画的技巧，而不是去寻找一个自己想画的对象。我们认为爱情是对象的问题，对爱情有热度。事实上，我们必须要有能力、有信心让爱情有持久度。所以需要去培养自己爱的能力，经营、去维护甚至去修复一段感情。在爱中，免有人会犯错，们需要做一个很好的聆听者，不是那个喋喋不休的人。</p>
<p>之前看过一段话说：时间能带走一切东西。所有人们可以留下来的东西，时间通通都可以带走。比如美丽的容颜。</p>
<p>有一种人，他们会频繁的更换爱的对象。他们是爱无能的人，他们没有爱的能力，他们没有办法沉淀下来来维护爱、欣赏爱。爱对它们来说只是一种好奇心。他们无法欣赏那些看似平常看似平淡无奇却长长久久的美，不能感受到两个人相互依赖相互依偎的美。这个也像一个体能不太好的人想去尝试各种体育项目，换了这个换那个，总觉得是体育项目的问题，但真实的原因是她自己的体质不够好，要先培养自己足够的体能。</p>
<p>也有可能是因为这些人外部展现出来的出色和自己内心世界的空洞两者相互矛盾，他们无法正视自己是一个无趣的人，也担心别人走入他们的心里的时候会发现他们自己是一个无趣的人。在他们的内心不是繁华的宫殿，而是荒草不生的荒凉的空地。</p>
<blockquote class="blockquote-center">
<p><strong>激情与爱情（性与爱）</strong></p>

</blockquote>
<p>激情点燃了爱的火炬，爱情要让火炬一直燃烧，要保持爱的持久度。两个人的相处是由最开始的拘束，到最终的自然确立关系。这个是激情的部分，也是两个人 fall in love。但这个过程不是爱情的终点，而是爱情的起点。我们要把激情维护成温情，两个人相互陪伴，being in Love。要去学着经营和维护自己爱的对象，保护自己爱的人。帮助他成长的同时也让自己成长，让彼此成为更好的人。</p>
<h2 id="1-2-四句喜欢的话："><a href="#1-2-四句喜欢的话：" class="headerlink" title="1.2. 四句喜欢的话："></a>1.2. 四句喜欢的话：</h2><blockquote class="blockquote-center">
<p><strong>每一个不曾起舞的日子都是对生命的辜负。（用心对待此时此刻，不负此生。）</strong></p>

</blockquote>

<p>过去是完成了的现在，未来是当下的延伸。人生的过去和未来都是由现在决定的。那些永远不来的才是未来，而真真切切的就是现在。那些没有来的未来就是由当下决定的，未来是由当下延伸出去的。我们用心的对待此时此刻，就用心的对待了由此时此刻完成的过去和由此时此刻所延伸的未来。</p>
<p>关于幸福这个话题，很多人都觉得等到明天或者等到未来的某一天我们要追寻幸福。我们总把幸福不断的延伸，觉得达到什么目标之后我们才有资格去幸福、实现梦想。但总有一个明天会让我们推卸梦想。所以我们要从现在开始好好的去生活，好好对待自己的梦想，好好的对待自己想做的事情。</p>
<p>著名的诗人海子写过《面朝大海春暖花开》这首诗，但其实他还有另外一首诗《从明天开始做一个幸福的人》。但从明天开始这句话的潜台词就是：今天不幸福。不要从明天开始才去做一个幸福的人，而要从此时此刻开始。在自己能力的范围内创造属于自己的幸福。如果你有50万，你就创造50万的幸福；如果你只有50块，就创造50块的幸福。按自己的生活节奏过自己认为幸福的生活。</p>
<p>我们人生有很多阶段，在学生的时候我们要演好学生的生活；以后在公司要演好公司职员的生活。在人生的每个港口我们都要安家落户落户，做最真实的自己。很多时候我们并没有那么富裕，但我们可以用贫穷的物质过好丰富的精神生活。很多时候我们会很忙，但是忙也就是一件事接着一件事，去把他们做好就好了。我们很忙的时候，也不会有时间来抱怨。如果自己时间很闲的话，我们可以做一些没有效率的事情，比如抄书什么的。你要记住你不是一个人，你是有小伙伴的，你就是自己最好的小伙伴。一个人很自由，我们要享受独处。</p>
<p>要看重每一个当下，把握好此时此刻，不要等到明天才想着开始做一个幸福的或者真诚的人。要全身全心地投入每一个过程，尽人事，做最真实的自己。有时候目标导向性太强、效率优先，反而让我们很不舒服。尽力而为、顺其自然，有志者事未必竟成，但我们要全心全意的去做。</p>
<blockquote class="blockquote-center">
<p><strong>我自风情万种与世无争</strong></p>

</blockquote>

<p>在不干扰别人、不给别人带来麻烦、不影响别人的情况下，我们真的不必太去在意别人的想法。（但这也是有条件的，我们不能做不道德的事情。）</p>
<p>有这样一个问题:让别人喜欢自己和自己喜欢自己哪个更重要。说实话这两个都很重要，但如果非要选一个最重要的，那只能选让自己喜欢自己这个更重要。因为不管你活成什么样，活的多优秀、多完美、甚至是多糟糕，总有人喜欢你，总有人不喜欢你。当你做真实的自己的时候，还是有人喜欢你，有人不喜欢你。但你会更喜欢你。喜欢你的人多了一个最重要的人，你喜欢你自己。当一个人真的喜欢自己的时候，他会由内而外的散发出自信。</p>
<p>这里区分一下自信和他信。很多时候很多人将自己的自信建立于别人对自己的信任之上，很在意别人的眼光，但其实这是不必要的。因为你们信，所以我才信我。这是典型的他信。而真正的自信是自己知道自己的重量，不会因为别人夸自己而觉得自己很厉害，也不会因为别人贬低自己而看轻自己。不管别人怎么说自己，我自己知道我自己是怎样的人。很多时候别人喜欢你，并不是因为你这个人优不优秀，也许是因为他们可以从你身上得到好处吧。</p>
<p>当一个人由内而外散发出自由和自信的气息的时候有很多别称，有一个称呼叫魅力、从容、风情。这是一种来自真正喜欢自己的人的自信。一个人喜欢自己的时候是自信自由而优雅的。</p>
<p>很多时候我们会很喜欢优雅这个词，但香奈儿的slogan告诉我们言行自如便是一种优雅。举手投足之间表露的自信，由内而外散发的自由和优雅。</p>
<p>一个人发自内心有自由、自信，会散发出一种感染力。正能量不是告诉别人“加油你是最棒的”。正能量是将自己活成了一个光源、一个小太阳。不需要跟别人说什么，当他们接近我们的时候，不管我自己愿不愿意，他们都被我温暖，我们都照亮了他们的内心。一个负能量满满的人，不管他说什么都会大打折扣，他们也给不了别人有用的建议。让自己活出自信、自由，真正喜欢自己，会散发出一种正能量，这才叫感染力。你的存在本身就是一种光明与优雅。</p>
<p>如何找到好友？大家都知道“物以类聚，人以群分”。只有同等能量的人才能相互识别、相互结识、相互珍惜、相互欣赏，彼此成为知己。我们想要怎么样的朋友，首先我们要将自己变成那样的人。只有成为那样的人之后，才会引来那样的人。自信而自由的喜欢自己，才会吸引到那样的人。做一个闪闪发光的真诚的人。</p>
<p>一个很爱自己的人一定也是一个热爱生活的人，一个人对自己很满意的时候也会对世界很满意，因为这是这个世界将他变成让他满意的自己。所有的厌世都是自厌，因为他们不喜欢这样的自己。</p>
<blockquote class="blockquote-center">
<p><strong>把有意义的事变得有意思，让有意思的事儿变得有意义。</strong></p>

</blockquote>

<p>我们要将无趣而有意义的事情变得好玩，将有意思的事把它变得更有意义。</p>
<blockquote class="blockquote-center">
<p><strong>告诉他们我度过了幸福的一生。</strong></p>

</blockquote>

<p>我自己要幸福，要帮助他人，让他们变得更加幸福。自己好好活着，要帮别人好好活着。</p>
<h2 id="1-3-很喜欢的一句话："><a href="#1-3-很喜欢的一句话：" class="headerlink" title="1.3. 很喜欢的一句话："></a>1.3. 很喜欢的一句话：</h2><blockquote class="blockquote-center">
<p><strong>希望我遇到的每一个人，经历的每一件事，都因为我而变得更加美好。</strong></p>

</blockquote>

<div class="note success"><p><a href="http://rs.xidian.edu.cn/forum.php?mod=viewthread&tid=935336">全文转自西电睿思学姐(内网)</a></p>
</div>
]]></content>
      <categories>
        <category>心灵成长</category>
      </categories>
      <tags>
        <tag>爱情观</tag>
      </tags>
  </entry>
  <entry>
    <title>syslog协议与Rsyslog系统日志软件简介</title>
    <url>/2021/08/07/syslogProtocolAndRsyslog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/syslogProtocol.png"  style="zoom:75%;" />

<a id="more"></a>

<h1 id="1-syslog系统日志协议"><a href="#1-syslog系统日志协议" class="headerlink" title="1. syslog系统日志协议"></a>1. syslog系统日志协议</h1><h2 id="1-1-syslog协议简介"><a href="#1-1-syslog协议简介" class="headerlink" title="1.1. syslog协议简介"></a>1.1. syslog协议简介</h2><ul>
<li>Unix/Linux系统中的<strong>绝大部分日志</strong>都是通过一种叫做<strong>syslog</strong>的机制<strong>产生和维护</strong>的。</li>
<li><strong>syslog协议</strong>是一个<b><font color="red" style="">转发系统日志信息的标准</font></b>，它是在美国加州大学伯克利软件分布研究中心BSD的 TCP/IP 系统实施中开发的，目前已成为一种工业标准协议。</li>
<li>syslog协议可根据与日志消息的生产关系分为客户端和服务器端。其中<strong>客户端</strong>是产生日志消息的一方；<strong>服务器端</strong>负责接收客户端发送来的日志消息，并进行保存到特定的日志文件中或其他方式的处理。</li>
<li><strong>syslog记录着系统中的任何事件</strong>，任何希望生成日志的程序都可以向 syslog 发送信息。 </li>
</ul>
<h2 id="1-2-syslog协议的日志信息结构"><a href="#1-2-syslog协议的日志信息结构" class="headerlink" title="1.2. syslog协议的日志信息结构"></a>1.2. syslog协议的日志信息结构</h2><p>标准syslog协议的日志信息结构主要由PRI（priority，优先级）、HEADER、MSG三部分组成。下方为某syslog消息示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;147&gt;Oct 9 22:33:20 hlfedora auditd[1787]: The audit daemon is exiting.</span><br></pre></td></tr></table></figure>

<table width="700" border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <td colspan="5" align="center"><b><font color="red" style="">&lt;147&gt;</font></b><b><font color="blue" style="">Oct 9 22:33:20 hlfedora</font></b> <b><font color="green" style="">auditd[1787]: The audit daemon is exiting.</font></b></td>
    </tr>
    <tr>
        <td align="center"><b><font color="red" style="">&lt;147&gt;</font></b></td>
        <td colspan="2" align="center"><b><font color="blue" style="">Oct 9 22:33:20 hlfedora</font></b></td>
        <td colspan="2" align="center"><b><font color="green" style="">auditd[1787]: The audit daemon is exiting.</font></b></td>
    </tr>
    <tr>
        <th align="center"><b><font color="red" style="">PRI</font></b></th>
        <th colspan="2" align="center"><b><font color="blue" style="">HEADER</font></b></th>
        <th colspan="2" align="center"><b><font color="green" style="">MSG</font></b></th>
    </tr>
    <tr>
        <th align="center"><b>&lt;Facility * 8 + Severity&gt;</th>
        <th align="center"><b>时间</th>
        <th align="center"><b>主机名（或IP）</th>
        <th align="center"><b>TAG（可选）</th>
        <th align="center"><b>Content</th>
    </tr>
    <tr>
        <td align="center">&lt;18(local2) * 8 + 3(Error)&gt;</td>
        <td align="center">Oct 9 22:33:20</td>
        <td align="center">hlfedora</td>
        <td align="center">auditd[1787]:</td>
        <td align="center"> The audit daemon is exiting.</td>
    </tr>
</table>

<p>其中“&lt;147&gt;”是PRI部分，“Oct 9 22:33:20 hlfedora”是HEADER部分，“auditd[1787]: The audit daemon is exiting.”是MSG部分。</p>
<h3 id="1-2-1-PRI部分"><a href="#1-2-1-PRI部分" class="headerlink" title="1.2.1. PRI部分"></a>1.2.1. PRI部分</h3><p>PRI（priority，优先级）部分由尖括号包含的一个数字构成，这个数字包含了程序模块（Facility）、严重性（Severity），这个数字是由 Facility 乘以 8 再加上 Severity 得来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">priNum = Facility * 8 + Severity</span><br></pre></td></tr></table></figure>

<p><b><font color="red" style="">协议定义了24个日志 程序模块（Facility）：</font></b></p>
<table>
<thead>
<tr>
<th align="center">Numerical Code</th>
<th align="left">Facility</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="left">kernel messages</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">user-level messages</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">mail system</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">system daemons</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">security/authorization messages (note 1)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">messages generated internally by syslogd</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">line printer subsystem</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">network news subsystem</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">UUCP subsystem</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">clock daemon (note 2)</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">security/authorization messages (note 1)</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">FTP daemon</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">NTP subsystem</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">log audit (note 1)</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">log alert (note 1)</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">clock daemon (note 2)</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left">local use 0  (local0)</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left">local use 1  (local1)</td>
</tr>
<tr>
<td align="center"><strong>18</strong></td>
<td align="left"><strong>local use 2  (local2)</strong></td>
</tr>
<tr>
<td align="center">19</td>
<td align="left">local use 3  (local3)</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left">local use 4  (local4)</td>
</tr>
<tr>
<td align="center">21</td>
<td align="left">local use 5  (local5)</td>
</tr>
<tr>
<td align="center">22</td>
<td align="left">local use 6  (local6)</td>
</tr>
<tr>
<td align="center">23</td>
<td align="left">local use 7  (local7)</td>
</tr>
</tbody></table>
<blockquote>
<p>Note 1 - Various operating systems have been found to utilize<br>Facilities 4, 10, 13 and 14 for security/authorization,audit, and alert messages which seem to be similar.<br>Note 2 - Various operating systems have been found to utilize<br>both Facilities 9 and 15 for clock (cron/at) messages.</p>
</blockquote>
<p><b><font color="red" style="">协议定义了8个日志级别——严重性（Severity）：</font></b></p>
<table>
<thead>
<tr>
<th align="center">Numerical Code</th>
<th align="left">Severity</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="left">Emergency: system is unusable</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">Alert: action must be taken immediately</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">Critical: critical conditions</td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="left"><strong>Error: error conditions</strong></td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">Warning: warning conditions</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">Notice: normal but significant condition</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">Informational: informational messages</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">Debug: debug-level messages</td>
</tr>
</tbody></table>
<p>对上述PRI值为147的日志消息示例，syslog协议在：</p>
<ul>
<li><p><strong>填充PRI字段时</strong>，根据要传入日志消息的程序模块（Facility）和严重性（Severity）参数计算消息的PRI值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">18(local2) * 8 + 3(Error) = 147</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解析时PRI字段时</strong>，取 PRI值(<b><font color="green" style="">10010</font></b><b><font color="red" style="">011</font></b>B, 147) 的：</p>
<ul>
<li>低位3位(<b><font color="red" style="">011</font></b>B, 3)即可得到Severity的值(<b><font color="red" style="">Error</font></b>)；</li>
<li>取PRI值的高5位（右移3位后）(<b><font color="green" style="">10010</font></b>B, 18)即可得到Facility的值(<b><font color="green" style="">local2</font></b>)。</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-HEADER部分"><a href="#1-2-2-HEADER部分" class="headerlink" title="1.2.2. HEADER部分"></a>1.2.2. HEADER部分</h3><p>HEADER部分包括两个字段，<strong>时间</strong>和<strong>主机名（或IP）</strong>。其格式如下：</p>
<table  border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <td colspan="2" align="center">Oct 9 22:33:20 hlfedora</td>
    </tr>
    <tr>
        <th align="center">时间</th>
        <th align="center">主机名（或IP）</th>
    </tr>
    <tr>
        <td align="center">Oct 9 22:33:20</td>
        <td align="center">hlfedora</td>
    </tr>
</table>

<p>格式必须是“Mmm dd hh:mm:ss”，不包括年份。“日”的数字如果是1～9，前面会补一个空格（也就是月份后面有两个空格），而“小时”、“分”、“秒”则在前面补“0”。<br>月份取值包括：Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec</p>
<p>备注：</p>
<ul>
<li>长期以来，没有一个标准来规范syslog的格式，导致syslog的<strong>格式是非常随意</strong>；</li>
<li>某些不标准的syslog格式中包含了年份，若未做<strong>容错处理</strong>将会导致解析出错；</li>
<li>大部分syslog都包含PRI和MSG部分，而HEADER可能没有，这个时候MSG部分紧跟在PRI后面，中间没有空格。</li>
</ul>
<h3 id="1-2-3-MSG部分"><a href="#1-2-3-MSG部分" class="headerlink" title="1.2.3. MSG部分"></a>1.2.3. MSG部分</h3><p>MSG由TAG部分（可选）和Content部分构成。其格式如下：</p>
<table  border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <td colspan="2" align="center">auditd[1787]: The audit daemon is exiting.</td>
    </tr>
    <tr>
        <th align="center">TAG（可选）</th>
        <th align="center">Content</th>
    </tr>
    <tr>
        <td align="center">auditd[1787]</td>
        <td align="center"> The audit daemon is exiting.</td>
    </tr>
</table>

<p>其中，TAG域的值是产生日志消息的<strong>程序或进程</strong>的名称，TAG后面用一个冒号隔开Content部分，这部分的内容是应用程序自定义的日志正文。</p>
<h2 id="1-3-各日志文件的默认意义说明"><a href="#1-3-各日志文件的默认意义说明" class="headerlink" title="1.3. 各日志文件的默认意义说明"></a>1.3. 各日志文件的默认意义说明</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th align="center"><b>文件</b></th>
        <th align="center"><b>说明</b></th>
    </tr>
    <tr>
        <td><b>/var/log/messages</b></td>
        <td>系统主日志文件，记录常见的系统和服务错误信息</td>
    </tr>
    <tr>
        <td><b>/var/log/syslog</b></td>
        <td>只记录警告信息，常常是系统出问题的信息，使用lastlog查看</td>
    </tr>
    <tr>
        <td>/var/log/boot.log</td>
        <td>记录系统在引导过程中发生的事件，即开机自检中显示信息</td>
    </tr>
    <tr>
        <td>/var/log/lastlog</td>
        <td>记录最后一次用户成功登陆的时间、登陆IP等信息</td>
    </tr>
    <tr>
        <td>/var/log/secure</td>
        <td>系统认证/安全日志。记录用户和工作组变坏情况、用户登陆认证情况</td>
    </tr>
    <tr>
        <td>/var/log/maillog</td>
        <td>邮件postfix相关日志</td>
    </tr>
    <tr>
        <td>/var/log/btmp</td>
        <td>记录Linux登陆失败的用户、时间以及远程IP地址</td>
    </tr>
    <tr>
        <td>/var/log/cron</td>
        <td>记录计划任务crond服务执行情况</td>
    </tr>
    <tr>
        <td>/var/log/dmesg</td>
        <td>记录系统启动相关日志</td>
    </tr>
</table>

<h1 id="2-Rsyslog系统日志软件简介"><a href="#2-Rsyslog系统日志软件简介" class="headerlink" title="2. Rsyslog系统日志软件简介"></a>2. Rsyslog系统日志软件简介</h1><h2 id="2-1-系统日志软件简介"><a href="#2-1-系统日志软件简介" class="headerlink" title="2.1. 系统日志软件简介"></a>2.1. 系统日志软件简介</h2><ul>
<li>系统日志软件可根据当条日志消息的<strong>PRI属性值</strong>，即对应syslog协议中的<strong>程序模块（Facility）</strong>和<strong>严重性级别（Severity）</strong>，对当条日志消息按配置文件中<strong>指定的方式进行处理</strong>，如：保存到不同的文件中、发送到远程服务器或数据库等。</li>
<li><b><font color="red" style="">Syslog</font></b> 是早期大部分Linux发行版的内置<strong>日志记录程序</strong>，现已逐渐被 <b><font color="red" style="">Rsyslog</font></b> 取代（<strong>优势</strong>：性能和安全性更高，日志处理规模可达每秒百万条），Red Hat Enterprise Linux 6 之后的系统默认使用了Rsyslog。</li>
<li>系统日志软件转发日志消息时，绝大多数情况下使用UDP协议转发syslog消息，少数情况使用TCP协议（RFC3195协议）转发syslog消息</li>
</ul>
<h2 id="2-2-常用的系统日志软件（Syslog、Syslog-ng-与-Rsyslog）对比"><a href="#2-2-常用的系统日志软件（Syslog、Syslog-ng-与-Rsyslog）对比" class="headerlink" title="2.2. 常用的系统日志软件（Syslog、Syslog-ng 与 Rsyslog）对比"></a>2.2. 常用的系统日志软件（Syslog、Syslog-ng 与 Rsyslog）对比</h2><table border="1" cellspacing="1" style="border: 1ps dotted #666" >
    <tr>
        <th> </th>
        <th align="center"><b><a href="//en.wikipedia.org/wiki/Syslog">Syslog</a></b></th>
        <th align="center"><b><a href="//www.syslog-ng.com/products/open-source-log-management">Syslog-ng</a></b></th>
        <th align="center"><b><a href="//www.rsyslog.com">Rsyslog</a></b></th>
    </tr>
    <tr>
        <td align="center">诞生时间</td>
        <td align="center">1980</td>
        <td align="center">1998</td>
        <td align="center">2004</td>
    </tr>
    <tr>
        <td align="center">守护进程</td>
        <td align="center">syslogd<br>klogd</td>
        <td align="center">journald</td>
        <td align="center">rsyslogd</td>
    </tr>
    <tr>
        <td align="center">配置文件</td>
        <td align="center">/etc/syslog.conf</td>
        <td align="center">/etc/syslog.conf</td>
        <td align="center">/etc/rsyslog.conf</td>
    </tr>
    <tr>
        <td align="center">主要特性</td>
        <td>* 支持单机模式<br>* 支持C/S架构<br>* 支持UDP/TCP协议</td>
        <td>* 支持SSL/TLS协议<br>* 支持输出日志到数据库，如：MySQL、<br>Oracle、PostgreSQL和SQLite.<br>* 支持标准的Syslog协议<br>* 支持Filter、Parse以及Rewrite<br>* 支持更多的平台和更高的负载能力</td>
        <td>* 多线程<br>* 支持TCP, SSL, TLS, RELP<br>* 支持输出日志到各种数据库，如：MySQL，PostgreSQL，<br>MongoDB，ElasticSearch等<br>* 可通过可靠事件记录协议（Reliable Event Logging Protocol<br>，RELP） + TCP实现数据的可靠传输<br>* 可对输出格式进行精细控制<br>具有强大的消息过滤能力<br>具有高精度时间戳、队列操作（内存，磁盘以及混合模式等）<br>支持数据的加密和压缩传输等</td>
    </tr>
</table>

<p>常用系统日志软件中，应用最广泛同时性能最强大的是<strong>Rsyslog</strong>（官网标语：The rocket-fast system for log processing）。</p>
<h2 id="2-3-Rsyslog工作流"><a href="#2-3-Rsyslog工作流" class="headerlink" title="2.3. Rsyslog工作流"></a>2.3. Rsyslog工作流</h2><p>支持多线程的Rsyslog工作流示意图（多种输入输出方式并行处理）：</p>
<img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/RsyslogWorkFlow.png" class="full-image" alt="Rsyslog工作流" />

<p>对单个日志消息，日志message先进入主队列再过滤到分支队列，最后在各个processor线程中输出内容，输出到指定的输出方式中（如：写文件、发送远程主机、存数据库等）。</p>
<img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/RsyslogMsgDeal.jpg" class="full-image" alt="Rsyslog消息处理流程" />

<h2 id="2-4-Rsyslog日志消息流向"><a href="#2-4-Rsyslog日志消息流向" class="headerlink" title="2.4. Rsyslog日志消息流向"></a>2.4. Rsyslog日志消息流向</h2><p>下面从 rsyslogd 进程的输入和输出两个方面概述的日志信息流向。</p>
<img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/RsyslogFeaturesImagemap.png" class="full-image" alt="Rsyslog msg流向" />

<p><strong>输入</strong>：</p>
<ol>
<li>接收Linux内核进程发送到/dev/klog（特殊的设备，读取内核发出的消息）的日志消息</li>
<li>接收用户进程（通过进程间通信）发送到/dev/log（UNIX域数据包套接字）的日志消息</li>
<li>接收UDP协议（TCP/IP网络通信）发送到514端口的日志消息</li>
<li>监听写入文件的日志消息</li>
</ol>
<p><strong>输出</strong>：</p>
<ol>
<li>写入本地指定文件</li>
<li>发送给远程主机（eg. 远程ELK实时日志分析平台）</li>
<li>输出日志到数据库</li>
</ol>
<h1 id="3-参考文档"><a href="#3-参考文档" class="headerlink" title="3. 参考文档"></a>3. 参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/skyofbitbit/p/3674664.html">linux syslog详解</a></li>
<li><a href="https://www.rsyslog.com/">Rsyslog官网</a></li>
<li><a href="https://www.cnblogs.com/taosiyu/p/12930410.html">rsyslog详解实战和避坑</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>syslog</tag>
      </tags>
  </entry>
  <entry>
    <title>Python简单网页爬虫练习</title>
    <url>/2019/04/30/webCrawlerSimpleTest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/webCrawlerSimpleTest.jpg" class="full-image" />

<h1 id="1-爬取豆瓣一周口碑榜的电影列表"><a href="#1-爬取豆瓣一周口碑榜的电影列表" class="headerlink" title="1. 爬取豆瓣一周口碑榜的电影列表"></a>1. 爬取豆瓣一周口碑榜的电影列表</h1><p>爬取结果展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">爬取豆瓣一周口碑榜的电影列表（十个）:</span><br><span class="line">复仇者联盟<span class="number">4</span>：终局之战</span><br><span class="line">触不可及(美版)</span><br><span class="line">盗梦特攻队</span><br><span class="line">深红累之渊</span><br><span class="line">遇见女孩的感觉</span><br><span class="line">撞死了一只羊</span><br><span class="line">归家：碧昂斯电影作品</span><br><span class="line">西班牙之旅</span><br><span class="line">娑婆诃</span><br><span class="line">番石榴岛</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h1><ul>
<li>安装Python环境。详见<a href="https://eisenhao.cn/2018/09/23/AfterInstallManjaro/#%E5%AE%89%E8%A3%85Python3-7">安装Python3.7</a></li>
<li>使用pip3安装requests、lxml模块。参考<a href="https://eisenhao.cn/2018/09/23/AfterInstallManjaro/#%E4%BD%BF%E7%94%A8pip3%E5%AE%89%E8%A3%85Numpy%E6%A8%A1%E5%9D%97">使用pip3安装Numpy模块</a></li>
<li>运行平台：终端或Python IDE软件(eg.<a href="http://www.jetbrains.com/pycharm/">PyCharm</a>)</li>
</ul>
<h1 id="3-开始动手吧"><a href="#3-开始动手吧" class="headerlink" title="3. 开始动手吧"></a>3. 开始动手吧</h1><p>仅9行代码能爬豆瓣一周口碑榜的电影列表?<br>答案是肯定的，运行下方python代码即可实现首部结果。</p>
<figure class="highlight python"><figcaption><span>源码文件:webCrawlerTest1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取豆瓣一周口碑榜的电影列表（十个）https://movie.douban.com/</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/&#x27;</span> <span class="comment">#需要爬数据的网址</span></span><br><span class="line">page = requests.Session().get(url)</span><br><span class="line">tree = html.fromstring(page.text)</span><br><span class="line">result = tree.xpath(<span class="string">&#x27;//td[@class=&quot;title&quot;]//a/text()&#x27;</span>)<span class="comment"># 爬取豆瓣一周口碑榜的电影列表（十个）https://movie.douban.com/</span></span><br><span class="line"><span class="comment"># //td ：这个相当于指定是大目录；</span></span><br><span class="line"><span class="comment"># [@class=&quot;title&quot;]：这个相当于指定的小目录；</span></span><br><span class="line"><span class="comment"># //a ：这个相当于最小的目录；</span></span><br><span class="line"><span class="comment"># /text()：这个是提取其中的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式输出</span></span><br><span class="line">print(<span class="string">&quot;爬取豆瓣一周口碑榜的电影列表（十个）:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    print(i, end=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><h2 id="4-1-爬取网页内容关键点："><a href="#4-1-爬取网页内容关键点：" class="headerlink" title="4.1. 爬取网页内容关键点："></a>4.1. 爬取网页内容关键点：</h2><ul>
<li>待爬取网页地址，eg.上述事例代码中的’<a href="https://movie.douban.com/&#39;">https://movie.douban.com/&#39;</a></li>
<li>待爬取网页数据格式，eg.上述事例代码中的’//td[@class=”title”]//a/text()’</li>
</ul>
<h2 id="4-2-网页数据格式"><a href="#4-2-网页数据格式" class="headerlink" title="4.2. 网页数据格式"></a>4.2. 网页数据格式</h2><p>对于第二点获取网页数据格式，只能通过在网页浏览器F12查看HTML源码归纳总结得出<br>点击菜单栏左上按钮后再点击网页的待爬取内容，此时浏览器会跳转到该内容部分对应的HTML源码的对应代码，归纳总结源码得出正则表达式。<br><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/webCrawlerSimpleTest_2.jpg" class="full-image" /><br>可以看出上图中选中的HTML代码部分与归纳得出的规则<code>'//td[@class="title"]//a/text()'</code>具有很大的相似度。<br>其中：</p>
<ul>
<li>//td ：这个相当于指定是大目录；</li>
<li>[@class=”title”]：这个相当于指定的小目录；</li>
<li>//a ：这个相当于最小的目录；</li>
<li>/text()：这个是提取其中的数据。</li>
</ul>
<h1 id="5-练习"><a href="#5-练习" class="headerlink" title="5. 练习"></a>5. 练习</h1><p>爬虫小白上手简单用例就结束了，点击网页的即将上映，更改实例代码爬取“即将上映”练手试试吧！注意待爬取网页地址和内容格式一般不会有什么大问题。</p>
<p>针对上例爬取网页内容关注的两点：</p>
<ul>
<li>待爬取网页地址，eg.上述事例代码中的’<a href="https://movie.douban.com/cinema/later/xian/&#39;">https://movie.douban.com/cinema/later/xian/&#39;</a></li>
<li>待爬取网页数据格式，eg.上述事例代码中的’//div[@class=”intro”]//a/text()’</li>
</ul>
<figure class="highlight python"><figcaption><span>源码文件:webCrawlerTest2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网页爬虫练习2： 爬取豆瓣-西安-影讯-即将上映内容 https://movie.douban.com/cinema/later/xian/</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/cinema/later/xian/&#x27;</span> <span class="comment">#需要爬数据的网址：豆瓣-西安-影讯-即将上映内容</span></span><br><span class="line">page = requests.Session().get(url)</span><br><span class="line">tree = html.fromstring(page.text)</span><br><span class="line"><span class="comment"># //div ：这个相当于指定是大目录；</span></span><br><span class="line"><span class="comment"># [@class=&quot;intro&quot;]：这个相当于指定的小目录；</span></span><br><span class="line"><span class="comment"># //a ：这个相当于最小的目录；</span></span><br><span class="line"><span class="comment"># /text()：这个是提取其中的数据。</span></span><br><span class="line">result = tree.xpath(<span class="string">&#x27;//div[@class=&quot;intro&quot;]//a/text()&#x27;</span>) <span class="comment">#爬取豆瓣爬取豆瓣-西安-影讯-即将上映内容</span></span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 格式输出</span></span><br><span class="line"><span class="comment"># print(&quot;爬取豆瓣-西安-影讯-即将上映内容&quot;)</span></span><br><span class="line"><span class="comment"># for i in result:</span></span><br><span class="line"><span class="comment">#     print(i, end=&#x27;\n&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;港珠澳大桥&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;下一任：前任&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;悟空奇遇记&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;猫公主苏菲&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;国礼&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;大破天门阵&#x27;</span>, <span class="string">&#x27;柔情史&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;罗马&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;大侦探皮卡丘&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;进京城&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;一个母亲的复仇&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;欢迎来北方II&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;半边天&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;一路疯癫&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;周恩来回延安&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;海蒂和爷爷&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;企鹅公路&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;妈阁是座城&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;致命梦魇&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;音乐家&#x27;</span>, <span class="string">&#x27;预告片&#x27;</span>, <span class="string">&#x27;你好现任&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="6-拓展"><a href="#6-拓展" class="headerlink" title="6. 拓展"></a>6. 拓展</h1><p>虽然实例代码比较简单，但实际中运行爬虫时仍会面临很多问题，比如： </p>
<ul>
<li>网页数据内容的规则难以归纳 </li>
<li>爬取的数据不规范（需进一步处理） </li>
<li>大部分网站拥有反爬虫机制等</li>
</ul>
<h1 id="7-参考文档"><a href="#7-参考文档" class="headerlink" title="7. 参考文档"></a>7. 参考文档</h1><ul>
<li><a href="https://blog.csdn.net/csqazwsxedc/article/details/68498842">5分钟，6行代码教你写爬虫！（python）</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>win10优化精选</title>
    <url>/2017/03/02/win10Optimization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/win10Optimization.jpg" class="full-image" />

<h1 id="1-Win-R-常用命令"><a href="#1-Win-R-常用命令" class="headerlink" title="1. Win + R 常用命令"></a>1. Win + R 常用命令</h1><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">msconfig</td>
<td align="left">系统配置 (启动方式：安全模式，有无GUI引导等)</td>
</tr>
<tr>
<td align="left">gpedit.msc</td>
<td align="left">本地组策略编辑器</td>
</tr>
<tr>
<td align="left">services.msc</td>
<td align="left">服务</td>
</tr>
<tr>
<td align="left">netplwiz</td>
<td align="left">用户账户</td>
</tr>
<tr>
<td align="left">msinfo32</td>
<td align="left">查看系统是否UEFI启动</td>
</tr>
<tr>
<td align="left">slmgr.vbs -dlv</td>
<td align="left">查询操作系统版本、部分产品密钥、许可证等</td>
</tr>
<tr>
<td align="left">slmgr.vbs -xpr</td>
<td align="left">命令可以查询Win10是否永久激活</td>
</tr>
<tr>
<td align="left">winver</td>
<td align="left">查询系统内核版本，以及注册用户信息</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="2-win10组策略关闭自动更新、Windows-Defender"><a href="#2-win10组策略关闭自动更新、Windows-Defender" class="headerlink" title="2. win10组策略关闭自动更新、Windows Defender"></a>2. win10组策略关闭自动更新、Windows Defender</h1><ul>
<li>组策略关闭自动更新</li>
</ul>
<p>按Win键+R键调出运行，输入<code>gpedit.msc</code>点击“确定”，调出“本地组策略编辑器”。按顺序依次展开”计算机配置”，”管理模板” ，”windows组件” ，”windows更新 “。在右面找到“配置自动更新”，并双击。 禁用</p>
<ul>
<li>关闭Windows Defender</li>
</ul>
<p>找到计算机配置、管理模板、Windows组件、Windows Defender”选项“”双击打开“关闭 Windows Defender”后启用关掉“本地组策略编辑器”，重启电脑。</p>
<h1 id="3-离线安装-Net3-5"><a href="#3-离线安装-Net3-5" class="headerlink" title="3. 离线安装.Net3.5"></a>3. 离线安装.Net3.5</h1><ul>
<li>按键盘上的windows+x组合键，在弹出的系统菜单中选择“命令提示符（管理员）”这一项：</li>
<li>然后输入以下命令: (注意盘符要根据安装U盘实际盘符作出更改)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:NetFX3 &#x2F;Source:F:\sources\sxs #其中“d:\sources\sxs”为SXS文件夹路径：</span><br></pre></td></tr></table></figure>
命令无误后安回车，稍等即可开始离线安装了</li>
<li>当进程到100%时还需要稍等一会，显示“操作成功完成”后表示.net framework3.5离线安装完成：</li>
<li>到控制面板中的“启用或关闭Windows功能”中看看，.net framework3.5程序已经打勾，一些程序可正常安装了，也不会再弹出.net framework3.5安装提示：</li>
</ul>
<h1 id="4-免密登陆win10"><a href="#4-免密登陆win10" class="headerlink" title="4. 免密登陆win10"></a>4. 免密登陆win10</h1><ul>
<li>Win + R 打开运行程序，在空白框输入netplwiz,然后点击确定按钮</li>
<li>进入账户页面，选择一个账户，将下图所示的要使用计算机，用户必须输入用户名和密码复选框的勾去掉！</li>
<li>点击右下角“应用”弹出密码账户界面，输入密码，点击“确定”完成修改，下次将自动以此账户直接登录，免输密码！</li>
</ul>
<h1 id="5-Windows10必做的优化"><a href="#5-Windows10必做的优化" class="headerlink" title="5. Windows10必做的优化"></a>5. Windows10必做的优化</h1><ul>
<li>右键点击“此电脑”，选择“管理”，进入“计算机管理”窗口，在左侧的菜单选择“服务”，</li>
<li>手动禁用下列服务：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HomeGroup Listener</span><br><span class="line">HomeGroup Provider</span><br><span class="line">IPHelper （如果您的网络运营商不分配IPV6地址，可以将其关闭。）</span><br><span class="line">WindowsSearch （会在后台偷偷查户口。）</span><br><span class="line">Windows Update 禁用更新</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="6-卸载无用应用"><a href="#6-卸载无用应用" class="headerlink" title="6. 卸载无用应用"></a>6. 卸载无用应用</h1><ul>
<li>打开开始菜单里的“设置”应用，依次进入“系统”→“应用和功能”，可以卸掉一些您用不到的系统自带应用。</li>
</ul>
<h1 id="7-关闭优化驱动器"><a href="#7-关闭优化驱动器" class="headerlink" title="7. 关闭优化驱动器"></a>7. 关闭优化驱动器</h1><ul>
<li>双击“此电脑”打开，右键点击任意磁盘，选择“属性”。</li>
<li>在上方的标签选择“工具”，然后点击“优化”。</li>
<li>在下方“已计划的优化”处点“更改设置”，然后取消计划。</li>
<li>win10的“优化驱动器”即win7时代的磁盘碎片整理，每两三个月做一次即可，每周计划运行实属对资源的浪费。【固态硬盘不需要】</li>
</ul>
<h1 id="8-禁用系统保护"><a href="#8-禁用系统保护" class="headerlink" title="8. 禁用系统保护"></a>8. 禁用系统保护</h1><ul>
<li>右键点击“此电脑”，选择“属性”，再在“系统”窗口的左侧选择“系统保护”。</li>
<li>在下方配置系统保护功能，选择禁用。（如果有开启的话）</li>
<li>“系统保护”即XP时代的“系统还原”。现在一键GHOST或各品牌厂商的一键恢复软件的功能完爆它几条街，它也就没什么用了，关掉吧，还能节省一些磁盘空间。</li>
</ul>
<h1 id="9-关闭IPV6"><a href="#9-关闭IPV6" class="headerlink" title="9. 关闭IPV6"></a>9. 关闭IPV6</h1><p>如果您的网络运营商不分配IPV6地址，可以将其关闭。</p>
<ul>
<li>右键点击“此电脑”，选择“管理”，进入“计算机管理”窗口。在左侧的菜单选择“服务”，并在右侧找到“IPHelper”。右键点击它，选择“属性”，并在新打开的窗口中把启动类型改为“禁用”。方法基本同第一部分。</li>
<li>网络共享中心&gt;网络连接&gt;以太网&gt;属性&gt;取消ipv6。</li>
</ul>
<h1 id="10-关闭家庭组"><a href="#10-关闭家庭组" class="headerlink" title="10. 关闭家庭组"></a>10. 关闭家庭组</h1><p>因为这功能会导致硬盘和CPU处于高负荷状态</p>
<ul>
<li>关闭方法：控制面板&gt;家庭组&gt;离开。</li>
</ul>
<h1 id="11-防火墙"><a href="#11-防火墙" class="headerlink" title="11. 防火墙"></a>11. 防火墙</h1><p>可在控制面板里面的防火墙的“高级设置”里面的“属性”把“域配置文件”、“专用配置文件”、“公用配置文件”的状态改成关闭，这样就可以在不禁用防火墙服务的情况下关闭防火墙。但windows firewall　(windows防火墙服务)千万不能停用。</p>
<h1 id="12-设置好Superfetch服务-Windows-Search"><a href="#12-设置好Superfetch服务-Windows-Search" class="headerlink" title="12. 设置好Superfetch服务 Windows Search"></a>12. 设置好Superfetch服务 Windows Search</h1><p>服务Superfetch启动类型改成延迟启动或禁用，可以避免Win10对硬盘的频繁访问。关于Superfetch和Search，SSD用户要关</p>
<h1 id="13-开启HybridBoot"><a href="#13-开启HybridBoot" class="headerlink" title="13. 开启HybridBoot"></a>13. 开启HybridBoot</h1><ul>
<li>Win10启动飞快</li>
</ul>
<p>控制面板&gt;电源选项&gt;选择电源按钮的功能，更改当前不可用的设置&gt;关机设置&gt;勾上启用快速启动。</p>
<ul>
<li>关闭休眠</li>
</ul>
<p>Win+R输入powercfg -h on，关闭休眠：powercfg -h off（关闭后C盘会空出几G的空间）</p>
<h1 id="14-关闭性能特效"><a href="#14-关闭性能特效" class="headerlink" title="14. 关闭性能特效"></a>14. 关闭性能特效</h1><p>配置不太好的机器可以适当关闭显示效果以提高系统相应速度</p>
<ul>
<li>系统属性&gt;高级&gt;性能&gt;设置&gt;关闭淡出淡入效果。打开文件夹，小软件很快的</li>
</ul>
<h1 id="15-关闭讨厌的第三方软件服务项"><a href="#15-关闭讨厌的第三方软件服务项" class="headerlink" title="15. 关闭讨厌的第三方软件服务项"></a>15. 关闭讨厌的第三方软件服务项</h1><ul>
<li>Win+ R输入“msconfig”→确定。打开系统配置→勾选隐藏所有的Microsoft服务去掉不需要运行的服务</li>
<li>引导 – 勾上无GUI引导，确定。</li>
</ul>
<h1 id="16-Win10加速关机速度"><a href="#16-Win10加速关机速度" class="headerlink" title="16. Win10加速关机速度"></a>16. Win10加速关机速度</h1><ul>
<li>Win+R键。输入 gpedit.msc</li>
<li>计算机管理中选择，模块管理 - 系统 -关机选项</li>
<li>“启用” 关闭会阻止或取消关机的应用程序的自动终止功能</li>
</ul>
<h1 id="17-关闭计划任务里的隐藏的自启动程序"><a href="#17-关闭计划任务里的隐藏的自启动程序" class="headerlink" title="17. 关闭计划任务里的隐藏的自启动程序"></a>17. 关闭计划任务里的隐藏的自启动程序</h1><ul>
<li>控制面板→所有控制面板项→管理工具→任务计划程序→任务计划程序库→右侧任务列表→禁用不需要的任务</li>
</ul>
<h1 id="18-关闭windows安全中心服务"><a href="#18-关闭windows安全中心服务" class="headerlink" title="18. 关闭windows安全中心服务"></a>18. 关闭windows安全中心服务</h1><ul>
<li>Win+R键 输入services.msc回车——找到SecurityCenter ，设置禁用。</li>
</ul>
<h1 id="19-关闭onedrive，自动上传文件"><a href="#19-关闭onedrive，自动上传文件" class="headerlink" title="19. 关闭onedrive，自动上传文件"></a>19. 关闭onedrive，自动上传文件</h1><ul>
<li>Win+R键输入 <code>gpedit.msc</code></li>
</ul>
<p>在计算机配置 管理模板 windows组件里，有三个选项关闭</p>
<h1 id="20-取消默认网速20-限制，让网速在快一点儿"><a href="#20-取消默认网速20-限制，让网速在快一点儿" class="headerlink" title="20. 取消默认网速20%限制，让网速在快一点儿"></a>20. 取消默认网速20%限制，让网速在快一点儿</h1><ul>
<li>单击“开始”菜单，然后单击“运行”，在出现的“运行”对话框的“打开”文本框中输入<code>gpedit.msc</code>命令，点击“确定”，启动组策略管理器</li>
<li>展开“计算机配置”，而后再展开其下的“管理模板”子项目，展开“网络”，单击选中“Qos数据包调度程序”项目</li>
<li>双击“限制可保留带宽”，将该项目设置为“已启动”，并将“带宽限制”设置为“0”就可以了</li>
<li>单击“确定”按钮使设置生效</li>
</ul>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的Markdown博文语法简介</title>
    <url>/2018/08/31/write-a-md-file/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/write-a-md-file.jpg" class="full-image" />

<h1 id="1-md文件预定义参数"><a href="#1-md文件预定义参数" class="headerlink" title="1. md文件预定义参数"></a>1. md文件预定义参数</h1><h2 id="1-1-预定义参数"><a href="#1-1-预定义参数" class="headerlink" title="1.1. 预定义参数"></a>1.1. 预定义参数</h2><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<a id="more"></a>

<p>layout|布局|post<br>title|标题|<br>date|建立日期|文件建立日期<br>updated|更新日期|文件更新日期<br>comments|开启文章的评论功能|true<br>tags|标签（不适用于分页）|<br>categories|分类（不适用于分页）|<br>permalink|覆盖文章网址|</p>
<h2 id="1-2-本文的md文件预定义参数"><a href="#1-2-本文的md文件预定义参数" class="headerlink" title="1.2. 本文的md文件预定义参数"></a>1.2. 本文的md文件预定义参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout: post</span><br><span class="line">title: Markdown文章写作格式＆语法</span><br><span class="line">date: 2018&#x2F;8&#x2F;31 12:10:44</span><br><span class="line">updated: 2018&#x2F;9&#x2F;1 19:24:45</span><br><span class="line">comments: true</span><br><span class="line">tags:</span><br><span class="line">- Markdown</span><br><span class="line">- Hexo</span><br><span class="line">categories:</span><br><span class="line">- Markdown</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="2-Hexo下的Markdown语法"><a href="#2-Hexo下的Markdown语法" class="headerlink" title="2. Hexo下的Markdown语法"></a>2. Hexo下的Markdown语法</h1><h2 id="2-1-语法简明描述"><a href="#2-1-语法简明描述" class="headerlink" title="2.1. 语法简明描述"></a>2.1. 语法简明描述</h2><ol>
<li><strong>分段：</strong> <code>两个回车</code></li>
<li><strong>换行：</strong> <code>两个空格 + 回车</code></li>
<li><strong>标题：</strong> # ~ ######，#号的个数表示几级标题，即表示一～六级标题。(eg: <code>### 三级标题</code>)</li>
<li><strong>强调：</strong> <em>倾斜</em>(<code>*倾斜*</code>) 、 <strong>加粗</strong>(<code>**加粗**</code> or <code>__加粗__</code>) 、**<em>倾斜加粗**</em>(<code>***倾斜加粗***</code>) 、 <del>删除线</del>(<code>~~删除线~~</code>) 、 <code>标记</code>  (<code>`标记`</code>)</li>
<li><strong>列表：</strong> <code>* </code> 、<code>+ </code> 、<code>- </code> 、<code>数字序号. </code>(有序)  选其中之一，注意后面都紧跟一个空格</li>
<li><strong>引用：</strong> <code>&gt; </code> ，注意&gt;后面紧跟一个空格(eg: <code>&gt; 引用文字</code>)，结束引用时输入<code>两个回车</code>以结束引用</li>
<li><strong>图片：</strong> 在需要添加图片的位置<code>![图片](图片地址)</code>便可，图片地址可以是本地路径，或网络地址</li>
<li><strong>表格：</strong> - 和 | 分割行和列 ，<code>:</code>与<code>-</code>的相对位置控制当前列的左对齐、居中对齐、右对齐方式(<code>:----|:----:|----:</code>)，表格代码段可能需要与上部分代码空一行</li>
<li><strong>代码块：</strong> 每行代码前加四个空格(不显示行号)，或 使用<code>```代码内容```</code>(显示行号，<code>`</code>为键盘Esc下方按键)</li>
<li><strong>文本链接：</strong> [文字链接名称](链接地址)，eg: <a href="https://eisenhao.github.io/">我的博客</a> (<code>[我的博客](<a href="https://eisenhao.github.io/">https://eisenhao.github.io/</a></code>)</li>
<li><strong>小型文本：</strong> <small>小型文本</small><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;small&gt;小型文本&lt;&#x2F;small&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>高亮：</strong> 比如<code>突出背景色</code>来显示强调效果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;code&gt;突出背景色&lt;&#x2F;code&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>代码注释：</strong> 注释内容有助于理解代码，而不会被编译<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注释内容 --&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>网址链接：</strong> &lt;网址链接&gt;，eg: 我的博客:<a href="https://eisenhao.cn/">https://eisenhao.cn/</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我的博客:&lt;https:&#x2F;&#x2F;eisenhao.cn&#x2F;&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>阅读全文：</strong> 常用于文章过长，只显示文章前半部分，结合Hexo实现文章截断，点击阅读更多后显示全文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>文本右对齐：</strong><br>正常文本<div align = center>文本居中</div>
<div align = right>文本右对齐</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正常文本</span><br><span class="line">&lt;div align &#x3D; center&gt;文本居中&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div align &#x3D; right&gt;文本右对齐&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>代码块高级用法</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 请忽视&quot;&#96;\&#96;&#96;&quot;中的转移符&quot;\&quot;</span><br><span class="line">&#96;\&#96;&#96;[language] [title] [url] [link-text]</span><br><span class="line">代码块内容</span><br><span class="line">&#96;\&#96;&#96;</span><br><span class="line">[language] 是代码语言的名称，用来设置代码块颜色高亮，非必须；</span><br><span class="line">[title] 是顶部左边的说明，非必须；</span><br><span class="line">[url] 是顶部右边的超链接地址，非必须；</span><br><span class="line">[link text] 如它的字面意思，超链接的名称，非必须。</span><br></pre></td></tr></table></figure>
亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]，更多关于代码块的高级用法可参考文档：<a href="https://www.ofind.cn/blog/HEXO/HEXO%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%8B%93%E5%B1%95%E4%BF%AE%E6%94%B9.html">HEXO下的语法高亮拓展修改</a>。<br>例如以下代码:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 请忽视&quot;&#96;\&#96;&#96;&quot;中的转移符&quot;\&quot;</span><br><span class="line">&#96;\&#96;&#96;c++ 文件位置：~&#x2F;GitHub&#x2F;Cpp_Learning&#x2F;Cpp_demo.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#96;\&#96;&#96;</span><br></pre></td></tr></table></figure>
效果如下:<figure class="highlight c++"><figcaption><span>文件位置：~/GitHub/Cpp_Learning/Cpp_demo.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-2-引用嵌套"><a href="#2-2-引用嵌套" class="headerlink" title="2.2. 引用嵌套"></a>2.2. 引用嵌套</h2><p>引用的嵌套使用，注意引用字段结束后输入两个回车结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 植物</span><br><span class="line">&gt;&gt; 陆生植物</span><br><span class="line">&gt;&gt;&gt; 树</span><br><span class="line">&gt;&gt;&gt; 草</span><br><span class="line">&gt;&gt;&gt;&gt; 苹果树</span><br><span class="line">&gt;&gt;&gt;&gt; 梨树</span><br><span class="line">&gt;&gt;橘子树 &#x2F;&#x2F;由于没有用没有空行间隔，忽略降级引用标记</span><br><span class="line">香蕉树 &#x2F;&#x2F;由于没有用没有空行间隔，忽略降级引用标记</span><br><span class="line"></span><br><span class="line">&gt;&gt; 水生植物</span><br><span class="line">&gt;&gt;&gt; 藻</span><br><span class="line">海草</span><br><span class="line"></span><br><span class="line">共输入两个回车，结束引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>植物</p>
<blockquote>
<p>陆生植物</p>
<blockquote>
<p>树<br>草</p>
<blockquote>
<p>苹果树<br>梨树<br>橘子树 //由于没有用没有空行间隔，忽略降级引用标记<br>香蕉树 //由于没有用没有空行间隔，忽略降级引用标记</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>水生植物</p>
<blockquote>
<p>藻<br>海草</p>
</blockquote>
</blockquote>
</blockquote>
<p>共输入两个回车，结束引用</p>
<h2 id="2-3-列表"><a href="#2-3-列表" class="headerlink" title="2.3. 列表"></a>2.3. 列表</h2><h3 id="2-3-1-无序列表"><a href="#2-3-1-无序列表" class="headerlink" title="2.3.1. 无序列表"></a>2.3.1. 无序列表</h3><p><code>* </code>、<code>+ </code>、<code>- </code>三种方式都能表示无序列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 无序列表1</span><br><span class="line">+ 无序列表2</span><br><span class="line">- 无序列表3</span><br></pre></td></tr></table></figure>
<ul>
<li>无序列表1</li>
</ul>
<ul>
<li>无序列表2</li>
</ul>
<ul>
<li>无序列表3</li>
</ul>
<h3 id="2-3-2-有序列表"><a href="#2-3-2-有序列表" class="headerlink" title="2.3.2. 有序列表"></a>2.3.2. 有序列表</h3><p>只取第一个列表的数字序号，序号依次增加，与接下来的数字序号无关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 有序列表3</span><br><span class="line">9. 有序列表9</span><br><span class="line">2. 有序列表2</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>有序列表3</li>
<li>有序列表9</li>
<li>有序列表2</li>
</ol>
<h2 id="2-4-分割线"><a href="#2-4-分割线" class="headerlink" title="2.4. 分割线"></a>2.4. 分割线</h2><p>分割线可以由<code>*</code>、<code>-</code>、<code>_</code>这3种符号每种至少3个来表示(不必严格连续)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- * *</span><br><span class="line">-- -</span><br><span class="line">_ _ _</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对应效果:</p>
<ul>
<li><ul>
<li>*</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="3-内置标签"><a href="#3-内置标签" class="headerlink" title="3. 内置标签"></a>3. 内置标签</h1><p>标签(Tag Plugin)是Hexo提供的一种快速生成特定内容的方式。例如，在标准Markdown语法中，我们无法指定图片的大小。这种情景，我们即可使用标签来解决。Hexo内置来许多标签来帮助写作者可以更快的书写，参考Hexo的<a href="https://hexo.io/zh-cn/docs/tag-plugins.html">完整的标签列表</a>。Hexo也开放来接口给主题，使提供给写作者更简便的写作方法成为可能。</p>
<h2 id="3-1-文本居中的引用"><a href="#3-1-文本居中的引用" class="headerlink" title="3.1. 文本居中的引用"></a>3.1. 文本居中的引用</h2><p>此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。例如作为文章开篇引用或者结束语之前的总结引用。</p>
<h3 id="3-1-1-HTML引用方式"><a href="#3-1-1-HTML引用方式" class="headerlink" title="3.1.1. HTML引用方式:"></a>3.1.1. HTML引用方式:</h3><p>使用HTML方式：直接在Markdown文件中编写HTML来调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class&#x3D;&quot;blockquote-center&quot; 是必须的 --&gt;</span><br><span class="line">&lt;blockquote class&#x3D;&quot;blockquote-center&quot;&gt;HTML引用方式&lt;&#x2F;blockquote&gt;</span><br></pre></td></tr></table></figure>
<!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="blockquote-center" 是必须的 -->
<blockquote class="blockquote-center">HTML引用方式</blockquote>

<h3 id="3-1-2-标签引用方式"><a href="#3-1-2-标签引用方式" class="headerlink" title="3.1.2. 标签引用方式:"></a>3.1.2. 标签引用方式:</h3><p>使用<code>centerquote</code>或者<code>cq</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;</span><br><span class="line">&#123;% centerquote %&#125;标签引用方式1&#123;% endcenterquote %&#125;</span><br><span class="line">&lt;!-- 标签别名 --&gt;</span><br><span class="line">&#123;% cq %&#125;标签引用方式2&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>
<!-- 标签 方式，要求版本在0.4.5或以上 -->
<blockquote class="blockquote-center">
<p>标签引用方式1</p>

</blockquote>
<!-- 标签别名 -->
<blockquote class="blockquote-center">
<p>标签引用方式2</p>

</blockquote>

<h2 id="3-2-突破容器宽度限制的图片引用"><a href="#3-2-突破容器宽度限制的图片引用" class="headerlink" title="3.2. 突破容器宽度限制的图片引用"></a>3.2. 突破容器宽度限制的图片引用</h2><p>当使用此标签引用图片时，图片将自动扩大26%，并突破文章容器的宽度。此标签使用于需要突出显示的图片,图片的扩大与容器的偏差从视觉上提升图片的吸引力。此标签有两种调用方式（详细参看底下示例）：</p>
<h3 id="3-2-1-HTML引用图片方式"><a href="#3-2-1-HTML引用图片方式" class="headerlink" title="3.2.1. HTML引用图片方式"></a>3.2.1. HTML引用图片方式</h3><p>使用这种方式时，为<code>img</code>添加属性<code>class="full-image"</code>即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML引用图片方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class&#x3D;&quot;full-image&quot; 是必须的 --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;cdn.wfolio.ru&#x2F;w&#x2F;4b318a3da2f7d3a89fa5957a8dd9a00dd2609616&#x2F;m_limit%2Cw_1920&#x2F;sites&#x2F;181&#x2F;assets&#x2F;1524794399_7fc3ff.jpg&quot; class&#x3D;&quot;full-image&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<!-- HTML引用图片方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="full-image" 是必须的 -->

<img data-src="https://cdn.wfolio.ru/w/4b318a3da2f7d3a89fa5957a8dd9a00dd2609616/m_limit%2Cw_1920/sites/181/assets/1524794399_7fc3ff.jpg" class="full-image" />


<h1 id="4-Bootstrap-Callout"><a href="#4-Bootstrap-Callout" class="headerlink" title="4. Bootstrap Callout"></a>4. Bootstrap Callout</h1><p>这些样式出现在<a href="http://getbootstrap.com/">Bootstrap官方文档</a>中。</p>
<p><strong>使用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code>可以是以下一个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">primary</span><br><span class="line">success</span><br><span class="line">info</span><br><span class="line">warning</span><br><span class="line">danger</span><br></pre></td></tr></table></figure>
<p>代码实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;1.default效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary %&#125;2.primary效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success %&#125;3.success效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info %&#125;4.info效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning %&#125;5.warning效果&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger %&#125;6.danger效果&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note default"><p>1.default效果</p>
</div>
<div class="note primary"><p>2.primary效果</p>
</div>
<div class="note success"><p>3.success效果</p>
</div>
<div class="note info"><p>4.info效果</p>
</div>
<div class="note warning"><p>5.warning效果</p>
</div>
<div class="note danger"><p>6.danger效果</p>
</div>

<h1 id="5-主题自带样式-label-标签"><a href="#5-主题自带样式-label-标签" class="headerlink" title="5. 主题自带样式 label 标签"></a>5. 主题自带样式 label 标签</h1><p>首先需要在主题配置文件中有配置，需要配置下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit &#x2F;你的Hexo站点目录&#x2F;themes&#x2F;next&#x2F;_config.yml</span><br><span class="line"># Label tag.</span><br><span class="line">label: true</span><br></pre></td></tr></table></figure>
<p>效果如下：(目前存在一个 bug，如果把它加在一段文字的段首，则会有点问题，issue 页面。)</p>
<mark class="label default">default</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label default@default %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label primary">primary</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label primary@primary %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label success">success</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label success@success %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label info">info</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label info@info %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label warning">warning</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label warning@warning %&#125;</span><br></pre></td></tr></table></figure>
<mark class="label danger">danger</mark>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label danger@danger %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-NexT主题自带样式-tabs-标签"><a href="#6-NexT主题自带样式-tabs-标签" class="headerlink" title="6. NexT主题自带样式 tabs 标签"></a>6. NexT主题自带样式 tabs 标签</h1><p>在主题配置文件中有配置，需要配置下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit &#x2F;你的Hexo站点目录&#x2F;themes&#x2F;next&#x2F;_config.yml</span><br><span class="line"># Tabs tag.</span><br><span class="line">tabs:</span><br><span class="line">  enable: true</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 0</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong> 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong></p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong> 哇，你找到我了!</p></div></div></div>

<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 选项卡, 2 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 1** 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 2**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<p>然后上面源码中, 2表示一开始在第二个选项卡，非必须，若数值为-1则隐藏选项卡内容。更多用法请查看 <a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Tab-tag-test">这个页面</a>。</p>
<h1 id="7-主题自带样式–按钮"><a href="#7-主题自带样式–按钮" class="headerlink" title="7. 主题自带样式–按钮"></a>7. 主题自带样式–<strong>按钮</strong></h1><p>效果：</p>
<a class="btn" href="https://www.baidu.com"><i class="fa fa-download fa-lg fa-fw"></i>点击下载百度</a>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% btn https:&#x2F;&#x2F;www.baidu.com, 点击下载百度, download fa-lg fa-fw %&#125;</span><br></pre></td></tr></table></figure>
<p>关于按钮的更多使用可以前往 <a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test">这个网页</a>查看。</p>
<h1 id="8-插入音乐"><a href="#8-插入音乐" class="headerlink" title="8. 插入音乐"></a>8. 插入音乐</h1><p>音乐的话，网易云音乐的外链很好用，不仅有可以单曲，还能有歌单，有兴趣的自己去网易云音乐找首歌尝试。但是有一些音乐因为版权原因放不了，还有就是不完全支持 https，导致小绿锁不见了。要解决这些缺点，就需要安装插件alien。</p>
<h2 id="8-1-方法1：可以直接用-HTML-的标签，写法如下："><a href="#8-1-方法1：可以直接用-HTML-的标签，写法如下：" class="headerlink" title="8.1. 方法1：可以直接用 HTML 的标签，写法如下："></a>8.1. 方法1：可以直接用 HTML 的标签，写法如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;audio src&#x3D;&quot;https:&#x2F;&#x2F;什么什么什么.mp3&quot; style&#x3D;&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls&#x3D;&quot;controls&quot; loop&#x3D;&quot;loop&quot; preload&#x3D;&quot;meta&quot;&gt;Your browser does not support the audio tag.&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-方法2：用插件，有显示歌词功能，也美观，建议使用这种方法。"><a href="#8-2-方法2：用插件，有显示歌词功能，也美观，建议使用这种方法。" class="headerlink" title="8.2. 方法2：用插件，有显示歌词功能，也美观，建议使用这种方法。"></a>8.2. 方法2：用插件，有显示歌词功能，也美观，建议使用这种方法。</h2><p>首先在<code>站点</code>文件夹根目录安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>

<p>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;歌曲名&quot; &quot;歌手名&quot; &quot;https:&#x2F;&#x2F;什么什么什么.mp3&quot; &quot;https:&#x2F;&#x2F;封面图.jpg&quot; &quot;lrc:https:&#x2F;&#x2F;歌词.lrc&quot; %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外可以支持歌单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlist %&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;autoplay&quot;: false,</span><br><span class="line">    &quot;showlrc&quot;: 3,</span><br><span class="line">    &quot;mutex&quot;: true,</span><br><span class="line">    &quot;music&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;title&quot;: &quot;歌曲名&quot;,</span><br><span class="line">            &quot;author&quot;: &quot;歌手名&quot;,</span><br><span class="line">            &quot;url&quot;: &quot;https:&#x2F;&#x2F;什么什么什么.mp3&quot;,</span><br><span class="line">            &quot;pic&quot;: &quot;https:&#x2F;&#x2F;封面图.jpg&quot;,</span><br><span class="line">            &quot;lrc&quot;: &quot;https:&#x2F;&#x2F;歌词.lrc&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;title&quot;: &quot;歌曲名&quot;,</span><br><span class="line">            &quot;author&quot;: &quot;歌手名&quot;,</span><br><span class="line">            &quot;url&quot;: &quot;https:&#x2F;&#x2F;什么什么什么.mp3&quot;,</span><br><span class="line">            &quot;pic&quot;: &quot;https:&#x2F;&#x2F;封面图.jpg&quot;,</span><br><span class="line">            &quot;lrc&quot;: &quot;https:&#x2F;&#x2F;歌词.lrc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>

<p>效果可以见<a href="https://reuixiy.github.io/uncategorized/2010/01/01/test.html">易象辞的 Hello World</a>，里面的详细参数见<a href="https://github.com/MoePlayer/hexo-tag-aplayer">README</a> 和这插件的“母亲” Aplayer 的<a href="https://aplayer.js.org/">官方文档</a>。</p>
<h2 id="8-3-下方测试插入音乐"><a href="#8-3-下方测试插入音乐" class="headerlink" title="8.3. 下方测试插入音乐"></a>8.3. 下方测试插入音乐</h2><h3 id="8-3-1-方式1：HTML的标签插入音乐（网易云音乐）"><a href="#8-3-1-方式1：HTML的标签插入音乐（网易云音乐）" class="headerlink" title="8.3.1. 方式1：HTML的标签插入音乐（网易云音乐）"></a>8.3.1. 方式1：HTML的标签插入音乐（网易云音乐）</h3><p>网易云音乐 -&gt; 生成外链播放器 -&gt; 复制代码 -&gt; 粘贴到md文档</p>
<p>网易云iframe插件：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=414611053&auto=1&height=66"></iframe>

<p>网易云flash插件：</p>
<p><embed src="//music.163.com/style/swf/widget.swf?sid=414611053&type=2&auto=1&width=320&height=66" width="340" height="86"  allowNetworking="all"></embed></p>
<h3 id="8-3-2-方式2：用hexo-tag-aplayer插件音乐"><a href="#8-3-2-方式2：用hexo-tag-aplayer插件音乐" class="headerlink" title="8.3.2. 方式2：用hexo-tag-aplayer插件音乐"></a>8.3.2. 方式2：用hexo-tag-aplayer插件音乐</h3><p>巧取网易云音乐mp3外链方法，不知到现在有没有被禁<br>例如：在网易云网页版点击”陈芳语-爱你”，从浏览器地址栏发现”陈芳语-爱你”的id为：22852057，则将下方代码’id=’后的数字更改为‘22852057’之后就是”陈芳语-爱你”mp3格式的外链，新建标签页粘贴该地址可直接播放，应用在博客里插入外链还是很方便的（ps:在网易云还没禁用此bug之前）。</p>
<p>将歌词文件放在“hexo站点文件夹/source/uploads/”文件夹内，封面图、歌词文件引用地址为：<br>“<a href="https://eisenhao.github.io/uploads/%E5%B0%81%E9%9D%A2%E5%9B%BE.jpg&quot;%E3%80%81&quot;https://eisenhao.github.io/uploads/%E6%AD%8C%E8%AF%8D.lrc&quot;">https://eisenhao.github.io/uploads/封面图.jpg&quot;、&quot;https://eisenhao.github.io/uploads/歌词.lrc&quot;</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 网易云网页版关于&quot;陈芳语-爱你&quot;的歌曲id&#x3D;22852057</span><br><span class="line">http:&#x2F;&#x2F;music.163.com&#x2F;song&#x2F;media&#x2F;outer&#x2F;url?id&#x3D;22852057.mp3 #可直接播放外链（已失效）</span><br><span class="line">https:&#x2F;&#x2F;eisenhao.github.io&#x2F;uploads&#x2F;loveYou.jpg #封面图</span><br><span class="line">https:&#x2F;&#x2F;eisenhao.github.io&#x2F;uploads&#x2F;fangyuchen_loveyou.lrc #歌词 &#x2F;&#x2F;暂时无法添加lrc歌词，只能内嵌歌词</span><br></pre></td></tr></table></figure>

<h2 id="8-4-下方测试插件插入音乐（无歌词，lrc方式歌词失效）："><a href="#8-4-下方测试插件插入音乐（无歌词，lrc方式歌词失效）：" class="headerlink" title="8.4. 下方测试插件插入音乐（无歌词，lrc方式歌词失效）："></a>8.4. 下方测试插件插入音乐（无歌词，lrc方式歌词失效）：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;爱你&quot; &quot;陈芳语&quot; &quot;https:&#x2F;&#x2F;eisenhao.coding.net&#x2F;p&#x2F;eisenhao&#x2F;d&#x2F;eisenhao&#x2F;git&#x2F;raw&#x2F;master&#x2F;uploads&#x2F;22852057.mp3&quot; &quot;https:&#x2F;&#x2F;eisenhao.github.io&#x2F;uploads&#x2F;loveYou.jpg&quot; &quot;lrc:https:&#x2F;&#x2F;eisenhao.github.io&#x2F;uploads&#x2F;fangyuchen_loveyou.lrc&quot; %&#125;</span><br></pre></td></tr></table></figure>


        <div id="aplayer-bYlAokGr" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-bYlAokGr"),
            narrow: false,
            autoplay: false,
            showlrc: 3,
            music: {
              title: "爱你",
              author: "陈芳语",
              url: "https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/22852057.mp3",
              pic: "https://eisenhao.github.io/uploads/loveYou.jpg",
              lrc: "https://eisenhao.github.io/uploads/fangyuchen_loveyou.lrc"
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h2 id="8-5-下方测试插件插入内嵌音乐歌词："><a href="#8-5-下方测试插件插入内嵌音乐歌词：" class="headerlink" title="8.5. 下方测试插件插入内嵌音乐歌词："></a>8.5. 下方测试插件插入内嵌音乐歌词：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlrc &quot;爱你&quot; &quot;陈芳语&quot; &quot;https:&#x2F;&#x2F;eisenhao.coding.net&#x2F;p&#x2F;eisenhao&#x2F;d&#x2F;eisenhao&#x2F;git&#x2F;raw&#x2F;master&#x2F;uploads&#x2F;22852057.mp3&quot; &quot;https:&#x2F;&#x2F;eisenhao.coding.net&#x2F;p&#x2F;eisenhao&#x2F;d&#x2F;eisenhao&#x2F;git&#x2F;raw&#x2F;master&#x2F;uploads&#x2F;loveYou.jpg&quot; %&#125;</span><br><span class="line">[00:00.25]Kimberley(陈芳语) - 爱你[00:06.43]我闭上眼睛 贴着你心跳呼吸[00:13.42]而此刻地球 只剩我们而已[00:20.16]你微笑的唇型 总勾着我的心[00:26.73]每一秒初吻 我每一秒都想要吻你[00:36.11]就这样 爱你 爱你 爱你 随时都要一起[00:42.43]我喜欢 爱你 外套 味道 还有你的怀里[00:49.11]把我们 衣服 钮扣 互扣 那就不用分离[00:56.49]美好爱情 我就爱这样贴近 因为你[01:16.85]有时没生气 故意闹脾气[01:23.42]你的紧张在意 让我觉得安心[01:30.04]从你某个角度 我总看见自己[01:36.76]到底你懂我 或其时我本来就像你[01:46.17]就这样 爱你 爱你 爱你 随时都要一起[01:52.70]我喜欢 爱你 外套 味道 还有你的怀里[01:59.28]把我们 衣服 钮扣 互扣 那就不用分离[02:06.80]美好爱情 我就爱这样贴近 因为你[02:17.73]想变成你的氧气 溜进你身体里[02:31.49]好好看看在你心里 你有多麽宝贝 我爱你[02:44.44]就这样 爱你 爱你 爱你 随时都要一起 （爱你）[02:49.27]我喜欢 爱你 外套 味道 还有你的怀里[02:55.92]把我们 衣服 钮扣 互扣 那就不用分离[03:03.50]美好爱情 我就爱这样贴近 因为你[03:10.28]我们爱情 会一直没有距离 最美丽</span><br><span class="line">&#123;% endaplayerlrc %&#125;</span><br></pre></td></tr></table></figure>

<div id="aplayer-MLxoqGox" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
				<pre class="aplayer-lrc-content">[00:00.25]Kimberley(陈芳语) - 爱你[00:06.43]我闭上眼睛 贴着你心跳呼吸[00:13.42]而此刻地球 只剩我们而已[00:20.16]你微笑的唇型 总勾着我的心[00:26.73]每一秒初吻 我每一秒都想要吻你[00:36.11]就这样 爱你 爱你 爱你 随时都要一起[00:42.43]我喜欢 爱你 外套 味道 还有你的怀里[00:49.11]把我们 衣服 钮扣 互扣 那就不用分离[00:56.49]美好爱情 我就爱这样贴近 因为你[01:16.85]有时没生气 故意闹脾气[01:23.42]你的紧张在意 让我觉得安心[01:30.04]从你某个角度 我总看见自己[01:36.76]到底你懂我 或其时我本来就像你[01:46.17]就这样 爱你 爱你 爱你 随时都要一起[01:52.70]我喜欢 爱你 外套 味道 还有你的怀里[01:59.28]把我们 衣服 钮扣 互扣 那就不用分离[02:06.80]美好爱情 我就爱这样贴近 因为你[02:17.73]想变成你的氧气 溜进你身体里[02:31.49]好好看看在你心里 你有多麽宝贝 我爱你[02:44.44]就这样 爱你 爱你 爱你 随时都要一起 （爱你）[02:49.27]我喜欢 爱你 外套 味道 还有你的怀里[02:55.92]把我们 衣服 钮扣 互扣 那就不用分离[03:03.50]美好爱情 我就爱这样贴近 因为你[03:10.28]我们爱情 会一直没有距离 最美丽</pre>
			</div>
			<script>
				var ap = new APlayer({
					element: document.getElementById("aplayer-MLxoqGox"),
					narrow: false,
					autoplay: false,
					showlrc: 2,
					music: {
						title: "爱你",
						author: "陈芳语",
						url: "https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/22852057.mp3",
						pic: "https://eisenhao.coding.net/p/eisenhao/d/eisenhao/git/raw/master/uploads/loveYou.jpg",
					}
				});
				window.aplayers || (window.aplayers = []);
				window.aplayers.push(ap);
			</script>

<h1 id="9-插入视频"><a href="#9-插入视频" class="headerlink" title="9. 插入视频"></a>9. 插入视频</h1><h2 id="9-1-可以直接用-HTML-的标签，写法如下："><a href="#9-1-可以直接用-HTML-的标签，写法如下：" class="headerlink" title="9.1. 可以直接用 HTML 的标签，写法如下："></a>9.1. 可以直接用 HTML 的标签，写法如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video poster&#x3D;&quot;https:&#x2F;&#x2F;封面图.jpg&quot; src&#x3D;&quot;https:&#x2F;&#x2F;什么什么什么.mp4&quot; style&#x3D;&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls&#x3D;&quot;controls&quot; loop&#x3D;&quot;loop&quot; preload&#x3D;&quot;meta&quot;&gt;Your browser does not support the video tag.&lt;&#x2F;video&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-2-用第三方视频网站提供的嵌入式代码"><a href="#9-2-用第三方视频网站提供的嵌入式代码" class="headerlink" title="9.2. 用第三方视频网站提供的嵌入式代码"></a>9.2. 用第三方视频网站提供的嵌入式代码</h2><p>如bilibili提供的iframe插件，可在博客md文件中插入以下代码插入视频。获取iframe代码简诉：</p>
<ul>
<li>找到想要分享的视频</li>
<li>点击视频右上角三个竖点按钮 -&gt; 点击功能窗口 -&gt; 点击分享 -&gt; 复制视频的唯一嵌入代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;26361000&amp;cid&#x3D;49053680&amp;page&#x3D;1&amp;season_type&#x3D;1&quot; scrolling&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; frameborder&#x3D;&quot;no&quot; framespacing&#x3D;&quot;0&quot; allowfullscreen&#x3D;&quot;true&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>
<iframe src="//player.bilibili.com/player.html?aid=26361000&cid=49053680&page=1&season_type=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

</li>
</ul>
<h2 id="9-3-用插件，功能更加强大，比如可以弹幕，非常建议食用。"><a href="#9-3-用插件，功能更加强大，比如可以弹幕，非常建议食用。" class="headerlink" title="9.3. 用插件，功能更加强大，比如可以弹幕，非常建议食用。"></a>9.3. 用插件，功能更加强大，比如可以弹幕，非常建议食用。</h2><p>首先在站点文件夹根目录安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure>
<p>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer &quot;url&#x3D;https:&#x2F;&#x2F;什么什么什么.mp4&quot; &quot;https:&#x2F;&#x2F;封面图.jpg&quot; &quot;api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer&#x2F;&quot; &quot;id&#x3D;&quot; &quot;loop&#x3D;false&quot; %&#125;</span><br></pre></td></tr></table></figure>
<p>要使用弹幕，必须有<code>api</code>和<code>id</code>两项，并且若使用的是官方的api地址（即上面的），id的值不能与<a href="https://api.prprpr.me/dplayer/list">这个列表</a>的值一样。id的值自己随便取，唯一要求就是前面这点。</p>
<p>如果唯一要求难倒了你，可以使用<a href="http://tool.oschina.net/encrypt?type=2">这个工具</a>将一段与众不同的文字joy生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>效果，在这<a href="https://reuixiy.github.io/tags/video/">易象辞的博客的video</a>标签里自己找一篇文章看看。</p>
<p>当然，这个插件的功能还有很多，可以去<a href="https://github.com/MoePlayer/hexo-tag-dplayer">README</a>和这插件的“母亲” Dplayer 的<a href="https://dplayer.js.org/">官方文档</a>看看。</p>
<ul>
<li><ul>
<li>*</li>
</ul>
</li>
</ul>
<h1 id="10-Linux-技巧每日一练：cp命令"><a href="#10-Linux-技巧每日一练：cp命令" class="headerlink" title="10. Linux 技巧每日一练：cp命令"></a>10. Linux 技巧每日一练：cp命令</h1><blockquote>
<p>cp命令。用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。</p>
</blockquote>
<blockquote>
<p>cp语法: cp(选项)(参数)</p>
</blockquote>
<p>复制Folder文件夹所有文件到Backup文件夹，并显示所有改动的文件，常用于文件备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -ruv Folder&#x2F;* Backup</span><br></pre></td></tr></table></figure>

<h2 id="10-1-选项参数及说明"><a href="#10-1-选项参数及说明" class="headerlink" title="10.1. 选项参数及说明"></a>10.1. 选项参数及说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a    此参数的效果和同时指定&quot;-dpR&quot;参数相同；</span><br><span class="line">-d    当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；</span><br><span class="line">-f    强行复制文件或目录，不论目标文件或目录是否已存在；</span><br><span class="line">-i    覆盖既有文件之前先询问用户；</span><br><span class="line">-l    对源文件建立硬连接，而非复制文件；</span><br><span class="line">-p    保留源文件或目录的属性；</span><br><span class="line">-R&#x2F;r  递归处理，将指定目录下的所有文件与子目录一并处理；</span><br><span class="line">-s    对源文件建立符号连接，而非复制文件；</span><br><span class="line">-u    使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；</span><br><span class="line">-S    在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；</span><br><span class="line">-b    覆盖已存在的文件目标前将目标文件备份；</span><br><span class="line">-v    详细显示命令执行的操作。</span><br></pre></td></tr></table></figure>

<h1 id="11-参考文档"><a href="#11-参考文档" class="headerlink" title="11. 参考文档"></a>11. 参考文档</h1><ul>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98">reuixiy</a></li>
<li><a href="https://blog.csdn.net/WilliamZ98/article/details/81074219">Hexo 使用 Markdown 编辑技巧大全</a></li>
<li><a href="https://blog.csdn.net/chwshuang/article/details/52350551">Hexo在Github中搭建博客系统(5)Markdown语法</a></li>
<li><a href="http://theme-next.iissnan.com/tag-plugins.html">Next-内置标签</a></li>
<li><a href="http://man.linuxde.net/cp">Linux命令大全</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
